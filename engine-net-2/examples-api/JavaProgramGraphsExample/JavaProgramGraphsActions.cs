// This file has been generated automatically by GrGen (www.grgen.net)
// Do not modify this file! Any changes will be lost!
// Generated from "..\..\examples\JavaProgramGraphs-GraBaTs08\JavaProgramGraphs.grg" on Sat Jun 25 14:38:31 CEST 2011

using System;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using GRGEN_LIBGR = de.unika.ipd.grGen.libGr;
using GRGEN_LGSP = de.unika.ipd.grGen.lgsp;
using GRGEN_EXPR = de.unika.ipd.grGen.expression;
using GRGEN_MODEL = de.unika.ipd.grGen.Model_JavaProgramGraphs;

namespace de.unika.ipd.grGen.Action_JavaProgramGraphs
{
	public class Pattern_MultipleContainedPackagesOrClasses : GRGEN_LGSP.LGSPMatchingPattern
	{
		private static Pattern_MultipleContainedPackagesOrClasses instance = null;
		public static Pattern_MultipleContainedPackagesOrClasses Instance { get { if (instance==null) { instance = new Pattern_MultipleContainedPackagesOrClasses(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] MultipleContainedPackagesOrClasses_node_p_AllowedTypes = null;
		public static bool[] MultipleContainedPackagesOrClasses_node_p_IsAllowedType = null;
		public enum MultipleContainedPackagesOrClasses_NodeNums { @p, };
		public enum MultipleContainedPackagesOrClasses_EdgeNums { };
		public enum MultipleContainedPackagesOrClasses_VariableNums { };
		public enum MultipleContainedPackagesOrClasses_SubNums { };
		public enum MultipleContainedPackagesOrClasses_AltNums { };
		public enum MultipleContainedPackagesOrClasses_IterNums { @iter_0, @iter_1, };




		public GRGEN_LGSP.PatternGraph pat_MultipleContainedPackagesOrClasses;

		public static GRGEN_LIBGR.NodeType[] MultipleContainedPackagesOrClasses_iter_0_node_sub_AllowedTypes = null;
		public static bool[] MultipleContainedPackagesOrClasses_iter_0_node_sub_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] MultipleContainedPackagesOrClasses_iter_0_edge__edge0_AllowedTypes = null;
		public static bool[] MultipleContainedPackagesOrClasses_iter_0_edge__edge0_IsAllowedType = null;
		public enum MultipleContainedPackagesOrClasses_iter_0_NodeNums { @sub, @p, };
		public enum MultipleContainedPackagesOrClasses_iter_0_EdgeNums { @_edge0, };
		public enum MultipleContainedPackagesOrClasses_iter_0_VariableNums { };
		public enum MultipleContainedPackagesOrClasses_iter_0_SubNums { @mpc, };
		public enum MultipleContainedPackagesOrClasses_iter_0_AltNums { };
		public enum MultipleContainedPackagesOrClasses_iter_0_IterNums { };




		public GRGEN_LGSP.PatternGraph MultipleContainedPackagesOrClasses_iter_0;

		public static GRGEN_LIBGR.NodeType[] MultipleContainedPackagesOrClasses_iter_1_node_c_AllowedTypes = null;
		public static bool[] MultipleContainedPackagesOrClasses_iter_1_node_c_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] MultipleContainedPackagesOrClasses_iter_1_edge__edge0_AllowedTypes = null;
		public static bool[] MultipleContainedPackagesOrClasses_iter_1_edge__edge0_IsAllowedType = null;
		public enum MultipleContainedPackagesOrClasses_iter_1_NodeNums { @c, @p, };
		public enum MultipleContainedPackagesOrClasses_iter_1_EdgeNums { @_edge0, };
		public enum MultipleContainedPackagesOrClasses_iter_1_VariableNums { };
		public enum MultipleContainedPackagesOrClasses_iter_1_SubNums { @mm, @mv, };
		public enum MultipleContainedPackagesOrClasses_iter_1_AltNums { };
		public enum MultipleContainedPackagesOrClasses_iter_1_IterNums { };




		public GRGEN_LGSP.PatternGraph MultipleContainedPackagesOrClasses_iter_1;


		private Pattern_MultipleContainedPackagesOrClasses()
		{
			name = "MultipleContainedPackagesOrClasses";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Package.typeVar, };
			inputNames = new string[] { "MultipleContainedPackagesOrClasses_node_p", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };

		}
		private void initialize()
		{
			bool[,] MultipleContainedPackagesOrClasses_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] MultipleContainedPackagesOrClasses_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] MultipleContainedPackagesOrClasses_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] MultipleContainedPackagesOrClasses_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode MultipleContainedPackagesOrClasses_node_p = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Package, "GRGEN_MODEL.IPackage", "MultipleContainedPackagesOrClasses_node_p", "p", MultipleContainedPackagesOrClasses_node_p_AllowedTypes, MultipleContainedPackagesOrClasses_node_p_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			bool[,] MultipleContainedPackagesOrClasses_iter_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MultipleContainedPackagesOrClasses_iter_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MultipleContainedPackagesOrClasses_iter_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MultipleContainedPackagesOrClasses_iter_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MultipleContainedPackagesOrClasses_iter_0_node_sub = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Package, "GRGEN_MODEL.IPackage", "MultipleContainedPackagesOrClasses_iter_0_node_sub", "sub", MultipleContainedPackagesOrClasses_iter_0_node_sub_AllowedTypes, MultipleContainedPackagesOrClasses_iter_0_node_sub_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MultipleContainedPackagesOrClasses_iter_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "MultipleContainedPackagesOrClasses_iter_0_edge__edge0", "_edge0", MultipleContainedPackagesOrClasses_iter_0_edge__edge0_AllowedTypes, MultipleContainedPackagesOrClasses_iter_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding MultipleContainedPackagesOrClasses_iter_0_mpc = new GRGEN_LGSP.PatternGraphEmbedding("mpc", Pattern_MultipleContainedPackagesOrClasses.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MultipleContainedPackagesOrClasses_iter_0_node_sub"),
				}, 
				new string[] { }, new string[] { "MultipleContainedPackagesOrClasses_iter_0_node_sub" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			MultipleContainedPackagesOrClasses_iter_0 = new GRGEN_LGSP.PatternGraph(
				"iter_0",
				"MultipleContainedPackagesOrClasses_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleContainedPackagesOrClasses_iter_0_node_sub, MultipleContainedPackagesOrClasses_node_p }, 
				new GRGEN_LGSP.PatternEdge[] { MultipleContainedPackagesOrClasses_iter_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { MultipleContainedPackagesOrClasses_iter_0_mpc }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MultipleContainedPackagesOrClasses_iter_0_isNodeHomomorphicGlobal,
				MultipleContainedPackagesOrClasses_iter_0_isEdgeHomomorphicGlobal,
				MultipleContainedPackagesOrClasses_iter_0_isNodeTotallyHomomorphic,
				MultipleContainedPackagesOrClasses_iter_0_isEdgeTotallyHomomorphic
			);
			MultipleContainedPackagesOrClasses_iter_0.edgeToSourceNode.Add(MultipleContainedPackagesOrClasses_iter_0_edge__edge0, MultipleContainedPackagesOrClasses_iter_0_node_sub);
			MultipleContainedPackagesOrClasses_iter_0.edgeToTargetNode.Add(MultipleContainedPackagesOrClasses_iter_0_edge__edge0, MultipleContainedPackagesOrClasses_node_p);

			bool[,] MultipleContainedPackagesOrClasses_iter_1_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MultipleContainedPackagesOrClasses_iter_1_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MultipleContainedPackagesOrClasses_iter_1_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MultipleContainedPackagesOrClasses_iter_1_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MultipleContainedPackagesOrClasses_iter_1_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "MultipleContainedPackagesOrClasses_iter_1_node_c", "c", MultipleContainedPackagesOrClasses_iter_1_node_c_AllowedTypes, MultipleContainedPackagesOrClasses_iter_1_node_c_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MultipleContainedPackagesOrClasses_iter_1_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "MultipleContainedPackagesOrClasses_iter_1_edge__edge0", "_edge0", MultipleContainedPackagesOrClasses_iter_1_edge__edge0_AllowedTypes, MultipleContainedPackagesOrClasses_iter_1_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding MultipleContainedPackagesOrClasses_iter_1_mm = new GRGEN_LGSP.PatternGraphEmbedding("mm", Pattern_MultipleMethodBodies.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MultipleContainedPackagesOrClasses_iter_1_node_c"),
				}, 
				new string[] { }, new string[] { "MultipleContainedPackagesOrClasses_iter_1_node_c" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			GRGEN_LGSP.PatternGraphEmbedding MultipleContainedPackagesOrClasses_iter_1_mv = new GRGEN_LGSP.PatternGraphEmbedding("mv", Pattern_MultipleVariables.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MultipleContainedPackagesOrClasses_iter_1_node_c"),
				}, 
				new string[] { }, new string[] { "MultipleContainedPackagesOrClasses_iter_1_node_c" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			MultipleContainedPackagesOrClasses_iter_1 = new GRGEN_LGSP.PatternGraph(
				"iter_1",
				"MultipleContainedPackagesOrClasses_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleContainedPackagesOrClasses_iter_1_node_c, MultipleContainedPackagesOrClasses_node_p }, 
				new GRGEN_LGSP.PatternEdge[] { MultipleContainedPackagesOrClasses_iter_1_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { MultipleContainedPackagesOrClasses_iter_1_mm, MultipleContainedPackagesOrClasses_iter_1_mv }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MultipleContainedPackagesOrClasses_iter_1_isNodeHomomorphicGlobal,
				MultipleContainedPackagesOrClasses_iter_1_isEdgeHomomorphicGlobal,
				MultipleContainedPackagesOrClasses_iter_1_isNodeTotallyHomomorphic,
				MultipleContainedPackagesOrClasses_iter_1_isEdgeTotallyHomomorphic
			);
			MultipleContainedPackagesOrClasses_iter_1.edgeToSourceNode.Add(MultipleContainedPackagesOrClasses_iter_1_edge__edge0, MultipleContainedPackagesOrClasses_iter_1_node_c);
			MultipleContainedPackagesOrClasses_iter_1.edgeToTargetNode.Add(MultipleContainedPackagesOrClasses_iter_1_edge__edge0, MultipleContainedPackagesOrClasses_node_p);

			GRGEN_LGSP.Iterated MultipleContainedPackagesOrClasses_iter_0_it = new GRGEN_LGSP.Iterated( MultipleContainedPackagesOrClasses_iter_0, 0, 0);
			GRGEN_LGSP.Iterated MultipleContainedPackagesOrClasses_iter_1_it = new GRGEN_LGSP.Iterated( MultipleContainedPackagesOrClasses_iter_1, 0, 0);
			pat_MultipleContainedPackagesOrClasses = new GRGEN_LGSP.PatternGraph(
				"MultipleContainedPackagesOrClasses",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleContainedPackagesOrClasses_node_p }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] { MultipleContainedPackagesOrClasses_iter_0_it, MultipleContainedPackagesOrClasses_iter_1_it,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				MultipleContainedPackagesOrClasses_isNodeHomomorphicGlobal,
				MultipleContainedPackagesOrClasses_isEdgeHomomorphicGlobal,
				MultipleContainedPackagesOrClasses_isNodeTotallyHomomorphic,
				MultipleContainedPackagesOrClasses_isEdgeTotallyHomomorphic
			);
			MultipleContainedPackagesOrClasses_iter_0.embeddingGraph = pat_MultipleContainedPackagesOrClasses;
			MultipleContainedPackagesOrClasses_iter_1.embeddingGraph = pat_MultipleContainedPackagesOrClasses;

			MultipleContainedPackagesOrClasses_node_p.pointOfDefinition = null;
			MultipleContainedPackagesOrClasses_iter_0_node_sub.pointOfDefinition = MultipleContainedPackagesOrClasses_iter_0;
			MultipleContainedPackagesOrClasses_iter_0_edge__edge0.pointOfDefinition = MultipleContainedPackagesOrClasses_iter_0;
			MultipleContainedPackagesOrClasses_iter_0_mpc.PointOfDefinition = MultipleContainedPackagesOrClasses_iter_0;
			MultipleContainedPackagesOrClasses_iter_1_node_c.pointOfDefinition = MultipleContainedPackagesOrClasses_iter_1;
			MultipleContainedPackagesOrClasses_iter_1_edge__edge0.pointOfDefinition = MultipleContainedPackagesOrClasses_iter_1;
			MultipleContainedPackagesOrClasses_iter_1_mm.PointOfDefinition = MultipleContainedPackagesOrClasses_iter_1;
			MultipleContainedPackagesOrClasses_iter_1_mv.PointOfDefinition = MultipleContainedPackagesOrClasses_iter_1;

			patternGraph = pat_MultipleContainedPackagesOrClasses;
		}


		public void MultipleContainedPackagesOrClasses_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleContainedPackagesOrClasses curMatch = (Match_MultipleContainedPackagesOrClasses)_curMatch;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleContainedPackagesOrClasses_iter_0, IMatch_MultipleContainedPackagesOrClasses_iter_0> iterated_iter_0 = curMatch._iter_0;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleContainedPackagesOrClasses_iter_1, IMatch_MultipleContainedPackagesOrClasses_iter_1> iterated_iter_1 = curMatch._iter_1;
			graph.SettingAddedNodeNames( MultipleContainedPackagesOrClasses_addedNodeNames );
			MultipleContainedPackagesOrClasses_iter_0_Modify(graph, iterated_iter_0);
			MultipleContainedPackagesOrClasses_iter_1_Modify(graph, iterated_iter_1);
			graph.SettingAddedEdgeNames( MultipleContainedPackagesOrClasses_addedEdgeNames );
		}
		private static string[] MultipleContainedPackagesOrClasses_addedNodeNames = new string[] {  };
		private static string[] MultipleContainedPackagesOrClasses_addedEdgeNames = new string[] {  };

		public void MultipleContainedPackagesOrClasses_Create(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPNode node_p)
		{
			graph.SettingAddedNodeNames( create_MultipleContainedPackagesOrClasses_addedNodeNames );
			graph.SettingAddedEdgeNames( create_MultipleContainedPackagesOrClasses_addedEdgeNames );
		}
		private static string[] create_MultipleContainedPackagesOrClasses_addedNodeNames = new string[] {  };
		private static string[] create_MultipleContainedPackagesOrClasses_addedEdgeNames = new string[] {  };

		public void MultipleContainedPackagesOrClasses_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleContainedPackagesOrClasses curMatch)
		{
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleContainedPackagesOrClasses_iter_0, IMatch_MultipleContainedPackagesOrClasses_iter_0> iterated_iter_0 = curMatch._iter_0;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleContainedPackagesOrClasses_iter_1, IMatch_MultipleContainedPackagesOrClasses_iter_1> iterated_iter_1 = curMatch._iter_1;
			MultipleContainedPackagesOrClasses_iter_0_Delete(graph, iterated_iter_0);
			MultipleContainedPackagesOrClasses_iter_1_Delete(graph, iterated_iter_1);
		}

		public void MultipleContainedPackagesOrClasses_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleContainedPackagesOrClasses_iter_0, IMatch_MultipleContainedPackagesOrClasses_iter_0> curMatches)
		{
			for(Match_MultipleContainedPackagesOrClasses_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleContainedPackagesOrClasses_iter_0_Modify(graph, curMatch);
			}
		}

		public void MultipleContainedPackagesOrClasses_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleContainedPackagesOrClasses_iter_0, IMatch_MultipleContainedPackagesOrClasses_iter_0> curMatches)
		{
			for(Match_MultipleContainedPackagesOrClasses_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleContainedPackagesOrClasses_iter_0_Delete(graph, curMatch);
			}
		}

		public void MultipleContainedPackagesOrClasses_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleContainedPackagesOrClasses_iter_0 curMatch = (Match_MultipleContainedPackagesOrClasses_iter_0)_curMatch;
			GRGEN_MODEL.IPackage inode_sub = curMatch.node_sub;
			Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses subpattern_mpc = curMatch.@_mpc;
			graph.SettingAddedNodeNames( MultipleContainedPackagesOrClasses_iter_0_addedNodeNames );
			graph.EmitWriter.Write("package ");
			graph.EmitWriter.Write(inode_sub.@name);
			graph.EmitWriter.Write("\n{\n");
			Pattern_MultipleContainedPackagesOrClasses.Instance.MultipleContainedPackagesOrClasses_Modify(graph, subpattern_mpc);
			graph.EmitWriter.Write("}\n");
			graph.SettingAddedEdgeNames( MultipleContainedPackagesOrClasses_iter_0_addedEdgeNames );
			string tempvar_node_sub_name = inode_sub.@name;
		}
		private static string[] MultipleContainedPackagesOrClasses_iter_0_addedNodeNames = new string[] {  };
		private static string[] MultipleContainedPackagesOrClasses_iter_0_addedEdgeNames = new string[] {  };

		public void MultipleContainedPackagesOrClasses_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleContainedPackagesOrClasses_iter_0 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_sub = curMatch._node_sub;
			GRGEN_LGSP.LGSPNode node_p = curMatch._node_p;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses subpattern_mpc = curMatch.@_mpc;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_sub);
			graph.Remove(node_sub);
			graph.RemoveEdges(node_p);
			graph.Remove(node_p);
			Pattern_MultipleContainedPackagesOrClasses.Instance.MultipleContainedPackagesOrClasses_Delete(graph, subpattern_mpc);
		}

		public void MultipleContainedPackagesOrClasses_iter_1_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleContainedPackagesOrClasses_iter_1, IMatch_MultipleContainedPackagesOrClasses_iter_1> curMatches)
		{
			for(Match_MultipleContainedPackagesOrClasses_iter_1 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleContainedPackagesOrClasses_iter_1_Modify(graph, curMatch);
			}
		}

		public void MultipleContainedPackagesOrClasses_iter_1_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleContainedPackagesOrClasses_iter_1, IMatch_MultipleContainedPackagesOrClasses_iter_1> curMatches)
		{
			for(Match_MultipleContainedPackagesOrClasses_iter_1 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleContainedPackagesOrClasses_iter_1_Delete(graph, curMatch);
			}
		}

		public void MultipleContainedPackagesOrClasses_iter_1_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleContainedPackagesOrClasses_iter_1 curMatch = (Match_MultipleContainedPackagesOrClasses_iter_1)_curMatch;
			GRGEN_MODEL.IClass inode_c = curMatch.node_c;
			Pattern_MultipleMethodBodies.Match_MultipleMethodBodies subpattern_mm = curMatch.@_mm;
			Pattern_MultipleVariables.Match_MultipleVariables subpattern_mv = curMatch.@_mv;
			graph.SettingAddedNodeNames( MultipleContainedPackagesOrClasses_iter_1_addedNodeNames );
			graph.EmitWriter.Write("class ");
			graph.EmitWriter.Write(inode_c.@name);
			graph.EmitWriter.Write(" {\n");
			Pattern_MultipleMethodBodies.Instance.MultipleMethodBodies_Modify(graph, subpattern_mm);
			Pattern_MultipleVariables.Instance.MultipleVariables_Modify(graph, subpattern_mv);
			graph.EmitWriter.Write("}\n");
			graph.SettingAddedEdgeNames( MultipleContainedPackagesOrClasses_iter_1_addedEdgeNames );
			string tempvar_node_c_name = inode_c.@name;
		}
		private static string[] MultipleContainedPackagesOrClasses_iter_1_addedNodeNames = new string[] {  };
		private static string[] MultipleContainedPackagesOrClasses_iter_1_addedEdgeNames = new string[] {  };

		public void MultipleContainedPackagesOrClasses_iter_1_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleContainedPackagesOrClasses_iter_1 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPNode node_p = curMatch._node_p;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_MultipleMethodBodies.Match_MultipleMethodBodies subpattern_mm = curMatch.@_mm;
			Pattern_MultipleVariables.Match_MultipleVariables subpattern_mv = curMatch.@_mv;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_c);
			graph.Remove(node_c);
			graph.RemoveEdges(node_p);
			graph.Remove(node_p);
			Pattern_MultipleMethodBodies.Instance.MultipleMethodBodies_Delete(graph, subpattern_mm);
			Pattern_MultipleVariables.Instance.MultipleVariables_Delete(graph, subpattern_mv);
		}

		static Pattern_MultipleContainedPackagesOrClasses() {
		}

		public interface IMatch_MultipleContainedPackagesOrClasses : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IPackage node_p { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			GRGEN_LIBGR.IMatchesExact<IMatch_MultipleContainedPackagesOrClasses_iter_0> iter_0 { get; }
			GRGEN_LIBGR.IMatchesExact<IMatch_MultipleContainedPackagesOrClasses_iter_1> iter_1 { get; }
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MultipleContainedPackagesOrClasses_iter_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IPackage node_sub { get; }
			GRGEN_MODEL.IPackage node_p { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses @mpc { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MultipleContainedPackagesOrClasses_iter_1 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IClass node_c { get; }
			GRGEN_MODEL.IPackage node_p { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_MultipleMethodBodies.Match_MultipleMethodBodies @mm { get; }
			@Pattern_MultipleVariables.Match_MultipleVariables @mv { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_MultipleContainedPackagesOrClasses : GRGEN_LGSP.ListElement<Match_MultipleContainedPackagesOrClasses>, IMatch_MultipleContainedPackagesOrClasses
		{
			public GRGEN_MODEL.IPackage node_p { get { return (GRGEN_MODEL.IPackage)_node_p; } }
			public GRGEN_LGSP.LGSPNode _node_p;
			public enum MultipleContainedPackagesOrClasses_NodeNums { @p, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleContainedPackagesOrClasses_NodeNums.@p: return _node_p;
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IMatchesExact<IMatch_MultipleContainedPackagesOrClasses_iter_0> iter_0 { get { return _iter_0; } }
			public GRGEN_LIBGR.IMatchesExact<IMatch_MultipleContainedPackagesOrClasses_iter_1> iter_1 { get { return _iter_1; } }
			public GRGEN_LGSP.LGSPMatchesList<Match_MultipleContainedPackagesOrClasses_iter_0, IMatch_MultipleContainedPackagesOrClasses_iter_0> _iter_0;
			public GRGEN_LGSP.LGSPMatchesList<Match_MultipleContainedPackagesOrClasses_iter_1, IMatch_MultipleContainedPackagesOrClasses_iter_1> _iter_1;
			public enum MultipleContainedPackagesOrClasses_IterNums { @iter_0, @iter_1, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 2;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				case (int)MultipleContainedPackagesOrClasses_IterNums.@iter_0: return _iter_0;
				case (int)MultipleContainedPackagesOrClasses_IterNums.@iter_1: return _iter_1;
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleContainedPackagesOrClasses.instance.pat_MultipleContainedPackagesOrClasses; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MultipleContainedPackagesOrClasses_iter_0 : GRGEN_LGSP.ListElement<Match_MultipleContainedPackagesOrClasses_iter_0>, IMatch_MultipleContainedPackagesOrClasses_iter_0
		{
			public GRGEN_MODEL.IPackage node_sub { get { return (GRGEN_MODEL.IPackage)_node_sub; } }
			public GRGEN_MODEL.IPackage node_p { get { return (GRGEN_MODEL.IPackage)_node_p; } }
			public GRGEN_LGSP.LGSPNode _node_sub;
			public GRGEN_LGSP.LGSPNode _node_p;
			public enum MultipleContainedPackagesOrClasses_iter_0_NodeNums { @sub, @p, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleContainedPackagesOrClasses_iter_0_NodeNums.@sub: return _node_sub;
				case (int)MultipleContainedPackagesOrClasses_iter_0_NodeNums.@p: return _node_p;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge0 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MultipleContainedPackagesOrClasses_iter_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MultipleContainedPackagesOrClasses_iter_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_iter_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses @mpc { get { return @_mpc; } }
			public @Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses @_mpc;
			public enum MultipleContainedPackagesOrClasses_iter_0_SubNums { @mpc, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)MultipleContainedPackagesOrClasses_iter_0_SubNums.@mpc: return _mpc;
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_iter_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_iter_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_iter_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleContainedPackagesOrClasses.instance.MultipleContainedPackagesOrClasses_iter_0; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MultipleContainedPackagesOrClasses_iter_1 : GRGEN_LGSP.ListElement<Match_MultipleContainedPackagesOrClasses_iter_1>, IMatch_MultipleContainedPackagesOrClasses_iter_1
		{
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_MODEL.IPackage node_p { get { return (GRGEN_MODEL.IPackage)_node_p; } }
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_p;
			public enum MultipleContainedPackagesOrClasses_iter_1_NodeNums { @c, @p, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleContainedPackagesOrClasses_iter_1_NodeNums.@c: return _node_c;
				case (int)MultipleContainedPackagesOrClasses_iter_1_NodeNums.@p: return _node_p;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge0 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MultipleContainedPackagesOrClasses_iter_1_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MultipleContainedPackagesOrClasses_iter_1_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_iter_1_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_MultipleMethodBodies.Match_MultipleMethodBodies @mm { get { return @_mm; } }
			public @Pattern_MultipleVariables.Match_MultipleVariables @mv { get { return @_mv; } }
			public @Pattern_MultipleMethodBodies.Match_MultipleMethodBodies @_mm;
			public @Pattern_MultipleVariables.Match_MultipleVariables @_mv;
			public enum MultipleContainedPackagesOrClasses_iter_1_SubNums { @mm, @mv, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 2;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)MultipleContainedPackagesOrClasses_iter_1_SubNums.@mm: return _mm;
				case (int)MultipleContainedPackagesOrClasses_iter_1_SubNums.@mv: return _mv;
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_iter_1_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_iter_1_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleContainedPackagesOrClasses_iter_1_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleContainedPackagesOrClasses.instance.MultipleContainedPackagesOrClasses_iter_1; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Pattern_MultipleVariables : GRGEN_LGSP.LGSPMatchingPattern
	{
		private static Pattern_MultipleVariables instance = null;
		public static Pattern_MultipleVariables Instance { get { if (instance==null) { instance = new Pattern_MultipleVariables(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] MultipleVariables_node_c_AllowedTypes = null;
		public static bool[] MultipleVariables_node_c_IsAllowedType = null;
		public enum MultipleVariables_NodeNums { @c, };
		public enum MultipleVariables_EdgeNums { };
		public enum MultipleVariables_VariableNums { };
		public enum MultipleVariables_SubNums { };
		public enum MultipleVariables_AltNums { };
		public enum MultipleVariables_IterNums { @iter_0, };




		public GRGEN_LGSP.PatternGraph pat_MultipleVariables;

		public static GRGEN_LIBGR.NodeType[] MultipleVariables_iter_0_node_v_AllowedTypes = null;
		public static bool[] MultipleVariables_iter_0_node_v_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] MultipleVariables_iter_0_edge__edge0_AllowedTypes = null;
		public static bool[] MultipleVariables_iter_0_edge__edge0_IsAllowedType = null;
		public enum MultipleVariables_iter_0_NodeNums { @v, @c, };
		public enum MultipleVariables_iter_0_EdgeNums { @_edge0, };
		public enum MultipleVariables_iter_0_VariableNums { };
		public enum MultipleVariables_iter_0_SubNums { };
		public enum MultipleVariables_iter_0_AltNums { };
		public enum MultipleVariables_iter_0_IterNums { };




		public GRGEN_LGSP.PatternGraph MultipleVariables_iter_0;


		private Pattern_MultipleVariables()
		{
			name = "MultipleVariables";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, };
			inputNames = new string[] { "MultipleVariables_node_c", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };

		}
		private void initialize()
		{
			bool[,] MultipleVariables_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] MultipleVariables_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] MultipleVariables_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] MultipleVariables_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode MultipleVariables_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "MultipleVariables_node_c", "c", MultipleVariables_node_c_AllowedTypes, MultipleVariables_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			bool[,] MultipleVariables_iter_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MultipleVariables_iter_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MultipleVariables_iter_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MultipleVariables_iter_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MultipleVariables_iter_0_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "MultipleVariables_iter_0_node_v", "v", MultipleVariables_iter_0_node_v_AllowedTypes, MultipleVariables_iter_0_node_v_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MultipleVariables_iter_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "MultipleVariables_iter_0_edge__edge0", "_edge0", MultipleVariables_iter_0_edge__edge0_AllowedTypes, MultipleVariables_iter_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			MultipleVariables_iter_0 = new GRGEN_LGSP.PatternGraph(
				"iter_0",
				"MultipleVariables_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleVariables_iter_0_node_v, MultipleVariables_node_c }, 
				new GRGEN_LGSP.PatternEdge[] { MultipleVariables_iter_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MultipleVariables_iter_0_isNodeHomomorphicGlobal,
				MultipleVariables_iter_0_isEdgeHomomorphicGlobal,
				MultipleVariables_iter_0_isNodeTotallyHomomorphic,
				MultipleVariables_iter_0_isEdgeTotallyHomomorphic
			);
			MultipleVariables_iter_0.edgeToSourceNode.Add(MultipleVariables_iter_0_edge__edge0, MultipleVariables_iter_0_node_v);
			MultipleVariables_iter_0.edgeToTargetNode.Add(MultipleVariables_iter_0_edge__edge0, MultipleVariables_node_c);

			GRGEN_LGSP.Iterated MultipleVariables_iter_0_it = new GRGEN_LGSP.Iterated( MultipleVariables_iter_0, 0, 0);
			pat_MultipleVariables = new GRGEN_LGSP.PatternGraph(
				"MultipleVariables",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleVariables_node_c }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] { MultipleVariables_iter_0_it,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				MultipleVariables_isNodeHomomorphicGlobal,
				MultipleVariables_isEdgeHomomorphicGlobal,
				MultipleVariables_isNodeTotallyHomomorphic,
				MultipleVariables_isEdgeTotallyHomomorphic
			);
			MultipleVariables_iter_0.embeddingGraph = pat_MultipleVariables;

			MultipleVariables_node_c.pointOfDefinition = null;
			MultipleVariables_iter_0_node_v.pointOfDefinition = MultipleVariables_iter_0;
			MultipleVariables_iter_0_edge__edge0.pointOfDefinition = MultipleVariables_iter_0;

			patternGraph = pat_MultipleVariables;
		}


		public void MultipleVariables_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleVariables curMatch = (Match_MultipleVariables)_curMatch;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleVariables_iter_0, IMatch_MultipleVariables_iter_0> iterated_iter_0 = curMatch._iter_0;
			graph.SettingAddedNodeNames( MultipleVariables_addedNodeNames );
			MultipleVariables_iter_0_Modify(graph, iterated_iter_0);
			graph.SettingAddedEdgeNames( MultipleVariables_addedEdgeNames );
		}
		private static string[] MultipleVariables_addedNodeNames = new string[] {  };
		private static string[] MultipleVariables_addedEdgeNames = new string[] {  };

		public void MultipleVariables_Create(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPNode node_c)
		{
			graph.SettingAddedNodeNames( create_MultipleVariables_addedNodeNames );
			graph.SettingAddedEdgeNames( create_MultipleVariables_addedEdgeNames );
		}
		private static string[] create_MultipleVariables_addedNodeNames = new string[] {  };
		private static string[] create_MultipleVariables_addedEdgeNames = new string[] {  };

		public void MultipleVariables_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleVariables curMatch)
		{
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleVariables_iter_0, IMatch_MultipleVariables_iter_0> iterated_iter_0 = curMatch._iter_0;
			MultipleVariables_iter_0_Delete(graph, iterated_iter_0);
		}

		public void MultipleVariables_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleVariables_iter_0, IMatch_MultipleVariables_iter_0> curMatches)
		{
			for(Match_MultipleVariables_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleVariables_iter_0_Modify(graph, curMatch);
			}
		}

		public void MultipleVariables_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleVariables_iter_0, IMatch_MultipleVariables_iter_0> curMatches)
		{
			for(Match_MultipleVariables_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleVariables_iter_0_Delete(graph, curMatch);
			}
		}

		public void MultipleVariables_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleVariables_iter_0 curMatch = (Match_MultipleVariables_iter_0)_curMatch;
			GRGEN_MODEL.IVariable inode_v = curMatch.node_v;
			graph.SettingAddedNodeNames( MultipleVariables_iter_0_addedNodeNames );
			graph.EmitWriter.Write("var ");
			graph.EmitWriter.Write(inode_v.@name);
			graph.EmitWriter.Write(";\n");
			graph.SettingAddedEdgeNames( MultipleVariables_iter_0_addedEdgeNames );
			string tempvar_node_v_name = inode_v.@name;
		}
		private static string[] MultipleVariables_iter_0_addedNodeNames = new string[] {  };
		private static string[] MultipleVariables_iter_0_addedEdgeNames = new string[] {  };

		public void MultipleVariables_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleVariables_iter_0 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_v = curMatch._node_v;
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_v);
			graph.Remove(node_v);
			graph.RemoveEdges(node_c);
			graph.Remove(node_c);
		}

		static Pattern_MultipleVariables() {
		}

		public interface IMatch_MultipleVariables : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			GRGEN_LIBGR.IMatchesExact<IMatch_MultipleVariables_iter_0> iter_0 { get; }
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MultipleVariables_iter_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IVariable node_v { get; }
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_MultipleVariables : GRGEN_LGSP.ListElement<Match_MultipleVariables>, IMatch_MultipleVariables
		{
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum MultipleVariables_NodeNums { @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleVariables_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public enum MultipleVariables_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleVariables_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleVariables_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleVariables_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IMatchesExact<IMatch_MultipleVariables_iter_0> iter_0 { get { return _iter_0; } }
			public GRGEN_LGSP.LGSPMatchesList<Match_MultipleVariables_iter_0, IMatch_MultipleVariables_iter_0> _iter_0;
			public enum MultipleVariables_IterNums { @iter_0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 1;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				case (int)MultipleVariables_IterNums.@iter_0: return _iter_0;
				default: return null;
				}
			}
			
			public enum MultipleVariables_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleVariables.instance.pat_MultipleVariables; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MultipleVariables_iter_0 : GRGEN_LGSP.ListElement<Match_MultipleVariables_iter_0>, IMatch_MultipleVariables_iter_0
		{
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_v;
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum MultipleVariables_iter_0_NodeNums { @v, @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleVariables_iter_0_NodeNums.@v: return _node_v;
				case (int)MultipleVariables_iter_0_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge0 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MultipleVariables_iter_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MultipleVariables_iter_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MultipleVariables_iter_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleVariables_iter_0_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleVariables_iter_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleVariables_iter_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleVariables_iter_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleVariables.instance.MultipleVariables_iter_0; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Pattern_MultipleMethodBodies : GRGEN_LGSP.LGSPMatchingPattern
	{
		private static Pattern_MultipleMethodBodies instance = null;
		public static Pattern_MultipleMethodBodies Instance { get { if (instance==null) { instance = new Pattern_MultipleMethodBodies(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] MultipleMethodBodies_node_c_AllowedTypes = null;
		public static bool[] MultipleMethodBodies_node_c_IsAllowedType = null;
		public enum MultipleMethodBodies_NodeNums { @c, };
		public enum MultipleMethodBodies_EdgeNums { };
		public enum MultipleMethodBodies_VariableNums { };
		public enum MultipleMethodBodies_SubNums { };
		public enum MultipleMethodBodies_AltNums { };
		public enum MultipleMethodBodies_IterNums { @iter_0, };




		public GRGEN_LGSP.PatternGraph pat_MultipleMethodBodies;

		public static GRGEN_LIBGR.NodeType[] MultipleMethodBodies_iter_0_node_mb_AllowedTypes = null;
		public static bool[] MultipleMethodBodies_iter_0_node_mb_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] MultipleMethodBodies_iter_0_edge__edge0_AllowedTypes = null;
		public static bool[] MultipleMethodBodies_iter_0_edge__edge0_IsAllowedType = null;
		public enum MultipleMethodBodies_iter_0_NodeNums { @mb, @c, };
		public enum MultipleMethodBodies_iter_0_EdgeNums { @_edge0, };
		public enum MultipleMethodBodies_iter_0_VariableNums { };
		public enum MultipleMethodBodies_iter_0_SubNums { @bi, };
		public enum MultipleMethodBodies_iter_0_AltNums { };
		public enum MultipleMethodBodies_iter_0_IterNums { };




		public GRGEN_LGSP.PatternGraph MultipleMethodBodies_iter_0;


		private Pattern_MultipleMethodBodies()
		{
			name = "MultipleMethodBodies";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, };
			inputNames = new string[] { "MultipleMethodBodies_node_c", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };

		}
		private void initialize()
		{
			bool[,] MultipleMethodBodies_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] MultipleMethodBodies_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] MultipleMethodBodies_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] MultipleMethodBodies_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode MultipleMethodBodies_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "MultipleMethodBodies_node_c", "c", MultipleMethodBodies_node_c_AllowedTypes, MultipleMethodBodies_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			bool[,] MultipleMethodBodies_iter_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MultipleMethodBodies_iter_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MultipleMethodBodies_iter_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MultipleMethodBodies_iter_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MultipleMethodBodies_iter_0_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "MultipleMethodBodies_iter_0_node_mb", "mb", MultipleMethodBodies_iter_0_node_mb_AllowedTypes, MultipleMethodBodies_iter_0_node_mb_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MultipleMethodBodies_iter_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "MultipleMethodBodies_iter_0_edge__edge0", "_edge0", MultipleMethodBodies_iter_0_edge__edge0_AllowedTypes, MultipleMethodBodies_iter_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding MultipleMethodBodies_iter_0_bi = new GRGEN_LGSP.PatternGraphEmbedding("bi", Pattern_MethodBodyAndImplementation.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MultipleMethodBodies_iter_0_node_mb"),
				}, 
				new string[] { }, new string[] { "MultipleMethodBodies_iter_0_node_mb" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			MultipleMethodBodies_iter_0 = new GRGEN_LGSP.PatternGraph(
				"iter_0",
				"MultipleMethodBodies_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleMethodBodies_iter_0_node_mb, MultipleMethodBodies_node_c }, 
				new GRGEN_LGSP.PatternEdge[] { MultipleMethodBodies_iter_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { MultipleMethodBodies_iter_0_bi }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MultipleMethodBodies_iter_0_isNodeHomomorphicGlobal,
				MultipleMethodBodies_iter_0_isEdgeHomomorphicGlobal,
				MultipleMethodBodies_iter_0_isNodeTotallyHomomorphic,
				MultipleMethodBodies_iter_0_isEdgeTotallyHomomorphic
			);
			MultipleMethodBodies_iter_0.edgeToSourceNode.Add(MultipleMethodBodies_iter_0_edge__edge0, MultipleMethodBodies_iter_0_node_mb);
			MultipleMethodBodies_iter_0.edgeToTargetNode.Add(MultipleMethodBodies_iter_0_edge__edge0, MultipleMethodBodies_node_c);

			GRGEN_LGSP.Iterated MultipleMethodBodies_iter_0_it = new GRGEN_LGSP.Iterated( MultipleMethodBodies_iter_0, 0, 0);
			pat_MultipleMethodBodies = new GRGEN_LGSP.PatternGraph(
				"MultipleMethodBodies",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleMethodBodies_node_c }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] { MultipleMethodBodies_iter_0_it,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				MultipleMethodBodies_isNodeHomomorphicGlobal,
				MultipleMethodBodies_isEdgeHomomorphicGlobal,
				MultipleMethodBodies_isNodeTotallyHomomorphic,
				MultipleMethodBodies_isEdgeTotallyHomomorphic
			);
			MultipleMethodBodies_iter_0.embeddingGraph = pat_MultipleMethodBodies;

			MultipleMethodBodies_node_c.pointOfDefinition = null;
			MultipleMethodBodies_iter_0_node_mb.pointOfDefinition = MultipleMethodBodies_iter_0;
			MultipleMethodBodies_iter_0_edge__edge0.pointOfDefinition = MultipleMethodBodies_iter_0;
			MultipleMethodBodies_iter_0_bi.PointOfDefinition = MultipleMethodBodies_iter_0;

			patternGraph = pat_MultipleMethodBodies;
		}


		public void MultipleMethodBodies_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleMethodBodies curMatch = (Match_MultipleMethodBodies)_curMatch;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleMethodBodies_iter_0, IMatch_MultipleMethodBodies_iter_0> iterated_iter_0 = curMatch._iter_0;
			graph.SettingAddedNodeNames( MultipleMethodBodies_addedNodeNames );
			MultipleMethodBodies_iter_0_Modify(graph, iterated_iter_0);
			graph.SettingAddedEdgeNames( MultipleMethodBodies_addedEdgeNames );
		}
		private static string[] MultipleMethodBodies_addedNodeNames = new string[] {  };
		private static string[] MultipleMethodBodies_addedEdgeNames = new string[] {  };

		public void MultipleMethodBodies_Create(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPNode node_c)
		{
			graph.SettingAddedNodeNames( create_MultipleMethodBodies_addedNodeNames );
			graph.SettingAddedEdgeNames( create_MultipleMethodBodies_addedEdgeNames );
		}
		private static string[] create_MultipleMethodBodies_addedNodeNames = new string[] {  };
		private static string[] create_MultipleMethodBodies_addedEdgeNames = new string[] {  };

		public void MultipleMethodBodies_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleMethodBodies curMatch)
		{
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleMethodBodies_iter_0, IMatch_MultipleMethodBodies_iter_0> iterated_iter_0 = curMatch._iter_0;
			MultipleMethodBodies_iter_0_Delete(graph, iterated_iter_0);
		}

		public void MultipleMethodBodies_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleMethodBodies_iter_0, IMatch_MultipleMethodBodies_iter_0> curMatches)
		{
			for(Match_MultipleMethodBodies_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleMethodBodies_iter_0_Modify(graph, curMatch);
			}
		}

		public void MultipleMethodBodies_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleMethodBodies_iter_0, IMatch_MultipleMethodBodies_iter_0> curMatches)
		{
			for(Match_MultipleMethodBodies_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleMethodBodies_iter_0_Delete(graph, curMatch);
			}
		}

		public void MultipleMethodBodies_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleMethodBodies_iter_0 curMatch = (Match_MultipleMethodBodies_iter_0)_curMatch;
			Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation subpattern_bi = curMatch.@_bi;
			graph.SettingAddedNodeNames( MultipleMethodBodies_iter_0_addedNodeNames );
			graph.EmitWriter.Write("method body");
			Pattern_MethodBodyAndImplementation.Instance.MethodBodyAndImplementation_Modify(graph, subpattern_bi);
			graph.EmitWriter.Write(";\n");
			graph.SettingAddedEdgeNames( MultipleMethodBodies_iter_0_addedEdgeNames );
		}
		private static string[] MultipleMethodBodies_iter_0_addedNodeNames = new string[] {  };
		private static string[] MultipleMethodBodies_iter_0_addedEdgeNames = new string[] {  };

		public void MultipleMethodBodies_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleMethodBodies_iter_0 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_mb = curMatch._node_mb;
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation subpattern_bi = curMatch.@_bi;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_mb);
			graph.Remove(node_mb);
			graph.RemoveEdges(node_c);
			graph.Remove(node_c);
			Pattern_MethodBodyAndImplementation.Instance.MethodBodyAndImplementation_Delete(graph, subpattern_bi);
		}

		static Pattern_MultipleMethodBodies() {
		}

		public interface IMatch_MultipleMethodBodies : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			GRGEN_LIBGR.IMatchesExact<IMatch_MultipleMethodBodies_iter_0> iter_0 { get; }
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MultipleMethodBodies_iter_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IMethodBody node_mb { get; }
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation @bi { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_MultipleMethodBodies : GRGEN_LGSP.ListElement<Match_MultipleMethodBodies>, IMatch_MultipleMethodBodies
		{
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum MultipleMethodBodies_NodeNums { @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleMethodBodies_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public enum MultipleMethodBodies_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleMethodBodies_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleMethodBodies_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleMethodBodies_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IMatchesExact<IMatch_MultipleMethodBodies_iter_0> iter_0 { get { return _iter_0; } }
			public GRGEN_LGSP.LGSPMatchesList<Match_MultipleMethodBodies_iter_0, IMatch_MultipleMethodBodies_iter_0> _iter_0;
			public enum MultipleMethodBodies_IterNums { @iter_0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 1;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				case (int)MultipleMethodBodies_IterNums.@iter_0: return _iter_0;
				default: return null;
				}
			}
			
			public enum MultipleMethodBodies_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleMethodBodies.instance.pat_MultipleMethodBodies; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MultipleMethodBodies_iter_0 : GRGEN_LGSP.ListElement<Match_MultipleMethodBodies_iter_0>, IMatch_MultipleMethodBodies_iter_0
		{
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_mb;
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum MultipleMethodBodies_iter_0_NodeNums { @mb, @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleMethodBodies_iter_0_NodeNums.@mb: return _node_mb;
				case (int)MultipleMethodBodies_iter_0_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge0 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MultipleMethodBodies_iter_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MultipleMethodBodies_iter_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MultipleMethodBodies_iter_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation @bi { get { return @_bi; } }
			public @Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation @_bi;
			public enum MultipleMethodBodies_iter_0_SubNums { @bi, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)MultipleMethodBodies_iter_0_SubNums.@bi: return _bi;
				default: return null;
				}
			}
			
			public enum MultipleMethodBodies_iter_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleMethodBodies_iter_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleMethodBodies_iter_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleMethodBodies.instance.MultipleMethodBodies_iter_0; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Pattern_MethodBodyAndImplementation : GRGEN_LGSP.LGSPMatchingPattern
	{
		private static Pattern_MethodBodyAndImplementation instance = null;
		public static Pattern_MethodBodyAndImplementation Instance { get { if (instance==null) { instance = new Pattern_MethodBodyAndImplementation(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] MethodBodyAndImplementation_node_mb_AllowedTypes = null;
		public static bool[] MethodBodyAndImplementation_node_mb_IsAllowedType = null;
		public enum MethodBodyAndImplementation_NodeNums { @mb, };
		public enum MethodBodyAndImplementation_EdgeNums { };
		public enum MethodBodyAndImplementation_VariableNums { };
		public enum MethodBodyAndImplementation_SubNums { };
		public enum MethodBodyAndImplementation_AltNums { };
		public enum MethodBodyAndImplementation_IterNums { @iter_0, @iter_1, };




		public GRGEN_LGSP.PatternGraph pat_MethodBodyAndImplementation;

		public static GRGEN_LIBGR.NodeType[] MethodBodyAndImplementation_iter_0_node_op_AllowedTypes = null;
		public static bool[] MethodBodyAndImplementation_iter_0_node_op_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] MethodBodyAndImplementation_iter_0_edge__edge0_AllowedTypes = null;
		public static bool[] MethodBodyAndImplementation_iter_0_edge__edge0_IsAllowedType = null;
		public enum MethodBodyAndImplementation_iter_0_NodeNums { @op, @mb, };
		public enum MethodBodyAndImplementation_iter_0_EdgeNums { @_edge0, };
		public enum MethodBodyAndImplementation_iter_0_VariableNums { };
		public enum MethodBodyAndImplementation_iter_0_SubNums { @_sub0, };
		public enum MethodBodyAndImplementation_iter_0_AltNums { };
		public enum MethodBodyAndImplementation_iter_0_IterNums { };




		public GRGEN_LGSP.PatternGraph MethodBodyAndImplementation_iter_0;

		public static GRGEN_LIBGR.NodeType[] MethodBodyAndImplementation_iter_1_node_b_AllowedTypes = null;
		public static bool[] MethodBodyAndImplementation_iter_1_node_b_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] MethodBodyAndImplementation_iter_1_edge__edge0_AllowedTypes = null;
		public static bool[] MethodBodyAndImplementation_iter_1_edge__edge0_IsAllowedType = null;
		public enum MethodBodyAndImplementation_iter_1_NodeNums { @b, @mb, };
		public enum MethodBodyAndImplementation_iter_1_EdgeNums { @_edge0, };
		public enum MethodBodyAndImplementation_iter_1_VariableNums { };
		public enum MethodBodyAndImplementation_iter_1_SubNums { @me, };
		public enum MethodBodyAndImplementation_iter_1_AltNums { };
		public enum MethodBodyAndImplementation_iter_1_IterNums { };




		public GRGEN_LGSP.PatternGraph MethodBodyAndImplementation_iter_1;


		private Pattern_MethodBodyAndImplementation()
		{
			name = "MethodBodyAndImplementation";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_MethodBody.typeVar, };
			inputNames = new string[] { "MethodBodyAndImplementation_node_mb", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };

		}
		private void initialize()
		{
			bool[,] MethodBodyAndImplementation_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] MethodBodyAndImplementation_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] MethodBodyAndImplementation_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] MethodBodyAndImplementation_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode MethodBodyAndImplementation_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "MethodBodyAndImplementation_node_mb", "mb", MethodBodyAndImplementation_node_mb_AllowedTypes, MethodBodyAndImplementation_node_mb_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			bool[,] MethodBodyAndImplementation_iter_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MethodBodyAndImplementation_iter_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MethodBodyAndImplementation_iter_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MethodBodyAndImplementation_iter_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MethodBodyAndImplementation_iter_0_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "MethodBodyAndImplementation_iter_0_node_op", "op", MethodBodyAndImplementation_iter_0_node_op_AllowedTypes, MethodBodyAndImplementation_iter_0_node_op_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MethodBodyAndImplementation_iter_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@binding, "GRGEN_MODEL.Ibinding", "MethodBodyAndImplementation_iter_0_edge__edge0", "_edge0", MethodBodyAndImplementation_iter_0_edge__edge0_AllowedTypes, MethodBodyAndImplementation_iter_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding MethodBodyAndImplementation_iter_0__sub0 = new GRGEN_LGSP.PatternGraphEmbedding("_sub0", Pattern_MultipleParameters.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MethodBodyAndImplementation_iter_0_node_op"),
				}, 
				new string[] { }, new string[] { "MethodBodyAndImplementation_iter_0_node_op" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			MethodBodyAndImplementation_iter_0 = new GRGEN_LGSP.PatternGraph(
				"iter_0",
				"MethodBodyAndImplementation_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MethodBodyAndImplementation_iter_0_node_op, MethodBodyAndImplementation_node_mb }, 
				new GRGEN_LGSP.PatternEdge[] { MethodBodyAndImplementation_iter_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { MethodBodyAndImplementation_iter_0__sub0 }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MethodBodyAndImplementation_iter_0_isNodeHomomorphicGlobal,
				MethodBodyAndImplementation_iter_0_isEdgeHomomorphicGlobal,
				MethodBodyAndImplementation_iter_0_isNodeTotallyHomomorphic,
				MethodBodyAndImplementation_iter_0_isEdgeTotallyHomomorphic
			);
			MethodBodyAndImplementation_iter_0.edgeToSourceNode.Add(MethodBodyAndImplementation_iter_0_edge__edge0, MethodBodyAndImplementation_iter_0_node_op);
			MethodBodyAndImplementation_iter_0.edgeToTargetNode.Add(MethodBodyAndImplementation_iter_0_edge__edge0, MethodBodyAndImplementation_node_mb);

			bool[,] MethodBodyAndImplementation_iter_1_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MethodBodyAndImplementation_iter_1_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MethodBodyAndImplementation_iter_1_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MethodBodyAndImplementation_iter_1_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MethodBodyAndImplementation_iter_1_node_b = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Block, "GRGEN_MODEL.IBlock", "MethodBodyAndImplementation_iter_1_node_b", "b", MethodBodyAndImplementation_iter_1_node_b_AllowedTypes, MethodBodyAndImplementation_iter_1_node_b_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MethodBodyAndImplementation_iter_1_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "MethodBodyAndImplementation_iter_1_edge__edge0", "_edge0", MethodBodyAndImplementation_iter_1_edge__edge0_AllowedTypes, MethodBodyAndImplementation_iter_1_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding MethodBodyAndImplementation_iter_1_me = new GRGEN_LGSP.PatternGraphEmbedding("me", Pattern_MultipleExpressions.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MethodBodyAndImplementation_iter_1_node_b"),
				}, 
				new string[] { }, new string[] { "MethodBodyAndImplementation_iter_1_node_b" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			MethodBodyAndImplementation_iter_1 = new GRGEN_LGSP.PatternGraph(
				"iter_1",
				"MethodBodyAndImplementation_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MethodBodyAndImplementation_iter_1_node_b, MethodBodyAndImplementation_node_mb }, 
				new GRGEN_LGSP.PatternEdge[] { MethodBodyAndImplementation_iter_1_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { MethodBodyAndImplementation_iter_1_me }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MethodBodyAndImplementation_iter_1_isNodeHomomorphicGlobal,
				MethodBodyAndImplementation_iter_1_isEdgeHomomorphicGlobal,
				MethodBodyAndImplementation_iter_1_isNodeTotallyHomomorphic,
				MethodBodyAndImplementation_iter_1_isEdgeTotallyHomomorphic
			);
			MethodBodyAndImplementation_iter_1.edgeToSourceNode.Add(MethodBodyAndImplementation_iter_1_edge__edge0, MethodBodyAndImplementation_iter_1_node_b);
			MethodBodyAndImplementation_iter_1.edgeToTargetNode.Add(MethodBodyAndImplementation_iter_1_edge__edge0, MethodBodyAndImplementation_node_mb);

			GRGEN_LGSP.Iterated MethodBodyAndImplementation_iter_0_it = new GRGEN_LGSP.Iterated( MethodBodyAndImplementation_iter_0, 0, 1);
			GRGEN_LGSP.Iterated MethodBodyAndImplementation_iter_1_it = new GRGEN_LGSP.Iterated( MethodBodyAndImplementation_iter_1, 0, 1);
			pat_MethodBodyAndImplementation = new GRGEN_LGSP.PatternGraph(
				"MethodBodyAndImplementation",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MethodBodyAndImplementation_node_mb }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] { MethodBodyAndImplementation_iter_0_it, MethodBodyAndImplementation_iter_1_it,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				MethodBodyAndImplementation_isNodeHomomorphicGlobal,
				MethodBodyAndImplementation_isEdgeHomomorphicGlobal,
				MethodBodyAndImplementation_isNodeTotallyHomomorphic,
				MethodBodyAndImplementation_isEdgeTotallyHomomorphic
			);
			MethodBodyAndImplementation_iter_0.embeddingGraph = pat_MethodBodyAndImplementation;
			MethodBodyAndImplementation_iter_1.embeddingGraph = pat_MethodBodyAndImplementation;

			MethodBodyAndImplementation_node_mb.pointOfDefinition = null;
			MethodBodyAndImplementation_iter_0_node_op.pointOfDefinition = MethodBodyAndImplementation_iter_0;
			MethodBodyAndImplementation_iter_0_edge__edge0.pointOfDefinition = MethodBodyAndImplementation_iter_0;
			MethodBodyAndImplementation_iter_0__sub0.PointOfDefinition = MethodBodyAndImplementation_iter_0;
			MethodBodyAndImplementation_iter_1_node_b.pointOfDefinition = MethodBodyAndImplementation_iter_1;
			MethodBodyAndImplementation_iter_1_edge__edge0.pointOfDefinition = MethodBodyAndImplementation_iter_1;
			MethodBodyAndImplementation_iter_1_me.PointOfDefinition = MethodBodyAndImplementation_iter_1;

			patternGraph = pat_MethodBodyAndImplementation;
		}


		public void MethodBodyAndImplementation_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MethodBodyAndImplementation curMatch = (Match_MethodBodyAndImplementation)_curMatch;
			GRGEN_LGSP.LGSPMatchesList<Match_MethodBodyAndImplementation_iter_0, IMatch_MethodBodyAndImplementation_iter_0> iterated_iter_0 = curMatch._iter_0;
			GRGEN_LGSP.LGSPMatchesList<Match_MethodBodyAndImplementation_iter_1, IMatch_MethodBodyAndImplementation_iter_1> iterated_iter_1 = curMatch._iter_1;
			graph.SettingAddedNodeNames( MethodBodyAndImplementation_addedNodeNames );
			MethodBodyAndImplementation_iter_0_Modify(graph, iterated_iter_0);
			MethodBodyAndImplementation_iter_1_Modify(graph, iterated_iter_1);
			graph.SettingAddedEdgeNames( MethodBodyAndImplementation_addedEdgeNames );
		}
		private static string[] MethodBodyAndImplementation_addedNodeNames = new string[] {  };
		private static string[] MethodBodyAndImplementation_addedEdgeNames = new string[] {  };

		public void MethodBodyAndImplementation_Create(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPNode node_mb)
		{
			graph.SettingAddedNodeNames( create_MethodBodyAndImplementation_addedNodeNames );
			graph.SettingAddedEdgeNames( create_MethodBodyAndImplementation_addedEdgeNames );
		}
		private static string[] create_MethodBodyAndImplementation_addedNodeNames = new string[] {  };
		private static string[] create_MethodBodyAndImplementation_addedEdgeNames = new string[] {  };

		public void MethodBodyAndImplementation_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MethodBodyAndImplementation curMatch)
		{
			GRGEN_LGSP.LGSPMatchesList<Match_MethodBodyAndImplementation_iter_0, IMatch_MethodBodyAndImplementation_iter_0> iterated_iter_0 = curMatch._iter_0;
			GRGEN_LGSP.LGSPMatchesList<Match_MethodBodyAndImplementation_iter_1, IMatch_MethodBodyAndImplementation_iter_1> iterated_iter_1 = curMatch._iter_1;
			MethodBodyAndImplementation_iter_0_Delete(graph, iterated_iter_0);
			MethodBodyAndImplementation_iter_1_Delete(graph, iterated_iter_1);
		}

		public void MethodBodyAndImplementation_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MethodBodyAndImplementation_iter_0, IMatch_MethodBodyAndImplementation_iter_0> curMatches)
		{
			for(Match_MethodBodyAndImplementation_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MethodBodyAndImplementation_iter_0_Modify(graph, curMatch);
			}
		}

		public void MethodBodyAndImplementation_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MethodBodyAndImplementation_iter_0, IMatch_MethodBodyAndImplementation_iter_0> curMatches)
		{
			for(Match_MethodBodyAndImplementation_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MethodBodyAndImplementation_iter_0_Delete(graph, curMatch);
			}
		}

		public void MethodBodyAndImplementation_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MethodBodyAndImplementation_iter_0 curMatch = (Match_MethodBodyAndImplementation_iter_0)_curMatch;
			GRGEN_LGSP.LGSPNode node_op = curMatch._node_op;
			Pattern_MultipleParameters.Match_MultipleParameters subpattern__sub0 = curMatch.@__sub0;
			graph.SettingAddedNodeNames( MethodBodyAndImplementation_iter_0_addedNodeNames );
			graph.SettingAddedEdgeNames( MethodBodyAndImplementation_iter_0_addedEdgeNames );
		}
		private static string[] MethodBodyAndImplementation_iter_0_addedNodeNames = new string[] {  };
		private static string[] MethodBodyAndImplementation_iter_0_addedEdgeNames = new string[] {  };

		public void MethodBodyAndImplementation_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MethodBodyAndImplementation_iter_0 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_op = curMatch._node_op;
			GRGEN_LGSP.LGSPNode node_mb = curMatch._node_mb;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_MultipleParameters.Match_MultipleParameters subpattern__sub0 = curMatch.@__sub0;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_op);
			graph.Remove(node_op);
			graph.RemoveEdges(node_mb);
			graph.Remove(node_mb);
			Pattern_MultipleParameters.Instance.MultipleParameters_Delete(graph, subpattern__sub0);
		}

		public void MethodBodyAndImplementation_iter_1_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MethodBodyAndImplementation_iter_1, IMatch_MethodBodyAndImplementation_iter_1> curMatches)
		{
			for(Match_MethodBodyAndImplementation_iter_1 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MethodBodyAndImplementation_iter_1_Modify(graph, curMatch);
			}
		}

		public void MethodBodyAndImplementation_iter_1_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MethodBodyAndImplementation_iter_1, IMatch_MethodBodyAndImplementation_iter_1> curMatches)
		{
			for(Match_MethodBodyAndImplementation_iter_1 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MethodBodyAndImplementation_iter_1_Delete(graph, curMatch);
			}
		}

		public void MethodBodyAndImplementation_iter_1_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MethodBodyAndImplementation_iter_1 curMatch = (Match_MethodBodyAndImplementation_iter_1)_curMatch;
			Pattern_MultipleExpressions.Match_MultipleExpressions subpattern_me = curMatch.@_me;
			graph.SettingAddedNodeNames( MethodBodyAndImplementation_iter_1_addedNodeNames );
			graph.EmitWriter.Write(" {");
			Pattern_MultipleExpressions.Instance.MultipleExpressions_Modify(graph, subpattern_me);
			graph.EmitWriter.Write("}");
			graph.SettingAddedEdgeNames( MethodBodyAndImplementation_iter_1_addedEdgeNames );
		}
		private static string[] MethodBodyAndImplementation_iter_1_addedNodeNames = new string[] {  };
		private static string[] MethodBodyAndImplementation_iter_1_addedEdgeNames = new string[] {  };

		public void MethodBodyAndImplementation_iter_1_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MethodBodyAndImplementation_iter_1 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_b = curMatch._node_b;
			GRGEN_LGSP.LGSPNode node_mb = curMatch._node_mb;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_MultipleExpressions.Match_MultipleExpressions subpattern_me = curMatch.@_me;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_b);
			graph.Remove(node_b);
			graph.RemoveEdges(node_mb);
			graph.Remove(node_mb);
			Pattern_MultipleExpressions.Instance.MultipleExpressions_Delete(graph, subpattern_me);
		}

		static Pattern_MethodBodyAndImplementation() {
		}

		public interface IMatch_MethodBodyAndImplementation : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IMethodBody node_mb { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			GRGEN_LIBGR.IMatchesExact<IMatch_MethodBodyAndImplementation_iter_0> iter_0 { get; }
			GRGEN_LIBGR.IMatchesExact<IMatch_MethodBodyAndImplementation_iter_1> iter_1 { get; }
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MethodBodyAndImplementation_iter_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IMethodBody node_mb { get; }
			//Edges
			GRGEN_MODEL.Ibinding edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_MultipleParameters.Match_MultipleParameters @_sub0 { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MethodBodyAndImplementation_iter_1 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IBlock node_b { get; }
			GRGEN_MODEL.IMethodBody node_mb { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_MultipleExpressions.Match_MultipleExpressions @me { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_MethodBodyAndImplementation : GRGEN_LGSP.ListElement<Match_MethodBodyAndImplementation>, IMatch_MethodBodyAndImplementation
		{
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_LGSP.LGSPNode _node_mb;
			public enum MethodBodyAndImplementation_NodeNums { @mb, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MethodBodyAndImplementation_NodeNums.@mb: return _node_mb;
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IMatchesExact<IMatch_MethodBodyAndImplementation_iter_0> iter_0 { get { return _iter_0; } }
			public GRGEN_LIBGR.IMatchesExact<IMatch_MethodBodyAndImplementation_iter_1> iter_1 { get { return _iter_1; } }
			public GRGEN_LGSP.LGSPMatchesList<Match_MethodBodyAndImplementation_iter_0, IMatch_MethodBodyAndImplementation_iter_0> _iter_0;
			public GRGEN_LGSP.LGSPMatchesList<Match_MethodBodyAndImplementation_iter_1, IMatch_MethodBodyAndImplementation_iter_1> _iter_1;
			public enum MethodBodyAndImplementation_IterNums { @iter_0, @iter_1, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 2;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				case (int)MethodBodyAndImplementation_IterNums.@iter_0: return _iter_0;
				case (int)MethodBodyAndImplementation_IterNums.@iter_1: return _iter_1;
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MethodBodyAndImplementation.instance.pat_MethodBodyAndImplementation; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MethodBodyAndImplementation_iter_0 : GRGEN_LGSP.ListElement<Match_MethodBodyAndImplementation_iter_0>, IMatch_MethodBodyAndImplementation_iter_0
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_mb;
			public enum MethodBodyAndImplementation_iter_0_NodeNums { @op, @mb, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MethodBodyAndImplementation_iter_0_NodeNums.@op: return _node_op;
				case (int)MethodBodyAndImplementation_iter_0_NodeNums.@mb: return _node_mb;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ibinding edge__edge0 { get { return (GRGEN_MODEL.Ibinding)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MethodBodyAndImplementation_iter_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MethodBodyAndImplementation_iter_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_iter_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_MultipleParameters.Match_MultipleParameters @_sub0 { get { return @__sub0; } }
			public @Pattern_MultipleParameters.Match_MultipleParameters @__sub0;
			public enum MethodBodyAndImplementation_iter_0_SubNums { @_sub0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)MethodBodyAndImplementation_iter_0_SubNums.@_sub0: return __sub0;
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_iter_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_iter_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_iter_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MethodBodyAndImplementation.instance.MethodBodyAndImplementation_iter_0; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MethodBodyAndImplementation_iter_1 : GRGEN_LGSP.ListElement<Match_MethodBodyAndImplementation_iter_1>, IMatch_MethodBodyAndImplementation_iter_1
		{
			public GRGEN_MODEL.IBlock node_b { get { return (GRGEN_MODEL.IBlock)_node_b; } }
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_LGSP.LGSPNode _node_b;
			public GRGEN_LGSP.LGSPNode _node_mb;
			public enum MethodBodyAndImplementation_iter_1_NodeNums { @b, @mb, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MethodBodyAndImplementation_iter_1_NodeNums.@b: return _node_b;
				case (int)MethodBodyAndImplementation_iter_1_NodeNums.@mb: return _node_mb;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge0 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MethodBodyAndImplementation_iter_1_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MethodBodyAndImplementation_iter_1_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_iter_1_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_MultipleExpressions.Match_MultipleExpressions @me { get { return @_me; } }
			public @Pattern_MultipleExpressions.Match_MultipleExpressions @_me;
			public enum MethodBodyAndImplementation_iter_1_SubNums { @me, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)MethodBodyAndImplementation_iter_1_SubNums.@me: return _me;
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_iter_1_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_iter_1_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MethodBodyAndImplementation_iter_1_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MethodBodyAndImplementation.instance.MethodBodyAndImplementation_iter_1; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Pattern_MultipleParameters : GRGEN_LGSP.LGSPMatchingPattern
	{
		private static Pattern_MultipleParameters instance = null;
		public static Pattern_MultipleParameters Instance { get { if (instance==null) { instance = new Pattern_MultipleParameters(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] MultipleParameters_node_op_AllowedTypes = null;
		public static bool[] MultipleParameters_node_op_IsAllowedType = null;
		public enum MultipleParameters_NodeNums { @op, };
		public enum MultipleParameters_EdgeNums { };
		public enum MultipleParameters_VariableNums { };
		public enum MultipleParameters_SubNums { };
		public enum MultipleParameters_AltNums { };
		public enum MultipleParameters_IterNums { @iter_0, };




		public GRGEN_LGSP.PatternGraph pat_MultipleParameters;

		public static GRGEN_LIBGR.NodeType[] MultipleParameters_iter_0_node__node0_AllowedTypes = null;
		public static bool[] MultipleParameters_iter_0_node__node0_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] MultipleParameters_iter_0_edge__edge0_AllowedTypes = null;
		public static bool[] MultipleParameters_iter_0_edge__edge0_IsAllowedType = null;
		public enum MultipleParameters_iter_0_NodeNums { @op, @_node0, };
		public enum MultipleParameters_iter_0_EdgeNums { @_edge0, };
		public enum MultipleParameters_iter_0_VariableNums { };
		public enum MultipleParameters_iter_0_SubNums { };
		public enum MultipleParameters_iter_0_AltNums { };
		public enum MultipleParameters_iter_0_IterNums { };




		public GRGEN_LGSP.PatternGraph MultipleParameters_iter_0;


		private Pattern_MultipleParameters()
		{
			name = "MultipleParameters";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, };
			inputNames = new string[] { "MultipleParameters_node_op", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };

		}
		private void initialize()
		{
			bool[,] MultipleParameters_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] MultipleParameters_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] MultipleParameters_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] MultipleParameters_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode MultipleParameters_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "MultipleParameters_node_op", "op", MultipleParameters_node_op_AllowedTypes, MultipleParameters_node_op_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			bool[,] MultipleParameters_iter_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MultipleParameters_iter_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MultipleParameters_iter_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MultipleParameters_iter_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MultipleParameters_iter_0_node__node0 = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Parameter, "GRGEN_MODEL.IParameter", "MultipleParameters_iter_0_node__node0", "_node0", MultipleParameters_iter_0_node__node0_AllowedTypes, MultipleParameters_iter_0_node__node0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MultipleParameters_iter_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@parameter, "GRGEN_MODEL.Iparameter", "MultipleParameters_iter_0_edge__edge0", "_edge0", MultipleParameters_iter_0_edge__edge0_AllowedTypes, MultipleParameters_iter_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			MultipleParameters_iter_0 = new GRGEN_LGSP.PatternGraph(
				"iter_0",
				"MultipleParameters_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleParameters_node_op, MultipleParameters_iter_0_node__node0 }, 
				new GRGEN_LGSP.PatternEdge[] { MultipleParameters_iter_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MultipleParameters_iter_0_isNodeHomomorphicGlobal,
				MultipleParameters_iter_0_isEdgeHomomorphicGlobal,
				MultipleParameters_iter_0_isNodeTotallyHomomorphic,
				MultipleParameters_iter_0_isEdgeTotallyHomomorphic
			);
			MultipleParameters_iter_0.edgeToSourceNode.Add(MultipleParameters_iter_0_edge__edge0, MultipleParameters_node_op);
			MultipleParameters_iter_0.edgeToTargetNode.Add(MultipleParameters_iter_0_edge__edge0, MultipleParameters_iter_0_node__node0);

			GRGEN_LGSP.Iterated MultipleParameters_iter_0_it = new GRGEN_LGSP.Iterated( MultipleParameters_iter_0, 0, 0);
			pat_MultipleParameters = new GRGEN_LGSP.PatternGraph(
				"MultipleParameters",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleParameters_node_op }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] { MultipleParameters_iter_0_it,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				MultipleParameters_isNodeHomomorphicGlobal,
				MultipleParameters_isEdgeHomomorphicGlobal,
				MultipleParameters_isNodeTotallyHomomorphic,
				MultipleParameters_isEdgeTotallyHomomorphic
			);
			MultipleParameters_iter_0.embeddingGraph = pat_MultipleParameters;

			MultipleParameters_node_op.pointOfDefinition = null;
			MultipleParameters_iter_0_node__node0.pointOfDefinition = MultipleParameters_iter_0;
			MultipleParameters_iter_0_edge__edge0.pointOfDefinition = MultipleParameters_iter_0;

			patternGraph = pat_MultipleParameters;
		}


		public void MultipleParameters_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleParameters curMatch = (Match_MultipleParameters)_curMatch;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleParameters_iter_0, IMatch_MultipleParameters_iter_0> iterated_iter_0 = curMatch._iter_0;
			graph.SettingAddedNodeNames( MultipleParameters_addedNodeNames );
			MultipleParameters_iter_0_Modify(graph, iterated_iter_0);
			graph.SettingAddedEdgeNames( MultipleParameters_addedEdgeNames );
		}
		private static string[] MultipleParameters_addedNodeNames = new string[] {  };
		private static string[] MultipleParameters_addedEdgeNames = new string[] {  };

		public void MultipleParameters_Create(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPNode node_op)
		{
			graph.SettingAddedNodeNames( create_MultipleParameters_addedNodeNames );
			graph.SettingAddedEdgeNames( create_MultipleParameters_addedEdgeNames );
		}
		private static string[] create_MultipleParameters_addedNodeNames = new string[] {  };
		private static string[] create_MultipleParameters_addedEdgeNames = new string[] {  };

		public void MultipleParameters_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleParameters curMatch)
		{
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleParameters_iter_0, IMatch_MultipleParameters_iter_0> iterated_iter_0 = curMatch._iter_0;
			MultipleParameters_iter_0_Delete(graph, iterated_iter_0);
		}

		public void MultipleParameters_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleParameters_iter_0, IMatch_MultipleParameters_iter_0> curMatches)
		{
			for(Match_MultipleParameters_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleParameters_iter_0_Modify(graph, curMatch);
			}
		}

		public void MultipleParameters_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleParameters_iter_0, IMatch_MultipleParameters_iter_0> curMatches)
		{
			for(Match_MultipleParameters_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleParameters_iter_0_Delete(graph, curMatch);
			}
		}

		public void MultipleParameters_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleParameters_iter_0 curMatch = (Match_MultipleParameters_iter_0)_curMatch;
			graph.SettingAddedNodeNames( MultipleParameters_iter_0_addedNodeNames );
			graph.SettingAddedEdgeNames( MultipleParameters_iter_0_addedEdgeNames );
		}
		private static string[] MultipleParameters_iter_0_addedNodeNames = new string[] {  };
		private static string[] MultipleParameters_iter_0_addedEdgeNames = new string[] {  };

		public void MultipleParameters_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleParameters_iter_0 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_op = curMatch._node_op;
			GRGEN_LGSP.LGSPNode node__node0 = curMatch._node__node0;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_op);
			graph.Remove(node_op);
			graph.RemoveEdges(node__node0);
			graph.Remove(node__node0);
		}

		static Pattern_MultipleParameters() {
		}

		public interface IMatch_MultipleParameters : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			GRGEN_LIBGR.IMatchesExact<IMatch_MultipleParameters_iter_0> iter_0 { get; }
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MultipleParameters_iter_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IParameter node__node0 { get; }
			//Edges
			GRGEN_MODEL.Iparameter edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_MultipleParameters : GRGEN_LGSP.ListElement<Match_MultipleParameters>, IMatch_MultipleParameters
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public enum MultipleParameters_NodeNums { @op, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleParameters_NodeNums.@op: return _node_op;
				default: return null;
				}
			}
			
			public enum MultipleParameters_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleParameters_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleParameters_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleParameters_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IMatchesExact<IMatch_MultipleParameters_iter_0> iter_0 { get { return _iter_0; } }
			public GRGEN_LGSP.LGSPMatchesList<Match_MultipleParameters_iter_0, IMatch_MultipleParameters_iter_0> _iter_0;
			public enum MultipleParameters_IterNums { @iter_0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 1;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				case (int)MultipleParameters_IterNums.@iter_0: return _iter_0;
				default: return null;
				}
			}
			
			public enum MultipleParameters_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleParameters.instance.pat_MultipleParameters; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MultipleParameters_iter_0 : GRGEN_LGSP.ListElement<Match_MultipleParameters_iter_0>, IMatch_MultipleParameters_iter_0
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IParameter node__node0 { get { return (GRGEN_MODEL.IParameter)_node__node0; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node__node0;
			public enum MultipleParameters_iter_0_NodeNums { @op, @_node0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleParameters_iter_0_NodeNums.@op: return _node_op;
				case (int)MultipleParameters_iter_0_NodeNums.@_node0: return _node__node0;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iparameter edge__edge0 { get { return (GRGEN_MODEL.Iparameter)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MultipleParameters_iter_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MultipleParameters_iter_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MultipleParameters_iter_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleParameters_iter_0_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleParameters_iter_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleParameters_iter_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleParameters_iter_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleParameters.instance.MultipleParameters_iter_0; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Pattern_MultipleExpressions : GRGEN_LGSP.LGSPMatchingPattern
	{
		private static Pattern_MultipleExpressions instance = null;
		public static Pattern_MultipleExpressions Instance { get { if (instance==null) { instance = new Pattern_MultipleExpressions(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] MultipleExpressions_node_b_AllowedTypes = null;
		public static bool[] MultipleExpressions_node_b_IsAllowedType = null;
		public enum MultipleExpressions_NodeNums { @b, };
		public enum MultipleExpressions_EdgeNums { };
		public enum MultipleExpressions_VariableNums { };
		public enum MultipleExpressions_SubNums { };
		public enum MultipleExpressions_AltNums { };
		public enum MultipleExpressions_IterNums { @iter_0, @iter_1, };




		public GRGEN_LGSP.PatternGraph pat_MultipleExpressions;

		public static GRGEN_LIBGR.NodeType[] MultipleExpressions_iter_0_node_next_AllowedTypes = { GRGEN_MODEL.NodeType_Expression.typeVar, GRGEN_MODEL.NodeType_Access.typeVar, GRGEN_MODEL.NodeType_Update.typeVar, GRGEN_MODEL.NodeType_Instantiation.typeVar, GRGEN_MODEL.NodeType_Operator.typeVar, GRGEN_MODEL.NodeType_Return.typeVar, GRGEN_MODEL.NodeType_Block.typeVar, };
		public static bool[] MultipleExpressions_iter_0_node_next_IsAllowedType = { false, false, false, false, false, false, false, false, true, true, true, false, true, true, true, true, false, false, };
		public static GRGEN_LIBGR.EdgeType[] MultipleExpressions_iter_0_edge__edge0_AllowedTypes = null;
		public static bool[] MultipleExpressions_iter_0_edge__edge0_IsAllowedType = null;
		public enum MultipleExpressions_iter_0_NodeNums { @b, @next, };
		public enum MultipleExpressions_iter_0_EdgeNums { @_edge0, };
		public enum MultipleExpressions_iter_0_VariableNums { };
		public enum MultipleExpressions_iter_0_SubNums { @ec, };
		public enum MultipleExpressions_iter_0_AltNums { };
		public enum MultipleExpressions_iter_0_IterNums { };




		public GRGEN_LGSP.PatternGraph MultipleExpressions_iter_0;

		public static GRGEN_LIBGR.NodeType[] MultipleExpressions_iter_1_node_call_AllowedTypes = null;
		public static bool[] MultipleExpressions_iter_1_node_call_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] MultipleExpressions_iter_1_edge__edge0_AllowedTypes = null;
		public static bool[] MultipleExpressions_iter_1_edge__edge0_IsAllowedType = null;
		public enum MultipleExpressions_iter_1_NodeNums { @b, @call, };
		public enum MultipleExpressions_iter_1_EdgeNums { @_edge0, };
		public enum MultipleExpressions_iter_1_VariableNums { };
		public enum MultipleExpressions_iter_1_SubNums { @ec, @_sub0, };
		public enum MultipleExpressions_iter_1_AltNums { };
		public enum MultipleExpressions_iter_1_IterNums { };




		public GRGEN_LGSP.PatternGraph MultipleExpressions_iter_1;


		private Pattern_MultipleExpressions()
		{
			name = "MultipleExpressions";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Block.typeVar, };
			inputNames = new string[] { "MultipleExpressions_node_b", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };

		}
		private void initialize()
		{
			bool[,] MultipleExpressions_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] MultipleExpressions_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] MultipleExpressions_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] MultipleExpressions_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode MultipleExpressions_node_b = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Block, "GRGEN_MODEL.IBlock", "MultipleExpressions_node_b", "b", MultipleExpressions_node_b_AllowedTypes, MultipleExpressions_node_b_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			bool[,] MultipleExpressions_iter_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MultipleExpressions_iter_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MultipleExpressions_iter_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MultipleExpressions_iter_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MultipleExpressions_iter_0_node_next = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "MultipleExpressions_iter_0_node_next", "next", MultipleExpressions_iter_0_node_next_AllowedTypes, MultipleExpressions_iter_0_node_next_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MultipleExpressions_iter_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "MultipleExpressions_iter_0_edge__edge0", "_edge0", MultipleExpressions_iter_0_edge__edge0_AllowedTypes, MultipleExpressions_iter_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding MultipleExpressions_iter_0_ec = new GRGEN_LGSP.PatternGraphEmbedding("ec", Pattern_ExpressionChain.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MultipleExpressions_iter_0_node_next"),
				}, 
				new string[] { }, new string[] { "MultipleExpressions_iter_0_node_next" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			MultipleExpressions_iter_0 = new GRGEN_LGSP.PatternGraph(
				"iter_0",
				"MultipleExpressions_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleExpressions_node_b, MultipleExpressions_iter_0_node_next }, 
				new GRGEN_LGSP.PatternEdge[] { MultipleExpressions_iter_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { MultipleExpressions_iter_0_ec }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MultipleExpressions_iter_0_isNodeHomomorphicGlobal,
				MultipleExpressions_iter_0_isEdgeHomomorphicGlobal,
				MultipleExpressions_iter_0_isNodeTotallyHomomorphic,
				MultipleExpressions_iter_0_isEdgeTotallyHomomorphic
			);
			MultipleExpressions_iter_0.edgeToSourceNode.Add(MultipleExpressions_iter_0_edge__edge0, MultipleExpressions_node_b);
			MultipleExpressions_iter_0.edgeToTargetNode.Add(MultipleExpressions_iter_0_edge__edge0, MultipleExpressions_iter_0_node_next);

			bool[,] MultipleExpressions_iter_1_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MultipleExpressions_iter_1_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MultipleExpressions_iter_1_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MultipleExpressions_iter_1_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MultipleExpressions_iter_1_node_call = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "MultipleExpressions_iter_1_node_call", "call", MultipleExpressions_iter_1_node_call_AllowedTypes, MultipleExpressions_iter_1_node_call_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MultipleExpressions_iter_1_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "MultipleExpressions_iter_1_edge__edge0", "_edge0", MultipleExpressions_iter_1_edge__edge0_AllowedTypes, MultipleExpressions_iter_1_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding MultipleExpressions_iter_1_ec = new GRGEN_LGSP.PatternGraphEmbedding("ec", Pattern_ExpressionChain.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MultipleExpressions_iter_1_node_call"),
				}, 
				new string[] { }, new string[] { "MultipleExpressions_iter_1_node_call" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			GRGEN_LGSP.PatternGraphEmbedding MultipleExpressions_iter_1__sub0 = new GRGEN_LGSP.PatternGraphEmbedding("_sub0", Pattern_MultipleActualParameters.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MultipleExpressions_iter_1_node_call"),
				}, 
				new string[] { }, new string[] { "MultipleExpressions_iter_1_node_call" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			MultipleExpressions_iter_1 = new GRGEN_LGSP.PatternGraph(
				"iter_1",
				"MultipleExpressions_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleExpressions_node_b, MultipleExpressions_iter_1_node_call }, 
				new GRGEN_LGSP.PatternEdge[] { MultipleExpressions_iter_1_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { MultipleExpressions_iter_1_ec, MultipleExpressions_iter_1__sub0 }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MultipleExpressions_iter_1_isNodeHomomorphicGlobal,
				MultipleExpressions_iter_1_isEdgeHomomorphicGlobal,
				MultipleExpressions_iter_1_isNodeTotallyHomomorphic,
				MultipleExpressions_iter_1_isEdgeTotallyHomomorphic
			);
			MultipleExpressions_iter_1.edgeToSourceNode.Add(MultipleExpressions_iter_1_edge__edge0, MultipleExpressions_node_b);
			MultipleExpressions_iter_1.edgeToTargetNode.Add(MultipleExpressions_iter_1_edge__edge0, MultipleExpressions_iter_1_node_call);

			GRGEN_LGSP.Iterated MultipleExpressions_iter_0_it = new GRGEN_LGSP.Iterated( MultipleExpressions_iter_0, 0, 0);
			GRGEN_LGSP.Iterated MultipleExpressions_iter_1_it = new GRGEN_LGSP.Iterated( MultipleExpressions_iter_1, 0, 0);
			pat_MultipleExpressions = new GRGEN_LGSP.PatternGraph(
				"MultipleExpressions",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleExpressions_node_b }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] { MultipleExpressions_iter_0_it, MultipleExpressions_iter_1_it,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				MultipleExpressions_isNodeHomomorphicGlobal,
				MultipleExpressions_isEdgeHomomorphicGlobal,
				MultipleExpressions_isNodeTotallyHomomorphic,
				MultipleExpressions_isEdgeTotallyHomomorphic
			);
			MultipleExpressions_iter_0.embeddingGraph = pat_MultipleExpressions;
			MultipleExpressions_iter_1.embeddingGraph = pat_MultipleExpressions;

			MultipleExpressions_node_b.pointOfDefinition = null;
			MultipleExpressions_iter_0_node_next.pointOfDefinition = MultipleExpressions_iter_0;
			MultipleExpressions_iter_0_edge__edge0.pointOfDefinition = MultipleExpressions_iter_0;
			MultipleExpressions_iter_0_ec.PointOfDefinition = MultipleExpressions_iter_0;
			MultipleExpressions_iter_1_node_call.pointOfDefinition = MultipleExpressions_iter_1;
			MultipleExpressions_iter_1_edge__edge0.pointOfDefinition = MultipleExpressions_iter_1;
			MultipleExpressions_iter_1_ec.PointOfDefinition = MultipleExpressions_iter_1;
			MultipleExpressions_iter_1__sub0.PointOfDefinition = MultipleExpressions_iter_1;

			patternGraph = pat_MultipleExpressions;
		}


		public void MultipleExpressions_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleExpressions curMatch = (Match_MultipleExpressions)_curMatch;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleExpressions_iter_0, IMatch_MultipleExpressions_iter_0> iterated_iter_0 = curMatch._iter_0;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleExpressions_iter_1, IMatch_MultipleExpressions_iter_1> iterated_iter_1 = curMatch._iter_1;
			graph.SettingAddedNodeNames( MultipleExpressions_addedNodeNames );
			MultipleExpressions_iter_0_Modify(graph, iterated_iter_0);
			MultipleExpressions_iter_1_Modify(graph, iterated_iter_1);
			graph.SettingAddedEdgeNames( MultipleExpressions_addedEdgeNames );
		}
		private static string[] MultipleExpressions_addedNodeNames = new string[] {  };
		private static string[] MultipleExpressions_addedEdgeNames = new string[] {  };

		public void MultipleExpressions_Create(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPNode node_b)
		{
			graph.SettingAddedNodeNames( create_MultipleExpressions_addedNodeNames );
			graph.SettingAddedEdgeNames( create_MultipleExpressions_addedEdgeNames );
		}
		private static string[] create_MultipleExpressions_addedNodeNames = new string[] {  };
		private static string[] create_MultipleExpressions_addedEdgeNames = new string[] {  };

		public void MultipleExpressions_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleExpressions curMatch)
		{
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleExpressions_iter_0, IMatch_MultipleExpressions_iter_0> iterated_iter_0 = curMatch._iter_0;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleExpressions_iter_1, IMatch_MultipleExpressions_iter_1> iterated_iter_1 = curMatch._iter_1;
			MultipleExpressions_iter_0_Delete(graph, iterated_iter_0);
			MultipleExpressions_iter_1_Delete(graph, iterated_iter_1);
		}

		public void MultipleExpressions_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleExpressions_iter_0, IMatch_MultipleExpressions_iter_0> curMatches)
		{
			for(Match_MultipleExpressions_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleExpressions_iter_0_Modify(graph, curMatch);
			}
		}

		public void MultipleExpressions_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleExpressions_iter_0, IMatch_MultipleExpressions_iter_0> curMatches)
		{
			for(Match_MultipleExpressions_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleExpressions_iter_0_Delete(graph, curMatch);
			}
		}

		public void MultipleExpressions_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleExpressions_iter_0 curMatch = (Match_MultipleExpressions_iter_0)_curMatch;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern_ec = curMatch.@_ec;
			graph.SettingAddedNodeNames( MultipleExpressions_iter_0_addedNodeNames );
			graph.EmitWriter.Write("exp");
			Pattern_ExpressionChain.Instance.ExpressionChain_Modify(graph, subpattern_ec);
			graph.EmitWriter.Write(" ");
			graph.SettingAddedEdgeNames( MultipleExpressions_iter_0_addedEdgeNames );
		}
		private static string[] MultipleExpressions_iter_0_addedNodeNames = new string[] {  };
		private static string[] MultipleExpressions_iter_0_addedEdgeNames = new string[] {  };

		public void MultipleExpressions_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleExpressions_iter_0 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_b = curMatch._node_b;
			GRGEN_LGSP.LGSPNode node_next = curMatch._node_next;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern_ec = curMatch.@_ec;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_b);
			graph.Remove(node_b);
			graph.RemoveEdges(node_next);
			graph.Remove(node_next);
			Pattern_ExpressionChain.Instance.ExpressionChain_Delete(graph, subpattern_ec);
		}

		public void MultipleExpressions_iter_1_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleExpressions_iter_1, IMatch_MultipleExpressions_iter_1> curMatches)
		{
			for(Match_MultipleExpressions_iter_1 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleExpressions_iter_1_Modify(graph, curMatch);
			}
		}

		public void MultipleExpressions_iter_1_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleExpressions_iter_1, IMatch_MultipleExpressions_iter_1> curMatches)
		{
			for(Match_MultipleExpressions_iter_1 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleExpressions_iter_1_Delete(graph, curMatch);
			}
		}

		public void MultipleExpressions_iter_1_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleExpressions_iter_1 curMatch = (Match_MultipleExpressions_iter_1)_curMatch;
			GRGEN_LGSP.LGSPNode node_call = curMatch._node_call;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern_ec = curMatch.@_ec;
			Pattern_MultipleActualParameters.Match_MultipleActualParameters subpattern__sub0 = curMatch.@__sub0;
			graph.SettingAddedNodeNames( MultipleExpressions_iter_1_addedNodeNames );
			graph.EmitWriter.Write("call");
			Pattern_ExpressionChain.Instance.ExpressionChain_Modify(graph, subpattern_ec);
			graph.EmitWriter.Write(" ");
			graph.SettingAddedEdgeNames( MultipleExpressions_iter_1_addedEdgeNames );
		}
		private static string[] MultipleExpressions_iter_1_addedNodeNames = new string[] {  };
		private static string[] MultipleExpressions_iter_1_addedEdgeNames = new string[] {  };

		public void MultipleExpressions_iter_1_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleExpressions_iter_1 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_b = curMatch._node_b;
			GRGEN_LGSP.LGSPNode node_call = curMatch._node_call;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern_ec = curMatch.@_ec;
			Pattern_MultipleActualParameters.Match_MultipleActualParameters subpattern__sub0 = curMatch.@__sub0;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_b);
			graph.Remove(node_b);
			graph.RemoveEdges(node_call);
			graph.Remove(node_call);
			Pattern_ExpressionChain.Instance.ExpressionChain_Delete(graph, subpattern_ec);
			Pattern_MultipleActualParameters.Instance.MultipleActualParameters_Delete(graph, subpattern__sub0);
		}

		static Pattern_MultipleExpressions() {
		}

		public interface IMatch_MultipleExpressions : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IBlock node_b { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			GRGEN_LIBGR.IMatchesExact<IMatch_MultipleExpressions_iter_0> iter_0 { get; }
			GRGEN_LIBGR.IMatchesExact<IMatch_MultipleExpressions_iter_1> iter_1 { get; }
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MultipleExpressions_iter_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IBlock node_b { get; }
			GRGEN_MODEL.IExpression node_next { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_ExpressionChain.Match_ExpressionChain @ec { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MultipleExpressions_iter_1 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IBlock node_b { get; }
			GRGEN_MODEL.ICall node_call { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_ExpressionChain.Match_ExpressionChain @ec { get; }
			@Pattern_MultipleActualParameters.Match_MultipleActualParameters @_sub0 { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_MultipleExpressions : GRGEN_LGSP.ListElement<Match_MultipleExpressions>, IMatch_MultipleExpressions
		{
			public GRGEN_MODEL.IBlock node_b { get { return (GRGEN_MODEL.IBlock)_node_b; } }
			public GRGEN_LGSP.LGSPNode _node_b;
			public enum MultipleExpressions_NodeNums { @b, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleExpressions_NodeNums.@b: return _node_b;
				default: return null;
				}
			}
			
			public enum MultipleExpressions_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExpressions_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExpressions_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExpressions_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IMatchesExact<IMatch_MultipleExpressions_iter_0> iter_0 { get { return _iter_0; } }
			public GRGEN_LIBGR.IMatchesExact<IMatch_MultipleExpressions_iter_1> iter_1 { get { return _iter_1; } }
			public GRGEN_LGSP.LGSPMatchesList<Match_MultipleExpressions_iter_0, IMatch_MultipleExpressions_iter_0> _iter_0;
			public GRGEN_LGSP.LGSPMatchesList<Match_MultipleExpressions_iter_1, IMatch_MultipleExpressions_iter_1> _iter_1;
			public enum MultipleExpressions_IterNums { @iter_0, @iter_1, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 2;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				case (int)MultipleExpressions_IterNums.@iter_0: return _iter_0;
				case (int)MultipleExpressions_IterNums.@iter_1: return _iter_1;
				default: return null;
				}
			}
			
			public enum MultipleExpressions_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleExpressions.instance.pat_MultipleExpressions; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MultipleExpressions_iter_0 : GRGEN_LGSP.ListElement<Match_MultipleExpressions_iter_0>, IMatch_MultipleExpressions_iter_0
		{
			public GRGEN_MODEL.IBlock node_b { get { return (GRGEN_MODEL.IBlock)_node_b; } }
			public GRGEN_MODEL.IExpression node_next { get { return (GRGEN_MODEL.IExpression)_node_next; } }
			public GRGEN_LGSP.LGSPNode _node_b;
			public GRGEN_LGSP.LGSPNode _node_next;
			public enum MultipleExpressions_iter_0_NodeNums { @b, @next, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleExpressions_iter_0_NodeNums.@b: return _node_b;
				case (int)MultipleExpressions_iter_0_NodeNums.@next: return _node_next;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge__edge0 { get { return (GRGEN_MODEL.Iexpression)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MultipleExpressions_iter_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MultipleExpressions_iter_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MultipleExpressions_iter_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_ExpressionChain.Match_ExpressionChain @ec { get { return @_ec; } }
			public @Pattern_ExpressionChain.Match_ExpressionChain @_ec;
			public enum MultipleExpressions_iter_0_SubNums { @ec, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)MultipleExpressions_iter_0_SubNums.@ec: return _ec;
				default: return null;
				}
			}
			
			public enum MultipleExpressions_iter_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExpressions_iter_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExpressions_iter_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleExpressions.instance.MultipleExpressions_iter_0; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MultipleExpressions_iter_1 : GRGEN_LGSP.ListElement<Match_MultipleExpressions_iter_1>, IMatch_MultipleExpressions_iter_1
		{
			public GRGEN_MODEL.IBlock node_b { get { return (GRGEN_MODEL.IBlock)_node_b; } }
			public GRGEN_MODEL.ICall node_call { get { return (GRGEN_MODEL.ICall)_node_call; } }
			public GRGEN_LGSP.LGSPNode _node_b;
			public GRGEN_LGSP.LGSPNode _node_call;
			public enum MultipleExpressions_iter_1_NodeNums { @b, @call, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleExpressions_iter_1_NodeNums.@b: return _node_b;
				case (int)MultipleExpressions_iter_1_NodeNums.@call: return _node_call;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge__edge0 { get { return (GRGEN_MODEL.Iexpression)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MultipleExpressions_iter_1_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MultipleExpressions_iter_1_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MultipleExpressions_iter_1_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_ExpressionChain.Match_ExpressionChain @ec { get { return @_ec; } }
			public @Pattern_MultipleActualParameters.Match_MultipleActualParameters @_sub0 { get { return @__sub0; } }
			public @Pattern_ExpressionChain.Match_ExpressionChain @_ec;
			public @Pattern_MultipleActualParameters.Match_MultipleActualParameters @__sub0;
			public enum MultipleExpressions_iter_1_SubNums { @ec, @_sub0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 2;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)MultipleExpressions_iter_1_SubNums.@ec: return _ec;
				case (int)MultipleExpressions_iter_1_SubNums.@_sub0: return __sub0;
				default: return null;
				}
			}
			
			public enum MultipleExpressions_iter_1_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExpressions_iter_1_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExpressions_iter_1_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleExpressions.instance.MultipleExpressions_iter_1; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Pattern_ExpressionChain : GRGEN_LGSP.LGSPMatchingPattern
	{
		private static Pattern_ExpressionChain instance = null;
		public static Pattern_ExpressionChain Instance { get { if (instance==null) { instance = new Pattern_ExpressionChain(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] ExpressionChain_node_e_AllowedTypes = null;
		public static bool[] ExpressionChain_node_e_IsAllowedType = null;
		public enum ExpressionChain_NodeNums { @e, };
		public enum ExpressionChain_EdgeNums { };
		public enum ExpressionChain_VariableNums { };
		public enum ExpressionChain_SubNums { };
		public enum ExpressionChain_AltNums { @alt_0, };
		public enum ExpressionChain_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_ExpressionChain;

		public enum ExpressionChain_alt_0_CaseNums { @ExprAndAgain, @CallAndAgain, @End, };
		public static GRGEN_LIBGR.NodeType[] ExpressionChain_alt_0_ExprAndAgain_node_next_AllowedTypes = { GRGEN_MODEL.NodeType_Expression.typeVar, GRGEN_MODEL.NodeType_Access.typeVar, GRGEN_MODEL.NodeType_Update.typeVar, GRGEN_MODEL.NodeType_Instantiation.typeVar, GRGEN_MODEL.NodeType_Operator.typeVar, GRGEN_MODEL.NodeType_Return.typeVar, GRGEN_MODEL.NodeType_Block.typeVar, };
		public static bool[] ExpressionChain_alt_0_ExprAndAgain_node_next_IsAllowedType = { false, false, false, false, false, false, false, false, true, true, true, false, true, true, true, true, false, false, };
		public static GRGEN_LIBGR.EdgeType[] ExpressionChain_alt_0_ExprAndAgain_edge__edge0_AllowedTypes = null;
		public static bool[] ExpressionChain_alt_0_ExprAndAgain_edge__edge0_IsAllowedType = null;
		public enum ExpressionChain_alt_0_ExprAndAgain_NodeNums { @e, @next, };
		public enum ExpressionChain_alt_0_ExprAndAgain_EdgeNums { @_edge0, };
		public enum ExpressionChain_alt_0_ExprAndAgain_VariableNums { };
		public enum ExpressionChain_alt_0_ExprAndAgain_SubNums { @ec, };
		public enum ExpressionChain_alt_0_ExprAndAgain_AltNums { };
		public enum ExpressionChain_alt_0_ExprAndAgain_IterNums { };




		public GRGEN_LGSP.PatternGraph ExpressionChain_alt_0_ExprAndAgain;

		public static GRGEN_LIBGR.NodeType[] ExpressionChain_alt_0_CallAndAgain_node_call_AllowedTypes = null;
		public static bool[] ExpressionChain_alt_0_CallAndAgain_node_call_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] ExpressionChain_alt_0_CallAndAgain_edge__edge0_AllowedTypes = null;
		public static bool[] ExpressionChain_alt_0_CallAndAgain_edge__edge0_IsAllowedType = null;
		public enum ExpressionChain_alt_0_CallAndAgain_NodeNums { @e, @call, };
		public enum ExpressionChain_alt_0_CallAndAgain_EdgeNums { @_edge0, };
		public enum ExpressionChain_alt_0_CallAndAgain_VariableNums { };
		public enum ExpressionChain_alt_0_CallAndAgain_SubNums { @ec, @_sub0, };
		public enum ExpressionChain_alt_0_CallAndAgain_AltNums { };
		public enum ExpressionChain_alt_0_CallAndAgain_IterNums { };




		public GRGEN_LGSP.PatternGraph ExpressionChain_alt_0_CallAndAgain;

		public enum ExpressionChain_alt_0_End_NodeNums { @e, };
		public enum ExpressionChain_alt_0_End_EdgeNums { };
		public enum ExpressionChain_alt_0_End_VariableNums { };
		public enum ExpressionChain_alt_0_End_SubNums { };
		public enum ExpressionChain_alt_0_End_AltNums { };
		public enum ExpressionChain_alt_0_End_IterNums { };




		public GRGEN_LGSP.PatternGraph ExpressionChain_alt_0_End;

		public static GRGEN_LIBGR.EdgeType[] ExpressionChain_alt_0_End_neg_0_edge__edge0_AllowedTypes = null;
		public static bool[] ExpressionChain_alt_0_End_neg_0_edge__edge0_IsAllowedType = null;
		public enum ExpressionChain_alt_0_End_neg_0_NodeNums { @e, };
		public enum ExpressionChain_alt_0_End_neg_0_EdgeNums { @_edge0, };
		public enum ExpressionChain_alt_0_End_neg_0_VariableNums { };
		public enum ExpressionChain_alt_0_End_neg_0_SubNums { };
		public enum ExpressionChain_alt_0_End_neg_0_AltNums { };
		public enum ExpressionChain_alt_0_End_neg_0_IterNums { };

		public GRGEN_LGSP.PatternGraph ExpressionChain_alt_0_End_neg_0;


		private Pattern_ExpressionChain()
		{
			name = "ExpressionChain";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Expression.typeVar, };
			inputNames = new string[] { "ExpressionChain_node_e", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };

		}
		private void initialize()
		{
			bool[,] ExpressionChain_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] ExpressionChain_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] ExpressionChain_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] ExpressionChain_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode ExpressionChain_node_e = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "ExpressionChain_node_e", "e", ExpressionChain_node_e_AllowedTypes, ExpressionChain_node_e_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			bool[,] ExpressionChain_alt_0_ExprAndAgain_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] ExpressionChain_alt_0_ExprAndAgain_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] ExpressionChain_alt_0_ExprAndAgain_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] ExpressionChain_alt_0_ExprAndAgain_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode ExpressionChain_alt_0_ExprAndAgain_node_next = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "ExpressionChain_alt_0_ExprAndAgain_node_next", "next", ExpressionChain_alt_0_ExprAndAgain_node_next_AllowedTypes, ExpressionChain_alt_0_ExprAndAgain_node_next_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge ExpressionChain_alt_0_ExprAndAgain_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "ExpressionChain_alt_0_ExprAndAgain_edge__edge0", "_edge0", ExpressionChain_alt_0_ExprAndAgain_edge__edge0_AllowedTypes, ExpressionChain_alt_0_ExprAndAgain_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding ExpressionChain_alt_0_ExprAndAgain_ec = new GRGEN_LGSP.PatternGraphEmbedding("ec", Pattern_ExpressionChain.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("ExpressionChain_alt_0_ExprAndAgain_node_next"),
				}, 
				new string[] { }, new string[] { "ExpressionChain_alt_0_ExprAndAgain_node_next" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			ExpressionChain_alt_0_ExprAndAgain = new GRGEN_LGSP.PatternGraph(
				"ExprAndAgain",
				"ExpressionChain_alt_0_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { ExpressionChain_node_e, ExpressionChain_alt_0_ExprAndAgain_node_next }, 
				new GRGEN_LGSP.PatternEdge[] { ExpressionChain_alt_0_ExprAndAgain_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { ExpressionChain_alt_0_ExprAndAgain_ec }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				ExpressionChain_alt_0_ExprAndAgain_isNodeHomomorphicGlobal,
				ExpressionChain_alt_0_ExprAndAgain_isEdgeHomomorphicGlobal,
				ExpressionChain_alt_0_ExprAndAgain_isNodeTotallyHomomorphic,
				ExpressionChain_alt_0_ExprAndAgain_isEdgeTotallyHomomorphic
			);
			ExpressionChain_alt_0_ExprAndAgain.edgeToSourceNode.Add(ExpressionChain_alt_0_ExprAndAgain_edge__edge0, ExpressionChain_node_e);
			ExpressionChain_alt_0_ExprAndAgain.edgeToTargetNode.Add(ExpressionChain_alt_0_ExprAndAgain_edge__edge0, ExpressionChain_alt_0_ExprAndAgain_node_next);

			bool[,] ExpressionChain_alt_0_CallAndAgain_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] ExpressionChain_alt_0_CallAndAgain_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] ExpressionChain_alt_0_CallAndAgain_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] ExpressionChain_alt_0_CallAndAgain_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode ExpressionChain_alt_0_CallAndAgain_node_call = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "ExpressionChain_alt_0_CallAndAgain_node_call", "call", ExpressionChain_alt_0_CallAndAgain_node_call_AllowedTypes, ExpressionChain_alt_0_CallAndAgain_node_call_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge ExpressionChain_alt_0_CallAndAgain_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "ExpressionChain_alt_0_CallAndAgain_edge__edge0", "_edge0", ExpressionChain_alt_0_CallAndAgain_edge__edge0_AllowedTypes, ExpressionChain_alt_0_CallAndAgain_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding ExpressionChain_alt_0_CallAndAgain_ec = new GRGEN_LGSP.PatternGraphEmbedding("ec", Pattern_ExpressionChain.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("ExpressionChain_alt_0_CallAndAgain_node_call"),
				}, 
				new string[] { }, new string[] { "ExpressionChain_alt_0_CallAndAgain_node_call" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			GRGEN_LGSP.PatternGraphEmbedding ExpressionChain_alt_0_CallAndAgain__sub0 = new GRGEN_LGSP.PatternGraphEmbedding("_sub0", Pattern_MultipleActualParameters.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("ExpressionChain_alt_0_CallAndAgain_node_call"),
				}, 
				new string[] { }, new string[] { "ExpressionChain_alt_0_CallAndAgain_node_call" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			ExpressionChain_alt_0_CallAndAgain = new GRGEN_LGSP.PatternGraph(
				"CallAndAgain",
				"ExpressionChain_alt_0_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { ExpressionChain_node_e, ExpressionChain_alt_0_CallAndAgain_node_call }, 
				new GRGEN_LGSP.PatternEdge[] { ExpressionChain_alt_0_CallAndAgain_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { ExpressionChain_alt_0_CallAndAgain_ec, ExpressionChain_alt_0_CallAndAgain__sub0 }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				ExpressionChain_alt_0_CallAndAgain_isNodeHomomorphicGlobal,
				ExpressionChain_alt_0_CallAndAgain_isEdgeHomomorphicGlobal,
				ExpressionChain_alt_0_CallAndAgain_isNodeTotallyHomomorphic,
				ExpressionChain_alt_0_CallAndAgain_isEdgeTotallyHomomorphic
			);
			ExpressionChain_alt_0_CallAndAgain.edgeToSourceNode.Add(ExpressionChain_alt_0_CallAndAgain_edge__edge0, ExpressionChain_node_e);
			ExpressionChain_alt_0_CallAndAgain.edgeToTargetNode.Add(ExpressionChain_alt_0_CallAndAgain_edge__edge0, ExpressionChain_alt_0_CallAndAgain_node_call);

			bool[,] ExpressionChain_alt_0_End_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] ExpressionChain_alt_0_End_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] ExpressionChain_alt_0_End_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] ExpressionChain_alt_0_End_isEdgeTotallyHomomorphic = new bool[0] ;
			bool[,] ExpressionChain_alt_0_End_neg_0_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] ExpressionChain_alt_0_End_neg_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] ExpressionChain_alt_0_End_neg_0_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] ExpressionChain_alt_0_End_neg_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternEdge ExpressionChain_alt_0_End_neg_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "ExpressionChain_alt_0_End_neg_0_edge__edge0", "_edge0", ExpressionChain_alt_0_End_neg_0_edge__edge0_AllowedTypes, ExpressionChain_alt_0_End_neg_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			ExpressionChain_alt_0_End_neg_0 = new GRGEN_LGSP.PatternGraph(
				"neg_0",
				"ExpressionChain_alt_0_End_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { ExpressionChain_node_e }, 
				new GRGEN_LGSP.PatternEdge[] { ExpressionChain_alt_0_End_neg_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				ExpressionChain_alt_0_End_neg_0_isNodeHomomorphicGlobal,
				ExpressionChain_alt_0_End_neg_0_isEdgeHomomorphicGlobal,
				ExpressionChain_alt_0_End_neg_0_isNodeTotallyHomomorphic,
				ExpressionChain_alt_0_End_neg_0_isEdgeTotallyHomomorphic
			);
			ExpressionChain_alt_0_End_neg_0.edgeToSourceNode.Add(ExpressionChain_alt_0_End_neg_0_edge__edge0, ExpressionChain_node_e);

			ExpressionChain_alt_0_End = new GRGEN_LGSP.PatternGraph(
				"End",
				"ExpressionChain_alt_0_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { ExpressionChain_node_e }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] { ExpressionChain_alt_0_End_neg_0,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				ExpressionChain_alt_0_End_isNodeHomomorphicGlobal,
				ExpressionChain_alt_0_End_isEdgeHomomorphicGlobal,
				ExpressionChain_alt_0_End_isNodeTotallyHomomorphic,
				ExpressionChain_alt_0_End_isEdgeTotallyHomomorphic
			);
			ExpressionChain_alt_0_End_neg_0.embeddingGraph = ExpressionChain_alt_0_End;

			GRGEN_LGSP.Alternative ExpressionChain_alt_0 = new GRGEN_LGSP.Alternative( "alt_0", "ExpressionChain_", new GRGEN_LGSP.PatternGraph[] { ExpressionChain_alt_0_ExprAndAgain, ExpressionChain_alt_0_CallAndAgain, ExpressionChain_alt_0_End } );

			pat_ExpressionChain = new GRGEN_LGSP.PatternGraph(
				"ExpressionChain",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { ExpressionChain_node_e }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] { ExpressionChain_alt_0,  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				ExpressionChain_isNodeHomomorphicGlobal,
				ExpressionChain_isEdgeHomomorphicGlobal,
				ExpressionChain_isNodeTotallyHomomorphic,
				ExpressionChain_isEdgeTotallyHomomorphic
			);
			ExpressionChain_alt_0_ExprAndAgain.embeddingGraph = pat_ExpressionChain;
			ExpressionChain_alt_0_CallAndAgain.embeddingGraph = pat_ExpressionChain;
			ExpressionChain_alt_0_End.embeddingGraph = pat_ExpressionChain;

			ExpressionChain_node_e.pointOfDefinition = null;
			ExpressionChain_alt_0_ExprAndAgain_node_next.pointOfDefinition = ExpressionChain_alt_0_ExprAndAgain;
			ExpressionChain_alt_0_ExprAndAgain_edge__edge0.pointOfDefinition = ExpressionChain_alt_0_ExprAndAgain;
			ExpressionChain_alt_0_ExprAndAgain_ec.PointOfDefinition = ExpressionChain_alt_0_ExprAndAgain;
			ExpressionChain_alt_0_CallAndAgain_node_call.pointOfDefinition = ExpressionChain_alt_0_CallAndAgain;
			ExpressionChain_alt_0_CallAndAgain_edge__edge0.pointOfDefinition = ExpressionChain_alt_0_CallAndAgain;
			ExpressionChain_alt_0_CallAndAgain_ec.PointOfDefinition = ExpressionChain_alt_0_CallAndAgain;
			ExpressionChain_alt_0_CallAndAgain__sub0.PointOfDefinition = ExpressionChain_alt_0_CallAndAgain;
			ExpressionChain_alt_0_End_neg_0_edge__edge0.pointOfDefinition = ExpressionChain_alt_0_End_neg_0;

			patternGraph = pat_ExpressionChain;
		}


		public void ExpressionChain_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_ExpressionChain curMatch = (Match_ExpressionChain)_curMatch;
			IMatch_ExpressionChain_alt_0 alternative_alt_0 = curMatch._alt_0;
			graph.SettingAddedNodeNames( ExpressionChain_addedNodeNames );
			ExpressionChain_alt_0_Modify(graph, alternative_alt_0);
			graph.SettingAddedEdgeNames( ExpressionChain_addedEdgeNames );
		}
		private static string[] ExpressionChain_addedNodeNames = new string[] {  };
		private static string[] ExpressionChain_addedEdgeNames = new string[] {  };

		public void ExpressionChain_Create(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPNode node_e)
		{
			graph.SettingAddedNodeNames( create_ExpressionChain_addedNodeNames );
			graph.SettingAddedEdgeNames( create_ExpressionChain_addedEdgeNames );
		}
		private static string[] create_ExpressionChain_addedNodeNames = new string[] {  };
		private static string[] create_ExpressionChain_addedEdgeNames = new string[] {  };

		public void ExpressionChain_Delete(GRGEN_LGSP.LGSPGraph graph, Match_ExpressionChain curMatch)
		{
			IMatch_ExpressionChain_alt_0 alternative_alt_0 = curMatch._alt_0;
			ExpressionChain_alt_0_Delete(graph, alternative_alt_0);
		}

		public void ExpressionChain_alt_0_Modify(GRGEN_LGSP.LGSPGraph graph, IMatch_ExpressionChain_alt_0 curMatch)
		{
			if(curMatch.Pattern == ExpressionChain_alt_0_ExprAndAgain) {
				ExpressionChain_alt_0_ExprAndAgain_Modify(graph, (Match_ExpressionChain_alt_0_ExprAndAgain)curMatch);
				return;
			}
			else if(curMatch.Pattern == ExpressionChain_alt_0_CallAndAgain) {
				ExpressionChain_alt_0_CallAndAgain_Modify(graph, (Match_ExpressionChain_alt_0_CallAndAgain)curMatch);
				return;
			}
			else if(curMatch.Pattern == ExpressionChain_alt_0_End) {
				ExpressionChain_alt_0_End_Modify(graph, (Match_ExpressionChain_alt_0_End)curMatch);
				return;
			}
			throw new ApplicationException(); //debug assert
		}

		public void ExpressionChain_alt_0_Delete(GRGEN_LGSP.LGSPGraph graph, IMatch_ExpressionChain_alt_0 curMatch)
		{
			if(curMatch.Pattern == ExpressionChain_alt_0_ExprAndAgain) {
				ExpressionChain_alt_0_ExprAndAgain_Delete(graph, (Match_ExpressionChain_alt_0_ExprAndAgain)curMatch);
				return;
			}
			else if(curMatch.Pattern == ExpressionChain_alt_0_CallAndAgain) {
				ExpressionChain_alt_0_CallAndAgain_Delete(graph, (Match_ExpressionChain_alt_0_CallAndAgain)curMatch);
				return;
			}
			else if(curMatch.Pattern == ExpressionChain_alt_0_End) {
				ExpressionChain_alt_0_End_Delete(graph, (Match_ExpressionChain_alt_0_End)curMatch);
				return;
			}
			throw new ApplicationException(); //debug assert
		}

		public void ExpressionChain_alt_0_ExprAndAgain_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_ExpressionChain_alt_0_ExprAndAgain curMatch = (Match_ExpressionChain_alt_0_ExprAndAgain)_curMatch;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern_ec = curMatch.@_ec;
			graph.SettingAddedNodeNames( ExpressionChain_alt_0_ExprAndAgain_addedNodeNames );
			graph.EmitWriter.Write("--exp");
			Pattern_ExpressionChain.Instance.ExpressionChain_Modify(graph, subpattern_ec);
			graph.SettingAddedEdgeNames( ExpressionChain_alt_0_ExprAndAgain_addedEdgeNames );
		}
		private static string[] ExpressionChain_alt_0_ExprAndAgain_addedNodeNames = new string[] {  };
		private static string[] ExpressionChain_alt_0_ExprAndAgain_addedEdgeNames = new string[] {  };

		public void ExpressionChain_alt_0_ExprAndAgain_Delete(GRGEN_LGSP.LGSPGraph graph, Match_ExpressionChain_alt_0_ExprAndAgain curMatch)
		{
			GRGEN_LGSP.LGSPNode node_e = curMatch._node_e;
			GRGEN_LGSP.LGSPNode node_next = curMatch._node_next;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern_ec = curMatch.@_ec;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_e);
			graph.Remove(node_e);
			graph.RemoveEdges(node_next);
			graph.Remove(node_next);
			Pattern_ExpressionChain.Instance.ExpressionChain_Delete(graph, subpattern_ec);
		}

		public void ExpressionChain_alt_0_CallAndAgain_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_ExpressionChain_alt_0_CallAndAgain curMatch = (Match_ExpressionChain_alt_0_CallAndAgain)_curMatch;
			GRGEN_LGSP.LGSPNode node_call = curMatch._node_call;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern_ec = curMatch.@_ec;
			Pattern_MultipleActualParameters.Match_MultipleActualParameters subpattern__sub0 = curMatch.@__sub0;
			graph.SettingAddedNodeNames( ExpressionChain_alt_0_CallAndAgain_addedNodeNames );
			graph.EmitWriter.Write("--call");
			Pattern_ExpressionChain.Instance.ExpressionChain_Modify(graph, subpattern_ec);
			graph.SettingAddedEdgeNames( ExpressionChain_alt_0_CallAndAgain_addedEdgeNames );
		}
		private static string[] ExpressionChain_alt_0_CallAndAgain_addedNodeNames = new string[] {  };
		private static string[] ExpressionChain_alt_0_CallAndAgain_addedEdgeNames = new string[] {  };

		public void ExpressionChain_alt_0_CallAndAgain_Delete(GRGEN_LGSP.LGSPGraph graph, Match_ExpressionChain_alt_0_CallAndAgain curMatch)
		{
			GRGEN_LGSP.LGSPNode node_e = curMatch._node_e;
			GRGEN_LGSP.LGSPNode node_call = curMatch._node_call;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern_ec = curMatch.@_ec;
			Pattern_MultipleActualParameters.Match_MultipleActualParameters subpattern__sub0 = curMatch.@__sub0;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_e);
			graph.Remove(node_e);
			graph.RemoveEdges(node_call);
			graph.Remove(node_call);
			Pattern_ExpressionChain.Instance.ExpressionChain_Delete(graph, subpattern_ec);
			Pattern_MultipleActualParameters.Instance.MultipleActualParameters_Delete(graph, subpattern__sub0);
		}

		public void ExpressionChain_alt_0_End_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_ExpressionChain_alt_0_End curMatch = (Match_ExpressionChain_alt_0_End)_curMatch;
			graph.SettingAddedNodeNames( ExpressionChain_alt_0_End_addedNodeNames );
			graph.SettingAddedEdgeNames( ExpressionChain_alt_0_End_addedEdgeNames );
			graph.EmitWriter.Write(";");
		}
		private static string[] ExpressionChain_alt_0_End_addedNodeNames = new string[] {  };
		private static string[] ExpressionChain_alt_0_End_addedEdgeNames = new string[] {  };

		public void ExpressionChain_alt_0_End_Delete(GRGEN_LGSP.LGSPGraph graph, Match_ExpressionChain_alt_0_End curMatch)
		{
			GRGEN_LGSP.LGSPNode node_e = curMatch._node_e;
			graph.RemoveEdges(node_e);
			graph.Remove(node_e);
		}

		static Pattern_ExpressionChain() {
		}

		public interface IMatch_ExpressionChain : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IExpression node_e { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			IMatch_ExpressionChain_alt_0 alt_0 { get; }
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_ExpressionChain_alt_0 : GRGEN_LIBGR.IMatch
		{
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_ExpressionChain_alt_0_ExprAndAgain : IMatch_ExpressionChain_alt_0
		{
			//Nodes
			GRGEN_MODEL.IExpression node_e { get; }
			GRGEN_MODEL.IExpression node_next { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_ExpressionChain.Match_ExpressionChain @ec { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			new void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_ExpressionChain_alt_0_CallAndAgain : IMatch_ExpressionChain_alt_0
		{
			//Nodes
			GRGEN_MODEL.IExpression node_e { get; }
			GRGEN_MODEL.ICall node_call { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_ExpressionChain.Match_ExpressionChain @ec { get; }
			@Pattern_MultipleActualParameters.Match_MultipleActualParameters @_sub0 { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			new void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_ExpressionChain_alt_0_End : IMatch_ExpressionChain_alt_0
		{
			//Nodes
			GRGEN_MODEL.IExpression node_e { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			new void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_ExpressionChain_alt_0_End_neg_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IExpression node_e { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_ExpressionChain : GRGEN_LGSP.ListElement<Match_ExpressionChain>, IMatch_ExpressionChain
		{
			public GRGEN_MODEL.IExpression node_e { get { return (GRGEN_MODEL.IExpression)_node_e; } }
			public GRGEN_LGSP.LGSPNode _node_e;
			public enum ExpressionChain_NodeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)ExpressionChain_NodeNums.@e: return _node_e;
				default: return null;
				}
			}
			
			public enum ExpressionChain_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public IMatch_ExpressionChain_alt_0 alt_0 { get { return _alt_0; } }
			public IMatch_ExpressionChain_alt_0 _alt_0;
			public enum ExpressionChain_AltNums { @alt_0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 1;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				case (int)ExpressionChain_AltNums.@alt_0: return _alt_0;
				default: return null;
				}
			}
			
			public enum ExpressionChain_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_ExpressionChain.instance.pat_ExpressionChain; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_ExpressionChain_alt_0_ExprAndAgain : GRGEN_LGSP.ListElement<Match_ExpressionChain_alt_0_ExprAndAgain>, IMatch_ExpressionChain_alt_0_ExprAndAgain
		{
			public GRGEN_MODEL.IExpression node_e { get { return (GRGEN_MODEL.IExpression)_node_e; } }
			public GRGEN_MODEL.IExpression node_next { get { return (GRGEN_MODEL.IExpression)_node_next; } }
			public GRGEN_LGSP.LGSPNode _node_e;
			public GRGEN_LGSP.LGSPNode _node_next;
			public enum ExpressionChain_alt_0_ExprAndAgain_NodeNums { @e, @next, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)ExpressionChain_alt_0_ExprAndAgain_NodeNums.@e: return _node_e;
				case (int)ExpressionChain_alt_0_ExprAndAgain_NodeNums.@next: return _node_next;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge__edge0 { get { return (GRGEN_MODEL.Iexpression)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum ExpressionChain_alt_0_ExprAndAgain_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)ExpressionChain_alt_0_ExprAndAgain_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_ExprAndAgain_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_ExpressionChain.Match_ExpressionChain @ec { get { return @_ec; } }
			public @Pattern_ExpressionChain.Match_ExpressionChain @_ec;
			public enum ExpressionChain_alt_0_ExprAndAgain_SubNums { @ec, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)ExpressionChain_alt_0_ExprAndAgain_SubNums.@ec: return _ec;
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_ExprAndAgain_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_ExprAndAgain_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_ExprAndAgain_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_ExpressionChain.instance.ExpressionChain_alt_0_ExprAndAgain; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_ExpressionChain_alt_0_CallAndAgain : GRGEN_LGSP.ListElement<Match_ExpressionChain_alt_0_CallAndAgain>, IMatch_ExpressionChain_alt_0_CallAndAgain
		{
			public GRGEN_MODEL.IExpression node_e { get { return (GRGEN_MODEL.IExpression)_node_e; } }
			public GRGEN_MODEL.ICall node_call { get { return (GRGEN_MODEL.ICall)_node_call; } }
			public GRGEN_LGSP.LGSPNode _node_e;
			public GRGEN_LGSP.LGSPNode _node_call;
			public enum ExpressionChain_alt_0_CallAndAgain_NodeNums { @e, @call, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)ExpressionChain_alt_0_CallAndAgain_NodeNums.@e: return _node_e;
				case (int)ExpressionChain_alt_0_CallAndAgain_NodeNums.@call: return _node_call;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge__edge0 { get { return (GRGEN_MODEL.Iexpression)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum ExpressionChain_alt_0_CallAndAgain_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)ExpressionChain_alt_0_CallAndAgain_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_CallAndAgain_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_ExpressionChain.Match_ExpressionChain @ec { get { return @_ec; } }
			public @Pattern_MultipleActualParameters.Match_MultipleActualParameters @_sub0 { get { return @__sub0; } }
			public @Pattern_ExpressionChain.Match_ExpressionChain @_ec;
			public @Pattern_MultipleActualParameters.Match_MultipleActualParameters @__sub0;
			public enum ExpressionChain_alt_0_CallAndAgain_SubNums { @ec, @_sub0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 2;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)ExpressionChain_alt_0_CallAndAgain_SubNums.@ec: return _ec;
				case (int)ExpressionChain_alt_0_CallAndAgain_SubNums.@_sub0: return __sub0;
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_CallAndAgain_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_CallAndAgain_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_CallAndAgain_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_ExpressionChain.instance.ExpressionChain_alt_0_CallAndAgain; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_ExpressionChain_alt_0_End : GRGEN_LGSP.ListElement<Match_ExpressionChain_alt_0_End>, IMatch_ExpressionChain_alt_0_End
		{
			public GRGEN_MODEL.IExpression node_e { get { return (GRGEN_MODEL.IExpression)_node_e; } }
			public GRGEN_LGSP.LGSPNode _node_e;
			public enum ExpressionChain_alt_0_End_NodeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)ExpressionChain_alt_0_End_NodeNums.@e: return _node_e;
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_End_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_End_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_End_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_End_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_End_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_End_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_ExpressionChain.instance.ExpressionChain_alt_0_End; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_ExpressionChain_alt_0_End_neg_0 : GRGEN_LGSP.ListElement<Match_ExpressionChain_alt_0_End_neg_0>, IMatch_ExpressionChain_alt_0_End_neg_0
		{
			public GRGEN_MODEL.IExpression node_e { get { return (GRGEN_MODEL.IExpression)_node_e; } }
			public GRGEN_LGSP.LGSPNode _node_e;
			public enum ExpressionChain_alt_0_End_neg_0_NodeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)ExpressionChain_alt_0_End_neg_0_NodeNums.@e: return _node_e;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge__edge0 { get { return (GRGEN_MODEL.Iexpression)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum ExpressionChain_alt_0_End_neg_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)ExpressionChain_alt_0_End_neg_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_End_neg_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_End_neg_0_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_End_neg_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_End_neg_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum ExpressionChain_alt_0_End_neg_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_ExpressionChain.instance.ExpressionChain_alt_0_End_neg_0; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Pattern_MultipleActualParameters : GRGEN_LGSP.LGSPMatchingPattern
	{
		private static Pattern_MultipleActualParameters instance = null;
		public static Pattern_MultipleActualParameters Instance { get { if (instance==null) { instance = new Pattern_MultipleActualParameters(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] MultipleActualParameters_node_c_AllowedTypes = null;
		public static bool[] MultipleActualParameters_node_c_IsAllowedType = null;
		public enum MultipleActualParameters_NodeNums { @c, };
		public enum MultipleActualParameters_EdgeNums { };
		public enum MultipleActualParameters_VariableNums { };
		public enum MultipleActualParameters_SubNums { };
		public enum MultipleActualParameters_AltNums { };
		public enum MultipleActualParameters_IterNums { @iter_0, @iter_1, };




		public GRGEN_LGSP.PatternGraph pat_MultipleActualParameters;

		public static GRGEN_LIBGR.NodeType[] MultipleActualParameters_iter_0_node_next_AllowedTypes = { GRGEN_MODEL.NodeType_Expression.typeVar, GRGEN_MODEL.NodeType_Access.typeVar, GRGEN_MODEL.NodeType_Update.typeVar, GRGEN_MODEL.NodeType_Instantiation.typeVar, GRGEN_MODEL.NodeType_Operator.typeVar, GRGEN_MODEL.NodeType_Return.typeVar, GRGEN_MODEL.NodeType_Block.typeVar, };
		public static bool[] MultipleActualParameters_iter_0_node_next_IsAllowedType = { false, false, false, false, false, false, false, false, true, true, true, false, true, true, true, true, false, false, };
		public static GRGEN_LIBGR.EdgeType[] MultipleActualParameters_iter_0_edge__edge0_AllowedTypes = null;
		public static bool[] MultipleActualParameters_iter_0_edge__edge0_IsAllowedType = null;
		public enum MultipleActualParameters_iter_0_NodeNums { @c, @next, };
		public enum MultipleActualParameters_iter_0_EdgeNums { @_edge0, };
		public enum MultipleActualParameters_iter_0_VariableNums { };
		public enum MultipleActualParameters_iter_0_SubNums { @_sub0, };
		public enum MultipleActualParameters_iter_0_AltNums { };
		public enum MultipleActualParameters_iter_0_IterNums { };




		public GRGEN_LGSP.PatternGraph MultipleActualParameters_iter_0;

		public static GRGEN_LIBGR.NodeType[] MultipleActualParameters_iter_1_node_call_AllowedTypes = null;
		public static bool[] MultipleActualParameters_iter_1_node_call_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] MultipleActualParameters_iter_1_edge__edge0_AllowedTypes = null;
		public static bool[] MultipleActualParameters_iter_1_edge__edge0_IsAllowedType = null;
		public enum MultipleActualParameters_iter_1_NodeNums { @c, @call, };
		public enum MultipleActualParameters_iter_1_EdgeNums { @_edge0, };
		public enum MultipleActualParameters_iter_1_VariableNums { };
		public enum MultipleActualParameters_iter_1_SubNums { @_sub0, @_sub1, };
		public enum MultipleActualParameters_iter_1_AltNums { };
		public enum MultipleActualParameters_iter_1_IterNums { };




		public GRGEN_LGSP.PatternGraph MultipleActualParameters_iter_1;


		private Pattern_MultipleActualParameters()
		{
			name = "MultipleActualParameters";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Call.typeVar, };
			inputNames = new string[] { "MultipleActualParameters_node_c", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };

		}
		private void initialize()
		{
			bool[,] MultipleActualParameters_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] MultipleActualParameters_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] MultipleActualParameters_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] MultipleActualParameters_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode MultipleActualParameters_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "MultipleActualParameters_node_c", "c", MultipleActualParameters_node_c_AllowedTypes, MultipleActualParameters_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			bool[,] MultipleActualParameters_iter_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MultipleActualParameters_iter_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MultipleActualParameters_iter_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MultipleActualParameters_iter_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MultipleActualParameters_iter_0_node_next = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "MultipleActualParameters_iter_0_node_next", "next", MultipleActualParameters_iter_0_node_next_AllowedTypes, MultipleActualParameters_iter_0_node_next_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MultipleActualParameters_iter_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@actualParameter, "GRGEN_MODEL.IactualParameter", "MultipleActualParameters_iter_0_edge__edge0", "_edge0", MultipleActualParameters_iter_0_edge__edge0_AllowedTypes, MultipleActualParameters_iter_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding MultipleActualParameters_iter_0__sub0 = new GRGEN_LGSP.PatternGraphEmbedding("_sub0", Pattern_ExpressionChain.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MultipleActualParameters_iter_0_node_next"),
				}, 
				new string[] { }, new string[] { "MultipleActualParameters_iter_0_node_next" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			MultipleActualParameters_iter_0 = new GRGEN_LGSP.PatternGraph(
				"iter_0",
				"MultipleActualParameters_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleActualParameters_node_c, MultipleActualParameters_iter_0_node_next }, 
				new GRGEN_LGSP.PatternEdge[] { MultipleActualParameters_iter_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { MultipleActualParameters_iter_0__sub0 }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MultipleActualParameters_iter_0_isNodeHomomorphicGlobal,
				MultipleActualParameters_iter_0_isEdgeHomomorphicGlobal,
				MultipleActualParameters_iter_0_isNodeTotallyHomomorphic,
				MultipleActualParameters_iter_0_isEdgeTotallyHomomorphic
			);
			MultipleActualParameters_iter_0.edgeToSourceNode.Add(MultipleActualParameters_iter_0_edge__edge0, MultipleActualParameters_node_c);
			MultipleActualParameters_iter_0.edgeToTargetNode.Add(MultipleActualParameters_iter_0_edge__edge0, MultipleActualParameters_iter_0_node_next);

			bool[,] MultipleActualParameters_iter_1_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MultipleActualParameters_iter_1_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MultipleActualParameters_iter_1_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MultipleActualParameters_iter_1_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MultipleActualParameters_iter_1_node_call = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "MultipleActualParameters_iter_1_node_call", "call", MultipleActualParameters_iter_1_node_call_AllowedTypes, MultipleActualParameters_iter_1_node_call_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MultipleActualParameters_iter_1_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@actualParameter, "GRGEN_MODEL.IactualParameter", "MultipleActualParameters_iter_1_edge__edge0", "_edge0", MultipleActualParameters_iter_1_edge__edge0_AllowedTypes, MultipleActualParameters_iter_1_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding MultipleActualParameters_iter_1__sub0 = new GRGEN_LGSP.PatternGraphEmbedding("_sub0", Pattern_ExpressionChain.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MultipleActualParameters_iter_1_node_call"),
				}, 
				new string[] { }, new string[] { "MultipleActualParameters_iter_1_node_call" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			GRGEN_LGSP.PatternGraphEmbedding MultipleActualParameters_iter_1__sub1 = new GRGEN_LGSP.PatternGraphEmbedding("_sub1", Pattern_MultipleActualParameters.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MultipleActualParameters_iter_1_node_call"),
				}, 
				new string[] { }, new string[] { "MultipleActualParameters_iter_1_node_call" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			MultipleActualParameters_iter_1 = new GRGEN_LGSP.PatternGraph(
				"iter_1",
				"MultipleActualParameters_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleActualParameters_node_c, MultipleActualParameters_iter_1_node_call }, 
				new GRGEN_LGSP.PatternEdge[] { MultipleActualParameters_iter_1_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { MultipleActualParameters_iter_1__sub0, MultipleActualParameters_iter_1__sub1 }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MultipleActualParameters_iter_1_isNodeHomomorphicGlobal,
				MultipleActualParameters_iter_1_isEdgeHomomorphicGlobal,
				MultipleActualParameters_iter_1_isNodeTotallyHomomorphic,
				MultipleActualParameters_iter_1_isEdgeTotallyHomomorphic
			);
			MultipleActualParameters_iter_1.edgeToSourceNode.Add(MultipleActualParameters_iter_1_edge__edge0, MultipleActualParameters_node_c);
			MultipleActualParameters_iter_1.edgeToTargetNode.Add(MultipleActualParameters_iter_1_edge__edge0, MultipleActualParameters_iter_1_node_call);

			GRGEN_LGSP.Iterated MultipleActualParameters_iter_0_it = new GRGEN_LGSP.Iterated( MultipleActualParameters_iter_0, 0, 0);
			GRGEN_LGSP.Iterated MultipleActualParameters_iter_1_it = new GRGEN_LGSP.Iterated( MultipleActualParameters_iter_1, 0, 0);
			pat_MultipleActualParameters = new GRGEN_LGSP.PatternGraph(
				"MultipleActualParameters",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleActualParameters_node_c }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] { MultipleActualParameters_iter_0_it, MultipleActualParameters_iter_1_it,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				MultipleActualParameters_isNodeHomomorphicGlobal,
				MultipleActualParameters_isEdgeHomomorphicGlobal,
				MultipleActualParameters_isNodeTotallyHomomorphic,
				MultipleActualParameters_isEdgeTotallyHomomorphic
			);
			MultipleActualParameters_iter_0.embeddingGraph = pat_MultipleActualParameters;
			MultipleActualParameters_iter_1.embeddingGraph = pat_MultipleActualParameters;

			MultipleActualParameters_node_c.pointOfDefinition = null;
			MultipleActualParameters_iter_0_node_next.pointOfDefinition = MultipleActualParameters_iter_0;
			MultipleActualParameters_iter_0_edge__edge0.pointOfDefinition = MultipleActualParameters_iter_0;
			MultipleActualParameters_iter_0__sub0.PointOfDefinition = MultipleActualParameters_iter_0;
			MultipleActualParameters_iter_1_node_call.pointOfDefinition = MultipleActualParameters_iter_1;
			MultipleActualParameters_iter_1_edge__edge0.pointOfDefinition = MultipleActualParameters_iter_1;
			MultipleActualParameters_iter_1__sub0.PointOfDefinition = MultipleActualParameters_iter_1;
			MultipleActualParameters_iter_1__sub1.PointOfDefinition = MultipleActualParameters_iter_1;

			patternGraph = pat_MultipleActualParameters;
		}


		public void MultipleActualParameters_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleActualParameters curMatch = (Match_MultipleActualParameters)_curMatch;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleActualParameters_iter_0, IMatch_MultipleActualParameters_iter_0> iterated_iter_0 = curMatch._iter_0;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleActualParameters_iter_1, IMatch_MultipleActualParameters_iter_1> iterated_iter_1 = curMatch._iter_1;
			graph.SettingAddedNodeNames( MultipleActualParameters_addedNodeNames );
			MultipleActualParameters_iter_0_Modify(graph, iterated_iter_0);
			MultipleActualParameters_iter_1_Modify(graph, iterated_iter_1);
			graph.SettingAddedEdgeNames( MultipleActualParameters_addedEdgeNames );
		}
		private static string[] MultipleActualParameters_addedNodeNames = new string[] {  };
		private static string[] MultipleActualParameters_addedEdgeNames = new string[] {  };

		public void MultipleActualParameters_Create(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPNode node_c)
		{
			graph.SettingAddedNodeNames( create_MultipleActualParameters_addedNodeNames );
			graph.SettingAddedEdgeNames( create_MultipleActualParameters_addedEdgeNames );
		}
		private static string[] create_MultipleActualParameters_addedNodeNames = new string[] {  };
		private static string[] create_MultipleActualParameters_addedEdgeNames = new string[] {  };

		public void MultipleActualParameters_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleActualParameters curMatch)
		{
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleActualParameters_iter_0, IMatch_MultipleActualParameters_iter_0> iterated_iter_0 = curMatch._iter_0;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleActualParameters_iter_1, IMatch_MultipleActualParameters_iter_1> iterated_iter_1 = curMatch._iter_1;
			MultipleActualParameters_iter_0_Delete(graph, iterated_iter_0);
			MultipleActualParameters_iter_1_Delete(graph, iterated_iter_1);
		}

		public void MultipleActualParameters_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleActualParameters_iter_0, IMatch_MultipleActualParameters_iter_0> curMatches)
		{
			for(Match_MultipleActualParameters_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleActualParameters_iter_0_Modify(graph, curMatch);
			}
		}

		public void MultipleActualParameters_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleActualParameters_iter_0, IMatch_MultipleActualParameters_iter_0> curMatches)
		{
			for(Match_MultipleActualParameters_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleActualParameters_iter_0_Delete(graph, curMatch);
			}
		}

		public void MultipleActualParameters_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleActualParameters_iter_0 curMatch = (Match_MultipleActualParameters_iter_0)_curMatch;
			GRGEN_LGSP.LGSPNode node_next = curMatch._node_next;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern__sub0 = curMatch.@__sub0;
			graph.SettingAddedNodeNames( MultipleActualParameters_iter_0_addedNodeNames );
			graph.SettingAddedEdgeNames( MultipleActualParameters_iter_0_addedEdgeNames );
		}
		private static string[] MultipleActualParameters_iter_0_addedNodeNames = new string[] {  };
		private static string[] MultipleActualParameters_iter_0_addedEdgeNames = new string[] {  };

		public void MultipleActualParameters_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleActualParameters_iter_0 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPNode node_next = curMatch._node_next;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern__sub0 = curMatch.@__sub0;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_c);
			graph.Remove(node_c);
			graph.RemoveEdges(node_next);
			graph.Remove(node_next);
			Pattern_ExpressionChain.Instance.ExpressionChain_Delete(graph, subpattern__sub0);
		}

		public void MultipleActualParameters_iter_1_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleActualParameters_iter_1, IMatch_MultipleActualParameters_iter_1> curMatches)
		{
			for(Match_MultipleActualParameters_iter_1 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleActualParameters_iter_1_Modify(graph, curMatch);
			}
		}

		public void MultipleActualParameters_iter_1_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleActualParameters_iter_1, IMatch_MultipleActualParameters_iter_1> curMatches)
		{
			for(Match_MultipleActualParameters_iter_1 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleActualParameters_iter_1_Delete(graph, curMatch);
			}
		}

		public void MultipleActualParameters_iter_1_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleActualParameters_iter_1 curMatch = (Match_MultipleActualParameters_iter_1)_curMatch;
			GRGEN_LGSP.LGSPNode node_call = curMatch._node_call;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern__sub0 = curMatch.@__sub0;
			Pattern_MultipleActualParameters.Match_MultipleActualParameters subpattern__sub1 = curMatch.@__sub1;
			graph.SettingAddedNodeNames( MultipleActualParameters_iter_1_addedNodeNames );
			graph.SettingAddedEdgeNames( MultipleActualParameters_iter_1_addedEdgeNames );
		}
		private static string[] MultipleActualParameters_iter_1_addedNodeNames = new string[] {  };
		private static string[] MultipleActualParameters_iter_1_addedEdgeNames = new string[] {  };

		public void MultipleActualParameters_iter_1_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleActualParameters_iter_1 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPNode node_call = curMatch._node_call;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_ExpressionChain.Match_ExpressionChain subpattern__sub0 = curMatch.@__sub0;
			Pattern_MultipleActualParameters.Match_MultipleActualParameters subpattern__sub1 = curMatch.@__sub1;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_c);
			graph.Remove(node_c);
			graph.RemoveEdges(node_call);
			graph.Remove(node_call);
			Pattern_ExpressionChain.Instance.ExpressionChain_Delete(graph, subpattern__sub0);
			Pattern_MultipleActualParameters.Instance.MultipleActualParameters_Delete(graph, subpattern__sub1);
		}

		static Pattern_MultipleActualParameters() {
		}

		public interface IMatch_MultipleActualParameters : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.ICall node_c { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			GRGEN_LIBGR.IMatchesExact<IMatch_MultipleActualParameters_iter_0> iter_0 { get; }
			GRGEN_LIBGR.IMatchesExact<IMatch_MultipleActualParameters_iter_1> iter_1 { get; }
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MultipleActualParameters_iter_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.ICall node_c { get; }
			GRGEN_MODEL.IExpression node_next { get; }
			//Edges
			GRGEN_MODEL.IactualParameter edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_ExpressionChain.Match_ExpressionChain @_sub0 { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MultipleActualParameters_iter_1 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.ICall node_c { get; }
			GRGEN_MODEL.ICall node_call { get; }
			//Edges
			GRGEN_MODEL.IactualParameter edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_ExpressionChain.Match_ExpressionChain @_sub0 { get; }
			@Pattern_MultipleActualParameters.Match_MultipleActualParameters @_sub1 { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_MultipleActualParameters : GRGEN_LGSP.ListElement<Match_MultipleActualParameters>, IMatch_MultipleActualParameters
		{
			public GRGEN_MODEL.ICall node_c { get { return (GRGEN_MODEL.ICall)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum MultipleActualParameters_NodeNums { @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleActualParameters_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IMatchesExact<IMatch_MultipleActualParameters_iter_0> iter_0 { get { return _iter_0; } }
			public GRGEN_LIBGR.IMatchesExact<IMatch_MultipleActualParameters_iter_1> iter_1 { get { return _iter_1; } }
			public GRGEN_LGSP.LGSPMatchesList<Match_MultipleActualParameters_iter_0, IMatch_MultipleActualParameters_iter_0> _iter_0;
			public GRGEN_LGSP.LGSPMatchesList<Match_MultipleActualParameters_iter_1, IMatch_MultipleActualParameters_iter_1> _iter_1;
			public enum MultipleActualParameters_IterNums { @iter_0, @iter_1, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 2;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				case (int)MultipleActualParameters_IterNums.@iter_0: return _iter_0;
				case (int)MultipleActualParameters_IterNums.@iter_1: return _iter_1;
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleActualParameters.instance.pat_MultipleActualParameters; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MultipleActualParameters_iter_0 : GRGEN_LGSP.ListElement<Match_MultipleActualParameters_iter_0>, IMatch_MultipleActualParameters_iter_0
		{
			public GRGEN_MODEL.ICall node_c { get { return (GRGEN_MODEL.ICall)_node_c; } }
			public GRGEN_MODEL.IExpression node_next { get { return (GRGEN_MODEL.IExpression)_node_next; } }
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_next;
			public enum MultipleActualParameters_iter_0_NodeNums { @c, @next, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleActualParameters_iter_0_NodeNums.@c: return _node_c;
				case (int)MultipleActualParameters_iter_0_NodeNums.@next: return _node_next;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IactualParameter edge__edge0 { get { return (GRGEN_MODEL.IactualParameter)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MultipleActualParameters_iter_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MultipleActualParameters_iter_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_iter_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_ExpressionChain.Match_ExpressionChain @_sub0 { get { return @__sub0; } }
			public @Pattern_ExpressionChain.Match_ExpressionChain @__sub0;
			public enum MultipleActualParameters_iter_0_SubNums { @_sub0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)MultipleActualParameters_iter_0_SubNums.@_sub0: return __sub0;
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_iter_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_iter_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_iter_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleActualParameters.instance.MultipleActualParameters_iter_0; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MultipleActualParameters_iter_1 : GRGEN_LGSP.ListElement<Match_MultipleActualParameters_iter_1>, IMatch_MultipleActualParameters_iter_1
		{
			public GRGEN_MODEL.ICall node_c { get { return (GRGEN_MODEL.ICall)_node_c; } }
			public GRGEN_MODEL.ICall node_call { get { return (GRGEN_MODEL.ICall)_node_call; } }
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_call;
			public enum MultipleActualParameters_iter_1_NodeNums { @c, @call, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleActualParameters_iter_1_NodeNums.@c: return _node_c;
				case (int)MultipleActualParameters_iter_1_NodeNums.@call: return _node_call;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IactualParameter edge__edge0 { get { return (GRGEN_MODEL.IactualParameter)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MultipleActualParameters_iter_1_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MultipleActualParameters_iter_1_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_iter_1_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_ExpressionChain.Match_ExpressionChain @_sub0 { get { return @__sub0; } }
			public @Pattern_MultipleActualParameters.Match_MultipleActualParameters @_sub1 { get { return @__sub1; } }
			public @Pattern_ExpressionChain.Match_ExpressionChain @__sub0;
			public @Pattern_MultipleActualParameters.Match_MultipleActualParameters @__sub1;
			public enum MultipleActualParameters_iter_1_SubNums { @_sub0, @_sub1, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 2;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)MultipleActualParameters_iter_1_SubNums.@_sub0: return __sub0;
				case (int)MultipleActualParameters_iter_1_SubNums.@_sub1: return __sub1;
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_iter_1_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_iter_1_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleActualParameters_iter_1_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleActualParameters.instance.MultipleActualParameters_iter_1; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Pattern_MultipleExtendingClasses : GRGEN_LGSP.LGSPMatchingPattern
	{
		private static Pattern_MultipleExtendingClasses instance = null;
		public static Pattern_MultipleExtendingClasses Instance { get { if (instance==null) { instance = new Pattern_MultipleExtendingClasses(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] MultipleExtendingClasses_node_c_AllowedTypes = null;
		public static bool[] MultipleExtendingClasses_node_c_IsAllowedType = null;
		public enum MultipleExtendingClasses_NodeNums { @c, };
		public enum MultipleExtendingClasses_EdgeNums { };
		public enum MultipleExtendingClasses_VariableNums { };
		public enum MultipleExtendingClasses_SubNums { };
		public enum MultipleExtendingClasses_AltNums { };
		public enum MultipleExtendingClasses_IterNums { @iter_0, };




		public GRGEN_LGSP.PatternGraph pat_MultipleExtendingClasses;

		public static GRGEN_LIBGR.NodeType[] MultipleExtendingClasses_iter_0_node_sub_AllowedTypes = null;
		public static bool[] MultipleExtendingClasses_iter_0_node_sub_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] MultipleExtendingClasses_iter_0_edge__edge0_AllowedTypes = null;
		public static bool[] MultipleExtendingClasses_iter_0_edge__edge0_IsAllowedType = null;
		public enum MultipleExtendingClasses_iter_0_NodeNums { @sub, @c, };
		public enum MultipleExtendingClasses_iter_0_EdgeNums { @_edge0, };
		public enum MultipleExtendingClasses_iter_0_VariableNums { };
		public enum MultipleExtendingClasses_iter_0_SubNums { @_sub0, };
		public enum MultipleExtendingClasses_iter_0_AltNums { };
		public enum MultipleExtendingClasses_iter_0_IterNums { };




		public GRGEN_LGSP.PatternGraph MultipleExtendingClasses_iter_0;


		private Pattern_MultipleExtendingClasses()
		{
			name = "MultipleExtendingClasses";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, };
			inputNames = new string[] { "MultipleExtendingClasses_node_c", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };

		}
		private void initialize()
		{
			bool[,] MultipleExtendingClasses_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] MultipleExtendingClasses_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] MultipleExtendingClasses_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] MultipleExtendingClasses_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode MultipleExtendingClasses_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "MultipleExtendingClasses_node_c", "c", MultipleExtendingClasses_node_c_AllowedTypes, MultipleExtendingClasses_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			bool[,] MultipleExtendingClasses_iter_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MultipleExtendingClasses_iter_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MultipleExtendingClasses_iter_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MultipleExtendingClasses_iter_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode MultipleExtendingClasses_iter_0_node_sub = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "MultipleExtendingClasses_iter_0_node_sub", "sub", MultipleExtendingClasses_iter_0_node_sub_AllowedTypes, MultipleExtendingClasses_iter_0_node_sub_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MultipleExtendingClasses_iter_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@extends_, "GRGEN_MODEL.Iextends_", "MultipleExtendingClasses_iter_0_edge__edge0", "_edge0", MultipleExtendingClasses_iter_0_edge__edge0_AllowedTypes, MultipleExtendingClasses_iter_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding MultipleExtendingClasses_iter_0__sub0 = new GRGEN_LGSP.PatternGraphEmbedding("_sub0", Pattern_MultipleExtendingClasses.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("MultipleExtendingClasses_iter_0_node_sub"),
				}, 
				new string[] { }, new string[] { "MultipleExtendingClasses_iter_0_node_sub" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			MultipleExtendingClasses_iter_0 = new GRGEN_LGSP.PatternGraph(
				"iter_0",
				"MultipleExtendingClasses_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleExtendingClasses_iter_0_node_sub, MultipleExtendingClasses_node_c }, 
				new GRGEN_LGSP.PatternEdge[] { MultipleExtendingClasses_iter_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { MultipleExtendingClasses_iter_0__sub0 }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MultipleExtendingClasses_iter_0_isNodeHomomorphicGlobal,
				MultipleExtendingClasses_iter_0_isEdgeHomomorphicGlobal,
				MultipleExtendingClasses_iter_0_isNodeTotallyHomomorphic,
				MultipleExtendingClasses_iter_0_isEdgeTotallyHomomorphic
			);
			MultipleExtendingClasses_iter_0.edgeToSourceNode.Add(MultipleExtendingClasses_iter_0_edge__edge0, MultipleExtendingClasses_iter_0_node_sub);
			MultipleExtendingClasses_iter_0.edgeToTargetNode.Add(MultipleExtendingClasses_iter_0_edge__edge0, MultipleExtendingClasses_node_c);

			GRGEN_LGSP.Iterated MultipleExtendingClasses_iter_0_it = new GRGEN_LGSP.Iterated( MultipleExtendingClasses_iter_0, 0, 0);
			pat_MultipleExtendingClasses = new GRGEN_LGSP.PatternGraph(
				"MultipleExtendingClasses",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MultipleExtendingClasses_node_c }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] { MultipleExtendingClasses_iter_0_it,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				MultipleExtendingClasses_isNodeHomomorphicGlobal,
				MultipleExtendingClasses_isEdgeHomomorphicGlobal,
				MultipleExtendingClasses_isNodeTotallyHomomorphic,
				MultipleExtendingClasses_isEdgeTotallyHomomorphic
			);
			MultipleExtendingClasses_iter_0.embeddingGraph = pat_MultipleExtendingClasses;

			MultipleExtendingClasses_node_c.pointOfDefinition = null;
			MultipleExtendingClasses_iter_0_node_sub.pointOfDefinition = MultipleExtendingClasses_iter_0;
			MultipleExtendingClasses_iter_0_edge__edge0.pointOfDefinition = MultipleExtendingClasses_iter_0;
			MultipleExtendingClasses_iter_0__sub0.PointOfDefinition = MultipleExtendingClasses_iter_0;

			patternGraph = pat_MultipleExtendingClasses;
		}


		public void MultipleExtendingClasses_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleExtendingClasses curMatch = (Match_MultipleExtendingClasses)_curMatch;
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleExtendingClasses_iter_0, IMatch_MultipleExtendingClasses_iter_0> iterated_iter_0 = curMatch._iter_0;
			graph.SettingAddedNodeNames( MultipleExtendingClasses_addedNodeNames );
			MultipleExtendingClasses_iter_0_Modify(graph, iterated_iter_0);
			graph.SettingAddedEdgeNames( MultipleExtendingClasses_addedEdgeNames );
		}
		private static string[] MultipleExtendingClasses_addedNodeNames = new string[] {  };
		private static string[] MultipleExtendingClasses_addedEdgeNames = new string[] {  };

		public void MultipleExtendingClasses_Create(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPNode node_c)
		{
			graph.SettingAddedNodeNames( create_MultipleExtendingClasses_addedNodeNames );
			graph.SettingAddedEdgeNames( create_MultipleExtendingClasses_addedEdgeNames );
		}
		private static string[] create_MultipleExtendingClasses_addedNodeNames = new string[] {  };
		private static string[] create_MultipleExtendingClasses_addedEdgeNames = new string[] {  };

		public void MultipleExtendingClasses_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleExtendingClasses curMatch)
		{
			GRGEN_LGSP.LGSPMatchesList<Match_MultipleExtendingClasses_iter_0, IMatch_MultipleExtendingClasses_iter_0> iterated_iter_0 = curMatch._iter_0;
			MultipleExtendingClasses_iter_0_Delete(graph, iterated_iter_0);
		}

		public void MultipleExtendingClasses_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleExtendingClasses_iter_0, IMatch_MultipleExtendingClasses_iter_0> curMatches)
		{
			for(Match_MultipleExtendingClasses_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleExtendingClasses_iter_0_Modify(graph, curMatch);
			}
		}

		public void MultipleExtendingClasses_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_MultipleExtendingClasses_iter_0, IMatch_MultipleExtendingClasses_iter_0> curMatches)
		{
			for(Match_MultipleExtendingClasses_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				MultipleExtendingClasses_iter_0_Delete(graph, curMatch);
			}
		}

		public void MultipleExtendingClasses_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MultipleExtendingClasses_iter_0 curMatch = (Match_MultipleExtendingClasses_iter_0)_curMatch;
			GRGEN_LGSP.LGSPNode node_sub = curMatch._node_sub;
			Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses subpattern__sub0 = curMatch.@__sub0;
			graph.SettingAddedNodeNames( MultipleExtendingClasses_iter_0_addedNodeNames );
			graph.SettingAddedEdgeNames( MultipleExtendingClasses_iter_0_addedEdgeNames );
		}
		private static string[] MultipleExtendingClasses_iter_0_addedNodeNames = new string[] {  };
		private static string[] MultipleExtendingClasses_iter_0_addedEdgeNames = new string[] {  };

		public void MultipleExtendingClasses_iter_0_Delete(GRGEN_LGSP.LGSPGraph graph, Match_MultipleExtendingClasses_iter_0 curMatch)
		{
			GRGEN_LGSP.LGSPNode node_sub = curMatch._node_sub;
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses subpattern__sub0 = curMatch.@__sub0;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_sub);
			graph.Remove(node_sub);
			graph.RemoveEdges(node_c);
			graph.Remove(node_c);
			Pattern_MultipleExtendingClasses.Instance.MultipleExtendingClasses_Delete(graph, subpattern__sub0);
		}

		static Pattern_MultipleExtendingClasses() {
		}

		public interface IMatch_MultipleExtendingClasses : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			GRGEN_LIBGR.IMatchesExact<IMatch_MultipleExtendingClasses_iter_0> iter_0 { get; }
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MultipleExtendingClasses_iter_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IClass node_sub { get; }
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			GRGEN_MODEL.Iextends_ edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses @_sub0 { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_MultipleExtendingClasses : GRGEN_LGSP.ListElement<Match_MultipleExtendingClasses>, IMatch_MultipleExtendingClasses
		{
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum MultipleExtendingClasses_NodeNums { @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleExtendingClasses_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public enum MultipleExtendingClasses_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExtendingClasses_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExtendingClasses_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExtendingClasses_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IMatchesExact<IMatch_MultipleExtendingClasses_iter_0> iter_0 { get { return _iter_0; } }
			public GRGEN_LGSP.LGSPMatchesList<Match_MultipleExtendingClasses_iter_0, IMatch_MultipleExtendingClasses_iter_0> _iter_0;
			public enum MultipleExtendingClasses_IterNums { @iter_0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 1;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				case (int)MultipleExtendingClasses_IterNums.@iter_0: return _iter_0;
				default: return null;
				}
			}
			
			public enum MultipleExtendingClasses_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleExtendingClasses.instance.pat_MultipleExtendingClasses; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MultipleExtendingClasses_iter_0 : GRGEN_LGSP.ListElement<Match_MultipleExtendingClasses_iter_0>, IMatch_MultipleExtendingClasses_iter_0
		{
			public GRGEN_MODEL.IClass node_sub { get { return (GRGEN_MODEL.IClass)_node_sub; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_sub;
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum MultipleExtendingClasses_iter_0_NodeNums { @sub, @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MultipleExtendingClasses_iter_0_NodeNums.@sub: return _node_sub;
				case (int)MultipleExtendingClasses_iter_0_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iextends_ edge__edge0 { get { return (GRGEN_MODEL.Iextends_)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MultipleExtendingClasses_iter_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MultipleExtendingClasses_iter_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MultipleExtendingClasses_iter_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses @_sub0 { get { return @__sub0; } }
			public @Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses @__sub0;
			public enum MultipleExtendingClasses_iter_0_SubNums { @_sub0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)MultipleExtendingClasses_iter_0_SubNums.@_sub0: return __sub0;
				default: return null;
				}
			}
			
			public enum MultipleExtendingClasses_iter_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExtendingClasses_iter_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MultipleExtendingClasses_iter_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_MultipleExtendingClasses.instance.MultipleExtendingClasses_iter_0; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Pattern_InClass : GRGEN_LGSP.LGSPMatchingPattern
	{
		private static Pattern_InClass instance = null;
		public static Pattern_InClass Instance { get { if (instance==null) { instance = new Pattern_InClass(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] InClass_node_e_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] InClass_node_c_AllowedTypes = null;
		public static bool[] InClass_node_e_IsAllowedType = null;
		public static bool[] InClass_node_c_IsAllowedType = null;
		public enum InClass_NodeNums { @e, @c, };
		public enum InClass_EdgeNums { };
		public enum InClass_VariableNums { };
		public enum InClass_SubNums { };
		public enum InClass_AltNums { @alt_0, };
		public enum InClass_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_InClass;

		public enum InClass_alt_0_CaseNums { @Previous, @End, };
		public static GRGEN_LIBGR.NodeType[] InClass_alt_0_Previous_node_prev_AllowedTypes = { GRGEN_MODEL.NodeType_Expression.typeVar, GRGEN_MODEL.NodeType_Access.typeVar, GRGEN_MODEL.NodeType_Update.typeVar, GRGEN_MODEL.NodeType_Call.typeVar, GRGEN_MODEL.NodeType_Instantiation.typeVar, GRGEN_MODEL.NodeType_Operator.typeVar, GRGEN_MODEL.NodeType_Return.typeVar, };
		public static bool[] InClass_alt_0_Previous_node_prev_IsAllowedType = { false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, };
		public static GRGEN_LIBGR.EdgeType[] InClass_alt_0_Previous_edge__edge0_AllowedTypes = null;
		public static bool[] InClass_alt_0_Previous_edge__edge0_IsAllowedType = null;
		public enum InClass_alt_0_Previous_NodeNums { @prev, @e, @c, };
		public enum InClass_alt_0_Previous_EdgeNums { @_edge0, };
		public enum InClass_alt_0_Previous_VariableNums { };
		public enum InClass_alt_0_Previous_SubNums { @_sub0, };
		public enum InClass_alt_0_Previous_AltNums { };
		public enum InClass_alt_0_Previous_IterNums { };



		public GRGEN_LGSP.PatternGraph InClass_alt_0_Previous;

		public static GRGEN_LIBGR.NodeType[] InClass_alt_0_End_node_prev_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] InClass_alt_0_End_node_b_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] InClass_alt_0_End_node_mb_AllowedTypes = null;
		public static bool[] InClass_alt_0_End_node_prev_IsAllowedType = null;
		public static bool[] InClass_alt_0_End_node_b_IsAllowedType = null;
		public static bool[] InClass_alt_0_End_node_mb_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] InClass_alt_0_End_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] InClass_alt_0_End_edge__edge1_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] InClass_alt_0_End_edge__edge2_AllowedTypes = null;
		public static bool[] InClass_alt_0_End_edge__edge0_IsAllowedType = null;
		public static bool[] InClass_alt_0_End_edge__edge1_IsAllowedType = null;
		public static bool[] InClass_alt_0_End_edge__edge2_IsAllowedType = null;
		public enum InClass_alt_0_End_NodeNums { @prev, @e, @b, @mb, @c, };
		public enum InClass_alt_0_End_EdgeNums { @_edge0, @_edge1, @_edge2, };
		public enum InClass_alt_0_End_VariableNums { };
		public enum InClass_alt_0_End_SubNums { };
		public enum InClass_alt_0_End_AltNums { };
		public enum InClass_alt_0_End_IterNums { };



		public GRGEN_LGSP.PatternGraph InClass_alt_0_End;


		private Pattern_InClass()
		{
			name = "InClass";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Expression.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, };
			inputNames = new string[] { "InClass_node_e", "InClass_node_c", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };

		}
		private void initialize()
		{
			bool[,] InClass_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] InClass_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] InClass_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] InClass_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode InClass_node_e = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "InClass_node_e", "e", InClass_node_e_AllowedTypes, InClass_node_e_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode InClass_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "InClass_node_c", "c", InClass_node_c_AllowedTypes, InClass_node_c_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			bool[,] InClass_alt_0_Previous_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] InClass_alt_0_Previous_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] InClass_alt_0_Previous_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] InClass_alt_0_Previous_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode InClass_alt_0_Previous_node_prev = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "InClass_alt_0_Previous_node_prev", "prev", InClass_alt_0_Previous_node_prev_AllowedTypes, InClass_alt_0_Previous_node_prev_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge InClass_alt_0_Previous_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "InClass_alt_0_Previous_edge__edge0", "_edge0", InClass_alt_0_Previous_edge__edge0_AllowedTypes, InClass_alt_0_Previous_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding InClass_alt_0_Previous__sub0 = new GRGEN_LGSP.PatternGraphEmbedding("_sub0", Pattern_InClass.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("InClass_alt_0_Previous_node_prev"),
					new GRGEN_EXPR.GraphEntityExpression("InClass_node_c"),
				}, 
				new string[] { }, new string[] { "InClass_alt_0_Previous_node_prev", "InClass_node_c" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			InClass_alt_0_Previous = new GRGEN_LGSP.PatternGraph(
				"Previous",
				"InClass_alt_0_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { InClass_alt_0_Previous_node_prev, InClass_node_e, InClass_node_c }, 
				new GRGEN_LGSP.PatternEdge[] { InClass_alt_0_Previous_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { InClass_alt_0_Previous__sub0 }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, true, },
					{ false, true, true, },
					{ true, true, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				InClass_alt_0_Previous_isNodeHomomorphicGlobal,
				InClass_alt_0_Previous_isEdgeHomomorphicGlobal,
				InClass_alt_0_Previous_isNodeTotallyHomomorphic,
				InClass_alt_0_Previous_isEdgeTotallyHomomorphic
			);
			InClass_alt_0_Previous.edgeToSourceNode.Add(InClass_alt_0_Previous_edge__edge0, InClass_alt_0_Previous_node_prev);
			InClass_alt_0_Previous.edgeToTargetNode.Add(InClass_alt_0_Previous_edge__edge0, InClass_node_e);

			bool[,] InClass_alt_0_End_isNodeHomomorphicGlobal = new bool[5, 5] {
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
			};
			bool[,] InClass_alt_0_End_isEdgeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[] InClass_alt_0_End_isNodeTotallyHomomorphic = new bool[5] { false, false, false, false, false,  };
			bool[] InClass_alt_0_End_isEdgeTotallyHomomorphic = new bool[3] { false, false, false,  };
			GRGEN_LGSP.PatternNode InClass_alt_0_End_node_prev = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Block, "GRGEN_MODEL.IBlock", "InClass_alt_0_End_node_prev", "prev", InClass_alt_0_End_node_prev_AllowedTypes, InClass_alt_0_End_node_prev_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode InClass_alt_0_End_node_b = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Block, "GRGEN_MODEL.IBlock", "InClass_alt_0_End_node_b", "b", InClass_alt_0_End_node_b_AllowedTypes, InClass_alt_0_End_node_b_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode InClass_alt_0_End_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "InClass_alt_0_End_node_mb", "mb", InClass_alt_0_End_node_mb_AllowedTypes, InClass_alt_0_End_node_mb_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge InClass_alt_0_End_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "InClass_alt_0_End_edge__edge0", "_edge0", InClass_alt_0_End_edge__edge0_AllowedTypes, InClass_alt_0_End_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge InClass_alt_0_End_edge__edge1 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "InClass_alt_0_End_edge__edge1", "_edge1", InClass_alt_0_End_edge__edge1_AllowedTypes, InClass_alt_0_End_edge__edge1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge InClass_alt_0_End_edge__edge2 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "InClass_alt_0_End_edge__edge2", "_edge2", InClass_alt_0_End_edge__edge2_AllowedTypes, InClass_alt_0_End_edge__edge2_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			InClass_alt_0_End = new GRGEN_LGSP.PatternGraph(
				"End",
				"InClass_alt_0_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { InClass_alt_0_End_node_prev, InClass_node_e, InClass_alt_0_End_node_b, InClass_alt_0_End_node_mb, InClass_node_c }, 
				new GRGEN_LGSP.PatternEdge[] { InClass_alt_0_End_edge__edge0, InClass_alt_0_End_edge__edge1, InClass_alt_0_End_edge__edge2 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[5, 5] {
					{ true, false, false, false, false, },
					{ false, true, false, false, false, },
					{ false, false, true, false, false, },
					{ false, false, false, true, false, },
					{ false, false, false, false, true, },
				},
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				InClass_alt_0_End_isNodeHomomorphicGlobal,
				InClass_alt_0_End_isEdgeHomomorphicGlobal,
				InClass_alt_0_End_isNodeTotallyHomomorphic,
				InClass_alt_0_End_isEdgeTotallyHomomorphic
			);
			InClass_alt_0_End.edgeToSourceNode.Add(InClass_alt_0_End_edge__edge0, InClass_alt_0_End_node_prev);
			InClass_alt_0_End.edgeToTargetNode.Add(InClass_alt_0_End_edge__edge0, InClass_node_e);
			InClass_alt_0_End.edgeToSourceNode.Add(InClass_alt_0_End_edge__edge1, InClass_alt_0_End_node_b);
			InClass_alt_0_End.edgeToTargetNode.Add(InClass_alt_0_End_edge__edge1, InClass_alt_0_End_node_mb);
			InClass_alt_0_End.edgeToSourceNode.Add(InClass_alt_0_End_edge__edge2, InClass_alt_0_End_node_mb);
			InClass_alt_0_End.edgeToTargetNode.Add(InClass_alt_0_End_edge__edge2, InClass_node_c);

			GRGEN_LGSP.Alternative InClass_alt_0 = new GRGEN_LGSP.Alternative( "alt_0", "InClass_", new GRGEN_LGSP.PatternGraph[] { InClass_alt_0_Previous, InClass_alt_0_End } );

			pat_InClass = new GRGEN_LGSP.PatternGraph(
				"InClass",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { InClass_node_e, InClass_node_c }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] { InClass_alt_0,  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[0, 0] ,
				InClass_isNodeHomomorphicGlobal,
				InClass_isEdgeHomomorphicGlobal,
				InClass_isNodeTotallyHomomorphic,
				InClass_isEdgeTotallyHomomorphic
			);
			InClass_alt_0_Previous.embeddingGraph = pat_InClass;
			InClass_alt_0_End.embeddingGraph = pat_InClass;

			InClass_node_e.pointOfDefinition = null;
			InClass_node_c.pointOfDefinition = null;
			InClass_alt_0_Previous_node_prev.pointOfDefinition = InClass_alt_0_Previous;
			InClass_alt_0_Previous_edge__edge0.pointOfDefinition = InClass_alt_0_Previous;
			InClass_alt_0_Previous__sub0.PointOfDefinition = InClass_alt_0_Previous;
			InClass_alt_0_End_node_prev.pointOfDefinition = InClass_alt_0_End;
			InClass_alt_0_End_node_b.pointOfDefinition = InClass_alt_0_End;
			InClass_alt_0_End_node_mb.pointOfDefinition = InClass_alt_0_End;
			InClass_alt_0_End_edge__edge0.pointOfDefinition = InClass_alt_0_End;
			InClass_alt_0_End_edge__edge1.pointOfDefinition = InClass_alt_0_End;
			InClass_alt_0_End_edge__edge2.pointOfDefinition = InClass_alt_0_End;

			patternGraph = pat_InClass;
		}


		public void InClass_Create(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPNode node_e, GRGEN_LGSP.LGSPNode node_c)
		{
			graph.SettingAddedNodeNames( create_InClass_addedNodeNames );
			graph.SettingAddedEdgeNames( create_InClass_addedEdgeNames );
		}
		private static string[] create_InClass_addedNodeNames = new string[] {  };
		private static string[] create_InClass_addedEdgeNames = new string[] {  };

		public void InClass_Delete(GRGEN_LGSP.LGSPGraph graph, Match_InClass curMatch)
		{
			IMatch_InClass_alt_0 alternative_alt_0 = curMatch._alt_0;
			InClass_alt_0_Delete(graph, alternative_alt_0);
		}

		public void InClass_alt_0_Delete(GRGEN_LGSP.LGSPGraph graph, IMatch_InClass_alt_0 curMatch)
		{
			if(curMatch.Pattern == InClass_alt_0_Previous) {
				InClass_alt_0_Previous_Delete(graph, (Match_InClass_alt_0_Previous)curMatch);
				return;
			}
			else if(curMatch.Pattern == InClass_alt_0_End) {
				InClass_alt_0_End_Delete(graph, (Match_InClass_alt_0_End)curMatch);
				return;
			}
			throw new ApplicationException(); //debug assert
		}

		public void InClass_alt_0_Previous_Delete(GRGEN_LGSP.LGSPGraph graph, Match_InClass_alt_0_Previous curMatch)
		{
			GRGEN_LGSP.LGSPNode node_prev = curMatch._node_prev;
			GRGEN_LGSP.LGSPNode node_e = curMatch._node_e;
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_InClass.Match_InClass subpattern__sub0 = curMatch.@__sub0;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_prev);
			graph.Remove(node_prev);
			graph.RemoveEdges(node_e);
			graph.Remove(node_e);
			graph.RemoveEdges(node_c);
			graph.Remove(node_c);
			Pattern_InClass.Instance.InClass_Delete(graph, subpattern__sub0);
		}

		public void InClass_alt_0_End_Delete(GRGEN_LGSP.LGSPGraph graph, Match_InClass_alt_0_End curMatch)
		{
			GRGEN_LGSP.LGSPNode node_prev = curMatch._node_prev;
			GRGEN_LGSP.LGSPNode node_e = curMatch._node_e;
			GRGEN_LGSP.LGSPNode node_b = curMatch._node_b;
			GRGEN_LGSP.LGSPNode node_mb = curMatch._node_mb;
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			GRGEN_LGSP.LGSPEdge edge__edge1 = curMatch._edge__edge1;
			GRGEN_LGSP.LGSPEdge edge__edge2 = curMatch._edge__edge2;
			graph.Remove(edge__edge0);
			graph.Remove(edge__edge1);
			graph.Remove(edge__edge2);
			graph.RemoveEdges(node_prev);
			graph.Remove(node_prev);
			graph.RemoveEdges(node_e);
			graph.Remove(node_e);
			graph.RemoveEdges(node_b);
			graph.Remove(node_b);
			graph.RemoveEdges(node_mb);
			graph.Remove(node_mb);
			graph.RemoveEdges(node_c);
			graph.Remove(node_c);
		}

		static Pattern_InClass() {
		}

		public interface IMatch_InClass : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IExpression node_e { get; }
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			IMatch_InClass_alt_0 alt_0 { get; }
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_InClass_alt_0 : GRGEN_LIBGR.IMatch
		{
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_InClass_alt_0_Previous : IMatch_InClass_alt_0
		{
			//Nodes
			GRGEN_MODEL.IExpression node_prev { get; }
			GRGEN_MODEL.IExpression node_e { get; }
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_InClass.Match_InClass @_sub0 { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			new void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_InClass_alt_0_End : IMatch_InClass_alt_0
		{
			//Nodes
			GRGEN_MODEL.IBlock node_prev { get; }
			GRGEN_MODEL.IExpression node_e { get; }
			GRGEN_MODEL.IBlock node_b { get; }
			GRGEN_MODEL.IMethodBody node_mb { get; }
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge__edge0 { get; }
			GRGEN_MODEL.IbelongsTo edge__edge1 { get; }
			GRGEN_MODEL.IbelongsTo edge__edge2 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			new void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_InClass : GRGEN_LGSP.ListElement<Match_InClass>, IMatch_InClass
		{
			public GRGEN_MODEL.IExpression node_e { get { return (GRGEN_MODEL.IExpression)_node_e; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_e;
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum InClass_NodeNums { @e, @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)InClass_NodeNums.@e: return _node_e;
				case (int)InClass_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public enum InClass_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InClass_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InClass_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public IMatch_InClass_alt_0 alt_0 { get { return _alt_0; } }
			public IMatch_InClass_alt_0 _alt_0;
			public enum InClass_AltNums { @alt_0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 1;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				case (int)InClass_AltNums.@alt_0: return _alt_0;
				default: return null;
				}
			}
			
			public enum InClass_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InClass_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_InClass.instance.pat_InClass; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_InClass_alt_0_Previous : GRGEN_LGSP.ListElement<Match_InClass_alt_0_Previous>, IMatch_InClass_alt_0_Previous
		{
			public GRGEN_MODEL.IExpression node_prev { get { return (GRGEN_MODEL.IExpression)_node_prev; } }
			public GRGEN_MODEL.IExpression node_e { get { return (GRGEN_MODEL.IExpression)_node_e; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_prev;
			public GRGEN_LGSP.LGSPNode _node_e;
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum InClass_alt_0_Previous_NodeNums { @prev, @e, @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)InClass_alt_0_Previous_NodeNums.@prev: return _node_prev;
				case (int)InClass_alt_0_Previous_NodeNums.@e: return _node_e;
				case (int)InClass_alt_0_Previous_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge__edge0 { get { return (GRGEN_MODEL.Iexpression)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum InClass_alt_0_Previous_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)InClass_alt_0_Previous_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum InClass_alt_0_Previous_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_InClass.Match_InClass @_sub0 { get { return @__sub0; } }
			public @Pattern_InClass.Match_InClass @__sub0;
			public enum InClass_alt_0_Previous_SubNums { @_sub0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)InClass_alt_0_Previous_SubNums.@_sub0: return __sub0;
				default: return null;
				}
			}
			
			public enum InClass_alt_0_Previous_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InClass_alt_0_Previous_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InClass_alt_0_Previous_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_InClass.instance.InClass_alt_0_Previous; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_InClass_alt_0_End : GRGEN_LGSP.ListElement<Match_InClass_alt_0_End>, IMatch_InClass_alt_0_End
		{
			public GRGEN_MODEL.IBlock node_prev { get { return (GRGEN_MODEL.IBlock)_node_prev; } }
			public GRGEN_MODEL.IExpression node_e { get { return (GRGEN_MODEL.IExpression)_node_e; } }
			public GRGEN_MODEL.IBlock node_b { get { return (GRGEN_MODEL.IBlock)_node_b; } }
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_prev;
			public GRGEN_LGSP.LGSPNode _node_e;
			public GRGEN_LGSP.LGSPNode _node_b;
			public GRGEN_LGSP.LGSPNode _node_mb;
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum InClass_alt_0_End_NodeNums { @prev, @e, @b, @mb, @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 5;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)InClass_alt_0_End_NodeNums.@prev: return _node_prev;
				case (int)InClass_alt_0_End_NodeNums.@e: return _node_e;
				case (int)InClass_alt_0_End_NodeNums.@b: return _node_b;
				case (int)InClass_alt_0_End_NodeNums.@mb: return _node_mb;
				case (int)InClass_alt_0_End_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge__edge0 { get { return (GRGEN_MODEL.Iexpression)_edge__edge0; } }
			public GRGEN_MODEL.IbelongsTo edge__edge1 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge1; } }
			public GRGEN_MODEL.IbelongsTo edge__edge2 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge2; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge__edge1;
			public GRGEN_LGSP.LGSPEdge _edge__edge2;
			public enum InClass_alt_0_End_EdgeNums { @_edge0, @_edge1, @_edge2, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 3;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)InClass_alt_0_End_EdgeNums.@_edge0: return _edge__edge0;
				case (int)InClass_alt_0_End_EdgeNums.@_edge1: return _edge__edge1;
				case (int)InClass_alt_0_End_EdgeNums.@_edge2: return _edge__edge2;
				default: return null;
				}
			}
			
			public enum InClass_alt_0_End_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InClass_alt_0_End_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InClass_alt_0_End_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InClass_alt_0_End_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InClass_alt_0_End_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_InClass.instance.InClass_alt_0_End; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Pattern_methodNameExistsSuper : GRGEN_LGSP.LGSPMatchingPattern
	{
		private static Pattern_methodNameExistsSuper instance = null;
		public static Pattern_methodNameExistsSuper Instance { get { if (instance==null) { instance = new Pattern_methodNameExistsSuper(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] methodNameExistsSuper_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] methodNameExistsSuper_node_cls_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] methodNameExistsSuper_node_opForName_AllowedTypes = null;
		public static bool[] methodNameExistsSuper_node_op_IsAllowedType = null;
		public static bool[] methodNameExistsSuper_node_cls_IsAllowedType = null;
		public static bool[] methodNameExistsSuper_node_opForName_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] methodNameExistsSuper_edge__edge0_AllowedTypes = null;
		public static bool[] methodNameExistsSuper_edge__edge0_IsAllowedType = null;
		public enum methodNameExistsSuper_NodeNums { @op, @cls, @opForName, };
		public enum methodNameExistsSuper_EdgeNums { @_edge0, };
		public enum methodNameExistsSuper_VariableNums { };
		public enum methodNameExistsSuper_SubNums { };
		public enum methodNameExistsSuper_AltNums { @alt_0, };
		public enum methodNameExistsSuper_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_methodNameExistsSuper;

		public enum methodNameExistsSuper_alt_0_CaseNums { @here, @super, };
		public enum methodNameExistsSuper_alt_0_here_NodeNums { @op, @opForName, };
		public enum methodNameExistsSuper_alt_0_here_EdgeNums { };
		public enum methodNameExistsSuper_alt_0_here_VariableNums { };
		public enum methodNameExistsSuper_alt_0_here_SubNums { };
		public enum methodNameExistsSuper_alt_0_here_AltNums { };
		public enum methodNameExistsSuper_alt_0_here_IterNums { };



		public GRGEN_LGSP.PatternGraph methodNameExistsSuper_alt_0_here;

		public static GRGEN_LIBGR.NodeType[] methodNameExistsSuper_alt_0_super_node_super_AllowedTypes = null;
		public static bool[] methodNameExistsSuper_alt_0_super_node_super_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] methodNameExistsSuper_alt_0_super_edge__edge0_AllowedTypes = null;
		public static bool[] methodNameExistsSuper_alt_0_super_edge__edge0_IsAllowedType = null;
		public enum methodNameExistsSuper_alt_0_super_NodeNums { @cls, @super, @opForName, };
		public enum methodNameExistsSuper_alt_0_super_EdgeNums { @_edge0, };
		public enum methodNameExistsSuper_alt_0_super_VariableNums { };
		public enum methodNameExistsSuper_alt_0_super_SubNums { @_sub0, };
		public enum methodNameExistsSuper_alt_0_super_AltNums { };
		public enum methodNameExistsSuper_alt_0_super_IterNums { };



		public GRGEN_LGSP.PatternGraph methodNameExistsSuper_alt_0_super;


		private Pattern_methodNameExistsSuper()
		{
			name = "methodNameExistsSuper";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, };
			inputNames = new string[] { "methodNameExistsSuper_node_opForName", "methodNameExistsSuper_node_cls", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };

		}
		private void initialize()
		{
			bool[,] methodNameExistsSuper_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] methodNameExistsSuper_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] methodNameExistsSuper_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] methodNameExistsSuper_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode methodNameExistsSuper_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "methodNameExistsSuper_node_op", "op", methodNameExistsSuper_node_op_AllowedTypes, methodNameExistsSuper_node_op_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode methodNameExistsSuper_node_cls = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "methodNameExistsSuper_node_cls", "cls", methodNameExistsSuper_node_cls_AllowedTypes, methodNameExistsSuper_node_cls_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode methodNameExistsSuper_node_opForName = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "methodNameExistsSuper_node_opForName", "opForName", methodNameExistsSuper_node_opForName_AllowedTypes, methodNameExistsSuper_node_opForName_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge methodNameExistsSuper_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "methodNameExistsSuper_edge__edge0", "_edge0", methodNameExistsSuper_edge__edge0_AllowedTypes, methodNameExistsSuper_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			bool[,] methodNameExistsSuper_alt_0_here_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] methodNameExistsSuper_alt_0_here_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] methodNameExistsSuper_alt_0_here_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] methodNameExistsSuper_alt_0_here_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternCondition methodNameExistsSuper_alt_0_here_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.EQ(new GRGEN_EXPR.Qualification("GRGEN_MODEL.IOperation", "methodNameExistsSuper_node_op", "name"), new GRGEN_EXPR.Qualification("GRGEN_MODEL.IOperation", "methodNameExistsSuper_node_opForName", "name")),
				new string[] { "methodNameExistsSuper_node_op", "methodNameExistsSuper_node_opForName" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			methodNameExistsSuper_alt_0_here = new GRGEN_LGSP.PatternGraph(
				"here",
				"methodNameExistsSuper_alt_0_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { methodNameExistsSuper_node_op, methodNameExistsSuper_node_opForName }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { methodNameExistsSuper_alt_0_here_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, true, },
					{ true, true, },
				},
				new bool[0, 0] ,
				methodNameExistsSuper_alt_0_here_isNodeHomomorphicGlobal,
				methodNameExistsSuper_alt_0_here_isEdgeHomomorphicGlobal,
				methodNameExistsSuper_alt_0_here_isNodeTotallyHomomorphic,
				methodNameExistsSuper_alt_0_here_isEdgeTotallyHomomorphic
			);

			bool[,] methodNameExistsSuper_alt_0_super_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] methodNameExistsSuper_alt_0_super_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] methodNameExistsSuper_alt_0_super_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] methodNameExistsSuper_alt_0_super_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode methodNameExistsSuper_alt_0_super_node_super = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "methodNameExistsSuper_alt_0_super_node_super", "super", methodNameExistsSuper_alt_0_super_node_super_AllowedTypes, methodNameExistsSuper_alt_0_super_node_super_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge methodNameExistsSuper_alt_0_super_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@extends_, "GRGEN_MODEL.Iextends_", "methodNameExistsSuper_alt_0_super_edge__edge0", "_edge0", methodNameExistsSuper_alt_0_super_edge__edge0_AllowedTypes, methodNameExistsSuper_alt_0_super_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding methodNameExistsSuper_alt_0_super__sub0 = new GRGEN_LGSP.PatternGraphEmbedding("_sub0", Pattern_methodNameExistsSuper.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("methodNameExistsSuper_node_opForName"),
					new GRGEN_EXPR.GraphEntityExpression("methodNameExistsSuper_alt_0_super_node_super"),
				}, 
				new string[] { }, new string[] { "methodNameExistsSuper_node_opForName", "methodNameExistsSuper_alt_0_super_node_super" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			methodNameExistsSuper_alt_0_super = new GRGEN_LGSP.PatternGraph(
				"super",
				"methodNameExistsSuper_alt_0_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { methodNameExistsSuper_node_cls, methodNameExistsSuper_alt_0_super_node_super, methodNameExistsSuper_node_opForName }, 
				new GRGEN_LGSP.PatternEdge[] { methodNameExistsSuper_alt_0_super_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { methodNameExistsSuper_alt_0_super__sub0 }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, true, },
					{ false, true, true, },
					{ true, true, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				methodNameExistsSuper_alt_0_super_isNodeHomomorphicGlobal,
				methodNameExistsSuper_alt_0_super_isEdgeHomomorphicGlobal,
				methodNameExistsSuper_alt_0_super_isNodeTotallyHomomorphic,
				methodNameExistsSuper_alt_0_super_isEdgeTotallyHomomorphic
			);
			methodNameExistsSuper_alt_0_super.edgeToSourceNode.Add(methodNameExistsSuper_alt_0_super_edge__edge0, methodNameExistsSuper_node_cls);
			methodNameExistsSuper_alt_0_super.edgeToTargetNode.Add(methodNameExistsSuper_alt_0_super_edge__edge0, methodNameExistsSuper_alt_0_super_node_super);

			GRGEN_LGSP.Alternative methodNameExistsSuper_alt_0 = new GRGEN_LGSP.Alternative( "alt_0", "methodNameExistsSuper_", new GRGEN_LGSP.PatternGraph[] { methodNameExistsSuper_alt_0_here, methodNameExistsSuper_alt_0_super } );

			pat_methodNameExistsSuper = new GRGEN_LGSP.PatternGraph(
				"methodNameExistsSuper",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { methodNameExistsSuper_node_op, methodNameExistsSuper_node_cls, methodNameExistsSuper_node_opForName }, 
				new GRGEN_LGSP.PatternEdge[] { methodNameExistsSuper_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] { methodNameExistsSuper_alt_0,  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				methodNameExistsSuper_isNodeHomomorphicGlobal,
				methodNameExistsSuper_isEdgeHomomorphicGlobal,
				methodNameExistsSuper_isNodeTotallyHomomorphic,
				methodNameExistsSuper_isEdgeTotallyHomomorphic
			);
			pat_methodNameExistsSuper.edgeToSourceNode.Add(methodNameExistsSuper_edge__edge0, methodNameExistsSuper_node_op);
			pat_methodNameExistsSuper.edgeToTargetNode.Add(methodNameExistsSuper_edge__edge0, methodNameExistsSuper_node_cls);
			methodNameExistsSuper_alt_0_here.embeddingGraph = pat_methodNameExistsSuper;
			methodNameExistsSuper_alt_0_super.embeddingGraph = pat_methodNameExistsSuper;

			methodNameExistsSuper_node_op.pointOfDefinition = pat_methodNameExistsSuper;
			methodNameExistsSuper_node_cls.pointOfDefinition = null;
			methodNameExistsSuper_node_opForName.pointOfDefinition = null;
			methodNameExistsSuper_edge__edge0.pointOfDefinition = pat_methodNameExistsSuper;
			methodNameExistsSuper_alt_0_super_node_super.pointOfDefinition = methodNameExistsSuper_alt_0_super;
			methodNameExistsSuper_alt_0_super_edge__edge0.pointOfDefinition = methodNameExistsSuper_alt_0_super;
			methodNameExistsSuper_alt_0_super__sub0.PointOfDefinition = methodNameExistsSuper_alt_0_super;

			patternGraph = pat_methodNameExistsSuper;
		}


		public void methodNameExistsSuper_Create(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPNode node_opForName, GRGEN_LGSP.LGSPNode node_cls)
		{
			graph.SettingAddedNodeNames( create_methodNameExistsSuper_addedNodeNames );
			GRGEN_MODEL.@Operation node_op = GRGEN_MODEL.@Operation.CreateNode(graph);
			graph.SettingAddedEdgeNames( create_methodNameExistsSuper_addedEdgeNames );
			GRGEN_MODEL.@belongsTo edge__edge0 = GRGEN_MODEL.@belongsTo.CreateEdge(graph, node_op, node_cls);
		}
		private static string[] create_methodNameExistsSuper_addedNodeNames = new string[] { "op" };
		private static string[] create_methodNameExistsSuper_addedEdgeNames = new string[] { "_edge0" };

		public void methodNameExistsSuper_Delete(GRGEN_LGSP.LGSPGraph graph, Match_methodNameExistsSuper curMatch)
		{
			GRGEN_LGSP.LGSPNode node_op = curMatch._node_op;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			IMatch_methodNameExistsSuper_alt_0 alternative_alt_0 = curMatch._alt_0;
			methodNameExistsSuper_alt_0_Delete(graph, alternative_alt_0);
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_op);
			graph.Remove(node_op);
		}

		public void methodNameExistsSuper_alt_0_Delete(GRGEN_LGSP.LGSPGraph graph, IMatch_methodNameExistsSuper_alt_0 curMatch)
		{
			if(curMatch.Pattern == methodNameExistsSuper_alt_0_here) {
				methodNameExistsSuper_alt_0_here_Delete(graph, (Match_methodNameExistsSuper_alt_0_here)curMatch);
				return;
			}
			else if(curMatch.Pattern == methodNameExistsSuper_alt_0_super) {
				methodNameExistsSuper_alt_0_super_Delete(graph, (Match_methodNameExistsSuper_alt_0_super)curMatch);
				return;
			}
			throw new ApplicationException(); //debug assert
		}

		public void methodNameExistsSuper_alt_0_here_Delete(GRGEN_LGSP.LGSPGraph graph, Match_methodNameExistsSuper_alt_0_here curMatch)
		{
			GRGEN_LGSP.LGSPNode node_op = curMatch._node_op;
			GRGEN_LGSP.LGSPNode node_opForName = curMatch._node_opForName;
			graph.RemoveEdges(node_op);
			graph.Remove(node_op);
			graph.RemoveEdges(node_opForName);
			graph.Remove(node_opForName);
		}

		public void methodNameExistsSuper_alt_0_super_Delete(GRGEN_LGSP.LGSPGraph graph, Match_methodNameExistsSuper_alt_0_super curMatch)
		{
			GRGEN_LGSP.LGSPNode node_cls = curMatch._node_cls;
			GRGEN_LGSP.LGSPNode node_super = curMatch._node_super;
			GRGEN_LGSP.LGSPNode node_opForName = curMatch._node_opForName;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			Pattern_methodNameExistsSuper.Match_methodNameExistsSuper subpattern__sub0 = curMatch.@__sub0;
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_cls);
			graph.Remove(node_cls);
			graph.RemoveEdges(node_super);
			graph.Remove(node_super);
			graph.RemoveEdges(node_opForName);
			graph.Remove(node_opForName);
			Pattern_methodNameExistsSuper.Instance.methodNameExistsSuper_Delete(graph, subpattern__sub0);
		}

		static Pattern_methodNameExistsSuper() {
		}

		public interface IMatch_methodNameExistsSuper : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IClass node_cls { get; }
			GRGEN_MODEL.IOperation node_opForName { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			IMatch_methodNameExistsSuper_alt_0 alt_0 { get; }
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_methodNameExistsSuper_alt_0 : GRGEN_LIBGR.IMatch
		{
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_methodNameExistsSuper_alt_0_here : IMatch_methodNameExistsSuper_alt_0
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IOperation node_opForName { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			new void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_methodNameExistsSuper_alt_0_super : IMatch_methodNameExistsSuper_alt_0
		{
			//Nodes
			GRGEN_MODEL.IClass node_cls { get; }
			GRGEN_MODEL.IClass node_super { get; }
			GRGEN_MODEL.IOperation node_opForName { get; }
			//Edges
			GRGEN_MODEL.Iextends_ edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_methodNameExistsSuper.Match_methodNameExistsSuper @_sub0 { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			new void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_methodNameExistsSuper : GRGEN_LGSP.ListElement<Match_methodNameExistsSuper>, IMatch_methodNameExistsSuper
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IClass node_cls { get { return (GRGEN_MODEL.IClass)_node_cls; } }
			public GRGEN_MODEL.IOperation node_opForName { get { return (GRGEN_MODEL.IOperation)_node_opForName; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_cls;
			public GRGEN_LGSP.LGSPNode _node_opForName;
			public enum methodNameExistsSuper_NodeNums { @op, @cls, @opForName, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)methodNameExistsSuper_NodeNums.@op: return _node_op;
				case (int)methodNameExistsSuper_NodeNums.@cls: return _node_cls;
				case (int)methodNameExistsSuper_NodeNums.@opForName: return _node_opForName;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge0 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum methodNameExistsSuper_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)methodNameExistsSuper_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public IMatch_methodNameExistsSuper_alt_0 alt_0 { get { return _alt_0; } }
			public IMatch_methodNameExistsSuper_alt_0 _alt_0;
			public enum methodNameExistsSuper_AltNums { @alt_0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 1;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				case (int)methodNameExistsSuper_AltNums.@alt_0: return _alt_0;
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_methodNameExistsSuper.instance.pat_methodNameExistsSuper; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_methodNameExistsSuper_alt_0_here : GRGEN_LGSP.ListElement<Match_methodNameExistsSuper_alt_0_here>, IMatch_methodNameExistsSuper_alt_0_here
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IOperation node_opForName { get { return (GRGEN_MODEL.IOperation)_node_opForName; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_opForName;
			public enum methodNameExistsSuper_alt_0_here_NodeNums { @op, @opForName, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)methodNameExistsSuper_alt_0_here_NodeNums.@op: return _node_op;
				case (int)methodNameExistsSuper_alt_0_here_NodeNums.@opForName: return _node_opForName;
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_alt_0_here_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_alt_0_here_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_alt_0_here_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_alt_0_here_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_alt_0_here_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_alt_0_here_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_methodNameExistsSuper.instance.methodNameExistsSuper_alt_0_here; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_methodNameExistsSuper_alt_0_super : GRGEN_LGSP.ListElement<Match_methodNameExistsSuper_alt_0_super>, IMatch_methodNameExistsSuper_alt_0_super
		{
			public GRGEN_MODEL.IClass node_cls { get { return (GRGEN_MODEL.IClass)_node_cls; } }
			public GRGEN_MODEL.IClass node_super { get { return (GRGEN_MODEL.IClass)_node_super; } }
			public GRGEN_MODEL.IOperation node_opForName { get { return (GRGEN_MODEL.IOperation)_node_opForName; } }
			public GRGEN_LGSP.LGSPNode _node_cls;
			public GRGEN_LGSP.LGSPNode _node_super;
			public GRGEN_LGSP.LGSPNode _node_opForName;
			public enum methodNameExistsSuper_alt_0_super_NodeNums { @cls, @super, @opForName, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)methodNameExistsSuper_alt_0_super_NodeNums.@cls: return _node_cls;
				case (int)methodNameExistsSuper_alt_0_super_NodeNums.@super: return _node_super;
				case (int)methodNameExistsSuper_alt_0_super_NodeNums.@opForName: return _node_opForName;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iextends_ edge__edge0 { get { return (GRGEN_MODEL.Iextends_)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum methodNameExistsSuper_alt_0_super_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)methodNameExistsSuper_alt_0_super_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_alt_0_super_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_methodNameExistsSuper.Match_methodNameExistsSuper @_sub0 { get { return @__sub0; } }
			public @Pattern_methodNameExistsSuper.Match_methodNameExistsSuper @__sub0;
			public enum methodNameExistsSuper_alt_0_super_SubNums { @_sub0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)methodNameExistsSuper_alt_0_super_SubNums.@_sub0: return __sub0;
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_alt_0_super_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_alt_0_super_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodNameExistsSuper_alt_0_super_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Pattern_methodNameExistsSuper.instance.methodNameExistsSuper_alt_0_super; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpGxl : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpGxl instance = null;
		public static Rule_dumpGxl Instance { get { if (instance==null) { instance = new Rule_dumpGxl(); instance.initialize(); } return instance; } }

		public enum dumpGxl_NodeNums { };
		public enum dumpGxl_EdgeNums { };
		public enum dumpGxl_VariableNums { @v, };
		public enum dumpGxl_SubNums { };
		public enum dumpGxl_AltNums { };
		public enum dumpGxl_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpGxl;


		private Rule_dumpGxl()
		{
			name = "dumpGxl";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpGxl_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpGxl_isNodeHomomorphicGlobal = new bool[0, 0] ;
			bool[,] dumpGxl_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpGxl_isNodeTotallyHomomorphic = new bool[0] ;
			bool[] dumpGxl_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpGxl_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpGxl_var_v", "v", 0, false, null);
			pat_dumpGxl = new GRGEN_LGSP.PatternGraph(
				"dumpGxl",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] {  }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpGxl_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[0, 0] ,
				new bool[0, 0] ,
				dumpGxl_isNodeHomomorphicGlobal,
				dumpGxl_isEdgeHomomorphicGlobal,
				dumpGxl_isNodeTotallyHomomorphic,
				dumpGxl_isEdgeTotallyHomomorphic
			);


			patternGraph = pat_dumpGxl;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpGxl curMatch = (Match_dumpGxl)_curMatch;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpGxl_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpGxl_addedEdgeNames );
			graph.EmitWriter.Write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
			graph.EmitWriter.Write("<!DOCTYPE gxl SYSTEM \"http://www.gupro.de/GXL/gxl-1.0.dtd\">");
			graph.EmitWriter.Write("<gxl>");
			graph.EmitWriter.Write("<graph id=\"");
			graph.EmitWriter.Write(graph.Name);
			graph.EmitWriter.Write("\" edgeids=\"true\">");
			graph.EmitWriter.Write("<type xlink:href=\"javaProgramGraphsSchema\"/>");
			ApplyXGRS_dumpGxl_0(graph, var_v);
			graph.EmitWriter.Write("</graph>");
			graph.EmitWriter.Write("</gxl>");
			return;
		}
		private static string[] dumpGxl_addedNodeNames = new string[] {  };
		private static string[] dumpGxl_addedEdgeNames = new string[] {  };

        public static bool ApplyXGRS_dumpGxl_0(GRGEN_LGSP.LGSPGraph graph, int var_v)
        {
            GRGEN_LGSP.LGSPActions actions = graph.curActions;
            bool res_50;
            bool res_29;
            bool res_28;
            bool res_0;
            Action_dumpNodePackage rule_dumpNodePackage = Action_dumpNodePackage.Instance;
            bool res_27;
            bool res_1;
            Action_dumpNodeClass rule_dumpNodeClass = Action_dumpNodeClass.Instance;
            bool res_26;
            bool res_2;
            Action_dumpNodeInterface rule_dumpNodeInterface = Action_dumpNodeInterface.Instance;
            bool res_25;
            bool res_3;
            Action_dumpNodeVariable rule_dumpNodeVariable = Action_dumpNodeVariable.Instance;
            bool res_24;
            bool res_4;
            Action_dumpNodeOperation rule_dumpNodeOperation = Action_dumpNodeOperation.Instance;
            bool res_23;
            bool res_5;
            Action_dumpNodeMethodBody rule_dumpNodeMethodBody = Action_dumpNodeMethodBody.Instance;
            bool res_22;
            bool res_6;
            Action_dumpNodeAccess rule_dumpNodeAccess = Action_dumpNodeAccess.Instance;
            bool res_21;
            bool res_7;
            Action_dumpNodeUpdate rule_dumpNodeUpdate = Action_dumpNodeUpdate.Instance;
            bool res_20;
            bool res_8;
            Action_dumpNodeCall rule_dumpNodeCall = Action_dumpNodeCall.Instance;
            bool res_19;
            bool res_9;
            Action_dumpNodeIstantiation rule_dumpNodeIstantiation = Action_dumpNodeIstantiation.Instance;
            bool res_18;
            bool res_10;
            Action_dumpNodeOperator rule_dumpNodeOperator = Action_dumpNodeOperator.Instance;
            bool res_17;
            bool res_11;
            Action_dumpNodeReturn rule_dumpNodeReturn = Action_dumpNodeReturn.Instance;
            bool res_16;
            bool res_12;
            Action_dumpNodeBlock rule_dumpNodeBlock = Action_dumpNodeBlock.Instance;
            bool res_15;
            bool res_13;
            Action_dumpNodeLiteral rule_dumpNodeLiteral = Action_dumpNodeLiteral.Instance;
            bool res_14;
            Action_dumpNodeParameter rule_dumpNodeParameter = Action_dumpNodeParameter.Instance;
            bool res_49;
            bool res_48;
            bool res_30;
            Action_dumpEdgeBelongsTo rule_dumpEdgeBelongsTo = Action_dumpEdgeBelongsTo.Instance;
            bool res_47;
            bool res_31;
            Action_dumpEdgeType rule_dumpEdgeType = Action_dumpEdgeType.Instance;
            bool res_46;
            bool res_32;
            Action_dumpEdgeExtends rule_dumpEdgeExtends = Action_dumpEdgeExtends.Instance;
            bool res_45;
            bool res_33;
            Action_dumpEdgeImports rule_dumpEdgeImports = Action_dumpEdgeImports.Instance;
            bool res_44;
            bool res_34;
            Action_dumpEdgeImplements rule_dumpEdgeImplements = Action_dumpEdgeImplements.Instance;
            bool res_43;
            bool res_35;
            Action_dumpEdgeParameter rule_dumpEdgeParameter = Action_dumpEdgeParameter.Instance;
            bool res_42;
            bool res_36;
            Action_dumpEdgeBinding rule_dumpEdgeBinding = Action_dumpEdgeBinding.Instance;
            bool res_41;
            bool res_37;
            Action_dumpEdgeLink rule_dumpEdgeLink = Action_dumpEdgeLink.Instance;
            bool res_40;
            bool res_38;
            Action_dumpEdgeExpression rule_dumpEdgeExpression = Action_dumpEdgeExpression.Instance;
            bool res_39;
            Action_dumpEdgeActualParameter rule_dumpEdgeActualParameter = Action_dumpEdgeActualParameter.Instance;
            long i_29 = 0;
            while(true)
            {
                GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> matches_0 = rule_dumpNodePackage.Match(graph, 1, (int)var_v);
                graph.Matched(matches_0, false);
                if(matches_0.Count==0) {
                    res_0 = (bool)(false);
                } else {
                    res_0 = (bool)(true);
                    if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_0.Count;
                    graph.Finishing(matches_0, false);
                    Rule_dumpNodePackage.IMatch_dumpNodePackage match_0 = matches_0.FirstExact;
                    rule_dumpNodePackage.Modify(graph, match_0);
                    if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                    graph.Finished(matches_0, false);
                }
                if(res_0)
                    res_28 = (bool)(true);
                else
                {
                    GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> matches_1 = rule_dumpNodeClass.Match(graph, 1, (int)var_v);
                    graph.Matched(matches_1, false);
                    if(matches_1.Count==0) {
                        res_1 = (bool)(false);
                    } else {
                        res_1 = (bool)(true);
                        if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_1.Count;
                        graph.Finishing(matches_1, false);
                        Rule_dumpNodeClass.IMatch_dumpNodeClass match_1 = matches_1.FirstExact;
                        rule_dumpNodeClass.Modify(graph, match_1);
                        if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                        graph.Finished(matches_1, false);
                    }
                    if(res_1)
                        res_27 = (bool)(true);
                    else
                    {
                        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> matches_2 = rule_dumpNodeInterface.Match(graph, 1, (int)var_v);
                        graph.Matched(matches_2, false);
                        if(matches_2.Count==0) {
                            res_2 = (bool)(false);
                        } else {
                            res_2 = (bool)(true);
                            if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_2.Count;
                            graph.Finishing(matches_2, false);
                            Rule_dumpNodeInterface.IMatch_dumpNodeInterface match_2 = matches_2.FirstExact;
                            rule_dumpNodeInterface.Modify(graph, match_2);
                            if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                            graph.Finished(matches_2, false);
                        }
                        if(res_2)
                            res_26 = (bool)(true);
                        else
                        {
                            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> matches_3 = rule_dumpNodeVariable.Match(graph, 1, (int)var_v);
                            graph.Matched(matches_3, false);
                            if(matches_3.Count==0) {
                                res_3 = (bool)(false);
                            } else {
                                res_3 = (bool)(true);
                                if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_3.Count;
                                graph.Finishing(matches_3, false);
                                Rule_dumpNodeVariable.IMatch_dumpNodeVariable match_3 = matches_3.FirstExact;
                                rule_dumpNodeVariable.Modify(graph, match_3);
                                if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                graph.Finished(matches_3, false);
                            }
                            if(res_3)
                                res_25 = (bool)(true);
                            else
                            {
                                GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> matches_4 = rule_dumpNodeOperation.Match(graph, 1, (int)var_v);
                                graph.Matched(matches_4, false);
                                if(matches_4.Count==0) {
                                    res_4 = (bool)(false);
                                } else {
                                    res_4 = (bool)(true);
                                    if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_4.Count;
                                    graph.Finishing(matches_4, false);
                                    Rule_dumpNodeOperation.IMatch_dumpNodeOperation match_4 = matches_4.FirstExact;
                                    rule_dumpNodeOperation.Modify(graph, match_4);
                                    if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                    graph.Finished(matches_4, false);
                                }
                                if(res_4)
                                    res_24 = (bool)(true);
                                else
                                {
                                    GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> matches_5 = rule_dumpNodeMethodBody.Match(graph, 1, (int)var_v);
                                    graph.Matched(matches_5, false);
                                    if(matches_5.Count==0) {
                                        res_5 = (bool)(false);
                                    } else {
                                        res_5 = (bool)(true);
                                        if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_5.Count;
                                        graph.Finishing(matches_5, false);
                                        Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody match_5 = matches_5.FirstExact;
                                        rule_dumpNodeMethodBody.Modify(graph, match_5);
                                        if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                        graph.Finished(matches_5, false);
                                    }
                                    if(res_5)
                                        res_23 = (bool)(true);
                                    else
                                    {
                                        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> matches_6 = rule_dumpNodeAccess.Match(graph, 1, (int)var_v);
                                        graph.Matched(matches_6, false);
                                        if(matches_6.Count==0) {
                                            res_6 = (bool)(false);
                                        } else {
                                            res_6 = (bool)(true);
                                            if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_6.Count;
                                            graph.Finishing(matches_6, false);
                                            Rule_dumpNodeAccess.IMatch_dumpNodeAccess match_6 = matches_6.FirstExact;
                                            rule_dumpNodeAccess.Modify(graph, match_6);
                                            if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                            graph.Finished(matches_6, false);
                                        }
                                        if(res_6)
                                            res_22 = (bool)(true);
                                        else
                                        {
                                            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> matches_7 = rule_dumpNodeUpdate.Match(graph, 1, (int)var_v);
                                            graph.Matched(matches_7, false);
                                            if(matches_7.Count==0) {
                                                res_7 = (bool)(false);
                                            } else {
                                                res_7 = (bool)(true);
                                                if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_7.Count;
                                                graph.Finishing(matches_7, false);
                                                Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate match_7 = matches_7.FirstExact;
                                                rule_dumpNodeUpdate.Modify(graph, match_7);
                                                if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                graph.Finished(matches_7, false);
                                            }
                                            if(res_7)
                                                res_21 = (bool)(true);
                                            else
                                            {
                                                GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> matches_8 = rule_dumpNodeCall.Match(graph, 1, (int)var_v);
                                                graph.Matched(matches_8, false);
                                                if(matches_8.Count==0) {
                                                    res_8 = (bool)(false);
                                                } else {
                                                    res_8 = (bool)(true);
                                                    if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_8.Count;
                                                    graph.Finishing(matches_8, false);
                                                    Rule_dumpNodeCall.IMatch_dumpNodeCall match_8 = matches_8.FirstExact;
                                                    rule_dumpNodeCall.Modify(graph, match_8);
                                                    if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                    graph.Finished(matches_8, false);
                                                }
                                                if(res_8)
                                                    res_20 = (bool)(true);
                                                else
                                                {
                                                    GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> matches_9 = rule_dumpNodeIstantiation.Match(graph, 1, (int)var_v);
                                                    graph.Matched(matches_9, false);
                                                    if(matches_9.Count==0) {
                                                        res_9 = (bool)(false);
                                                    } else {
                                                        res_9 = (bool)(true);
                                                        if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_9.Count;
                                                        graph.Finishing(matches_9, false);
                                                        Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation match_9 = matches_9.FirstExact;
                                                        rule_dumpNodeIstantiation.Modify(graph, match_9);
                                                        if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                        graph.Finished(matches_9, false);
                                                    }
                                                    if(res_9)
                                                        res_19 = (bool)(true);
                                                    else
                                                    {
                                                        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> matches_10 = rule_dumpNodeOperator.Match(graph, 1, (int)var_v);
                                                        graph.Matched(matches_10, false);
                                                        if(matches_10.Count==0) {
                                                            res_10 = (bool)(false);
                                                        } else {
                                                            res_10 = (bool)(true);
                                                            if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_10.Count;
                                                            graph.Finishing(matches_10, false);
                                                            Rule_dumpNodeOperator.IMatch_dumpNodeOperator match_10 = matches_10.FirstExact;
                                                            rule_dumpNodeOperator.Modify(graph, match_10);
                                                            if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                            graph.Finished(matches_10, false);
                                                        }
                                                        if(res_10)
                                                            res_18 = (bool)(true);
                                                        else
                                                        {
                                                            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> matches_11 = rule_dumpNodeReturn.Match(graph, 1, (int)var_v);
                                                            graph.Matched(matches_11, false);
                                                            if(matches_11.Count==0) {
                                                                res_11 = (bool)(false);
                                                            } else {
                                                                res_11 = (bool)(true);
                                                                if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_11.Count;
                                                                graph.Finishing(matches_11, false);
                                                                Rule_dumpNodeReturn.IMatch_dumpNodeReturn match_11 = matches_11.FirstExact;
                                                                rule_dumpNodeReturn.Modify(graph, match_11);
                                                                if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                                graph.Finished(matches_11, false);
                                                            }
                                                            if(res_11)
                                                                res_17 = (bool)(true);
                                                            else
                                                            {
                                                                GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> matches_12 = rule_dumpNodeBlock.Match(graph, 1, (int)var_v);
                                                                graph.Matched(matches_12, false);
                                                                if(matches_12.Count==0) {
                                                                    res_12 = (bool)(false);
                                                                } else {
                                                                    res_12 = (bool)(true);
                                                                    if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_12.Count;
                                                                    graph.Finishing(matches_12, false);
                                                                    Rule_dumpNodeBlock.IMatch_dumpNodeBlock match_12 = matches_12.FirstExact;
                                                                    rule_dumpNodeBlock.Modify(graph, match_12);
                                                                    if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                                    graph.Finished(matches_12, false);
                                                                }
                                                                if(res_12)
                                                                    res_16 = (bool)(true);
                                                                else
                                                                {
                                                                    GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> matches_13 = rule_dumpNodeLiteral.Match(graph, 1, (int)var_v);
                                                                    graph.Matched(matches_13, false);
                                                                    if(matches_13.Count==0) {
                                                                        res_13 = (bool)(false);
                                                                    } else {
                                                                        res_13 = (bool)(true);
                                                                        if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_13.Count;
                                                                        graph.Finishing(matches_13, false);
                                                                        Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral match_13 = matches_13.FirstExact;
                                                                        rule_dumpNodeLiteral.Modify(graph, match_13);
                                                                        if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                                        graph.Finished(matches_13, false);
                                                                    }
                                                                    if(res_13)
                                                                        res_15 = (bool)(true);
                                                                    else
                                                                    {
                                                                        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> matches_14 = rule_dumpNodeParameter.Match(graph, 1, (int)var_v);
                                                                        graph.Matched(matches_14, false);
                                                                        if(matches_14.Count==0) {
                                                                            res_14 = (bool)(false);
                                                                        } else {
                                                                            res_14 = (bool)(true);
                                                                            if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_14.Count;
                                                                            graph.Finishing(matches_14, false);
                                                                            Rule_dumpNodeParameter.IMatch_dumpNodeParameter match_14 = matches_14.FirstExact;
                                                                            rule_dumpNodeParameter.Modify(graph, match_14);
                                                                            if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                                            graph.Finished(matches_14, false);
                                                                        }
                                                                        res_15 = (bool)(res_14);
                                                                    }
                                                                    res_16 = (bool)(res_15);
                                                                }
                                                                res_17 = (bool)(res_16);
                                                            }
                                                            res_18 = (bool)(res_17);
                                                        }
                                                        res_19 = (bool)(res_18);
                                                    }
                                                    res_20 = (bool)(res_19);
                                                }
                                                res_21 = (bool)(res_20);
                                            }
                                            res_22 = (bool)(res_21);
                                        }
                                        res_23 = (bool)(res_22);
                                    }
                                    res_24 = (bool)(res_23);
                                }
                                res_25 = (bool)(res_24);
                            }
                            res_26 = (bool)(res_25);
                        }
                        res_27 = (bool)(res_26);
                    }
                    res_28 = (bool)(res_27);
                }
                if(!res_28) break;
                i_29++;
            }
            res_29 = (bool)(i_29 >= 0);
            if(!res_29)
                res_50 = (bool)(false);
            else
            {
                long i_49 = 0;
                while(true)
                {
                    GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> matches_30 = rule_dumpEdgeBelongsTo.Match(graph, 1, (int)var_v);
                    graph.Matched(matches_30, false);
                    if(matches_30.Count==0) {
                        res_30 = (bool)(false);
                    } else {
                        res_30 = (bool)(true);
                        if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_30.Count;
                        graph.Finishing(matches_30, false);
                        Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo match_30 = matches_30.FirstExact;
                        rule_dumpEdgeBelongsTo.Modify(graph, match_30);
                        if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                        graph.Finished(matches_30, false);
                    }
                    if(res_30)
                        res_48 = (bool)(true);
                    else
                    {
                        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> matches_31 = rule_dumpEdgeType.Match(graph, 1, (int)var_v);
                        graph.Matched(matches_31, false);
                        if(matches_31.Count==0) {
                            res_31 = (bool)(false);
                        } else {
                            res_31 = (bool)(true);
                            if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_31.Count;
                            graph.Finishing(matches_31, false);
                            Rule_dumpEdgeType.IMatch_dumpEdgeType match_31 = matches_31.FirstExact;
                            rule_dumpEdgeType.Modify(graph, match_31);
                            if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                            graph.Finished(matches_31, false);
                        }
                        if(res_31)
                            res_47 = (bool)(true);
                        else
                        {
                            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> matches_32 = rule_dumpEdgeExtends.Match(graph, 1, (int)var_v);
                            graph.Matched(matches_32, false);
                            if(matches_32.Count==0) {
                                res_32 = (bool)(false);
                            } else {
                                res_32 = (bool)(true);
                                if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_32.Count;
                                graph.Finishing(matches_32, false);
                                Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends match_32 = matches_32.FirstExact;
                                rule_dumpEdgeExtends.Modify(graph, match_32);
                                if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                graph.Finished(matches_32, false);
                            }
                            if(res_32)
                                res_46 = (bool)(true);
                            else
                            {
                                GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> matches_33 = rule_dumpEdgeImports.Match(graph, 1, (int)var_v);
                                graph.Matched(matches_33, false);
                                if(matches_33.Count==0) {
                                    res_33 = (bool)(false);
                                } else {
                                    res_33 = (bool)(true);
                                    if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_33.Count;
                                    graph.Finishing(matches_33, false);
                                    Rule_dumpEdgeImports.IMatch_dumpEdgeImports match_33 = matches_33.FirstExact;
                                    rule_dumpEdgeImports.Modify(graph, match_33);
                                    if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                    graph.Finished(matches_33, false);
                                }
                                if(res_33)
                                    res_45 = (bool)(true);
                                else
                                {
                                    GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> matches_34 = rule_dumpEdgeImplements.Match(graph, 1, (int)var_v);
                                    graph.Matched(matches_34, false);
                                    if(matches_34.Count==0) {
                                        res_34 = (bool)(false);
                                    } else {
                                        res_34 = (bool)(true);
                                        if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_34.Count;
                                        graph.Finishing(matches_34, false);
                                        Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements match_34 = matches_34.FirstExact;
                                        rule_dumpEdgeImplements.Modify(graph, match_34);
                                        if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                        graph.Finished(matches_34, false);
                                    }
                                    if(res_34)
                                        res_44 = (bool)(true);
                                    else
                                    {
                                        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> matches_35 = rule_dumpEdgeParameter.Match(graph, 1, (int)var_v);
                                        graph.Matched(matches_35, false);
                                        if(matches_35.Count==0) {
                                            res_35 = (bool)(false);
                                        } else {
                                            res_35 = (bool)(true);
                                            if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_35.Count;
                                            graph.Finishing(matches_35, false);
                                            Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter match_35 = matches_35.FirstExact;
                                            rule_dumpEdgeParameter.Modify(graph, match_35);
                                            if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                            graph.Finished(matches_35, false);
                                        }
                                        if(res_35)
                                            res_43 = (bool)(true);
                                        else
                                        {
                                            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> matches_36 = rule_dumpEdgeBinding.Match(graph, 1, (int)var_v);
                                            graph.Matched(matches_36, false);
                                            if(matches_36.Count==0) {
                                                res_36 = (bool)(false);
                                            } else {
                                                res_36 = (bool)(true);
                                                if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_36.Count;
                                                graph.Finishing(matches_36, false);
                                                Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding match_36 = matches_36.FirstExact;
                                                rule_dumpEdgeBinding.Modify(graph, match_36);
                                                if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                graph.Finished(matches_36, false);
                                            }
                                            if(res_36)
                                                res_42 = (bool)(true);
                                            else
                                            {
                                                GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> matches_37 = rule_dumpEdgeLink.Match(graph, 1, (int)var_v);
                                                graph.Matched(matches_37, false);
                                                if(matches_37.Count==0) {
                                                    res_37 = (bool)(false);
                                                } else {
                                                    res_37 = (bool)(true);
                                                    if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_37.Count;
                                                    graph.Finishing(matches_37, false);
                                                    Rule_dumpEdgeLink.IMatch_dumpEdgeLink match_37 = matches_37.FirstExact;
                                                    rule_dumpEdgeLink.Modify(graph, match_37);
                                                    if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                    graph.Finished(matches_37, false);
                                                }
                                                if(res_37)
                                                    res_41 = (bool)(true);
                                                else
                                                {
                                                    GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> matches_38 = rule_dumpEdgeExpression.Match(graph, 1, (int)var_v);
                                                    graph.Matched(matches_38, false);
                                                    if(matches_38.Count==0) {
                                                        res_38 = (bool)(false);
                                                    } else {
                                                        res_38 = (bool)(true);
                                                        if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_38.Count;
                                                        graph.Finishing(matches_38, false);
                                                        Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression match_38 = matches_38.FirstExact;
                                                        rule_dumpEdgeExpression.Modify(graph, match_38);
                                                        if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                        graph.Finished(matches_38, false);
                                                    }
                                                    if(res_38)
                                                        res_40 = (bool)(true);
                                                    else
                                                    {
                                                        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> matches_39 = rule_dumpEdgeActualParameter.Match(graph, 1, (int)var_v);
                                                        graph.Matched(matches_39, false);
                                                        if(matches_39.Count==0) {
                                                            res_39 = (bool)(false);
                                                        } else {
                                                            res_39 = (bool)(true);
                                                            if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_39.Count;
                                                            graph.Finishing(matches_39, false);
                                                            Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter match_39 = matches_39.FirstExact;
                                                            rule_dumpEdgeActualParameter.Modify(graph, match_39);
                                                            if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                                                            graph.Finished(matches_39, false);
                                                        }
                                                        res_40 = (bool)(res_39);
                                                    }
                                                    res_41 = (bool)(res_40);
                                                }
                                                res_42 = (bool)(res_41);
                                            }
                                            res_43 = (bool)(res_42);
                                        }
                                        res_44 = (bool)(res_43);
                                    }
                                    res_45 = (bool)(res_44);
                                }
                                res_46 = (bool)(res_45);
                            }
                            res_47 = (bool)(res_46);
                        }
                        res_48 = (bool)(res_47);
                    }
                    if(!res_48) break;
                    i_49++;
                }
                res_49 = (bool)(i_49 >= 0);
                res_50 = (bool)(res_49);
            }
            return res_50;
        }

		static Rule_dumpGxl() {
		}

		public interface IMatch_dumpGxl : GRGEN_LIBGR.IMatch
		{
			//Nodes
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpGxl : GRGEN_LGSP.ListElement<Match_dumpGxl>, IMatch_dumpGxl
		{
			public enum dumpGxl_NodeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 0;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpGxl_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpGxl_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpGxl_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpGxl_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpGxl_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpGxl_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpGxl_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpGxl.instance.pat_dumpGxl; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodePackage : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodePackage instance = null;
		public static Rule_dumpNodePackage Instance { get { if (instance==null) { instance = new Rule_dumpNodePackage(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodePackage_node_n_AllowedTypes = null;
		public static bool[] dumpNodePackage_node_n_IsAllowedType = null;
		public enum dumpNodePackage_NodeNums { @n, };
		public enum dumpNodePackage_EdgeNums { };
		public enum dumpNodePackage_VariableNums { @v, };
		public enum dumpNodePackage_SubNums { };
		public enum dumpNodePackage_AltNums { };
		public enum dumpNodePackage_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodePackage;


		private Rule_dumpNodePackage()
		{
			name = "dumpNodePackage";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodePackage_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodePackage_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodePackage_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodePackage_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodePackage_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodePackage_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodePackage_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodePackage_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Package, "GRGEN_MODEL.IPackage", "dumpNodePackage_node_n", "n", dumpNodePackage_node_n_AllowedTypes, dumpNodePackage_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodePackage_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodePackage_node_n", new GRGEN_EXPR.VariableExpression("dumpNodePackage_var_v"))),
				new string[] { "dumpNodePackage_node_n" }, new string[] {  }, new string[] { "dumpNodePackage_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodePackage = new GRGEN_LGSP.PatternGraph(
				"dumpNodePackage",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodePackage_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodePackage_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodePackage_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodePackage_isNodeHomomorphicGlobal,
				dumpNodePackage_isEdgeHomomorphicGlobal,
				dumpNodePackage_isNodeTotallyHomomorphic,
				dumpNodePackage_isEdgeTotallyHomomorphic
			);

			dumpNodePackage_node_n.pointOfDefinition = pat_dumpNodePackage;

			patternGraph = pat_dumpNodePackage;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodePackage curMatch = (Match_dumpNodePackage)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_MODEL.IPackage inode_n = curMatch.node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodePackage_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodePackage_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			string tempvar_node_n_name = inode_n.@name;
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Package\"/>");
			graph.EmitWriter.Write("<attr name=\"name\"> <string>");
			graph.EmitWriter.Write(tempvar_node_n_name);
			graph.EmitWriter.Write("</string> </attr>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodePackage_addedNodeNames = new string[] {  };
		private static string[] dumpNodePackage_addedEdgeNames = new string[] {  };

		static Rule_dumpNodePackage() {
		}

		public interface IMatch_dumpNodePackage : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IPackage node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodePackage : GRGEN_LGSP.ListElement<Match_dumpNodePackage>, IMatch_dumpNodePackage
		{
			public GRGEN_MODEL.IPackage node_n { get { return (GRGEN_MODEL.IPackage)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodePackage_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodePackage_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodePackage_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodePackage_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodePackage_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodePackage_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodePackage_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodePackage_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodePackage_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodePackage.instance.pat_dumpNodePackage; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeClass : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeClass instance = null;
		public static Rule_dumpNodeClass Instance { get { if (instance==null) { instance = new Rule_dumpNodeClass(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeClass_node_n_AllowedTypes = null;
		public static bool[] dumpNodeClass_node_n_IsAllowedType = null;
		public enum dumpNodeClass_NodeNums { @n, };
		public enum dumpNodeClass_EdgeNums { };
		public enum dumpNodeClass_VariableNums { @v, };
		public enum dumpNodeClass_SubNums { };
		public enum dumpNodeClass_AltNums { };
		public enum dumpNodeClass_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeClass;


		private Rule_dumpNodeClass()
		{
			name = "dumpNodeClass";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeClass_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeClass_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeClass_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeClass_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeClass_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeClass_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeClass_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeClass_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "dumpNodeClass_node_n", "n", dumpNodeClass_node_n_AllowedTypes, dumpNodeClass_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeClass_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeClass_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeClass_var_v"))),
				new string[] { "dumpNodeClass_node_n" }, new string[] {  }, new string[] { "dumpNodeClass_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeClass = new GRGEN_LGSP.PatternGraph(
				"dumpNodeClass",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeClass_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeClass_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeClass_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeClass_isNodeHomomorphicGlobal,
				dumpNodeClass_isEdgeHomomorphicGlobal,
				dumpNodeClass_isNodeTotallyHomomorphic,
				dumpNodeClass_isEdgeTotallyHomomorphic
			);

			dumpNodeClass_node_n.pointOfDefinition = pat_dumpNodeClass;

			patternGraph = pat_dumpNodeClass;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeClass curMatch = (Match_dumpNodeClass)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_MODEL.IClass inode_n = curMatch.node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeClass_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeClass_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			string tempvar_node_n_name = inode_n.@name;
			string tempvar_node_n_visibility = inode_n.@visibility;
			bool tempvar_node_n_isAbstract = inode_n.@isAbstract;
			bool tempvar_node_n_isFinal = inode_n.@isFinal;
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Class\"/>");
			graph.EmitWriter.Write("<attr name=\"name\"> <string>");
			graph.EmitWriter.Write(tempvar_node_n_name);
			graph.EmitWriter.Write("</string> </attr>");
			graph.EmitWriter.Write("<attr name=\"visibility\"> <string>");
			graph.EmitWriter.Write(tempvar_node_n_visibility);
			graph.EmitWriter.Write("</string> </attr>");
			graph.EmitWriter.Write("<attr name=\"isAbstract\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_isAbstract);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("<attr name=\"isFinal\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_isFinal);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeClass_addedNodeNames = new string[] {  };
		private static string[] dumpNodeClass_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeClass() {
		}

		public interface IMatch_dumpNodeClass : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IClass node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeClass : GRGEN_LGSP.ListElement<Match_dumpNodeClass>, IMatch_dumpNodeClass
		{
			public GRGEN_MODEL.IClass node_n { get { return (GRGEN_MODEL.IClass)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeClass_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeClass_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeClass_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeClass_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeClass_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeClass_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeClass_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeClass_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeClass_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeClass.instance.pat_dumpNodeClass; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeInterface : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeInterface instance = null;
		public static Rule_dumpNodeInterface Instance { get { if (instance==null) { instance = new Rule_dumpNodeInterface(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeInterface_node_n_AllowedTypes = null;
		public static bool[] dumpNodeInterface_node_n_IsAllowedType = null;
		public enum dumpNodeInterface_NodeNums { @n, };
		public enum dumpNodeInterface_EdgeNums { };
		public enum dumpNodeInterface_VariableNums { @v, };
		public enum dumpNodeInterface_SubNums { };
		public enum dumpNodeInterface_AltNums { };
		public enum dumpNodeInterface_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeInterface;


		private Rule_dumpNodeInterface()
		{
			name = "dumpNodeInterface";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeInterface_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeInterface_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeInterface_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeInterface_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeInterface_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeInterface_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeInterface_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeInterface_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Interface, "GRGEN_MODEL.IInterface", "dumpNodeInterface_node_n", "n", dumpNodeInterface_node_n_AllowedTypes, dumpNodeInterface_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeInterface_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeInterface_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeInterface_var_v"))),
				new string[] { "dumpNodeInterface_node_n" }, new string[] {  }, new string[] { "dumpNodeInterface_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeInterface = new GRGEN_LGSP.PatternGraph(
				"dumpNodeInterface",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeInterface_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeInterface_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeInterface_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeInterface_isNodeHomomorphicGlobal,
				dumpNodeInterface_isEdgeHomomorphicGlobal,
				dumpNodeInterface_isNodeTotallyHomomorphic,
				dumpNodeInterface_isEdgeTotallyHomomorphic
			);

			dumpNodeInterface_node_n.pointOfDefinition = pat_dumpNodeInterface;

			patternGraph = pat_dumpNodeInterface;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeInterface curMatch = (Match_dumpNodeInterface)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_MODEL.IInterface inode_n = curMatch.node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeInterface_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeInterface_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			string tempvar_node_n_name = inode_n.@name;
			string tempvar_node_n_visibility = inode_n.@visibility;
			bool tempvar_node_n_isAbstract = inode_n.@isAbstract;
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Interface\"/>");
			graph.EmitWriter.Write("<attr name=\"name\"> <string>");
			graph.EmitWriter.Write(tempvar_node_n_name);
			graph.EmitWriter.Write("</string> </attr>");
			graph.EmitWriter.Write("<attr name=\"visibility\"> <string>");
			graph.EmitWriter.Write(tempvar_node_n_visibility);
			graph.EmitWriter.Write("</string> </attr>");
			graph.EmitWriter.Write("<attr name=\"isAbstract\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_isAbstract);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeInterface_addedNodeNames = new string[] {  };
		private static string[] dumpNodeInterface_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeInterface() {
		}

		public interface IMatch_dumpNodeInterface : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IInterface node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeInterface : GRGEN_LGSP.ListElement<Match_dumpNodeInterface>, IMatch_dumpNodeInterface
		{
			public GRGEN_MODEL.IInterface node_n { get { return (GRGEN_MODEL.IInterface)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeInterface_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeInterface_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeInterface_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeInterface_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeInterface_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeInterface_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeInterface_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeInterface_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeInterface_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeInterface.instance.pat_dumpNodeInterface; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeVariable : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeVariable instance = null;
		public static Rule_dumpNodeVariable Instance { get { if (instance==null) { instance = new Rule_dumpNodeVariable(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeVariable_node_n_AllowedTypes = null;
		public static bool[] dumpNodeVariable_node_n_IsAllowedType = null;
		public enum dumpNodeVariable_NodeNums { @n, };
		public enum dumpNodeVariable_EdgeNums { };
		public enum dumpNodeVariable_VariableNums { @v, };
		public enum dumpNodeVariable_SubNums { };
		public enum dumpNodeVariable_AltNums { };
		public enum dumpNodeVariable_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeVariable;


		private Rule_dumpNodeVariable()
		{
			name = "dumpNodeVariable";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeVariable_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeVariable_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeVariable_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeVariable_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeVariable_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeVariable_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeVariable_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeVariable_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "dumpNodeVariable_node_n", "n", dumpNodeVariable_node_n_AllowedTypes, dumpNodeVariable_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeVariable_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeVariable_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeVariable_var_v"))),
				new string[] { "dumpNodeVariable_node_n" }, new string[] {  }, new string[] { "dumpNodeVariable_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeVariable = new GRGEN_LGSP.PatternGraph(
				"dumpNodeVariable",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeVariable_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeVariable_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeVariable_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeVariable_isNodeHomomorphicGlobal,
				dumpNodeVariable_isEdgeHomomorphicGlobal,
				dumpNodeVariable_isNodeTotallyHomomorphic,
				dumpNodeVariable_isEdgeTotallyHomomorphic
			);

			dumpNodeVariable_node_n.pointOfDefinition = pat_dumpNodeVariable;

			patternGraph = pat_dumpNodeVariable;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeVariable curMatch = (Match_dumpNodeVariable)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_MODEL.IVariable inode_n = curMatch.node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeVariable_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeVariable_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			string tempvar_node_n_name = inode_n.@name;
			string tempvar_node_n_visibility = inode_n.@visibility;
			bool tempvar_node_n_isStatic = inode_n.@isStatic;
			bool tempvar_node_n_isFinal = inode_n.@isFinal;
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Variable\"/>");
			graph.EmitWriter.Write("<attr name=\"name\"> <string>");
			graph.EmitWriter.Write(tempvar_node_n_name);
			graph.EmitWriter.Write("</string> </attr>");
			graph.EmitWriter.Write("<attr name=\"visibility\"> <string>");
			graph.EmitWriter.Write(tempvar_node_n_visibility);
			graph.EmitWriter.Write("</string> </attr>");
			graph.EmitWriter.Write("<attr name=\"isStatic\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_isStatic);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("<attr name=\"isFinal\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_isFinal);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeVariable_addedNodeNames = new string[] {  };
		private static string[] dumpNodeVariable_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeVariable() {
		}

		public interface IMatch_dumpNodeVariable : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IVariable node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeVariable : GRGEN_LGSP.ListElement<Match_dumpNodeVariable>, IMatch_dumpNodeVariable
		{
			public GRGEN_MODEL.IVariable node_n { get { return (GRGEN_MODEL.IVariable)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeVariable_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeVariable_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeVariable_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeVariable_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeVariable_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeVariable_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeVariable_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeVariable_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeVariable_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeVariable.instance.pat_dumpNodeVariable; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeOperation : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeOperation instance = null;
		public static Rule_dumpNodeOperation Instance { get { if (instance==null) { instance = new Rule_dumpNodeOperation(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeOperation_node_n_AllowedTypes = null;
		public static bool[] dumpNodeOperation_node_n_IsAllowedType = null;
		public enum dumpNodeOperation_NodeNums { @n, };
		public enum dumpNodeOperation_EdgeNums { };
		public enum dumpNodeOperation_VariableNums { @v, };
		public enum dumpNodeOperation_SubNums { };
		public enum dumpNodeOperation_AltNums { };
		public enum dumpNodeOperation_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeOperation;


		private Rule_dumpNodeOperation()
		{
			name = "dumpNodeOperation";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeOperation_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeOperation_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeOperation_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeOperation_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeOperation_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeOperation_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeOperation_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeOperation_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "dumpNodeOperation_node_n", "n", dumpNodeOperation_node_n_AllowedTypes, dumpNodeOperation_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeOperation_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeOperation_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeOperation_var_v"))),
				new string[] { "dumpNodeOperation_node_n" }, new string[] {  }, new string[] { "dumpNodeOperation_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeOperation = new GRGEN_LGSP.PatternGraph(
				"dumpNodeOperation",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeOperation_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeOperation_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeOperation_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeOperation_isNodeHomomorphicGlobal,
				dumpNodeOperation_isEdgeHomomorphicGlobal,
				dumpNodeOperation_isNodeTotallyHomomorphic,
				dumpNodeOperation_isEdgeTotallyHomomorphic
			);

			dumpNodeOperation_node_n.pointOfDefinition = pat_dumpNodeOperation;

			patternGraph = pat_dumpNodeOperation;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeOperation curMatch = (Match_dumpNodeOperation)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_MODEL.IOperation inode_n = curMatch.node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeOperation_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeOperation_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			string tempvar_node_n_name = inode_n.@name;
			string tempvar_node_n_visibility = inode_n.@visibility;
			bool tempvar_node_n_isAbstract = inode_n.@isAbstract;
			bool tempvar_node_n_isStatic = inode_n.@isStatic;
			bool tempvar_node_n_isFinal = inode_n.@isFinal;
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Operation\"/>");
			graph.EmitWriter.Write("<attr name=\"name\"> <string>");
			graph.EmitWriter.Write(tempvar_node_n_name);
			graph.EmitWriter.Write("</string> </attr>");
			graph.EmitWriter.Write("<attr name=\"visibility\"> <string>");
			graph.EmitWriter.Write(tempvar_node_n_visibility);
			graph.EmitWriter.Write("</string> </attr>");
			graph.EmitWriter.Write("<attr name=\"isAbstract\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_isAbstract);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("<attr name=\"isStatic\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_isStatic);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("<attr name=\"isFinal\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_isFinal);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeOperation_addedNodeNames = new string[] {  };
		private static string[] dumpNodeOperation_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeOperation() {
		}

		public interface IMatch_dumpNodeOperation : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeOperation : GRGEN_LGSP.ListElement<Match_dumpNodeOperation>, IMatch_dumpNodeOperation
		{
			public GRGEN_MODEL.IOperation node_n { get { return (GRGEN_MODEL.IOperation)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeOperation_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeOperation_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeOperation_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeOperation_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeOperation_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeOperation_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeOperation_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeOperation_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeOperation_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeOperation.instance.pat_dumpNodeOperation; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeMethodBody : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeMethodBody instance = null;
		public static Rule_dumpNodeMethodBody Instance { get { if (instance==null) { instance = new Rule_dumpNodeMethodBody(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeMethodBody_node_n_AllowedTypes = null;
		public static bool[] dumpNodeMethodBody_node_n_IsAllowedType = null;
		public enum dumpNodeMethodBody_NodeNums { @n, };
		public enum dumpNodeMethodBody_EdgeNums { };
		public enum dumpNodeMethodBody_VariableNums { @v, };
		public enum dumpNodeMethodBody_SubNums { };
		public enum dumpNodeMethodBody_AltNums { };
		public enum dumpNodeMethodBody_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeMethodBody;


		private Rule_dumpNodeMethodBody()
		{
			name = "dumpNodeMethodBody";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeMethodBody_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeMethodBody_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeMethodBody_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeMethodBody_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeMethodBody_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeMethodBody_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeMethodBody_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeMethodBody_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "dumpNodeMethodBody_node_n", "n", dumpNodeMethodBody_node_n_AllowedTypes, dumpNodeMethodBody_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeMethodBody_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeMethodBody_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeMethodBody_var_v"))),
				new string[] { "dumpNodeMethodBody_node_n" }, new string[] {  }, new string[] { "dumpNodeMethodBody_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeMethodBody = new GRGEN_LGSP.PatternGraph(
				"dumpNodeMethodBody",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeMethodBody_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeMethodBody_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeMethodBody_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeMethodBody_isNodeHomomorphicGlobal,
				dumpNodeMethodBody_isEdgeHomomorphicGlobal,
				dumpNodeMethodBody_isNodeTotallyHomomorphic,
				dumpNodeMethodBody_isEdgeTotallyHomomorphic
			);

			dumpNodeMethodBody_node_n.pointOfDefinition = pat_dumpNodeMethodBody;

			patternGraph = pat_dumpNodeMethodBody;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeMethodBody curMatch = (Match_dumpNodeMethodBody)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeMethodBody_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeMethodBody_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"MethodBody\"/>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeMethodBody_addedNodeNames = new string[] {  };
		private static string[] dumpNodeMethodBody_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeMethodBody() {
		}

		public interface IMatch_dumpNodeMethodBody : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IMethodBody node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeMethodBody : GRGEN_LGSP.ListElement<Match_dumpNodeMethodBody>, IMatch_dumpNodeMethodBody
		{
			public GRGEN_MODEL.IMethodBody node_n { get { return (GRGEN_MODEL.IMethodBody)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeMethodBody_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeMethodBody_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeMethodBody_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeMethodBody_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeMethodBody_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeMethodBody_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeMethodBody_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeMethodBody_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeMethodBody_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeMethodBody.instance.pat_dumpNodeMethodBody; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeAccess : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeAccess instance = null;
		public static Rule_dumpNodeAccess Instance { get { if (instance==null) { instance = new Rule_dumpNodeAccess(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeAccess_node_n_AllowedTypes = null;
		public static bool[] dumpNodeAccess_node_n_IsAllowedType = null;
		public enum dumpNodeAccess_NodeNums { @n, };
		public enum dumpNodeAccess_EdgeNums { };
		public enum dumpNodeAccess_VariableNums { @v, };
		public enum dumpNodeAccess_SubNums { };
		public enum dumpNodeAccess_AltNums { };
		public enum dumpNodeAccess_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeAccess;


		private Rule_dumpNodeAccess()
		{
			name = "dumpNodeAccess";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeAccess_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeAccess_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeAccess_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeAccess_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeAccess_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeAccess_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeAccess_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeAccess_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Access, "GRGEN_MODEL.IAccess", "dumpNodeAccess_node_n", "n", dumpNodeAccess_node_n_AllowedTypes, dumpNodeAccess_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeAccess_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeAccess_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeAccess_var_v"))),
				new string[] { "dumpNodeAccess_node_n" }, new string[] {  }, new string[] { "dumpNodeAccess_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeAccess = new GRGEN_LGSP.PatternGraph(
				"dumpNodeAccess",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeAccess_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeAccess_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeAccess_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeAccess_isNodeHomomorphicGlobal,
				dumpNodeAccess_isEdgeHomomorphicGlobal,
				dumpNodeAccess_isNodeTotallyHomomorphic,
				dumpNodeAccess_isEdgeTotallyHomomorphic
			);

			dumpNodeAccess_node_n.pointOfDefinition = pat_dumpNodeAccess;

			patternGraph = pat_dumpNodeAccess;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeAccess curMatch = (Match_dumpNodeAccess)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_MODEL.IAccess inode_n = curMatch.node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeAccess_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeAccess_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			bool tempvar_node_n_this = inode_n.@this;
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Access\"/>");
			graph.EmitWriter.Write("<attr name=\"this\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_this);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeAccess_addedNodeNames = new string[] {  };
		private static string[] dumpNodeAccess_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeAccess() {
		}

		public interface IMatch_dumpNodeAccess : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeAccess : GRGEN_LGSP.ListElement<Match_dumpNodeAccess>, IMatch_dumpNodeAccess
		{
			public GRGEN_MODEL.IAccess node_n { get { return (GRGEN_MODEL.IAccess)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeAccess_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeAccess_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeAccess_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeAccess_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeAccess_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeAccess_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeAccess_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeAccess_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeAccess_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeAccess.instance.pat_dumpNodeAccess; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeUpdate : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeUpdate instance = null;
		public static Rule_dumpNodeUpdate Instance { get { if (instance==null) { instance = new Rule_dumpNodeUpdate(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeUpdate_node_n_AllowedTypes = null;
		public static bool[] dumpNodeUpdate_node_n_IsAllowedType = null;
		public enum dumpNodeUpdate_NodeNums { @n, };
		public enum dumpNodeUpdate_EdgeNums { };
		public enum dumpNodeUpdate_VariableNums { @v, };
		public enum dumpNodeUpdate_SubNums { };
		public enum dumpNodeUpdate_AltNums { };
		public enum dumpNodeUpdate_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeUpdate;


		private Rule_dumpNodeUpdate()
		{
			name = "dumpNodeUpdate";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeUpdate_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeUpdate_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeUpdate_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeUpdate_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeUpdate_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeUpdate_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeUpdate_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeUpdate_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Update, "GRGEN_MODEL.IUpdate", "dumpNodeUpdate_node_n", "n", dumpNodeUpdate_node_n_AllowedTypes, dumpNodeUpdate_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeUpdate_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeUpdate_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeUpdate_var_v"))),
				new string[] { "dumpNodeUpdate_node_n" }, new string[] {  }, new string[] { "dumpNodeUpdate_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeUpdate = new GRGEN_LGSP.PatternGraph(
				"dumpNodeUpdate",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeUpdate_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeUpdate_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeUpdate_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeUpdate_isNodeHomomorphicGlobal,
				dumpNodeUpdate_isEdgeHomomorphicGlobal,
				dumpNodeUpdate_isNodeTotallyHomomorphic,
				dumpNodeUpdate_isEdgeTotallyHomomorphic
			);

			dumpNodeUpdate_node_n.pointOfDefinition = pat_dumpNodeUpdate;

			patternGraph = pat_dumpNodeUpdate;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeUpdate curMatch = (Match_dumpNodeUpdate)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_MODEL.IUpdate inode_n = curMatch.node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeUpdate_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeUpdate_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			bool tempvar_node_n_this = inode_n.@this;
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Update\"/>");
			graph.EmitWriter.Write("<attr name=\"this\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_this);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeUpdate_addedNodeNames = new string[] {  };
		private static string[] dumpNodeUpdate_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeUpdate() {
		}

		public interface IMatch_dumpNodeUpdate : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IUpdate node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeUpdate : GRGEN_LGSP.ListElement<Match_dumpNodeUpdate>, IMatch_dumpNodeUpdate
		{
			public GRGEN_MODEL.IUpdate node_n { get { return (GRGEN_MODEL.IUpdate)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeUpdate_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeUpdate_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeUpdate_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeUpdate_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeUpdate_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeUpdate_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeUpdate_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeUpdate_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeUpdate_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeUpdate.instance.pat_dumpNodeUpdate; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeCall : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeCall instance = null;
		public static Rule_dumpNodeCall Instance { get { if (instance==null) { instance = new Rule_dumpNodeCall(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeCall_node_n_AllowedTypes = null;
		public static bool[] dumpNodeCall_node_n_IsAllowedType = null;
		public enum dumpNodeCall_NodeNums { @n, };
		public enum dumpNodeCall_EdgeNums { };
		public enum dumpNodeCall_VariableNums { @v, };
		public enum dumpNodeCall_SubNums { };
		public enum dumpNodeCall_AltNums { };
		public enum dumpNodeCall_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeCall;


		private Rule_dumpNodeCall()
		{
			name = "dumpNodeCall";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeCall_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeCall_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeCall_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeCall_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeCall_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeCall_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeCall_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeCall_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "dumpNodeCall_node_n", "n", dumpNodeCall_node_n_AllowedTypes, dumpNodeCall_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeCall_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeCall_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeCall_var_v"))),
				new string[] { "dumpNodeCall_node_n" }, new string[] {  }, new string[] { "dumpNodeCall_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeCall = new GRGEN_LGSP.PatternGraph(
				"dumpNodeCall",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeCall_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeCall_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeCall_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeCall_isNodeHomomorphicGlobal,
				dumpNodeCall_isEdgeHomomorphicGlobal,
				dumpNodeCall_isNodeTotallyHomomorphic,
				dumpNodeCall_isEdgeTotallyHomomorphic
			);

			dumpNodeCall_node_n.pointOfDefinition = pat_dumpNodeCall;

			patternGraph = pat_dumpNodeCall;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeCall curMatch = (Match_dumpNodeCall)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_MODEL.ICall inode_n = curMatch.node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeCall_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeCall_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			bool tempvar_node_n_this = inode_n.@this;
			bool tempvar_node_n_super = inode_n.@super;
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Call\"/>");
			graph.EmitWriter.Write("<attr name=\"this\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_this);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("<attr name=\"super\"> <bool>");
			graph.EmitWriter.Write(tempvar_node_n_super);
			graph.EmitWriter.Write("</bool> </attr>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeCall_addedNodeNames = new string[] {  };
		private static string[] dumpNodeCall_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeCall() {
		}

		public interface IMatch_dumpNodeCall : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.ICall node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeCall : GRGEN_LGSP.ListElement<Match_dumpNodeCall>, IMatch_dumpNodeCall
		{
			public GRGEN_MODEL.ICall node_n { get { return (GRGEN_MODEL.ICall)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeCall_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeCall_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeCall_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeCall_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeCall_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeCall_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeCall_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeCall_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeCall_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeCall.instance.pat_dumpNodeCall; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeIstantiation : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeIstantiation instance = null;
		public static Rule_dumpNodeIstantiation Instance { get { if (instance==null) { instance = new Rule_dumpNodeIstantiation(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeIstantiation_node_n_AllowedTypes = null;
		public static bool[] dumpNodeIstantiation_node_n_IsAllowedType = null;
		public enum dumpNodeIstantiation_NodeNums { @n, };
		public enum dumpNodeIstantiation_EdgeNums { };
		public enum dumpNodeIstantiation_VariableNums { @v, };
		public enum dumpNodeIstantiation_SubNums { };
		public enum dumpNodeIstantiation_AltNums { };
		public enum dumpNodeIstantiation_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeIstantiation;


		private Rule_dumpNodeIstantiation()
		{
			name = "dumpNodeIstantiation";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeIstantiation_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeIstantiation_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeIstantiation_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeIstantiation_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeIstantiation_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeIstantiation_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeIstantiation_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeIstantiation_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Instantiation, "GRGEN_MODEL.IInstantiation", "dumpNodeIstantiation_node_n", "n", dumpNodeIstantiation_node_n_AllowedTypes, dumpNodeIstantiation_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeIstantiation_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeIstantiation_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeIstantiation_var_v"))),
				new string[] { "dumpNodeIstantiation_node_n" }, new string[] {  }, new string[] { "dumpNodeIstantiation_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeIstantiation = new GRGEN_LGSP.PatternGraph(
				"dumpNodeIstantiation",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeIstantiation_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeIstantiation_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeIstantiation_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeIstantiation_isNodeHomomorphicGlobal,
				dumpNodeIstantiation_isEdgeHomomorphicGlobal,
				dumpNodeIstantiation_isNodeTotallyHomomorphic,
				dumpNodeIstantiation_isEdgeTotallyHomomorphic
			);

			dumpNodeIstantiation_node_n.pointOfDefinition = pat_dumpNodeIstantiation;

			patternGraph = pat_dumpNodeIstantiation;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeIstantiation curMatch = (Match_dumpNodeIstantiation)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeIstantiation_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeIstantiation_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Instantiation\"/>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeIstantiation_addedNodeNames = new string[] {  };
		private static string[] dumpNodeIstantiation_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeIstantiation() {
		}

		public interface IMatch_dumpNodeIstantiation : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IInstantiation node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeIstantiation : GRGEN_LGSP.ListElement<Match_dumpNodeIstantiation>, IMatch_dumpNodeIstantiation
		{
			public GRGEN_MODEL.IInstantiation node_n { get { return (GRGEN_MODEL.IInstantiation)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeIstantiation_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeIstantiation_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeIstantiation_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeIstantiation_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeIstantiation_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeIstantiation_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeIstantiation_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeIstantiation_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeIstantiation_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeIstantiation.instance.pat_dumpNodeIstantiation; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeOperator : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeOperator instance = null;
		public static Rule_dumpNodeOperator Instance { get { if (instance==null) { instance = new Rule_dumpNodeOperator(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeOperator_node_n_AllowedTypes = null;
		public static bool[] dumpNodeOperator_node_n_IsAllowedType = null;
		public enum dumpNodeOperator_NodeNums { @n, };
		public enum dumpNodeOperator_EdgeNums { };
		public enum dumpNodeOperator_VariableNums { @v, };
		public enum dumpNodeOperator_SubNums { };
		public enum dumpNodeOperator_AltNums { };
		public enum dumpNodeOperator_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeOperator;


		private Rule_dumpNodeOperator()
		{
			name = "dumpNodeOperator";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeOperator_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeOperator_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeOperator_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeOperator_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeOperator_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeOperator_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeOperator_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeOperator_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operator, "GRGEN_MODEL.IOperator", "dumpNodeOperator_node_n", "n", dumpNodeOperator_node_n_AllowedTypes, dumpNodeOperator_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeOperator_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeOperator_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeOperator_var_v"))),
				new string[] { "dumpNodeOperator_node_n" }, new string[] {  }, new string[] { "dumpNodeOperator_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeOperator = new GRGEN_LGSP.PatternGraph(
				"dumpNodeOperator",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeOperator_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeOperator_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeOperator_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeOperator_isNodeHomomorphicGlobal,
				dumpNodeOperator_isEdgeHomomorphicGlobal,
				dumpNodeOperator_isNodeTotallyHomomorphic,
				dumpNodeOperator_isEdgeTotallyHomomorphic
			);

			dumpNodeOperator_node_n.pointOfDefinition = pat_dumpNodeOperator;

			patternGraph = pat_dumpNodeOperator;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeOperator curMatch = (Match_dumpNodeOperator)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_MODEL.IOperator inode_n = curMatch.node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeOperator_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeOperator_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			string tempvar_node_n_name = inode_n.@name;
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Operator\"/>");
			graph.EmitWriter.Write("<attr name=\"name\"> <string>");
			graph.EmitWriter.Write(tempvar_node_n_name);
			graph.EmitWriter.Write("</string> </attr>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeOperator_addedNodeNames = new string[] {  };
		private static string[] dumpNodeOperator_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeOperator() {
		}

		public interface IMatch_dumpNodeOperator : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperator node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeOperator : GRGEN_LGSP.ListElement<Match_dumpNodeOperator>, IMatch_dumpNodeOperator
		{
			public GRGEN_MODEL.IOperator node_n { get { return (GRGEN_MODEL.IOperator)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeOperator_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeOperator_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeOperator_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeOperator_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeOperator_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeOperator_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeOperator_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeOperator_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeOperator_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeOperator.instance.pat_dumpNodeOperator; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeReturn : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeReturn instance = null;
		public static Rule_dumpNodeReturn Instance { get { if (instance==null) { instance = new Rule_dumpNodeReturn(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeReturn_node_n_AllowedTypes = null;
		public static bool[] dumpNodeReturn_node_n_IsAllowedType = null;
		public enum dumpNodeReturn_NodeNums { @n, };
		public enum dumpNodeReturn_EdgeNums { };
		public enum dumpNodeReturn_VariableNums { @v, };
		public enum dumpNodeReturn_SubNums { };
		public enum dumpNodeReturn_AltNums { };
		public enum dumpNodeReturn_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeReturn;


		private Rule_dumpNodeReturn()
		{
			name = "dumpNodeReturn";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeReturn_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeReturn_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeReturn_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeReturn_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeReturn_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeReturn_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeReturn_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeReturn_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Return, "GRGEN_MODEL.IReturn", "dumpNodeReturn_node_n", "n", dumpNodeReturn_node_n_AllowedTypes, dumpNodeReturn_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeReturn_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeReturn_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeReturn_var_v"))),
				new string[] { "dumpNodeReturn_node_n" }, new string[] {  }, new string[] { "dumpNodeReturn_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeReturn = new GRGEN_LGSP.PatternGraph(
				"dumpNodeReturn",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeReturn_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeReturn_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeReturn_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeReturn_isNodeHomomorphicGlobal,
				dumpNodeReturn_isEdgeHomomorphicGlobal,
				dumpNodeReturn_isNodeTotallyHomomorphic,
				dumpNodeReturn_isEdgeTotallyHomomorphic
			);

			dumpNodeReturn_node_n.pointOfDefinition = pat_dumpNodeReturn;

			patternGraph = pat_dumpNodeReturn;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeReturn curMatch = (Match_dumpNodeReturn)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeReturn_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeReturn_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Return\"/>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeReturn_addedNodeNames = new string[] {  };
		private static string[] dumpNodeReturn_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeReturn() {
		}

		public interface IMatch_dumpNodeReturn : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IReturn node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeReturn : GRGEN_LGSP.ListElement<Match_dumpNodeReturn>, IMatch_dumpNodeReturn
		{
			public GRGEN_MODEL.IReturn node_n { get { return (GRGEN_MODEL.IReturn)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeReturn_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeReturn_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeReturn_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeReturn_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeReturn_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeReturn_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeReturn_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeReturn_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeReturn_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeReturn.instance.pat_dumpNodeReturn; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeBlock : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeBlock instance = null;
		public static Rule_dumpNodeBlock Instance { get { if (instance==null) { instance = new Rule_dumpNodeBlock(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeBlock_node_n_AllowedTypes = null;
		public static bool[] dumpNodeBlock_node_n_IsAllowedType = null;
		public enum dumpNodeBlock_NodeNums { @n, };
		public enum dumpNodeBlock_EdgeNums { };
		public enum dumpNodeBlock_VariableNums { @v, };
		public enum dumpNodeBlock_SubNums { };
		public enum dumpNodeBlock_AltNums { };
		public enum dumpNodeBlock_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeBlock;


		private Rule_dumpNodeBlock()
		{
			name = "dumpNodeBlock";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeBlock_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeBlock_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeBlock_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeBlock_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeBlock_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeBlock_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeBlock_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeBlock_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Block, "GRGEN_MODEL.IBlock", "dumpNodeBlock_node_n", "n", dumpNodeBlock_node_n_AllowedTypes, dumpNodeBlock_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeBlock_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeBlock_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeBlock_var_v"))),
				new string[] { "dumpNodeBlock_node_n" }, new string[] {  }, new string[] { "dumpNodeBlock_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeBlock = new GRGEN_LGSP.PatternGraph(
				"dumpNodeBlock",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeBlock_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeBlock_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeBlock_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeBlock_isNodeHomomorphicGlobal,
				dumpNodeBlock_isEdgeHomomorphicGlobal,
				dumpNodeBlock_isNodeTotallyHomomorphic,
				dumpNodeBlock_isEdgeTotallyHomomorphic
			);

			dumpNodeBlock_node_n.pointOfDefinition = pat_dumpNodeBlock;

			patternGraph = pat_dumpNodeBlock;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeBlock curMatch = (Match_dumpNodeBlock)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeBlock_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeBlock_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Block\"/>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeBlock_addedNodeNames = new string[] {  };
		private static string[] dumpNodeBlock_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeBlock() {
		}

		public interface IMatch_dumpNodeBlock : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IBlock node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeBlock : GRGEN_LGSP.ListElement<Match_dumpNodeBlock>, IMatch_dumpNodeBlock
		{
			public GRGEN_MODEL.IBlock node_n { get { return (GRGEN_MODEL.IBlock)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeBlock_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeBlock_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeBlock_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeBlock_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeBlock_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeBlock_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeBlock_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeBlock_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeBlock_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeBlock.instance.pat_dumpNodeBlock; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeLiteral : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeLiteral instance = null;
		public static Rule_dumpNodeLiteral Instance { get { if (instance==null) { instance = new Rule_dumpNodeLiteral(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeLiteral_node_n_AllowedTypes = null;
		public static bool[] dumpNodeLiteral_node_n_IsAllowedType = null;
		public enum dumpNodeLiteral_NodeNums { @n, };
		public enum dumpNodeLiteral_EdgeNums { };
		public enum dumpNodeLiteral_VariableNums { @v, };
		public enum dumpNodeLiteral_SubNums { };
		public enum dumpNodeLiteral_AltNums { };
		public enum dumpNodeLiteral_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeLiteral;


		private Rule_dumpNodeLiteral()
		{
			name = "dumpNodeLiteral";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeLiteral_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeLiteral_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeLiteral_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeLiteral_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeLiteral_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeLiteral_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeLiteral_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeLiteral_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Literal, "GRGEN_MODEL.ILiteral", "dumpNodeLiteral_node_n", "n", dumpNodeLiteral_node_n_AllowedTypes, dumpNodeLiteral_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeLiteral_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeLiteral_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeLiteral_var_v"))),
				new string[] { "dumpNodeLiteral_node_n" }, new string[] {  }, new string[] { "dumpNodeLiteral_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeLiteral = new GRGEN_LGSP.PatternGraph(
				"dumpNodeLiteral",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeLiteral_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeLiteral_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeLiteral_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeLiteral_isNodeHomomorphicGlobal,
				dumpNodeLiteral_isEdgeHomomorphicGlobal,
				dumpNodeLiteral_isNodeTotallyHomomorphic,
				dumpNodeLiteral_isEdgeTotallyHomomorphic
			);

			dumpNodeLiteral_node_n.pointOfDefinition = pat_dumpNodeLiteral;

			patternGraph = pat_dumpNodeLiteral;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeLiteral curMatch = (Match_dumpNodeLiteral)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_MODEL.ILiteral inode_n = curMatch.node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeLiteral_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeLiteral_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			string tempvar_node_n_value = inode_n.@value;
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Literal\"/>");
			graph.EmitWriter.Write("<attr name=\"value\"> <string>");
			graph.EmitWriter.Write(tempvar_node_n_value);
			graph.EmitWriter.Write("</string> </attr>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeLiteral_addedNodeNames = new string[] {  };
		private static string[] dumpNodeLiteral_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeLiteral() {
		}

		public interface IMatch_dumpNodeLiteral : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.ILiteral node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeLiteral : GRGEN_LGSP.ListElement<Match_dumpNodeLiteral>, IMatch_dumpNodeLiteral
		{
			public GRGEN_MODEL.ILiteral node_n { get { return (GRGEN_MODEL.ILiteral)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeLiteral_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeLiteral_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeLiteral_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeLiteral_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeLiteral_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeLiteral_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeLiteral_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeLiteral_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeLiteral_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeLiteral.instance.pat_dumpNodeLiteral; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpNodeParameter : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpNodeParameter instance = null;
		public static Rule_dumpNodeParameter Instance { get { if (instance==null) { instance = new Rule_dumpNodeParameter(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpNodeParameter_node_n_AllowedTypes = null;
		public static bool[] dumpNodeParameter_node_n_IsAllowedType = null;
		public enum dumpNodeParameter_NodeNums { @n, };
		public enum dumpNodeParameter_EdgeNums { };
		public enum dumpNodeParameter_VariableNums { @v, };
		public enum dumpNodeParameter_SubNums { };
		public enum dumpNodeParameter_AltNums { };
		public enum dumpNodeParameter_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpNodeParameter;


		private Rule_dumpNodeParameter()
		{
			name = "dumpNodeParameter";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpNodeParameter_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpNodeParameter_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] dumpNodeParameter_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] dumpNodeParameter_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] dumpNodeParameter_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable dumpNodeParameter_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpNodeParameter_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpNodeParameter_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Parameter, "GRGEN_MODEL.IParameter", "dumpNodeParameter_node_n", "n", dumpNodeParameter_node_n_AllowedTypes, dumpNodeParameter_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpNodeParameter_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpNodeParameter_node_n", new GRGEN_EXPR.VariableExpression("dumpNodeParameter_var_v"))),
				new string[] { "dumpNodeParameter_node_n" }, new string[] {  }, new string[] { "dumpNodeParameter_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpNodeParameter = new GRGEN_LGSP.PatternGraph(
				"dumpNodeParameter",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpNodeParameter_node_n }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { dumpNodeParameter_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpNodeParameter_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				dumpNodeParameter_isNodeHomomorphicGlobal,
				dumpNodeParameter_isEdgeHomomorphicGlobal,
				dumpNodeParameter_isNodeTotallyHomomorphic,
				dumpNodeParameter_isEdgeTotallyHomomorphic
			);

			dumpNodeParameter_node_n.pointOfDefinition = pat_dumpNodeParameter;

			patternGraph = pat_dumpNodeParameter;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpNodeParameter curMatch = (Match_dumpNodeParameter)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpNodeParameter_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpNodeParameter_addedEdgeNames );
			graph.SetVisited(node_n, var_v, true);
			graph.EmitWriter.Write("<node id=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_n));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"Parameter\"/>");
			graph.EmitWriter.Write("</node>");
			return;
		}
		private static string[] dumpNodeParameter_addedNodeNames = new string[] {  };
		private static string[] dumpNodeParameter_addedEdgeNames = new string[] {  };

		static Rule_dumpNodeParameter() {
		}

		public interface IMatch_dumpNodeParameter : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IParameter node_n { get; }
			//Edges
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpNodeParameter : GRGEN_LGSP.ListElement<Match_dumpNodeParameter>, IMatch_dumpNodeParameter
		{
			public GRGEN_MODEL.IParameter node_n { get { return (GRGEN_MODEL.IParameter)_node_n; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum dumpNodeParameter_NodeNums { @n, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpNodeParameter_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			
			public enum dumpNodeParameter_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpNodeParameter_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpNodeParameter_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpNodeParameter_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeParameter_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeParameter_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpNodeParameter_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpNodeParameter.instance.pat_dumpNodeParameter; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpEdgeBelongsTo : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpEdgeBelongsTo instance = null;
		public static Rule_dumpEdgeBelongsTo Instance { get { if (instance==null) { instance = new Rule_dumpEdgeBelongsTo(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpEdgeBelongsTo_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] dumpEdgeBelongsTo_node_tgt_AllowedTypes = null;
		public static bool[] dumpEdgeBelongsTo_node_src_IsAllowedType = null;
		public static bool[] dumpEdgeBelongsTo_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] dumpEdgeBelongsTo_edge_e_AllowedTypes = null;
		public static bool[] dumpEdgeBelongsTo_edge_e_IsAllowedType = null;
		public enum dumpEdgeBelongsTo_NodeNums { @src, @tgt, };
		public enum dumpEdgeBelongsTo_EdgeNums { @e, };
		public enum dumpEdgeBelongsTo_VariableNums { @v, };
		public enum dumpEdgeBelongsTo_SubNums { };
		public enum dumpEdgeBelongsTo_AltNums { };
		public enum dumpEdgeBelongsTo_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpEdgeBelongsTo;


		private Rule_dumpEdgeBelongsTo()
		{
			name = "dumpEdgeBelongsTo";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpEdgeBelongsTo_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpEdgeBelongsTo_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] dumpEdgeBelongsTo_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] dumpEdgeBelongsTo_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] dumpEdgeBelongsTo_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable dumpEdgeBelongsTo_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpEdgeBelongsTo_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpEdgeBelongsTo_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeBelongsTo_node_src", "src", dumpEdgeBelongsTo_node_src_AllowedTypes, dumpEdgeBelongsTo_node_src_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode dumpEdgeBelongsTo_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeBelongsTo_node_tgt", "tgt", dumpEdgeBelongsTo_node_tgt_AllowedTypes, dumpEdgeBelongsTo_node_tgt_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge dumpEdgeBelongsTo_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "dumpEdgeBelongsTo_edge_e", "e", dumpEdgeBelongsTo_edge_e_AllowedTypes, dumpEdgeBelongsTo_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpEdgeBelongsTo_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpEdgeBelongsTo_edge_e", new GRGEN_EXPR.VariableExpression("dumpEdgeBelongsTo_var_v"))),
				new string[] {  }, new string[] { "dumpEdgeBelongsTo_edge_e" }, new string[] { "dumpEdgeBelongsTo_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpEdgeBelongsTo = new GRGEN_LGSP.PatternGraph(
				"dumpEdgeBelongsTo",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpEdgeBelongsTo_node_src, dumpEdgeBelongsTo_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { dumpEdgeBelongsTo_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { dumpEdgeBelongsTo_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpEdgeBelongsTo_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				dumpEdgeBelongsTo_isNodeHomomorphicGlobal,
				dumpEdgeBelongsTo_isEdgeHomomorphicGlobal,
				dumpEdgeBelongsTo_isNodeTotallyHomomorphic,
				dumpEdgeBelongsTo_isEdgeTotallyHomomorphic
			);
			pat_dumpEdgeBelongsTo.edgeToSourceNode.Add(dumpEdgeBelongsTo_edge_e, dumpEdgeBelongsTo_node_src);
			pat_dumpEdgeBelongsTo.edgeToTargetNode.Add(dumpEdgeBelongsTo_edge_e, dumpEdgeBelongsTo_node_tgt);

			dumpEdgeBelongsTo_node_src.pointOfDefinition = pat_dumpEdgeBelongsTo;
			dumpEdgeBelongsTo_node_tgt.pointOfDefinition = pat_dumpEdgeBelongsTo;
			dumpEdgeBelongsTo_edge_e.pointOfDefinition = pat_dumpEdgeBelongsTo;

			patternGraph = pat_dumpEdgeBelongsTo;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpEdgeBelongsTo curMatch = (Match_dumpEdgeBelongsTo)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpEdgeBelongsTo_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpEdgeBelongsTo_addedEdgeNames );
			graph.SetVisited(edge_e, var_v, true);
			graph.EmitWriter.Write("<edge id=\"");
			graph.EmitWriter.Write(graph.GetElementName(edge_e));
			graph.EmitWriter.Write("\" from=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_src));
			graph.EmitWriter.Write("\" to=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_tgt));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"belongsTo\"/>");
			graph.EmitWriter.Write("</edge>");
			return;
		}
		private static string[] dumpEdgeBelongsTo_addedNodeNames = new string[] {  };
		private static string[] dumpEdgeBelongsTo_addedEdgeNames = new string[] {  };

		static Rule_dumpEdgeBelongsTo() {
		}

		public interface IMatch_dumpEdgeBelongsTo : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_LIBGR.INode node_src { get; }
			GRGEN_LIBGR.INode node_tgt { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge_e { get; }
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpEdgeBelongsTo : GRGEN_LGSP.ListElement<Match_dumpEdgeBelongsTo>, IMatch_dumpEdgeBelongsTo
		{
			public GRGEN_LIBGR.INode node_src { get { return (GRGEN_LIBGR.INode)_node_src; } }
			public GRGEN_LIBGR.INode node_tgt { get { return (GRGEN_LIBGR.INode)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum dumpEdgeBelongsTo_NodeNums { @src, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeBelongsTo_NodeNums.@src: return _node_src;
				case (int)dumpEdgeBelongsTo_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge_e { get { return (GRGEN_MODEL.IbelongsTo)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum dumpEdgeBelongsTo_EdgeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeBelongsTo_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpEdgeBelongsTo_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeBelongsTo_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpEdgeBelongsTo_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeBelongsTo_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeBelongsTo_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeBelongsTo_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpEdgeBelongsTo.instance.pat_dumpEdgeBelongsTo; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpEdgeType : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpEdgeType instance = null;
		public static Rule_dumpEdgeType Instance { get { if (instance==null) { instance = new Rule_dumpEdgeType(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpEdgeType_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] dumpEdgeType_node_tgt_AllowedTypes = null;
		public static bool[] dumpEdgeType_node_src_IsAllowedType = null;
		public static bool[] dumpEdgeType_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] dumpEdgeType_edge_e_AllowedTypes = null;
		public static bool[] dumpEdgeType_edge_e_IsAllowedType = null;
		public enum dumpEdgeType_NodeNums { @src, @tgt, };
		public enum dumpEdgeType_EdgeNums { @e, };
		public enum dumpEdgeType_VariableNums { @v, };
		public enum dumpEdgeType_SubNums { };
		public enum dumpEdgeType_AltNums { };
		public enum dumpEdgeType_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpEdgeType;


		private Rule_dumpEdgeType()
		{
			name = "dumpEdgeType";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpEdgeType_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpEdgeType_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] dumpEdgeType_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] dumpEdgeType_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] dumpEdgeType_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable dumpEdgeType_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpEdgeType_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpEdgeType_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeType_node_src", "src", dumpEdgeType_node_src_AllowedTypes, dumpEdgeType_node_src_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode dumpEdgeType_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeType_node_tgt", "tgt", dumpEdgeType_node_tgt_AllowedTypes, dumpEdgeType_node_tgt_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge dumpEdgeType_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@type_, "GRGEN_MODEL.Itype_", "dumpEdgeType_edge_e", "e", dumpEdgeType_edge_e_AllowedTypes, dumpEdgeType_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpEdgeType_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpEdgeType_edge_e", new GRGEN_EXPR.VariableExpression("dumpEdgeType_var_v"))),
				new string[] {  }, new string[] { "dumpEdgeType_edge_e" }, new string[] { "dumpEdgeType_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpEdgeType = new GRGEN_LGSP.PatternGraph(
				"dumpEdgeType",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpEdgeType_node_src, dumpEdgeType_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { dumpEdgeType_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { dumpEdgeType_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpEdgeType_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				dumpEdgeType_isNodeHomomorphicGlobal,
				dumpEdgeType_isEdgeHomomorphicGlobal,
				dumpEdgeType_isNodeTotallyHomomorphic,
				dumpEdgeType_isEdgeTotallyHomomorphic
			);
			pat_dumpEdgeType.edgeToSourceNode.Add(dumpEdgeType_edge_e, dumpEdgeType_node_src);
			pat_dumpEdgeType.edgeToTargetNode.Add(dumpEdgeType_edge_e, dumpEdgeType_node_tgt);

			dumpEdgeType_node_src.pointOfDefinition = pat_dumpEdgeType;
			dumpEdgeType_node_tgt.pointOfDefinition = pat_dumpEdgeType;
			dumpEdgeType_edge_e.pointOfDefinition = pat_dumpEdgeType;

			patternGraph = pat_dumpEdgeType;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpEdgeType curMatch = (Match_dumpEdgeType)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpEdgeType_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpEdgeType_addedEdgeNames );
			graph.SetVisited(edge_e, var_v, true);
			graph.EmitWriter.Write("<edge id=\"");
			graph.EmitWriter.Write(graph.GetElementName(edge_e));
			graph.EmitWriter.Write("\" from=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_src));
			graph.EmitWriter.Write("\" to=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_tgt));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"type\"/>");
			graph.EmitWriter.Write("</edge>");
			return;
		}
		private static string[] dumpEdgeType_addedNodeNames = new string[] {  };
		private static string[] dumpEdgeType_addedEdgeNames = new string[] {  };

		static Rule_dumpEdgeType() {
		}

		public interface IMatch_dumpEdgeType : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_LIBGR.INode node_src { get; }
			GRGEN_LIBGR.INode node_tgt { get; }
			//Edges
			GRGEN_MODEL.Itype_ edge_e { get; }
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpEdgeType : GRGEN_LGSP.ListElement<Match_dumpEdgeType>, IMatch_dumpEdgeType
		{
			public GRGEN_LIBGR.INode node_src { get { return (GRGEN_LIBGR.INode)_node_src; } }
			public GRGEN_LIBGR.INode node_tgt { get { return (GRGEN_LIBGR.INode)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum dumpEdgeType_NodeNums { @src, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeType_NodeNums.@src: return _node_src;
				case (int)dumpEdgeType_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Itype_ edge_e { get { return (GRGEN_MODEL.Itype_)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum dumpEdgeType_EdgeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeType_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpEdgeType_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeType_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpEdgeType_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeType_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeType_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeType_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpEdgeType.instance.pat_dumpEdgeType; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpEdgeExtends : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpEdgeExtends instance = null;
		public static Rule_dumpEdgeExtends Instance { get { if (instance==null) { instance = new Rule_dumpEdgeExtends(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpEdgeExtends_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] dumpEdgeExtends_node_tgt_AllowedTypes = null;
		public static bool[] dumpEdgeExtends_node_src_IsAllowedType = null;
		public static bool[] dumpEdgeExtends_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] dumpEdgeExtends_edge_e_AllowedTypes = null;
		public static bool[] dumpEdgeExtends_edge_e_IsAllowedType = null;
		public enum dumpEdgeExtends_NodeNums { @src, @tgt, };
		public enum dumpEdgeExtends_EdgeNums { @e, };
		public enum dumpEdgeExtends_VariableNums { @v, };
		public enum dumpEdgeExtends_SubNums { };
		public enum dumpEdgeExtends_AltNums { };
		public enum dumpEdgeExtends_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpEdgeExtends;


		private Rule_dumpEdgeExtends()
		{
			name = "dumpEdgeExtends";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpEdgeExtends_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpEdgeExtends_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] dumpEdgeExtends_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] dumpEdgeExtends_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] dumpEdgeExtends_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable dumpEdgeExtends_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpEdgeExtends_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpEdgeExtends_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeExtends_node_src", "src", dumpEdgeExtends_node_src_AllowedTypes, dumpEdgeExtends_node_src_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode dumpEdgeExtends_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeExtends_node_tgt", "tgt", dumpEdgeExtends_node_tgt_AllowedTypes, dumpEdgeExtends_node_tgt_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge dumpEdgeExtends_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@extends_, "GRGEN_MODEL.Iextends_", "dumpEdgeExtends_edge_e", "e", dumpEdgeExtends_edge_e_AllowedTypes, dumpEdgeExtends_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpEdgeExtends_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpEdgeExtends_edge_e", new GRGEN_EXPR.VariableExpression("dumpEdgeExtends_var_v"))),
				new string[] {  }, new string[] { "dumpEdgeExtends_edge_e" }, new string[] { "dumpEdgeExtends_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpEdgeExtends = new GRGEN_LGSP.PatternGraph(
				"dumpEdgeExtends",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpEdgeExtends_node_src, dumpEdgeExtends_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { dumpEdgeExtends_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { dumpEdgeExtends_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpEdgeExtends_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				dumpEdgeExtends_isNodeHomomorphicGlobal,
				dumpEdgeExtends_isEdgeHomomorphicGlobal,
				dumpEdgeExtends_isNodeTotallyHomomorphic,
				dumpEdgeExtends_isEdgeTotallyHomomorphic
			);
			pat_dumpEdgeExtends.edgeToSourceNode.Add(dumpEdgeExtends_edge_e, dumpEdgeExtends_node_src);
			pat_dumpEdgeExtends.edgeToTargetNode.Add(dumpEdgeExtends_edge_e, dumpEdgeExtends_node_tgt);

			dumpEdgeExtends_node_src.pointOfDefinition = pat_dumpEdgeExtends;
			dumpEdgeExtends_node_tgt.pointOfDefinition = pat_dumpEdgeExtends;
			dumpEdgeExtends_edge_e.pointOfDefinition = pat_dumpEdgeExtends;

			patternGraph = pat_dumpEdgeExtends;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpEdgeExtends curMatch = (Match_dumpEdgeExtends)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpEdgeExtends_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpEdgeExtends_addedEdgeNames );
			graph.SetVisited(edge_e, var_v, true);
			graph.EmitWriter.Write("<edge id=\"");
			graph.EmitWriter.Write(graph.GetElementName(edge_e));
			graph.EmitWriter.Write("\" from=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_src));
			graph.EmitWriter.Write("\" to=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_tgt));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"extends\"/>");
			graph.EmitWriter.Write("</edge>");
			return;
		}
		private static string[] dumpEdgeExtends_addedNodeNames = new string[] {  };
		private static string[] dumpEdgeExtends_addedEdgeNames = new string[] {  };

		static Rule_dumpEdgeExtends() {
		}

		public interface IMatch_dumpEdgeExtends : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_LIBGR.INode node_src { get; }
			GRGEN_LIBGR.INode node_tgt { get; }
			//Edges
			GRGEN_MODEL.Iextends_ edge_e { get; }
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpEdgeExtends : GRGEN_LGSP.ListElement<Match_dumpEdgeExtends>, IMatch_dumpEdgeExtends
		{
			public GRGEN_LIBGR.INode node_src { get { return (GRGEN_LIBGR.INode)_node_src; } }
			public GRGEN_LIBGR.INode node_tgt { get { return (GRGEN_LIBGR.INode)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum dumpEdgeExtends_NodeNums { @src, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeExtends_NodeNums.@src: return _node_src;
				case (int)dumpEdgeExtends_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iextends_ edge_e { get { return (GRGEN_MODEL.Iextends_)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum dumpEdgeExtends_EdgeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeExtends_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpEdgeExtends_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeExtends_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpEdgeExtends_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeExtends_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeExtends_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeExtends_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpEdgeExtends.instance.pat_dumpEdgeExtends; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpEdgeImports : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpEdgeImports instance = null;
		public static Rule_dumpEdgeImports Instance { get { if (instance==null) { instance = new Rule_dumpEdgeImports(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpEdgeImports_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] dumpEdgeImports_node_tgt_AllowedTypes = null;
		public static bool[] dumpEdgeImports_node_src_IsAllowedType = null;
		public static bool[] dumpEdgeImports_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] dumpEdgeImports_edge_e_AllowedTypes = null;
		public static bool[] dumpEdgeImports_edge_e_IsAllowedType = null;
		public enum dumpEdgeImports_NodeNums { @src, @tgt, };
		public enum dumpEdgeImports_EdgeNums { @e, };
		public enum dumpEdgeImports_VariableNums { @v, };
		public enum dumpEdgeImports_SubNums { };
		public enum dumpEdgeImports_AltNums { };
		public enum dumpEdgeImports_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpEdgeImports;


		private Rule_dumpEdgeImports()
		{
			name = "dumpEdgeImports";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpEdgeImports_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpEdgeImports_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] dumpEdgeImports_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] dumpEdgeImports_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] dumpEdgeImports_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable dumpEdgeImports_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpEdgeImports_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpEdgeImports_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeImports_node_src", "src", dumpEdgeImports_node_src_AllowedTypes, dumpEdgeImports_node_src_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode dumpEdgeImports_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeImports_node_tgt", "tgt", dumpEdgeImports_node_tgt_AllowedTypes, dumpEdgeImports_node_tgt_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge dumpEdgeImports_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@imports, "GRGEN_MODEL.Iimports", "dumpEdgeImports_edge_e", "e", dumpEdgeImports_edge_e_AllowedTypes, dumpEdgeImports_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpEdgeImports_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpEdgeImports_edge_e", new GRGEN_EXPR.VariableExpression("dumpEdgeImports_var_v"))),
				new string[] {  }, new string[] { "dumpEdgeImports_edge_e" }, new string[] { "dumpEdgeImports_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpEdgeImports = new GRGEN_LGSP.PatternGraph(
				"dumpEdgeImports",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpEdgeImports_node_src, dumpEdgeImports_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { dumpEdgeImports_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { dumpEdgeImports_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpEdgeImports_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				dumpEdgeImports_isNodeHomomorphicGlobal,
				dumpEdgeImports_isEdgeHomomorphicGlobal,
				dumpEdgeImports_isNodeTotallyHomomorphic,
				dumpEdgeImports_isEdgeTotallyHomomorphic
			);
			pat_dumpEdgeImports.edgeToSourceNode.Add(dumpEdgeImports_edge_e, dumpEdgeImports_node_src);
			pat_dumpEdgeImports.edgeToTargetNode.Add(dumpEdgeImports_edge_e, dumpEdgeImports_node_tgt);

			dumpEdgeImports_node_src.pointOfDefinition = pat_dumpEdgeImports;
			dumpEdgeImports_node_tgt.pointOfDefinition = pat_dumpEdgeImports;
			dumpEdgeImports_edge_e.pointOfDefinition = pat_dumpEdgeImports;

			patternGraph = pat_dumpEdgeImports;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpEdgeImports curMatch = (Match_dumpEdgeImports)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpEdgeImports_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpEdgeImports_addedEdgeNames );
			graph.SetVisited(edge_e, var_v, true);
			graph.EmitWriter.Write("<edge id=\"");
			graph.EmitWriter.Write(graph.GetElementName(edge_e));
			graph.EmitWriter.Write("\" from=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_src));
			graph.EmitWriter.Write("\" to=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_tgt));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"imports\"/>");
			graph.EmitWriter.Write("</edge>");
			return;
		}
		private static string[] dumpEdgeImports_addedNodeNames = new string[] {  };
		private static string[] dumpEdgeImports_addedEdgeNames = new string[] {  };

		static Rule_dumpEdgeImports() {
		}

		public interface IMatch_dumpEdgeImports : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_LIBGR.INode node_src { get; }
			GRGEN_LIBGR.INode node_tgt { get; }
			//Edges
			GRGEN_MODEL.Iimports edge_e { get; }
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpEdgeImports : GRGEN_LGSP.ListElement<Match_dumpEdgeImports>, IMatch_dumpEdgeImports
		{
			public GRGEN_LIBGR.INode node_src { get { return (GRGEN_LIBGR.INode)_node_src; } }
			public GRGEN_LIBGR.INode node_tgt { get { return (GRGEN_LIBGR.INode)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum dumpEdgeImports_NodeNums { @src, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeImports_NodeNums.@src: return _node_src;
				case (int)dumpEdgeImports_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iimports edge_e { get { return (GRGEN_MODEL.Iimports)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum dumpEdgeImports_EdgeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeImports_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpEdgeImports_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeImports_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpEdgeImports_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeImports_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeImports_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeImports_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpEdgeImports.instance.pat_dumpEdgeImports; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpEdgeImplements : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpEdgeImplements instance = null;
		public static Rule_dumpEdgeImplements Instance { get { if (instance==null) { instance = new Rule_dumpEdgeImplements(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpEdgeImplements_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] dumpEdgeImplements_node_tgt_AllowedTypes = null;
		public static bool[] dumpEdgeImplements_node_src_IsAllowedType = null;
		public static bool[] dumpEdgeImplements_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] dumpEdgeImplements_edge_e_AllowedTypes = null;
		public static bool[] dumpEdgeImplements_edge_e_IsAllowedType = null;
		public enum dumpEdgeImplements_NodeNums { @src, @tgt, };
		public enum dumpEdgeImplements_EdgeNums { @e, };
		public enum dumpEdgeImplements_VariableNums { @v, };
		public enum dumpEdgeImplements_SubNums { };
		public enum dumpEdgeImplements_AltNums { };
		public enum dumpEdgeImplements_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpEdgeImplements;


		private Rule_dumpEdgeImplements()
		{
			name = "dumpEdgeImplements";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpEdgeImplements_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpEdgeImplements_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] dumpEdgeImplements_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] dumpEdgeImplements_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] dumpEdgeImplements_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable dumpEdgeImplements_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpEdgeImplements_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpEdgeImplements_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeImplements_node_src", "src", dumpEdgeImplements_node_src_AllowedTypes, dumpEdgeImplements_node_src_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode dumpEdgeImplements_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeImplements_node_tgt", "tgt", dumpEdgeImplements_node_tgt_AllowedTypes, dumpEdgeImplements_node_tgt_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge dumpEdgeImplements_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@implements, "GRGEN_MODEL.Iimplements", "dumpEdgeImplements_edge_e", "e", dumpEdgeImplements_edge_e_AllowedTypes, dumpEdgeImplements_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpEdgeImplements_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpEdgeImplements_edge_e", new GRGEN_EXPR.VariableExpression("dumpEdgeImplements_var_v"))),
				new string[] {  }, new string[] { "dumpEdgeImplements_edge_e" }, new string[] { "dumpEdgeImplements_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpEdgeImplements = new GRGEN_LGSP.PatternGraph(
				"dumpEdgeImplements",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpEdgeImplements_node_src, dumpEdgeImplements_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { dumpEdgeImplements_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { dumpEdgeImplements_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpEdgeImplements_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				dumpEdgeImplements_isNodeHomomorphicGlobal,
				dumpEdgeImplements_isEdgeHomomorphicGlobal,
				dumpEdgeImplements_isNodeTotallyHomomorphic,
				dumpEdgeImplements_isEdgeTotallyHomomorphic
			);
			pat_dumpEdgeImplements.edgeToSourceNode.Add(dumpEdgeImplements_edge_e, dumpEdgeImplements_node_src);
			pat_dumpEdgeImplements.edgeToTargetNode.Add(dumpEdgeImplements_edge_e, dumpEdgeImplements_node_tgt);

			dumpEdgeImplements_node_src.pointOfDefinition = pat_dumpEdgeImplements;
			dumpEdgeImplements_node_tgt.pointOfDefinition = pat_dumpEdgeImplements;
			dumpEdgeImplements_edge_e.pointOfDefinition = pat_dumpEdgeImplements;

			patternGraph = pat_dumpEdgeImplements;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpEdgeImplements curMatch = (Match_dumpEdgeImplements)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpEdgeImplements_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpEdgeImplements_addedEdgeNames );
			graph.SetVisited(edge_e, var_v, true);
			graph.EmitWriter.Write("<edge id=\"");
			graph.EmitWriter.Write(graph.GetElementName(edge_e));
			graph.EmitWriter.Write("\" from=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_src));
			graph.EmitWriter.Write("\" to=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_tgt));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"implements\"/>");
			graph.EmitWriter.Write("</edge>");
			return;
		}
		private static string[] dumpEdgeImplements_addedNodeNames = new string[] {  };
		private static string[] dumpEdgeImplements_addedEdgeNames = new string[] {  };

		static Rule_dumpEdgeImplements() {
		}

		public interface IMatch_dumpEdgeImplements : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_LIBGR.INode node_src { get; }
			GRGEN_LIBGR.INode node_tgt { get; }
			//Edges
			GRGEN_MODEL.Iimplements edge_e { get; }
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpEdgeImplements : GRGEN_LGSP.ListElement<Match_dumpEdgeImplements>, IMatch_dumpEdgeImplements
		{
			public GRGEN_LIBGR.INode node_src { get { return (GRGEN_LIBGR.INode)_node_src; } }
			public GRGEN_LIBGR.INode node_tgt { get { return (GRGEN_LIBGR.INode)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum dumpEdgeImplements_NodeNums { @src, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeImplements_NodeNums.@src: return _node_src;
				case (int)dumpEdgeImplements_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iimplements edge_e { get { return (GRGEN_MODEL.Iimplements)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum dumpEdgeImplements_EdgeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeImplements_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpEdgeImplements_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeImplements_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpEdgeImplements_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeImplements_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeImplements_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeImplements_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpEdgeImplements.instance.pat_dumpEdgeImplements; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpEdgeParameter : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpEdgeParameter instance = null;
		public static Rule_dumpEdgeParameter Instance { get { if (instance==null) { instance = new Rule_dumpEdgeParameter(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpEdgeParameter_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] dumpEdgeParameter_node_tgt_AllowedTypes = null;
		public static bool[] dumpEdgeParameter_node_src_IsAllowedType = null;
		public static bool[] dumpEdgeParameter_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] dumpEdgeParameter_edge_e_AllowedTypes = null;
		public static bool[] dumpEdgeParameter_edge_e_IsAllowedType = null;
		public enum dumpEdgeParameter_NodeNums { @src, @tgt, };
		public enum dumpEdgeParameter_EdgeNums { @e, };
		public enum dumpEdgeParameter_VariableNums { @v, };
		public enum dumpEdgeParameter_SubNums { };
		public enum dumpEdgeParameter_AltNums { };
		public enum dumpEdgeParameter_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpEdgeParameter;


		private Rule_dumpEdgeParameter()
		{
			name = "dumpEdgeParameter";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpEdgeParameter_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpEdgeParameter_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] dumpEdgeParameter_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] dumpEdgeParameter_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] dumpEdgeParameter_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable dumpEdgeParameter_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpEdgeParameter_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpEdgeParameter_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeParameter_node_src", "src", dumpEdgeParameter_node_src_AllowedTypes, dumpEdgeParameter_node_src_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode dumpEdgeParameter_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeParameter_node_tgt", "tgt", dumpEdgeParameter_node_tgt_AllowedTypes, dumpEdgeParameter_node_tgt_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge dumpEdgeParameter_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@parameter, "GRGEN_MODEL.Iparameter", "dumpEdgeParameter_edge_e", "e", dumpEdgeParameter_edge_e_AllowedTypes, dumpEdgeParameter_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpEdgeParameter_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpEdgeParameter_edge_e", new GRGEN_EXPR.VariableExpression("dumpEdgeParameter_var_v"))),
				new string[] {  }, new string[] { "dumpEdgeParameter_edge_e" }, new string[] { "dumpEdgeParameter_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpEdgeParameter = new GRGEN_LGSP.PatternGraph(
				"dumpEdgeParameter",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpEdgeParameter_node_src, dumpEdgeParameter_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { dumpEdgeParameter_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { dumpEdgeParameter_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpEdgeParameter_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				dumpEdgeParameter_isNodeHomomorphicGlobal,
				dumpEdgeParameter_isEdgeHomomorphicGlobal,
				dumpEdgeParameter_isNodeTotallyHomomorphic,
				dumpEdgeParameter_isEdgeTotallyHomomorphic
			);
			pat_dumpEdgeParameter.edgeToSourceNode.Add(dumpEdgeParameter_edge_e, dumpEdgeParameter_node_src);
			pat_dumpEdgeParameter.edgeToTargetNode.Add(dumpEdgeParameter_edge_e, dumpEdgeParameter_node_tgt);

			dumpEdgeParameter_node_src.pointOfDefinition = pat_dumpEdgeParameter;
			dumpEdgeParameter_node_tgt.pointOfDefinition = pat_dumpEdgeParameter;
			dumpEdgeParameter_edge_e.pointOfDefinition = pat_dumpEdgeParameter;

			patternGraph = pat_dumpEdgeParameter;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpEdgeParameter curMatch = (Match_dumpEdgeParameter)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpEdgeParameter_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpEdgeParameter_addedEdgeNames );
			graph.SetVisited(edge_e, var_v, true);
			graph.EmitWriter.Write("<edge id=\"");
			graph.EmitWriter.Write(graph.GetElementName(edge_e));
			graph.EmitWriter.Write("\" from=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_src));
			graph.EmitWriter.Write("\" to=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_tgt));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"parameter\"/>");
			graph.EmitWriter.Write("</edge>");
			return;
		}
		private static string[] dumpEdgeParameter_addedNodeNames = new string[] {  };
		private static string[] dumpEdgeParameter_addedEdgeNames = new string[] {  };

		static Rule_dumpEdgeParameter() {
		}

		public interface IMatch_dumpEdgeParameter : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_LIBGR.INode node_src { get; }
			GRGEN_LIBGR.INode node_tgt { get; }
			//Edges
			GRGEN_MODEL.Iparameter edge_e { get; }
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpEdgeParameter : GRGEN_LGSP.ListElement<Match_dumpEdgeParameter>, IMatch_dumpEdgeParameter
		{
			public GRGEN_LIBGR.INode node_src { get { return (GRGEN_LIBGR.INode)_node_src; } }
			public GRGEN_LIBGR.INode node_tgt { get { return (GRGEN_LIBGR.INode)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum dumpEdgeParameter_NodeNums { @src, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeParameter_NodeNums.@src: return _node_src;
				case (int)dumpEdgeParameter_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iparameter edge_e { get { return (GRGEN_MODEL.Iparameter)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum dumpEdgeParameter_EdgeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeParameter_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpEdgeParameter_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeParameter_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpEdgeParameter_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeParameter_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeParameter_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeParameter_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpEdgeParameter.instance.pat_dumpEdgeParameter; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpEdgeBinding : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpEdgeBinding instance = null;
		public static Rule_dumpEdgeBinding Instance { get { if (instance==null) { instance = new Rule_dumpEdgeBinding(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpEdgeBinding_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] dumpEdgeBinding_node_tgt_AllowedTypes = null;
		public static bool[] dumpEdgeBinding_node_src_IsAllowedType = null;
		public static bool[] dumpEdgeBinding_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] dumpEdgeBinding_edge_e_AllowedTypes = null;
		public static bool[] dumpEdgeBinding_edge_e_IsAllowedType = null;
		public enum dumpEdgeBinding_NodeNums { @src, @tgt, };
		public enum dumpEdgeBinding_EdgeNums { @e, };
		public enum dumpEdgeBinding_VariableNums { @v, };
		public enum dumpEdgeBinding_SubNums { };
		public enum dumpEdgeBinding_AltNums { };
		public enum dumpEdgeBinding_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpEdgeBinding;


		private Rule_dumpEdgeBinding()
		{
			name = "dumpEdgeBinding";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpEdgeBinding_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpEdgeBinding_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] dumpEdgeBinding_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] dumpEdgeBinding_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] dumpEdgeBinding_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable dumpEdgeBinding_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpEdgeBinding_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpEdgeBinding_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeBinding_node_src", "src", dumpEdgeBinding_node_src_AllowedTypes, dumpEdgeBinding_node_src_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode dumpEdgeBinding_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeBinding_node_tgt", "tgt", dumpEdgeBinding_node_tgt_AllowedTypes, dumpEdgeBinding_node_tgt_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge dumpEdgeBinding_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@binding, "GRGEN_MODEL.Ibinding", "dumpEdgeBinding_edge_e", "e", dumpEdgeBinding_edge_e_AllowedTypes, dumpEdgeBinding_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpEdgeBinding_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpEdgeBinding_edge_e", new GRGEN_EXPR.VariableExpression("dumpEdgeBinding_var_v"))),
				new string[] {  }, new string[] { "dumpEdgeBinding_edge_e" }, new string[] { "dumpEdgeBinding_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpEdgeBinding = new GRGEN_LGSP.PatternGraph(
				"dumpEdgeBinding",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpEdgeBinding_node_src, dumpEdgeBinding_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { dumpEdgeBinding_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { dumpEdgeBinding_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpEdgeBinding_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				dumpEdgeBinding_isNodeHomomorphicGlobal,
				dumpEdgeBinding_isEdgeHomomorphicGlobal,
				dumpEdgeBinding_isNodeTotallyHomomorphic,
				dumpEdgeBinding_isEdgeTotallyHomomorphic
			);
			pat_dumpEdgeBinding.edgeToSourceNode.Add(dumpEdgeBinding_edge_e, dumpEdgeBinding_node_src);
			pat_dumpEdgeBinding.edgeToTargetNode.Add(dumpEdgeBinding_edge_e, dumpEdgeBinding_node_tgt);

			dumpEdgeBinding_node_src.pointOfDefinition = pat_dumpEdgeBinding;
			dumpEdgeBinding_node_tgt.pointOfDefinition = pat_dumpEdgeBinding;
			dumpEdgeBinding_edge_e.pointOfDefinition = pat_dumpEdgeBinding;

			patternGraph = pat_dumpEdgeBinding;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpEdgeBinding curMatch = (Match_dumpEdgeBinding)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpEdgeBinding_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpEdgeBinding_addedEdgeNames );
			graph.SetVisited(edge_e, var_v, true);
			graph.EmitWriter.Write("<edge id=\"");
			graph.EmitWriter.Write(graph.GetElementName(edge_e));
			graph.EmitWriter.Write("\" from=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_src));
			graph.EmitWriter.Write("\" to=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_tgt));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"binding\"/>");
			graph.EmitWriter.Write("</edge>");
			return;
		}
		private static string[] dumpEdgeBinding_addedNodeNames = new string[] {  };
		private static string[] dumpEdgeBinding_addedEdgeNames = new string[] {  };

		static Rule_dumpEdgeBinding() {
		}

		public interface IMatch_dumpEdgeBinding : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_LIBGR.INode node_src { get; }
			GRGEN_LIBGR.INode node_tgt { get; }
			//Edges
			GRGEN_MODEL.Ibinding edge_e { get; }
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpEdgeBinding : GRGEN_LGSP.ListElement<Match_dumpEdgeBinding>, IMatch_dumpEdgeBinding
		{
			public GRGEN_LIBGR.INode node_src { get { return (GRGEN_LIBGR.INode)_node_src; } }
			public GRGEN_LIBGR.INode node_tgt { get { return (GRGEN_LIBGR.INode)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum dumpEdgeBinding_NodeNums { @src, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeBinding_NodeNums.@src: return _node_src;
				case (int)dumpEdgeBinding_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ibinding edge_e { get { return (GRGEN_MODEL.Ibinding)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum dumpEdgeBinding_EdgeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeBinding_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpEdgeBinding_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeBinding_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpEdgeBinding_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeBinding_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeBinding_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeBinding_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpEdgeBinding.instance.pat_dumpEdgeBinding; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpEdgeLink : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpEdgeLink instance = null;
		public static Rule_dumpEdgeLink Instance { get { if (instance==null) { instance = new Rule_dumpEdgeLink(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpEdgeLink_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] dumpEdgeLink_node_tgt_AllowedTypes = null;
		public static bool[] dumpEdgeLink_node_src_IsAllowedType = null;
		public static bool[] dumpEdgeLink_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] dumpEdgeLink_edge_e_AllowedTypes = null;
		public static bool[] dumpEdgeLink_edge_e_IsAllowedType = null;
		public enum dumpEdgeLink_NodeNums { @src, @tgt, };
		public enum dumpEdgeLink_EdgeNums { @e, };
		public enum dumpEdgeLink_VariableNums { @v, };
		public enum dumpEdgeLink_SubNums { };
		public enum dumpEdgeLink_AltNums { };
		public enum dumpEdgeLink_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpEdgeLink;


		private Rule_dumpEdgeLink()
		{
			name = "dumpEdgeLink";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpEdgeLink_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpEdgeLink_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] dumpEdgeLink_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] dumpEdgeLink_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] dumpEdgeLink_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable dumpEdgeLink_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpEdgeLink_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpEdgeLink_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeLink_node_src", "src", dumpEdgeLink_node_src_AllowedTypes, dumpEdgeLink_node_src_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode dumpEdgeLink_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeLink_node_tgt", "tgt", dumpEdgeLink_node_tgt_AllowedTypes, dumpEdgeLink_node_tgt_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge dumpEdgeLink_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "dumpEdgeLink_edge_e", "e", dumpEdgeLink_edge_e_AllowedTypes, dumpEdgeLink_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpEdgeLink_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpEdgeLink_edge_e", new GRGEN_EXPR.VariableExpression("dumpEdgeLink_var_v"))),
				new string[] {  }, new string[] { "dumpEdgeLink_edge_e" }, new string[] { "dumpEdgeLink_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpEdgeLink = new GRGEN_LGSP.PatternGraph(
				"dumpEdgeLink",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpEdgeLink_node_src, dumpEdgeLink_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { dumpEdgeLink_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { dumpEdgeLink_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpEdgeLink_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				dumpEdgeLink_isNodeHomomorphicGlobal,
				dumpEdgeLink_isEdgeHomomorphicGlobal,
				dumpEdgeLink_isNodeTotallyHomomorphic,
				dumpEdgeLink_isEdgeTotallyHomomorphic
			);
			pat_dumpEdgeLink.edgeToSourceNode.Add(dumpEdgeLink_edge_e, dumpEdgeLink_node_src);
			pat_dumpEdgeLink.edgeToTargetNode.Add(dumpEdgeLink_edge_e, dumpEdgeLink_node_tgt);

			dumpEdgeLink_node_src.pointOfDefinition = pat_dumpEdgeLink;
			dumpEdgeLink_node_tgt.pointOfDefinition = pat_dumpEdgeLink;
			dumpEdgeLink_edge_e.pointOfDefinition = pat_dumpEdgeLink;

			patternGraph = pat_dumpEdgeLink;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpEdgeLink curMatch = (Match_dumpEdgeLink)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpEdgeLink_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpEdgeLink_addedEdgeNames );
			graph.SetVisited(edge_e, var_v, true);
			graph.EmitWriter.Write("<edge id=\"");
			graph.EmitWriter.Write(graph.GetElementName(edge_e));
			graph.EmitWriter.Write("\" from=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_src));
			graph.EmitWriter.Write("\" to=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_tgt));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"link\"/>");
			graph.EmitWriter.Write("</edge>");
			return;
		}
		private static string[] dumpEdgeLink_addedNodeNames = new string[] {  };
		private static string[] dumpEdgeLink_addedEdgeNames = new string[] {  };

		static Rule_dumpEdgeLink() {
		}

		public interface IMatch_dumpEdgeLink : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_LIBGR.INode node_src { get; }
			GRGEN_LIBGR.INode node_tgt { get; }
			//Edges
			GRGEN_MODEL.Ilink edge_e { get; }
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpEdgeLink : GRGEN_LGSP.ListElement<Match_dumpEdgeLink>, IMatch_dumpEdgeLink
		{
			public GRGEN_LIBGR.INode node_src { get { return (GRGEN_LIBGR.INode)_node_src; } }
			public GRGEN_LIBGR.INode node_tgt { get { return (GRGEN_LIBGR.INode)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum dumpEdgeLink_NodeNums { @src, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeLink_NodeNums.@src: return _node_src;
				case (int)dumpEdgeLink_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ilink edge_e { get { return (GRGEN_MODEL.Ilink)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum dumpEdgeLink_EdgeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeLink_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpEdgeLink_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeLink_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpEdgeLink_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeLink_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeLink_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeLink_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpEdgeLink.instance.pat_dumpEdgeLink; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpEdgeExpression : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpEdgeExpression instance = null;
		public static Rule_dumpEdgeExpression Instance { get { if (instance==null) { instance = new Rule_dumpEdgeExpression(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpEdgeExpression_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] dumpEdgeExpression_node_tgt_AllowedTypes = null;
		public static bool[] dumpEdgeExpression_node_src_IsAllowedType = null;
		public static bool[] dumpEdgeExpression_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] dumpEdgeExpression_edge_e_AllowedTypes = null;
		public static bool[] dumpEdgeExpression_edge_e_IsAllowedType = null;
		public enum dumpEdgeExpression_NodeNums { @src, @tgt, };
		public enum dumpEdgeExpression_EdgeNums { @e, };
		public enum dumpEdgeExpression_VariableNums { @v, };
		public enum dumpEdgeExpression_SubNums { };
		public enum dumpEdgeExpression_AltNums { };
		public enum dumpEdgeExpression_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpEdgeExpression;


		private Rule_dumpEdgeExpression()
		{
			name = "dumpEdgeExpression";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpEdgeExpression_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpEdgeExpression_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] dumpEdgeExpression_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] dumpEdgeExpression_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] dumpEdgeExpression_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable dumpEdgeExpression_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpEdgeExpression_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpEdgeExpression_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeExpression_node_src", "src", dumpEdgeExpression_node_src_AllowedTypes, dumpEdgeExpression_node_src_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode dumpEdgeExpression_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeExpression_node_tgt", "tgt", dumpEdgeExpression_node_tgt_AllowedTypes, dumpEdgeExpression_node_tgt_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge dumpEdgeExpression_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "dumpEdgeExpression_edge_e", "e", dumpEdgeExpression_edge_e_AllowedTypes, dumpEdgeExpression_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpEdgeExpression_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpEdgeExpression_edge_e", new GRGEN_EXPR.VariableExpression("dumpEdgeExpression_var_v"))),
				new string[] {  }, new string[] { "dumpEdgeExpression_edge_e" }, new string[] { "dumpEdgeExpression_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpEdgeExpression = new GRGEN_LGSP.PatternGraph(
				"dumpEdgeExpression",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpEdgeExpression_node_src, dumpEdgeExpression_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { dumpEdgeExpression_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { dumpEdgeExpression_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpEdgeExpression_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				dumpEdgeExpression_isNodeHomomorphicGlobal,
				dumpEdgeExpression_isEdgeHomomorphicGlobal,
				dumpEdgeExpression_isNodeTotallyHomomorphic,
				dumpEdgeExpression_isEdgeTotallyHomomorphic
			);
			pat_dumpEdgeExpression.edgeToSourceNode.Add(dumpEdgeExpression_edge_e, dumpEdgeExpression_node_src);
			pat_dumpEdgeExpression.edgeToTargetNode.Add(dumpEdgeExpression_edge_e, dumpEdgeExpression_node_tgt);

			dumpEdgeExpression_node_src.pointOfDefinition = pat_dumpEdgeExpression;
			dumpEdgeExpression_node_tgt.pointOfDefinition = pat_dumpEdgeExpression;
			dumpEdgeExpression_edge_e.pointOfDefinition = pat_dumpEdgeExpression;

			patternGraph = pat_dumpEdgeExpression;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpEdgeExpression curMatch = (Match_dumpEdgeExpression)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpEdgeExpression_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpEdgeExpression_addedEdgeNames );
			graph.SetVisited(edge_e, var_v, true);
			graph.EmitWriter.Write("<edge id=\"");
			graph.EmitWriter.Write(graph.GetElementName(edge_e));
			graph.EmitWriter.Write("\" from=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_src));
			graph.EmitWriter.Write("\" to=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_tgt));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"expression\"/>");
			graph.EmitWriter.Write("</edge>");
			return;
		}
		private static string[] dumpEdgeExpression_addedNodeNames = new string[] {  };
		private static string[] dumpEdgeExpression_addedEdgeNames = new string[] {  };

		static Rule_dumpEdgeExpression() {
		}

		public interface IMatch_dumpEdgeExpression : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_LIBGR.INode node_src { get; }
			GRGEN_LIBGR.INode node_tgt { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge_e { get; }
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpEdgeExpression : GRGEN_LGSP.ListElement<Match_dumpEdgeExpression>, IMatch_dumpEdgeExpression
		{
			public GRGEN_LIBGR.INode node_src { get { return (GRGEN_LIBGR.INode)_node_src; } }
			public GRGEN_LIBGR.INode node_tgt { get { return (GRGEN_LIBGR.INode)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum dumpEdgeExpression_NodeNums { @src, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeExpression_NodeNums.@src: return _node_src;
				case (int)dumpEdgeExpression_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge_e { get { return (GRGEN_MODEL.Iexpression)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum dumpEdgeExpression_EdgeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeExpression_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpEdgeExpression_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeExpression_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpEdgeExpression_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeExpression_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeExpression_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeExpression_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpEdgeExpression.instance.pat_dumpEdgeExpression; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_dumpEdgeActualParameter : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_dumpEdgeActualParameter instance = null;
		public static Rule_dumpEdgeActualParameter Instance { get { if (instance==null) { instance = new Rule_dumpEdgeActualParameter(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] dumpEdgeActualParameter_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] dumpEdgeActualParameter_node_tgt_AllowedTypes = null;
		public static bool[] dumpEdgeActualParameter_node_src_IsAllowedType = null;
		public static bool[] dumpEdgeActualParameter_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] dumpEdgeActualParameter_edge_e_AllowedTypes = null;
		public static bool[] dumpEdgeActualParameter_edge_e_IsAllowedType = null;
		public enum dumpEdgeActualParameter_NodeNums { @src, @tgt, };
		public enum dumpEdgeActualParameter_EdgeNums { @e, };
		public enum dumpEdgeActualParameter_VariableNums { @v, };
		public enum dumpEdgeActualParameter_SubNums { };
		public enum dumpEdgeActualParameter_AltNums { };
		public enum dumpEdgeActualParameter_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_dumpEdgeActualParameter;


		private Rule_dumpEdgeActualParameter()
		{
			name = "dumpEdgeActualParameter";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), };
			inputNames = new string[] { "dumpEdgeActualParameter_var_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] dumpEdgeActualParameter_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] dumpEdgeActualParameter_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] dumpEdgeActualParameter_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] dumpEdgeActualParameter_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable dumpEdgeActualParameter_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "dumpEdgeActualParameter_var_v", "v", 0, false, null);
			GRGEN_LGSP.PatternNode dumpEdgeActualParameter_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeActualParameter_node_src", "src", dumpEdgeActualParameter_node_src_AllowedTypes, dumpEdgeActualParameter_node_src_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode dumpEdgeActualParameter_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "dumpEdgeActualParameter_node_tgt", "tgt", dumpEdgeActualParameter_node_tgt_AllowedTypes, dumpEdgeActualParameter_node_tgt_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge dumpEdgeActualParameter_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@actualParameter, "GRGEN_MODEL.IactualParameter", "dumpEdgeActualParameter_edge_e", "e", dumpEdgeActualParameter_edge_e_AllowedTypes, dumpEdgeActualParameter_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition dumpEdgeActualParameter_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("dumpEdgeActualParameter_edge_e", new GRGEN_EXPR.VariableExpression("dumpEdgeActualParameter_var_v"))),
				new string[] {  }, new string[] { "dumpEdgeActualParameter_edge_e" }, new string[] { "dumpEdgeActualParameter_var_v" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)) });
			pat_dumpEdgeActualParameter = new GRGEN_LGSP.PatternGraph(
				"dumpEdgeActualParameter",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { dumpEdgeActualParameter_node_src, dumpEdgeActualParameter_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { dumpEdgeActualParameter_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { dumpEdgeActualParameter_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { dumpEdgeActualParameter_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				dumpEdgeActualParameter_isNodeHomomorphicGlobal,
				dumpEdgeActualParameter_isEdgeHomomorphicGlobal,
				dumpEdgeActualParameter_isNodeTotallyHomomorphic,
				dumpEdgeActualParameter_isEdgeTotallyHomomorphic
			);
			pat_dumpEdgeActualParameter.edgeToSourceNode.Add(dumpEdgeActualParameter_edge_e, dumpEdgeActualParameter_node_src);
			pat_dumpEdgeActualParameter.edgeToTargetNode.Add(dumpEdgeActualParameter_edge_e, dumpEdgeActualParameter_node_tgt);

			dumpEdgeActualParameter_node_src.pointOfDefinition = pat_dumpEdgeActualParameter;
			dumpEdgeActualParameter_node_tgt.pointOfDefinition = pat_dumpEdgeActualParameter;
			dumpEdgeActualParameter_edge_e.pointOfDefinition = pat_dumpEdgeActualParameter;

			patternGraph = pat_dumpEdgeActualParameter;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_dumpEdgeActualParameter curMatch = (Match_dumpEdgeActualParameter)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			int var_v = curMatch._var_v;
			graph.SettingAddedNodeNames( dumpEdgeActualParameter_addedNodeNames );
			graph.SettingAddedEdgeNames( dumpEdgeActualParameter_addedEdgeNames );
			graph.SetVisited(edge_e, var_v, true);
			graph.EmitWriter.Write("<edge id=\"");
			graph.EmitWriter.Write(graph.GetElementName(edge_e));
			graph.EmitWriter.Write("\" from=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_src));
			graph.EmitWriter.Write("\" to=\"");
			graph.EmitWriter.Write(graph.GetElementName(node_tgt));
			graph.EmitWriter.Write("\">");
			graph.EmitWriter.Write("<type xlink:href=\"actualParameter\"/>");
			graph.EmitWriter.Write("</edge>");
			return;
		}
		private static string[] dumpEdgeActualParameter_addedNodeNames = new string[] {  };
		private static string[] dumpEdgeActualParameter_addedEdgeNames = new string[] {  };

		static Rule_dumpEdgeActualParameter() {
		}

		public interface IMatch_dumpEdgeActualParameter : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_LIBGR.INode node_src { get; }
			GRGEN_LIBGR.INode node_tgt { get; }
			//Edges
			GRGEN_MODEL.IactualParameter edge_e { get; }
			//Variables
			int @var_v { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_dumpEdgeActualParameter : GRGEN_LGSP.ListElement<Match_dumpEdgeActualParameter>, IMatch_dumpEdgeActualParameter
		{
			public GRGEN_LIBGR.INode node_src { get { return (GRGEN_LIBGR.INode)_node_src; } }
			public GRGEN_LIBGR.INode node_tgt { get { return (GRGEN_LIBGR.INode)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum dumpEdgeActualParameter_NodeNums { @src, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeActualParameter_NodeNums.@src: return _node_src;
				case (int)dumpEdgeActualParameter_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IactualParameter edge_e { get { return (GRGEN_MODEL.IactualParameter)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum dumpEdgeActualParameter_EdgeNums { @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeActualParameter_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public int var_v { get { return _var_v; } }
			public int _var_v;
			public enum dumpEdgeActualParameter_VariableNums { @v, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)dumpEdgeActualParameter_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			
			public enum dumpEdgeActualParameter_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeActualParameter_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeActualParameter_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum dumpEdgeActualParameter_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_dumpEdgeActualParameter.instance.pat_dumpEdgeActualParameter; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_emitSpanningTree : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_emitSpanningTree instance = null;
		public static Rule_emitSpanningTree Instance { get { if (instance==null) { instance = new Rule_emitSpanningTree(); instance.initialize(); } return instance; } }

		public enum emitSpanningTree_NodeNums { };
		public enum emitSpanningTree_EdgeNums { };
		public enum emitSpanningTree_VariableNums { };
		public enum emitSpanningTree_SubNums { };
		public enum emitSpanningTree_AltNums { };
		public enum emitSpanningTree_IterNums { @iter_0, };




		public GRGEN_LGSP.PatternGraph pat_emitSpanningTree;

		public static GRGEN_LIBGR.NodeType[] emitSpanningTree_iter_0_node_p_AllowedTypes = null;
		public static bool[] emitSpanningTree_iter_0_node_p_IsAllowedType = null;
		public enum emitSpanningTree_iter_0_NodeNums { @p, };
		public enum emitSpanningTree_iter_0_EdgeNums { };
		public enum emitSpanningTree_iter_0_VariableNums { };
		public enum emitSpanningTree_iter_0_SubNums { @mpc, };
		public enum emitSpanningTree_iter_0_AltNums { };
		public enum emitSpanningTree_iter_0_IterNums { };




		public GRGEN_LGSP.PatternGraph emitSpanningTree_iter_0;

		public static GRGEN_LIBGR.EdgeType[] emitSpanningTree_iter_0_neg_0_edge__edge0_AllowedTypes = null;
		public static bool[] emitSpanningTree_iter_0_neg_0_edge__edge0_IsAllowedType = null;
		public enum emitSpanningTree_iter_0_neg_0_NodeNums { @p, };
		public enum emitSpanningTree_iter_0_neg_0_EdgeNums { @_edge0, };
		public enum emitSpanningTree_iter_0_neg_0_VariableNums { };
		public enum emitSpanningTree_iter_0_neg_0_SubNums { };
		public enum emitSpanningTree_iter_0_neg_0_AltNums { };
		public enum emitSpanningTree_iter_0_neg_0_IterNums { };

		public GRGEN_LGSP.PatternGraph emitSpanningTree_iter_0_neg_0;


		private Rule_emitSpanningTree()
		{
			name = "emitSpanningTree";

			inputs = new GRGEN_LIBGR.GrGenType[] { };
			inputNames = new string[] { };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] emitSpanningTree_isNodeHomomorphicGlobal = new bool[0, 0] ;
			bool[,] emitSpanningTree_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] emitSpanningTree_isNodeTotallyHomomorphic = new bool[0] ;
			bool[] emitSpanningTree_isEdgeTotallyHomomorphic = new bool[0] ;
			bool[,] emitSpanningTree_iter_0_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] emitSpanningTree_iter_0_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] emitSpanningTree_iter_0_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] emitSpanningTree_iter_0_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode emitSpanningTree_iter_0_node_p = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Package, "GRGEN_MODEL.IPackage", "emitSpanningTree_iter_0_node_p", "p", emitSpanningTree_iter_0_node_p_AllowedTypes, emitSpanningTree_iter_0_node_p_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding emitSpanningTree_iter_0_mpc = new GRGEN_LGSP.PatternGraphEmbedding("mpc", Pattern_MultipleContainedPackagesOrClasses.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("emitSpanningTree_iter_0_node_p"),
				}, 
				new string[] { }, new string[] { "emitSpanningTree_iter_0_node_p" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			bool[,] emitSpanningTree_iter_0_neg_0_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] emitSpanningTree_iter_0_neg_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] emitSpanningTree_iter_0_neg_0_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] emitSpanningTree_iter_0_neg_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternEdge emitSpanningTree_iter_0_neg_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "emitSpanningTree_iter_0_neg_0_edge__edge0", "_edge0", emitSpanningTree_iter_0_neg_0_edge__edge0_AllowedTypes, emitSpanningTree_iter_0_neg_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			emitSpanningTree_iter_0_neg_0 = new GRGEN_LGSP.PatternGraph(
				"neg_0",
				"emitSpanningTree_iter_0_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { emitSpanningTree_iter_0_node_p }, 
				new GRGEN_LGSP.PatternEdge[] { emitSpanningTree_iter_0_neg_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				emitSpanningTree_iter_0_neg_0_isNodeHomomorphicGlobal,
				emitSpanningTree_iter_0_neg_0_isEdgeHomomorphicGlobal,
				emitSpanningTree_iter_0_neg_0_isNodeTotallyHomomorphic,
				emitSpanningTree_iter_0_neg_0_isEdgeTotallyHomomorphic
			);
			emitSpanningTree_iter_0_neg_0.edgeToSourceNode.Add(emitSpanningTree_iter_0_neg_0_edge__edge0, emitSpanningTree_iter_0_node_p);

			emitSpanningTree_iter_0 = new GRGEN_LGSP.PatternGraph(
				"iter_0",
				"emitSpanningTree_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { emitSpanningTree_iter_0_node_p }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { emitSpanningTree_iter_0_mpc }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] { emitSpanningTree_iter_0_neg_0,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				emitSpanningTree_iter_0_isNodeHomomorphicGlobal,
				emitSpanningTree_iter_0_isEdgeHomomorphicGlobal,
				emitSpanningTree_iter_0_isNodeTotallyHomomorphic,
				emitSpanningTree_iter_0_isEdgeTotallyHomomorphic
			);
			emitSpanningTree_iter_0_neg_0.embeddingGraph = emitSpanningTree_iter_0;

			GRGEN_LGSP.Iterated emitSpanningTree_iter_0_it = new GRGEN_LGSP.Iterated( emitSpanningTree_iter_0, 0, 0);
			pat_emitSpanningTree = new GRGEN_LGSP.PatternGraph(
				"emitSpanningTree",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] {  }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] { emitSpanningTree_iter_0_it,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[0, 0] ,
				new bool[0, 0] ,
				emitSpanningTree_isNodeHomomorphicGlobal,
				emitSpanningTree_isEdgeHomomorphicGlobal,
				emitSpanningTree_isNodeTotallyHomomorphic,
				emitSpanningTree_isEdgeTotallyHomomorphic
			);
			emitSpanningTree_iter_0.embeddingGraph = pat_emitSpanningTree;

			emitSpanningTree_iter_0_node_p.pointOfDefinition = emitSpanningTree_iter_0;
			emitSpanningTree_iter_0_mpc.PointOfDefinition = emitSpanningTree_iter_0;
			emitSpanningTree_iter_0_neg_0_edge__edge0.pointOfDefinition = emitSpanningTree_iter_0_neg_0;

			patternGraph = pat_emitSpanningTree;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_emitSpanningTree curMatch = (Match_emitSpanningTree)_curMatch;
			GRGEN_LGSP.LGSPMatchesList<Match_emitSpanningTree_iter_0, IMatch_emitSpanningTree_iter_0> iterated_iter_0 = curMatch._iter_0;
			graph.SettingAddedNodeNames( emitSpanningTree_addedNodeNames );
			graph.EmitWriter.Write("// java program ");
			graph.EmitWriter.Write(graph.Name);
			graph.EmitWriter.Write("\n");
			emitSpanningTree_iter_0_Modify(graph, iterated_iter_0);
			graph.SettingAddedEdgeNames( emitSpanningTree_addedEdgeNames );
			return;
		}
		private static string[] emitSpanningTree_addedNodeNames = new string[] {  };
		private static string[] emitSpanningTree_addedEdgeNames = new string[] {  };

		public void emitSpanningTree_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LGSP.LGSPMatchesList<Match_emitSpanningTree_iter_0, IMatch_emitSpanningTree_iter_0> curMatches)
		{
			for(Match_emitSpanningTree_iter_0 curMatch=curMatches.Root; curMatch!=null; curMatch=curMatch.next) {
				emitSpanningTree_iter_0_Modify(graph, curMatch);
			}
		}

		public void emitSpanningTree_iter_0_Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_emitSpanningTree_iter_0 curMatch = (Match_emitSpanningTree_iter_0)_curMatch;
			GRGEN_MODEL.IPackage inode_p = curMatch.node_p;
			Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses subpattern_mpc = curMatch.@_mpc;
			graph.SettingAddedNodeNames( emitSpanningTree_iter_0_addedNodeNames );
			graph.EmitWriter.Write("package ");
			graph.EmitWriter.Write(inode_p.@name);
			graph.EmitWriter.Write("\n{\n");
			Pattern_MultipleContainedPackagesOrClasses.Instance.MultipleContainedPackagesOrClasses_Modify(graph, subpattern_mpc);
			graph.EmitWriter.Write("}\n");
			graph.SettingAddedEdgeNames( emitSpanningTree_iter_0_addedEdgeNames );
			string tempvar_node_p_name = inode_p.@name;
		}
		private static string[] emitSpanningTree_iter_0_addedNodeNames = new string[] {  };
		private static string[] emitSpanningTree_iter_0_addedEdgeNames = new string[] {  };

		static Rule_emitSpanningTree() {
		}

		public interface IMatch_emitSpanningTree : GRGEN_LIBGR.IMatch
		{
			//Nodes
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			GRGEN_LIBGR.IMatchesExact<IMatch_emitSpanningTree_iter_0> iter_0 { get; }
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_emitSpanningTree_iter_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IPackage node_p { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			@Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses @mpc { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			bool IsNullMatch { get; }
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_emitSpanningTree_iter_0_neg_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IPackage node_p { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_emitSpanningTree : GRGEN_LGSP.ListElement<Match_emitSpanningTree>, IMatch_emitSpanningTree
		{
			public enum emitSpanningTree_NodeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 0;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum emitSpanningTree_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum emitSpanningTree_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum emitSpanningTree_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum emitSpanningTree_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IMatchesExact<IMatch_emitSpanningTree_iter_0> iter_0 { get { return _iter_0; } }
			public GRGEN_LGSP.LGSPMatchesList<Match_emitSpanningTree_iter_0, IMatch_emitSpanningTree_iter_0> _iter_0;
			public enum emitSpanningTree_IterNums { @iter_0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 1;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				case (int)emitSpanningTree_IterNums.@iter_0: return _iter_0;
				default: return null;
				}
			}
			
			public enum emitSpanningTree_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_emitSpanningTree.instance.pat_emitSpanningTree; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_emitSpanningTree_iter_0 : GRGEN_LGSP.ListElement<Match_emitSpanningTree_iter_0>, IMatch_emitSpanningTree_iter_0
		{
			public GRGEN_MODEL.IPackage node_p { get { return (GRGEN_MODEL.IPackage)_node_p; } }
			public GRGEN_LGSP.LGSPNode _node_p;
			public enum emitSpanningTree_iter_0_NodeNums { @p, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)emitSpanningTree_iter_0_NodeNums.@p: return _node_p;
				default: return null;
				}
			}
			
			public enum emitSpanningTree_iter_0_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum emitSpanningTree_iter_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses @mpc { get { return @_mpc; } }
			public @Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses @_mpc;
			public enum emitSpanningTree_iter_0_SubNums { @mpc, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)emitSpanningTree_iter_0_SubNums.@mpc: return _mpc;
				default: return null;
				}
			}
			
			public enum emitSpanningTree_iter_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum emitSpanningTree_iter_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum emitSpanningTree_iter_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_emitSpanningTree.instance.emitSpanningTree_iter_0; } }
			public bool IsNullMatch { get { return _isNullMatch; } }
			public bool _isNullMatch;
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_emitSpanningTree_iter_0_neg_0 : GRGEN_LGSP.ListElement<Match_emitSpanningTree_iter_0_neg_0>, IMatch_emitSpanningTree_iter_0_neg_0
		{
			public GRGEN_MODEL.IPackage node_p { get { return (GRGEN_MODEL.IPackage)_node_p; } }
			public GRGEN_LGSP.LGSPNode _node_p;
			public enum emitSpanningTree_iter_0_neg_0_NodeNums { @p, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)emitSpanningTree_iter_0_neg_0_NodeNums.@p: return _node_p;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge0 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum emitSpanningTree_iter_0_neg_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)emitSpanningTree_iter_0_neg_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum emitSpanningTree_iter_0_neg_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum emitSpanningTree_iter_0_neg_0_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum emitSpanningTree_iter_0_neg_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum emitSpanningTree_iter_0_neg_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum emitSpanningTree_iter_0_neg_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_emitSpanningTree.instance.emitSpanningTree_iter_0_neg_0; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_InsertHelperEdgesForNestedLayout : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_InsertHelperEdgesForNestedLayout instance = null;
		public static Rule_InsertHelperEdgesForNestedLayout Instance { get { if (instance==null) { instance = new Rule_InsertHelperEdgesForNestedLayout(); instance.initialize(); } return instance; } }

		public enum InsertHelperEdgesForNestedLayout_NodeNums { };
		public enum InsertHelperEdgesForNestedLayout_EdgeNums { };
		public enum InsertHelperEdgesForNestedLayout_VariableNums { };
		public enum InsertHelperEdgesForNestedLayout_SubNums { };
		public enum InsertHelperEdgesForNestedLayout_AltNums { };
		public enum InsertHelperEdgesForNestedLayout_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_InsertHelperEdgesForNestedLayout;


		private Rule_InsertHelperEdgesForNestedLayout()
		{
			name = "InsertHelperEdgesForNestedLayout";

			inputs = new GRGEN_LIBGR.GrGenType[] { };
			inputNames = new string[] { };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] InsertHelperEdgesForNestedLayout_isNodeHomomorphicGlobal = new bool[0, 0] ;
			bool[,] InsertHelperEdgesForNestedLayout_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] InsertHelperEdgesForNestedLayout_isNodeTotallyHomomorphic = new bool[0] ;
			bool[] InsertHelperEdgesForNestedLayout_isEdgeTotallyHomomorphic = new bool[0] ;
			pat_InsertHelperEdgesForNestedLayout = new GRGEN_LGSP.PatternGraph(
				"InsertHelperEdgesForNestedLayout",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] {  }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[0, 0] ,
				new bool[0, 0] ,
				InsertHelperEdgesForNestedLayout_isNodeHomomorphicGlobal,
				InsertHelperEdgesForNestedLayout_isEdgeHomomorphicGlobal,
				InsertHelperEdgesForNestedLayout_isNodeTotallyHomomorphic,
				InsertHelperEdgesForNestedLayout_isEdgeTotallyHomomorphic
			);


			patternGraph = pat_InsertHelperEdgesForNestedLayout;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_InsertHelperEdgesForNestedLayout curMatch = (Match_InsertHelperEdgesForNestedLayout)_curMatch;
			graph.SettingAddedNodeNames( InsertHelperEdgesForNestedLayout_addedNodeNames );
			graph.SettingAddedEdgeNames( InsertHelperEdgesForNestedLayout_addedEdgeNames );
			ApplyXGRS_InsertHelperEdgesForNestedLayout_0(graph);
			return;
		}
		private static string[] InsertHelperEdgesForNestedLayout_addedNodeNames = new string[] {  };
		private static string[] InsertHelperEdgesForNestedLayout_addedEdgeNames = new string[] {  };

        public static bool ApplyXGRS_InsertHelperEdgesForNestedLayout_0(GRGEN_LGSP.LGSPGraph graph)
        {
            GRGEN_LGSP.LGSPActions actions = graph.curActions;
            bool res_58;
            bool res_52;
            bool res_51;
            Action_BindOperations rule_BindOperations = Action_BindOperations.Instance;
            bool res_57;
            bool res_54;
            bool res_53;
            Action_InitMoveIntoBlocks rule_InitMoveIntoBlocks = Action_InitMoveIntoBlocks.Instance;
            bool res_56;
            bool res_55;
            Action_MoveIntoBlocks rule_MoveIntoBlocks = Action_MoveIntoBlocks.Instance;
            long i_52 = 0;
            while(true)
            {
                GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> matches_51 = rule_BindOperations.Match(graph, 1);
                graph.Matched(matches_51, false);
                if(matches_51.Count==0) {
                    res_51 = (bool)(false);
                } else {
                    res_51 = (bool)(true);
                    if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_51.Count;
                    graph.Finishing(matches_51, false);
                    Rule_BindOperations.IMatch_BindOperations match_51 = matches_51.FirstExact;
                    rule_BindOperations.Modify(graph, match_51);
                    if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                    graph.Finished(matches_51, false);
                }
                if(!res_51) break;
                i_52++;
            }
            res_52 = (bool)(i_52 >= 0);
            if(!res_52)
                res_58 = (bool)(false);
            else
            {
                long i_54 = 0;
                while(true)
                {
                    GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> matches_53 = rule_InitMoveIntoBlocks.Match(graph, 1);
                    graph.Matched(matches_53, false);
                    if(matches_53.Count==0) {
                        res_53 = (bool)(false);
                    } else {
                        res_53 = (bool)(true);
                        if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_53.Count;
                        graph.Finishing(matches_53, false);
                        Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks match_53 = matches_53.FirstExact;
                        rule_InitMoveIntoBlocks.Modify(graph, match_53);
                        if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                        graph.Finished(matches_53, false);
                    }
                    if(!res_53) break;
                    i_54++;
                }
                res_54 = (bool)(i_54 >= 0);
                if(!res_54)
                    res_57 = (bool)(false);
                else
                {
                    long i_56 = 0;
                    while(true)
                    {
                        GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> matches_55 = rule_MoveIntoBlocks.Match(graph, 1);
                        graph.Matched(matches_55, false);
                        if(matches_55.Count==0) {
                            res_55 = (bool)(false);
                        } else {
                            res_55 = (bool)(true);
                            if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_55.Count;
                            graph.Finishing(matches_55, false);
                            Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks match_55 = matches_55.FirstExact;
                            rule_MoveIntoBlocks.Modify(graph, match_55);
                            if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                            graph.Finished(matches_55, false);
                        }
                        if(!res_55) break;
                        i_56++;
                    }
                    res_56 = (bool)(i_56 >= 0);
                    res_57 = (bool)(res_56);
                }
                res_58 = (bool)(res_57);
            }
            return res_58;
        }

		static Rule_InsertHelperEdgesForNestedLayout() {
		}

		public interface IMatch_InsertHelperEdgesForNestedLayout : GRGEN_LIBGR.IMatch
		{
			//Nodes
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_InsertHelperEdgesForNestedLayout : GRGEN_LGSP.ListElement<Match_InsertHelperEdgesForNestedLayout>, IMatch_InsertHelperEdgesForNestedLayout
		{
			public enum InsertHelperEdgesForNestedLayout_NodeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 0;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InsertHelperEdgesForNestedLayout_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InsertHelperEdgesForNestedLayout_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InsertHelperEdgesForNestedLayout_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InsertHelperEdgesForNestedLayout_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InsertHelperEdgesForNestedLayout_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InsertHelperEdgesForNestedLayout_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_InsertHelperEdgesForNestedLayout.instance.pat_InsertHelperEdgesForNestedLayout; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_BindOperations : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_BindOperations instance = null;
		public static Rule_BindOperations Instance { get { if (instance==null) { instance = new Rule_BindOperations(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] BindOperations_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] BindOperations_node_body_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] BindOperations_node_cl_AllowedTypes = null;
		public static bool[] BindOperations_node_op_IsAllowedType = null;
		public static bool[] BindOperations_node_body_IsAllowedType = null;
		public static bool[] BindOperations_node_cl_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] BindOperations_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] BindOperations_edge__edge1_AllowedTypes = null;
		public static bool[] BindOperations_edge__edge0_IsAllowedType = null;
		public static bool[] BindOperations_edge__edge1_IsAllowedType = null;
		public enum BindOperations_NodeNums { @op, @body, @cl, };
		public enum BindOperations_EdgeNums { @_edge0, @_edge1, };
		public enum BindOperations_VariableNums { };
		public enum BindOperations_SubNums { };
		public enum BindOperations_AltNums { };
		public enum BindOperations_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_BindOperations;

		public static GRGEN_LIBGR.EdgeType[] BindOperations_implneg_0_edge__edge3_AllowedTypes = null;
		public static bool[] BindOperations_implneg_0_edge__edge3_IsAllowedType = null;
		public enum BindOperations_implneg_0_NodeNums { @op, };
		public enum BindOperations_implneg_0_EdgeNums { @_edge3, };
		public enum BindOperations_implneg_0_VariableNums { };
		public enum BindOperations_implneg_0_SubNums { };
		public enum BindOperations_implneg_0_AltNums { };
		public enum BindOperations_implneg_0_IterNums { };

		public GRGEN_LGSP.PatternGraph BindOperations_implneg_0;

		public static GRGEN_LIBGR.EdgeType[] BindOperations_implneg_1_edge__edge4_AllowedTypes = null;
		public static bool[] BindOperations_implneg_1_edge__edge4_IsAllowedType = null;
		public enum BindOperations_implneg_1_NodeNums { @op, @body, };
		public enum BindOperations_implneg_1_EdgeNums { @_edge0, @_edge4, };
		public enum BindOperations_implneg_1_VariableNums { };
		public enum BindOperations_implneg_1_SubNums { };
		public enum BindOperations_implneg_1_AltNums { };
		public enum BindOperations_implneg_1_IterNums { };

		public GRGEN_LGSP.PatternGraph BindOperations_implneg_1;

		public static GRGEN_LIBGR.EdgeType[] BindOperations_implneg_2_edge__edge5_AllowedTypes = null;
		public static bool[] BindOperations_implneg_2_edge__edge5_IsAllowedType = null;
		public enum BindOperations_implneg_2_NodeNums { @op, @cl, };
		public enum BindOperations_implneg_2_EdgeNums { @_edge5, };
		public enum BindOperations_implneg_2_VariableNums { };
		public enum BindOperations_implneg_2_SubNums { };
		public enum BindOperations_implneg_2_AltNums { };
		public enum BindOperations_implneg_2_IterNums { };

		public GRGEN_LGSP.PatternGraph BindOperations_implneg_2;

		public static GRGEN_LIBGR.EdgeType[] BindOperations_implneg_3_edge__edge6_AllowedTypes = null;
		public static bool[] BindOperations_implneg_3_edge__edge6_IsAllowedType = null;
		public enum BindOperations_implneg_3_NodeNums { @body, };
		public enum BindOperations_implneg_3_EdgeNums { @_edge6, };
		public enum BindOperations_implneg_3_VariableNums { };
		public enum BindOperations_implneg_3_SubNums { };
		public enum BindOperations_implneg_3_AltNums { };
		public enum BindOperations_implneg_3_IterNums { };

		public GRGEN_LGSP.PatternGraph BindOperations_implneg_3;

		public static GRGEN_LIBGR.EdgeType[] BindOperations_implneg_4_edge__edge7_AllowedTypes = null;
		public static bool[] BindOperations_implneg_4_edge__edge7_IsAllowedType = null;
		public enum BindOperations_implneg_4_NodeNums { @body, @cl, };
		public enum BindOperations_implneg_4_EdgeNums { @_edge1, @_edge7, };
		public enum BindOperations_implneg_4_VariableNums { };
		public enum BindOperations_implneg_4_SubNums { };
		public enum BindOperations_implneg_4_AltNums { };
		public enum BindOperations_implneg_4_IterNums { };

		public GRGEN_LGSP.PatternGraph BindOperations_implneg_4;

		public static GRGEN_LIBGR.EdgeType[] BindOperations_implneg_5_edge__edge8_AllowedTypes = null;
		public static bool[] BindOperations_implneg_5_edge__edge8_IsAllowedType = null;
		public enum BindOperations_implneg_5_NodeNums { @cl, };
		public enum BindOperations_implneg_5_EdgeNums { @_edge8, };
		public enum BindOperations_implneg_5_VariableNums { };
		public enum BindOperations_implneg_5_SubNums { };
		public enum BindOperations_implneg_5_AltNums { };
		public enum BindOperations_implneg_5_IterNums { };

		public GRGEN_LGSP.PatternGraph BindOperations_implneg_5;


		private Rule_BindOperations()
		{
			name = "BindOperations";

			inputs = new GRGEN_LIBGR.GrGenType[] { };
			inputNames = new string[] { };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] BindOperations_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] BindOperations_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] BindOperations_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] BindOperations_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternNode BindOperations_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "BindOperations_node_op", "op", BindOperations_node_op_AllowedTypes, BindOperations_node_op_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode BindOperations_node_body = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "BindOperations_node_body", "body", BindOperations_node_body_AllowedTypes, BindOperations_node_body_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode BindOperations_node_cl = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "BindOperations_node_cl", "cl", BindOperations_node_cl_AllowedTypes, BindOperations_node_cl_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge BindOperations_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@binding, "GRGEN_MODEL.Ibinding", "BindOperations_edge__edge0", "_edge0", BindOperations_edge__edge0_AllowedTypes, BindOperations_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge BindOperations_edge__edge1 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "BindOperations_edge__edge1", "_edge1", BindOperations_edge__edge1_AllowedTypes, BindOperations_edge__edge1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			bool[,] BindOperations_implneg_0_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] BindOperations_implneg_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] BindOperations_implneg_0_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] BindOperations_implneg_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternEdge BindOperations_implneg_0_edge__edge3 = new GRGEN_LGSP.PatternEdge(false, (int) GRGEN_MODEL.EdgeTypes.@AEdge, "GRGEN_LIBGR.IEdge", "BindOperations_implneg_0_edge__edge3", "_edge3", BindOperations_implneg_0_edge__edge3_AllowedTypes, BindOperations_implneg_0_edge__edge3_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			BindOperations_implneg_0 = new GRGEN_LGSP.PatternGraph(
				"implneg_0",
				"BindOperations_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { BindOperations_node_op }, 
				new GRGEN_LGSP.PatternEdge[] { BindOperations_implneg_0_edge__edge3 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				BindOperations_implneg_0_isNodeHomomorphicGlobal,
				BindOperations_implneg_0_isEdgeHomomorphicGlobal,
				BindOperations_implneg_0_isNodeTotallyHomomorphic,
				BindOperations_implneg_0_isEdgeTotallyHomomorphic
			);
			BindOperations_implneg_0.edgeToSourceNode.Add(BindOperations_implneg_0_edge__edge3, BindOperations_node_op);
			BindOperations_implneg_0.edgeToTargetNode.Add(BindOperations_implneg_0_edge__edge3, BindOperations_node_op);

			bool[,] BindOperations_implneg_1_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] BindOperations_implneg_1_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] BindOperations_implneg_1_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] BindOperations_implneg_1_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternEdge BindOperations_implneg_1_edge__edge4 = new GRGEN_LGSP.PatternEdge(false, (int) GRGEN_MODEL.EdgeTypes.@AEdge, "GRGEN_LIBGR.IEdge", "BindOperations_implneg_1_edge__edge4", "_edge4", BindOperations_implneg_1_edge__edge4_AllowedTypes, BindOperations_implneg_1_edge__edge4_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			BindOperations_implneg_1 = new GRGEN_LGSP.PatternGraph(
				"implneg_1",
				"BindOperations_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { BindOperations_node_op, BindOperations_node_body }, 
				new GRGEN_LGSP.PatternEdge[] { BindOperations_edge__edge0, BindOperations_implneg_1_edge__edge4 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				BindOperations_implneg_1_isNodeHomomorphicGlobal,
				BindOperations_implneg_1_isEdgeHomomorphicGlobal,
				BindOperations_implneg_1_isNodeTotallyHomomorphic,
				BindOperations_implneg_1_isEdgeTotallyHomomorphic
			);
			BindOperations_implneg_1.edgeToSourceNode.Add(BindOperations_edge__edge0, BindOperations_node_op);
			BindOperations_implneg_1.edgeToTargetNode.Add(BindOperations_edge__edge0, BindOperations_node_body);
			BindOperations_implneg_1.edgeToSourceNode.Add(BindOperations_implneg_1_edge__edge4, BindOperations_node_op);
			BindOperations_implneg_1.edgeToTargetNode.Add(BindOperations_implneg_1_edge__edge4, BindOperations_node_body);

			bool[,] BindOperations_implneg_2_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] BindOperations_implneg_2_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] BindOperations_implneg_2_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] BindOperations_implneg_2_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternEdge BindOperations_implneg_2_edge__edge5 = new GRGEN_LGSP.PatternEdge(false, (int) GRGEN_MODEL.EdgeTypes.@AEdge, "GRGEN_LIBGR.IEdge", "BindOperations_implneg_2_edge__edge5", "_edge5", BindOperations_implneg_2_edge__edge5_AllowedTypes, BindOperations_implneg_2_edge__edge5_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			BindOperations_implneg_2 = new GRGEN_LGSP.PatternGraph(
				"implneg_2",
				"BindOperations_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { BindOperations_node_op, BindOperations_node_cl }, 
				new GRGEN_LGSP.PatternEdge[] { BindOperations_implneg_2_edge__edge5 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				BindOperations_implneg_2_isNodeHomomorphicGlobal,
				BindOperations_implneg_2_isEdgeHomomorphicGlobal,
				BindOperations_implneg_2_isNodeTotallyHomomorphic,
				BindOperations_implneg_2_isEdgeTotallyHomomorphic
			);
			BindOperations_implneg_2.edgeToSourceNode.Add(BindOperations_implneg_2_edge__edge5, BindOperations_node_op);
			BindOperations_implneg_2.edgeToTargetNode.Add(BindOperations_implneg_2_edge__edge5, BindOperations_node_cl);

			bool[,] BindOperations_implneg_3_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] BindOperations_implneg_3_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] BindOperations_implneg_3_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] BindOperations_implneg_3_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternEdge BindOperations_implneg_3_edge__edge6 = new GRGEN_LGSP.PatternEdge(false, (int) GRGEN_MODEL.EdgeTypes.@AEdge, "GRGEN_LIBGR.IEdge", "BindOperations_implneg_3_edge__edge6", "_edge6", BindOperations_implneg_3_edge__edge6_AllowedTypes, BindOperations_implneg_3_edge__edge6_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			BindOperations_implneg_3 = new GRGEN_LGSP.PatternGraph(
				"implneg_3",
				"BindOperations_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { BindOperations_node_body }, 
				new GRGEN_LGSP.PatternEdge[] { BindOperations_implneg_3_edge__edge6 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				BindOperations_implneg_3_isNodeHomomorphicGlobal,
				BindOperations_implneg_3_isEdgeHomomorphicGlobal,
				BindOperations_implneg_3_isNodeTotallyHomomorphic,
				BindOperations_implneg_3_isEdgeTotallyHomomorphic
			);
			BindOperations_implneg_3.edgeToSourceNode.Add(BindOperations_implneg_3_edge__edge6, BindOperations_node_body);
			BindOperations_implneg_3.edgeToTargetNode.Add(BindOperations_implneg_3_edge__edge6, BindOperations_node_body);

			bool[,] BindOperations_implneg_4_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] BindOperations_implneg_4_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] BindOperations_implneg_4_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] BindOperations_implneg_4_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternEdge BindOperations_implneg_4_edge__edge7 = new GRGEN_LGSP.PatternEdge(false, (int) GRGEN_MODEL.EdgeTypes.@AEdge, "GRGEN_LIBGR.IEdge", "BindOperations_implneg_4_edge__edge7", "_edge7", BindOperations_implneg_4_edge__edge7_AllowedTypes, BindOperations_implneg_4_edge__edge7_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			BindOperations_implneg_4 = new GRGEN_LGSP.PatternGraph(
				"implneg_4",
				"BindOperations_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { BindOperations_node_body, BindOperations_node_cl }, 
				new GRGEN_LGSP.PatternEdge[] { BindOperations_edge__edge1, BindOperations_implneg_4_edge__edge7 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				BindOperations_implneg_4_isNodeHomomorphicGlobal,
				BindOperations_implneg_4_isEdgeHomomorphicGlobal,
				BindOperations_implneg_4_isNodeTotallyHomomorphic,
				BindOperations_implneg_4_isEdgeTotallyHomomorphic
			);
			BindOperations_implneg_4.edgeToSourceNode.Add(BindOperations_edge__edge1, BindOperations_node_body);
			BindOperations_implneg_4.edgeToTargetNode.Add(BindOperations_edge__edge1, BindOperations_node_cl);
			BindOperations_implneg_4.edgeToSourceNode.Add(BindOperations_implneg_4_edge__edge7, BindOperations_node_body);
			BindOperations_implneg_4.edgeToTargetNode.Add(BindOperations_implneg_4_edge__edge7, BindOperations_node_cl);

			bool[,] BindOperations_implneg_5_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] BindOperations_implneg_5_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] BindOperations_implneg_5_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] BindOperations_implneg_5_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternEdge BindOperations_implneg_5_edge__edge8 = new GRGEN_LGSP.PatternEdge(false, (int) GRGEN_MODEL.EdgeTypes.@AEdge, "GRGEN_LIBGR.IEdge", "BindOperations_implneg_5_edge__edge8", "_edge8", BindOperations_implneg_5_edge__edge8_AllowedTypes, BindOperations_implneg_5_edge__edge8_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			BindOperations_implneg_5 = new GRGEN_LGSP.PatternGraph(
				"implneg_5",
				"BindOperations_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { BindOperations_node_cl }, 
				new GRGEN_LGSP.PatternEdge[] { BindOperations_implneg_5_edge__edge8 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				BindOperations_implneg_5_isNodeHomomorphicGlobal,
				BindOperations_implneg_5_isEdgeHomomorphicGlobal,
				BindOperations_implneg_5_isNodeTotallyHomomorphic,
				BindOperations_implneg_5_isEdgeTotallyHomomorphic
			);
			BindOperations_implneg_5.edgeToSourceNode.Add(BindOperations_implneg_5_edge__edge8, BindOperations_node_cl);
			BindOperations_implneg_5.edgeToTargetNode.Add(BindOperations_implneg_5_edge__edge8, BindOperations_node_cl);

			pat_BindOperations = new GRGEN_LGSP.PatternGraph(
				"BindOperations",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { BindOperations_node_op, BindOperations_node_body, BindOperations_node_cl }, 
				new GRGEN_LGSP.PatternEdge[] { BindOperations_edge__edge0, BindOperations_edge__edge1 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] { BindOperations_implneg_0, BindOperations_implneg_1, BindOperations_implneg_2, BindOperations_implneg_3, BindOperations_implneg_4, BindOperations_implneg_5,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				BindOperations_isNodeHomomorphicGlobal,
				BindOperations_isEdgeHomomorphicGlobal,
				BindOperations_isNodeTotallyHomomorphic,
				BindOperations_isEdgeTotallyHomomorphic
			);
			pat_BindOperations.edgeToSourceNode.Add(BindOperations_edge__edge0, BindOperations_node_op);
			pat_BindOperations.edgeToTargetNode.Add(BindOperations_edge__edge0, BindOperations_node_body);
			pat_BindOperations.edgeToSourceNode.Add(BindOperations_edge__edge1, BindOperations_node_body);
			pat_BindOperations.edgeToTargetNode.Add(BindOperations_edge__edge1, BindOperations_node_cl);
			BindOperations_implneg_0.embeddingGraph = pat_BindOperations;
			BindOperations_implneg_1.embeddingGraph = pat_BindOperations;
			BindOperations_implneg_2.embeddingGraph = pat_BindOperations;
			BindOperations_implneg_3.embeddingGraph = pat_BindOperations;
			BindOperations_implneg_4.embeddingGraph = pat_BindOperations;
			BindOperations_implneg_5.embeddingGraph = pat_BindOperations;

			BindOperations_node_op.pointOfDefinition = pat_BindOperations;
			BindOperations_node_body.pointOfDefinition = pat_BindOperations;
			BindOperations_node_cl.pointOfDefinition = pat_BindOperations;
			BindOperations_edge__edge0.pointOfDefinition = pat_BindOperations;
			BindOperations_edge__edge1.pointOfDefinition = pat_BindOperations;
			BindOperations_implneg_0_edge__edge3.pointOfDefinition = BindOperations_implneg_0;
			BindOperations_implneg_1_edge__edge4.pointOfDefinition = BindOperations_implneg_1;
			BindOperations_implneg_2_edge__edge5.pointOfDefinition = BindOperations_implneg_2;
			BindOperations_implneg_3_edge__edge6.pointOfDefinition = BindOperations_implneg_3;
			BindOperations_implneg_4_edge__edge7.pointOfDefinition = BindOperations_implneg_4;
			BindOperations_implneg_5_edge__edge8.pointOfDefinition = BindOperations_implneg_5;

			patternGraph = pat_BindOperations;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_BindOperations curMatch = (Match_BindOperations)_curMatch;
			GRGEN_LGSP.LGSPNode node_op = curMatch._node_op;
			GRGEN_LGSP.LGSPNode node_cl = curMatch._node_cl;
			graph.SettingAddedNodeNames( BindOperations_addedNodeNames );
			graph.SettingAddedEdgeNames( BindOperations_addedEdgeNames );
			GRGEN_MODEL.@inClass edge__edge2 = GRGEN_MODEL.@inClass.CreateEdge(graph, node_op, node_cl);
			return;
		}
		private static string[] BindOperations_addedNodeNames = new string[] {  };
		private static string[] BindOperations_addedEdgeNames = new string[] { "_edge2" };

		static Rule_BindOperations() {
		}

		public interface IMatch_BindOperations : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IMethodBody node_body { get; }
			GRGEN_MODEL.IClass node_cl { get; }
			//Edges
			GRGEN_MODEL.Ibinding edge__edge0 { get; }
			GRGEN_MODEL.IbelongsTo edge__edge1 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_BindOperations_implneg_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			//Edges
			GRGEN_LIBGR.IEdge edge__edge3 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_BindOperations_implneg_1 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IMethodBody node_body { get; }
			//Edges
			GRGEN_MODEL.Ibinding edge__edge0 { get; }
			GRGEN_LIBGR.IEdge edge__edge4 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_BindOperations_implneg_2 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IClass node_cl { get; }
			//Edges
			GRGEN_LIBGR.IEdge edge__edge5 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_BindOperations_implneg_3 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IMethodBody node_body { get; }
			//Edges
			GRGEN_LIBGR.IEdge edge__edge6 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_BindOperations_implneg_4 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IMethodBody node_body { get; }
			GRGEN_MODEL.IClass node_cl { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge1 { get; }
			GRGEN_LIBGR.IEdge edge__edge7 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_BindOperations_implneg_5 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IClass node_cl { get; }
			//Edges
			GRGEN_LIBGR.IEdge edge__edge8 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_BindOperations : GRGEN_LGSP.ListElement<Match_BindOperations>, IMatch_BindOperations
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IMethodBody node_body { get { return (GRGEN_MODEL.IMethodBody)_node_body; } }
			public GRGEN_MODEL.IClass node_cl { get { return (GRGEN_MODEL.IClass)_node_cl; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_body;
			public GRGEN_LGSP.LGSPNode _node_cl;
			public enum BindOperations_NodeNums { @op, @body, @cl, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_NodeNums.@op: return _node_op;
				case (int)BindOperations_NodeNums.@body: return _node_body;
				case (int)BindOperations_NodeNums.@cl: return _node_cl;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ibinding edge__edge0 { get { return (GRGEN_MODEL.Ibinding)_edge__edge0; } }
			public GRGEN_MODEL.IbelongsTo edge__edge1 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge1; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge__edge1;
			public enum BindOperations_EdgeNums { @_edge0, @_edge1, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_EdgeNums.@_edge0: return _edge__edge0;
				case (int)BindOperations_EdgeNums.@_edge1: return _edge__edge1;
				default: return null;
				}
			}
			
			public enum BindOperations_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_BindOperations.instance.pat_BindOperations; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_BindOperations_implneg_0 : GRGEN_LGSP.ListElement<Match_BindOperations_implneg_0>, IMatch_BindOperations_implneg_0
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public enum BindOperations_implneg_0_NodeNums { @op, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_0_NodeNums.@op: return _node_op;
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IEdge edge__edge3 { get { return (GRGEN_LIBGR.IEdge)_edge__edge3; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge3;
			public enum BindOperations_implneg_0_EdgeNums { @_edge3, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_0_EdgeNums.@_edge3: return _edge__edge3;
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_0_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_BindOperations.instance.BindOperations_implneg_0; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_BindOperations_implneg_1 : GRGEN_LGSP.ListElement<Match_BindOperations_implneg_1>, IMatch_BindOperations_implneg_1
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IMethodBody node_body { get { return (GRGEN_MODEL.IMethodBody)_node_body; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_body;
			public enum BindOperations_implneg_1_NodeNums { @op, @body, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_1_NodeNums.@op: return _node_op;
				case (int)BindOperations_implneg_1_NodeNums.@body: return _node_body;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ibinding edge__edge0 { get { return (GRGEN_MODEL.Ibinding)_edge__edge0; } }
			public GRGEN_LIBGR.IEdge edge__edge4 { get { return (GRGEN_LIBGR.IEdge)_edge__edge4; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge__edge4;
			public enum BindOperations_implneg_1_EdgeNums { @_edge0, @_edge4, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_1_EdgeNums.@_edge0: return _edge__edge0;
				case (int)BindOperations_implneg_1_EdgeNums.@_edge4: return _edge__edge4;
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_1_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_1_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_1_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_1_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_1_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_BindOperations.instance.BindOperations_implneg_1; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_BindOperations_implneg_2 : GRGEN_LGSP.ListElement<Match_BindOperations_implneg_2>, IMatch_BindOperations_implneg_2
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IClass node_cl { get { return (GRGEN_MODEL.IClass)_node_cl; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_cl;
			public enum BindOperations_implneg_2_NodeNums { @op, @cl, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_2_NodeNums.@op: return _node_op;
				case (int)BindOperations_implneg_2_NodeNums.@cl: return _node_cl;
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IEdge edge__edge5 { get { return (GRGEN_LIBGR.IEdge)_edge__edge5; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge5;
			public enum BindOperations_implneg_2_EdgeNums { @_edge5, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_2_EdgeNums.@_edge5: return _edge__edge5;
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_2_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_2_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_2_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_2_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_2_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_BindOperations.instance.BindOperations_implneg_2; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_BindOperations_implneg_3 : GRGEN_LGSP.ListElement<Match_BindOperations_implneg_3>, IMatch_BindOperations_implneg_3
		{
			public GRGEN_MODEL.IMethodBody node_body { get { return (GRGEN_MODEL.IMethodBody)_node_body; } }
			public GRGEN_LGSP.LGSPNode _node_body;
			public enum BindOperations_implneg_3_NodeNums { @body, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_3_NodeNums.@body: return _node_body;
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IEdge edge__edge6 { get { return (GRGEN_LIBGR.IEdge)_edge__edge6; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge6;
			public enum BindOperations_implneg_3_EdgeNums { @_edge6, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_3_EdgeNums.@_edge6: return _edge__edge6;
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_3_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_3_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_3_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_3_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_3_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_BindOperations.instance.BindOperations_implneg_3; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_BindOperations_implneg_4 : GRGEN_LGSP.ListElement<Match_BindOperations_implneg_4>, IMatch_BindOperations_implneg_4
		{
			public GRGEN_MODEL.IMethodBody node_body { get { return (GRGEN_MODEL.IMethodBody)_node_body; } }
			public GRGEN_MODEL.IClass node_cl { get { return (GRGEN_MODEL.IClass)_node_cl; } }
			public GRGEN_LGSP.LGSPNode _node_body;
			public GRGEN_LGSP.LGSPNode _node_cl;
			public enum BindOperations_implneg_4_NodeNums { @body, @cl, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_4_NodeNums.@body: return _node_body;
				case (int)BindOperations_implneg_4_NodeNums.@cl: return _node_cl;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge1 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge1; } }
			public GRGEN_LIBGR.IEdge edge__edge7 { get { return (GRGEN_LIBGR.IEdge)_edge__edge7; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge1;
			public GRGEN_LGSP.LGSPEdge _edge__edge7;
			public enum BindOperations_implneg_4_EdgeNums { @_edge1, @_edge7, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_4_EdgeNums.@_edge1: return _edge__edge1;
				case (int)BindOperations_implneg_4_EdgeNums.@_edge7: return _edge__edge7;
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_4_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_4_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_4_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_4_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_4_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_BindOperations.instance.BindOperations_implneg_4; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_BindOperations_implneg_5 : GRGEN_LGSP.ListElement<Match_BindOperations_implneg_5>, IMatch_BindOperations_implneg_5
		{
			public GRGEN_MODEL.IClass node_cl { get { return (GRGEN_MODEL.IClass)_node_cl; } }
			public GRGEN_LGSP.LGSPNode _node_cl;
			public enum BindOperations_implneg_5_NodeNums { @cl, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_5_NodeNums.@cl: return _node_cl;
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IEdge edge__edge8 { get { return (GRGEN_LIBGR.IEdge)_edge__edge8; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge8;
			public enum BindOperations_implneg_5_EdgeNums { @_edge8, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)BindOperations_implneg_5_EdgeNums.@_edge8: return _edge__edge8;
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_5_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_5_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_5_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_5_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum BindOperations_implneg_5_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_BindOperations.instance.BindOperations_implneg_5; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_InitMoveIntoBlocks : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_InitMoveIntoBlocks instance = null;
		public static Rule_InitMoveIntoBlocks Instance { get { if (instance==null) { instance = new Rule_InitMoveIntoBlocks(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] InitMoveIntoBlocks_node_b_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] InitMoveIntoBlocks_node_exp_AllowedTypes = null;
		public static bool[] InitMoveIntoBlocks_node_b_IsAllowedType = null;
		public static bool[] InitMoveIntoBlocks_node_exp_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] InitMoveIntoBlocks_edge__edge0_AllowedTypes = null;
		public static bool[] InitMoveIntoBlocks_edge__edge0_IsAllowedType = null;
		public enum InitMoveIntoBlocks_NodeNums { @b, @exp, };
		public enum InitMoveIntoBlocks_EdgeNums { @_edge0, };
		public enum InitMoveIntoBlocks_VariableNums { };
		public enum InitMoveIntoBlocks_SubNums { };
		public enum InitMoveIntoBlocks_AltNums { };
		public enum InitMoveIntoBlocks_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_InitMoveIntoBlocks;

		public static GRGEN_LIBGR.EdgeType[] InitMoveIntoBlocks_neg_0_edge__edge0_AllowedTypes = null;
		public static bool[] InitMoveIntoBlocks_neg_0_edge__edge0_IsAllowedType = null;
		public enum InitMoveIntoBlocks_neg_0_NodeNums { @exp, @b, };
		public enum InitMoveIntoBlocks_neg_0_EdgeNums { @_edge0, };
		public enum InitMoveIntoBlocks_neg_0_VariableNums { };
		public enum InitMoveIntoBlocks_neg_0_SubNums { };
		public enum InitMoveIntoBlocks_neg_0_AltNums { };
		public enum InitMoveIntoBlocks_neg_0_IterNums { };

		public GRGEN_LGSP.PatternGraph InitMoveIntoBlocks_neg_0;


		private Rule_InitMoveIntoBlocks()
		{
			name = "InitMoveIntoBlocks";

			inputs = new GRGEN_LIBGR.GrGenType[] { };
			inputNames = new string[] { };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] InitMoveIntoBlocks_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] InitMoveIntoBlocks_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] InitMoveIntoBlocks_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] InitMoveIntoBlocks_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode InitMoveIntoBlocks_node_b = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Block, "GRGEN_MODEL.IBlock", "InitMoveIntoBlocks_node_b", "b", InitMoveIntoBlocks_node_b_AllowedTypes, InitMoveIntoBlocks_node_b_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode InitMoveIntoBlocks_node_exp = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "InitMoveIntoBlocks_node_exp", "exp", InitMoveIntoBlocks_node_exp_AllowedTypes, InitMoveIntoBlocks_node_exp_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge InitMoveIntoBlocks_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "InitMoveIntoBlocks_edge__edge0", "_edge0", InitMoveIntoBlocks_edge__edge0_AllowedTypes, InitMoveIntoBlocks_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			bool[,] InitMoveIntoBlocks_neg_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] InitMoveIntoBlocks_neg_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] InitMoveIntoBlocks_neg_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] InitMoveIntoBlocks_neg_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternEdge InitMoveIntoBlocks_neg_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@inBlock, "GRGEN_MODEL.IinBlock", "InitMoveIntoBlocks_neg_0_edge__edge0", "_edge0", InitMoveIntoBlocks_neg_0_edge__edge0_AllowedTypes, InitMoveIntoBlocks_neg_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			InitMoveIntoBlocks_neg_0 = new GRGEN_LGSP.PatternGraph(
				"neg_0",
				"InitMoveIntoBlocks_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { InitMoveIntoBlocks_node_exp, InitMoveIntoBlocks_node_b }, 
				new GRGEN_LGSP.PatternEdge[] { InitMoveIntoBlocks_neg_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				InitMoveIntoBlocks_neg_0_isNodeHomomorphicGlobal,
				InitMoveIntoBlocks_neg_0_isEdgeHomomorphicGlobal,
				InitMoveIntoBlocks_neg_0_isNodeTotallyHomomorphic,
				InitMoveIntoBlocks_neg_0_isEdgeTotallyHomomorphic
			);
			InitMoveIntoBlocks_neg_0.edgeToSourceNode.Add(InitMoveIntoBlocks_neg_0_edge__edge0, InitMoveIntoBlocks_node_exp);
			InitMoveIntoBlocks_neg_0.edgeToTargetNode.Add(InitMoveIntoBlocks_neg_0_edge__edge0, InitMoveIntoBlocks_node_b);

			pat_InitMoveIntoBlocks = new GRGEN_LGSP.PatternGraph(
				"InitMoveIntoBlocks",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { InitMoveIntoBlocks_node_b, InitMoveIntoBlocks_node_exp }, 
				new GRGEN_LGSP.PatternEdge[] { InitMoveIntoBlocks_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] { InitMoveIntoBlocks_neg_0,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				InitMoveIntoBlocks_isNodeHomomorphicGlobal,
				InitMoveIntoBlocks_isEdgeHomomorphicGlobal,
				InitMoveIntoBlocks_isNodeTotallyHomomorphic,
				InitMoveIntoBlocks_isEdgeTotallyHomomorphic
			);
			pat_InitMoveIntoBlocks.edgeToSourceNode.Add(InitMoveIntoBlocks_edge__edge0, InitMoveIntoBlocks_node_b);
			pat_InitMoveIntoBlocks.edgeToTargetNode.Add(InitMoveIntoBlocks_edge__edge0, InitMoveIntoBlocks_node_exp);
			InitMoveIntoBlocks_neg_0.embeddingGraph = pat_InitMoveIntoBlocks;

			InitMoveIntoBlocks_node_b.pointOfDefinition = pat_InitMoveIntoBlocks;
			InitMoveIntoBlocks_node_exp.pointOfDefinition = pat_InitMoveIntoBlocks;
			InitMoveIntoBlocks_edge__edge0.pointOfDefinition = pat_InitMoveIntoBlocks;
			InitMoveIntoBlocks_neg_0_edge__edge0.pointOfDefinition = InitMoveIntoBlocks_neg_0;

			patternGraph = pat_InitMoveIntoBlocks;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_InitMoveIntoBlocks curMatch = (Match_InitMoveIntoBlocks)_curMatch;
			GRGEN_LGSP.LGSPNode node_exp = curMatch._node_exp;
			GRGEN_LGSP.LGSPNode node_b = curMatch._node_b;
			graph.SettingAddedNodeNames( InitMoveIntoBlocks_addedNodeNames );
			graph.SettingAddedEdgeNames( InitMoveIntoBlocks_addedEdgeNames );
			GRGEN_MODEL.@inBlock edge__edge1 = GRGEN_MODEL.@inBlock.CreateEdge(graph, node_exp, node_b);
			return;
		}
		private static string[] InitMoveIntoBlocks_addedNodeNames = new string[] {  };
		private static string[] InitMoveIntoBlocks_addedEdgeNames = new string[] { "_edge1" };

		static Rule_InitMoveIntoBlocks() {
		}

		public interface IMatch_InitMoveIntoBlocks : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IBlock node_b { get; }
			GRGEN_MODEL.IExpression node_exp { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_InitMoveIntoBlocks_neg_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IExpression node_exp { get; }
			GRGEN_MODEL.IBlock node_b { get; }
			//Edges
			GRGEN_MODEL.IinBlock edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_InitMoveIntoBlocks : GRGEN_LGSP.ListElement<Match_InitMoveIntoBlocks>, IMatch_InitMoveIntoBlocks
		{
			public GRGEN_MODEL.IBlock node_b { get { return (GRGEN_MODEL.IBlock)_node_b; } }
			public GRGEN_MODEL.IExpression node_exp { get { return (GRGEN_MODEL.IExpression)_node_exp; } }
			public GRGEN_LGSP.LGSPNode _node_b;
			public GRGEN_LGSP.LGSPNode _node_exp;
			public enum InitMoveIntoBlocks_NodeNums { @b, @exp, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)InitMoveIntoBlocks_NodeNums.@b: return _node_b;
				case (int)InitMoveIntoBlocks_NodeNums.@exp: return _node_exp;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge__edge0 { get { return (GRGEN_MODEL.Iexpression)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum InitMoveIntoBlocks_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)InitMoveIntoBlocks_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum InitMoveIntoBlocks_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InitMoveIntoBlocks_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InitMoveIntoBlocks_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InitMoveIntoBlocks_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InitMoveIntoBlocks_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_InitMoveIntoBlocks.instance.pat_InitMoveIntoBlocks; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_InitMoveIntoBlocks_neg_0 : GRGEN_LGSP.ListElement<Match_InitMoveIntoBlocks_neg_0>, IMatch_InitMoveIntoBlocks_neg_0
		{
			public GRGEN_MODEL.IExpression node_exp { get { return (GRGEN_MODEL.IExpression)_node_exp; } }
			public GRGEN_MODEL.IBlock node_b { get { return (GRGEN_MODEL.IBlock)_node_b; } }
			public GRGEN_LGSP.LGSPNode _node_exp;
			public GRGEN_LGSP.LGSPNode _node_b;
			public enum InitMoveIntoBlocks_neg_0_NodeNums { @exp, @b, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)InitMoveIntoBlocks_neg_0_NodeNums.@exp: return _node_exp;
				case (int)InitMoveIntoBlocks_neg_0_NodeNums.@b: return _node_b;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IinBlock edge__edge0 { get { return (GRGEN_MODEL.IinBlock)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum InitMoveIntoBlocks_neg_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)InitMoveIntoBlocks_neg_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum InitMoveIntoBlocks_neg_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InitMoveIntoBlocks_neg_0_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InitMoveIntoBlocks_neg_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InitMoveIntoBlocks_neg_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum InitMoveIntoBlocks_neg_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_InitMoveIntoBlocks.instance.InitMoveIntoBlocks_neg_0; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_MoveIntoBlocks : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_MoveIntoBlocks instance = null;
		public static Rule_MoveIntoBlocks Instance { get { if (instance==null) { instance = new Rule_MoveIntoBlocks(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] MoveIntoBlocks_node__node0_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] MoveIntoBlocks_node_b_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] MoveIntoBlocks_node_exp_AllowedTypes = null;
		public static bool[] MoveIntoBlocks_node__node0_IsAllowedType = null;
		public static bool[] MoveIntoBlocks_node_b_IsAllowedType = null;
		public static bool[] MoveIntoBlocks_node_exp_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] MoveIntoBlocks_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] MoveIntoBlocks_edge_e_AllowedTypes = null;
		public static bool[] MoveIntoBlocks_edge__edge0_IsAllowedType = null;
		public static bool[] MoveIntoBlocks_edge_e_IsAllowedType = null;
		public enum MoveIntoBlocks_NodeNums { @_node0, @b, @exp, };
		public enum MoveIntoBlocks_EdgeNums { @_edge0, @e, };
		public enum MoveIntoBlocks_VariableNums { };
		public enum MoveIntoBlocks_SubNums { };
		public enum MoveIntoBlocks_AltNums { };
		public enum MoveIntoBlocks_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_MoveIntoBlocks;

		public static GRGEN_LIBGR.EdgeType[] MoveIntoBlocks_neg_0_edge__edge0_AllowedTypes = null;
		public static bool[] MoveIntoBlocks_neg_0_edge__edge0_IsAllowedType = null;
		public enum MoveIntoBlocks_neg_0_NodeNums { @exp, @b, };
		public enum MoveIntoBlocks_neg_0_EdgeNums { @_edge0, };
		public enum MoveIntoBlocks_neg_0_VariableNums { };
		public enum MoveIntoBlocks_neg_0_SubNums { };
		public enum MoveIntoBlocks_neg_0_AltNums { };
		public enum MoveIntoBlocks_neg_0_IterNums { };

		public GRGEN_LGSP.PatternGraph MoveIntoBlocks_neg_0;


		private Rule_MoveIntoBlocks()
		{
			name = "MoveIntoBlocks";

			inputs = new GRGEN_LIBGR.GrGenType[] { };
			inputNames = new string[] { };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] MoveIntoBlocks_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] MoveIntoBlocks_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] MoveIntoBlocks_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] MoveIntoBlocks_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternNode MoveIntoBlocks_node__node0 = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "MoveIntoBlocks_node__node0", "_node0", MoveIntoBlocks_node__node0_AllowedTypes, MoveIntoBlocks_node__node0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode MoveIntoBlocks_node_b = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Block, "GRGEN_MODEL.IBlock", "MoveIntoBlocks_node_b", "b", MoveIntoBlocks_node_b_AllowedTypes, MoveIntoBlocks_node_b_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode MoveIntoBlocks_node_exp = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "MoveIntoBlocks_node_exp", "exp", MoveIntoBlocks_node_exp_AllowedTypes, MoveIntoBlocks_node_exp_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MoveIntoBlocks_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@inBlock, "GRGEN_MODEL.IinBlock", "MoveIntoBlocks_edge__edge0", "_edge0", MoveIntoBlocks_edge__edge0_AllowedTypes, MoveIntoBlocks_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge MoveIntoBlocks_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@Edge, "GRGEN_LIBGR.IEdge", "MoveIntoBlocks_edge_e", "e", MoveIntoBlocks_edge_e_AllowedTypes, MoveIntoBlocks_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition MoveIntoBlocks_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_OR(new GRGEN_EXPR.EQ(new GRGEN_EXPR.Typeof("MoveIntoBlocks_edge_e"), new GRGEN_EXPR.Constant("GRGEN_MODEL.EdgeType_expression.typeVar")), new GRGEN_EXPR.EQ(new GRGEN_EXPR.Typeof("MoveIntoBlocks_edge_e"), new GRGEN_EXPR.Constant("GRGEN_MODEL.EdgeType_actualParameter.typeVar"))),
				new string[] {  }, new string[] { "MoveIntoBlocks_edge_e" }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			bool[,] MoveIntoBlocks_neg_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] MoveIntoBlocks_neg_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] MoveIntoBlocks_neg_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] MoveIntoBlocks_neg_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternEdge MoveIntoBlocks_neg_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@inBlock, "GRGEN_MODEL.IinBlock", "MoveIntoBlocks_neg_0_edge__edge0", "_edge0", MoveIntoBlocks_neg_0_edge__edge0_AllowedTypes, MoveIntoBlocks_neg_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			MoveIntoBlocks_neg_0 = new GRGEN_LGSP.PatternGraph(
				"neg_0",
				"MoveIntoBlocks_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MoveIntoBlocks_node_exp, MoveIntoBlocks_node_b }, 
				new GRGEN_LGSP.PatternEdge[] { MoveIntoBlocks_neg_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				MoveIntoBlocks_neg_0_isNodeHomomorphicGlobal,
				MoveIntoBlocks_neg_0_isEdgeHomomorphicGlobal,
				MoveIntoBlocks_neg_0_isNodeTotallyHomomorphic,
				MoveIntoBlocks_neg_0_isEdgeTotallyHomomorphic
			);
			MoveIntoBlocks_neg_0.edgeToSourceNode.Add(MoveIntoBlocks_neg_0_edge__edge0, MoveIntoBlocks_node_exp);
			MoveIntoBlocks_neg_0.edgeToTargetNode.Add(MoveIntoBlocks_neg_0_edge__edge0, MoveIntoBlocks_node_b);

			pat_MoveIntoBlocks = new GRGEN_LGSP.PatternGraph(
				"MoveIntoBlocks",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { MoveIntoBlocks_node__node0, MoveIntoBlocks_node_b, MoveIntoBlocks_node_exp }, 
				new GRGEN_LGSP.PatternEdge[] { MoveIntoBlocks_edge__edge0, MoveIntoBlocks_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] { MoveIntoBlocks_neg_0,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { MoveIntoBlocks_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				MoveIntoBlocks_isNodeHomomorphicGlobal,
				MoveIntoBlocks_isEdgeHomomorphicGlobal,
				MoveIntoBlocks_isNodeTotallyHomomorphic,
				MoveIntoBlocks_isEdgeTotallyHomomorphic
			);
			pat_MoveIntoBlocks.edgeToSourceNode.Add(MoveIntoBlocks_edge__edge0, MoveIntoBlocks_node__node0);
			pat_MoveIntoBlocks.edgeToTargetNode.Add(MoveIntoBlocks_edge__edge0, MoveIntoBlocks_node_b);
			pat_MoveIntoBlocks.edgeToSourceNode.Add(MoveIntoBlocks_edge_e, MoveIntoBlocks_node__node0);
			pat_MoveIntoBlocks.edgeToTargetNode.Add(MoveIntoBlocks_edge_e, MoveIntoBlocks_node_exp);
			MoveIntoBlocks_neg_0.embeddingGraph = pat_MoveIntoBlocks;

			MoveIntoBlocks_node__node0.pointOfDefinition = pat_MoveIntoBlocks;
			MoveIntoBlocks_node_b.pointOfDefinition = pat_MoveIntoBlocks;
			MoveIntoBlocks_node_exp.pointOfDefinition = pat_MoveIntoBlocks;
			MoveIntoBlocks_edge__edge0.pointOfDefinition = pat_MoveIntoBlocks;
			MoveIntoBlocks_edge_e.pointOfDefinition = pat_MoveIntoBlocks;
			MoveIntoBlocks_neg_0_edge__edge0.pointOfDefinition = MoveIntoBlocks_neg_0;

			patternGraph = pat_MoveIntoBlocks;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_MoveIntoBlocks curMatch = (Match_MoveIntoBlocks)_curMatch;
			GRGEN_LGSP.LGSPNode node_exp = curMatch._node_exp;
			GRGEN_LGSP.LGSPNode node_b = curMatch._node_b;
			graph.SettingAddedNodeNames( MoveIntoBlocks_addedNodeNames );
			graph.SettingAddedEdgeNames( MoveIntoBlocks_addedEdgeNames );
			GRGEN_MODEL.@inBlock edge__edge1 = GRGEN_MODEL.@inBlock.CreateEdge(graph, node_exp, node_b);
			return;
		}
		private static string[] MoveIntoBlocks_addedNodeNames = new string[] {  };
		private static string[] MoveIntoBlocks_addedEdgeNames = new string[] { "_edge1" };

		static Rule_MoveIntoBlocks() {
		}

		public interface IMatch_MoveIntoBlocks : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IExpression node__node0 { get; }
			GRGEN_MODEL.IBlock node_b { get; }
			GRGEN_MODEL.IExpression node_exp { get; }
			//Edges
			GRGEN_MODEL.IinBlock edge__edge0 { get; }
			GRGEN_LIBGR.IEdge edge_e { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_MoveIntoBlocks_neg_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IExpression node_exp { get; }
			GRGEN_MODEL.IBlock node_b { get; }
			//Edges
			GRGEN_MODEL.IinBlock edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_MoveIntoBlocks : GRGEN_LGSP.ListElement<Match_MoveIntoBlocks>, IMatch_MoveIntoBlocks
		{
			public GRGEN_MODEL.IExpression node__node0 { get { return (GRGEN_MODEL.IExpression)_node__node0; } }
			public GRGEN_MODEL.IBlock node_b { get { return (GRGEN_MODEL.IBlock)_node_b; } }
			public GRGEN_MODEL.IExpression node_exp { get { return (GRGEN_MODEL.IExpression)_node_exp; } }
			public GRGEN_LGSP.LGSPNode _node__node0;
			public GRGEN_LGSP.LGSPNode _node_b;
			public GRGEN_LGSP.LGSPNode _node_exp;
			public enum MoveIntoBlocks_NodeNums { @_node0, @b, @exp, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MoveIntoBlocks_NodeNums.@_node0: return _node__node0;
				case (int)MoveIntoBlocks_NodeNums.@b: return _node_b;
				case (int)MoveIntoBlocks_NodeNums.@exp: return _node_exp;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IinBlock edge__edge0 { get { return (GRGEN_MODEL.IinBlock)_edge__edge0; } }
			public GRGEN_LIBGR.IEdge edge_e { get { return (GRGEN_LIBGR.IEdge)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum MoveIntoBlocks_EdgeNums { @_edge0, @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MoveIntoBlocks_EdgeNums.@_edge0: return _edge__edge0;
				case (int)MoveIntoBlocks_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public enum MoveIntoBlocks_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MoveIntoBlocks_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MoveIntoBlocks_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MoveIntoBlocks_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MoveIntoBlocks_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_MoveIntoBlocks.instance.pat_MoveIntoBlocks; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_MoveIntoBlocks_neg_0 : GRGEN_LGSP.ListElement<Match_MoveIntoBlocks_neg_0>, IMatch_MoveIntoBlocks_neg_0
		{
			public GRGEN_MODEL.IExpression node_exp { get { return (GRGEN_MODEL.IExpression)_node_exp; } }
			public GRGEN_MODEL.IBlock node_b { get { return (GRGEN_MODEL.IBlock)_node_b; } }
			public GRGEN_LGSP.LGSPNode _node_exp;
			public GRGEN_LGSP.LGSPNode _node_b;
			public enum MoveIntoBlocks_neg_0_NodeNums { @exp, @b, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)MoveIntoBlocks_neg_0_NodeNums.@exp: return _node_exp;
				case (int)MoveIntoBlocks_neg_0_NodeNums.@b: return _node_b;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IinBlock edge__edge0 { get { return (GRGEN_MODEL.IinBlock)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum MoveIntoBlocks_neg_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)MoveIntoBlocks_neg_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum MoveIntoBlocks_neg_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MoveIntoBlocks_neg_0_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MoveIntoBlocks_neg_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MoveIntoBlocks_neg_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum MoveIntoBlocks_neg_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_MoveIntoBlocks.instance.MoveIntoBlocks_neg_0; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_getClassAndVariable : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_getClassAndVariable instance = null;
		public static Rule_getClassAndVariable Instance { get { if (instance==null) { instance = new Rule_getClassAndVariable(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] getClassAndVariable_node_c_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] getClassAndVariable_node_v_AllowedTypes = null;
		public static bool[] getClassAndVariable_node_c_IsAllowedType = null;
		public static bool[] getClassAndVariable_node_v_IsAllowedType = null;
		public enum getClassAndVariable_NodeNums { @c, @v, };
		public enum getClassAndVariable_EdgeNums { };
		public enum getClassAndVariable_VariableNums { };
		public enum getClassAndVariable_SubNums { };
		public enum getClassAndVariable_AltNums { };
		public enum getClassAndVariable_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_getClassAndVariable;


		private Rule_getClassAndVariable()
		{
			name = "getClassAndVariable";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Variable.typeVar, };
			inputNames = new string[] { "getClassAndVariable_node_c", "getClassAndVariable_node_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Variable.typeVar, };

		}
		private void initialize()
		{
			bool[,] getClassAndVariable_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] getClassAndVariable_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] getClassAndVariable_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] getClassAndVariable_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode getClassAndVariable_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "getClassAndVariable_node_c", "c", getClassAndVariable_node_c_AllowedTypes, getClassAndVariable_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode getClassAndVariable_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "getClassAndVariable_node_v", "v", getClassAndVariable_node_v_AllowedTypes, getClassAndVariable_node_v_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			pat_getClassAndVariable = new GRGEN_LGSP.PatternGraph(
				"getClassAndVariable",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { getClassAndVariable_node_c, getClassAndVariable_node_v }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[0, 0] ,
				getClassAndVariable_isNodeHomomorphicGlobal,
				getClassAndVariable_isEdgeHomomorphicGlobal,
				getClassAndVariable_isNodeTotallyHomomorphic,
				getClassAndVariable_isEdgeTotallyHomomorphic
			);

			getClassAndVariable_node_c.pointOfDefinition = null;
			getClassAndVariable_node_v.pointOfDefinition = null;

			patternGraph = pat_getClassAndVariable;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IClass output_0, out GRGEN_MODEL.IVariable output_1)
		{
			Match_getClassAndVariable curMatch = (Match_getClassAndVariable)_curMatch;
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPNode node_v = curMatch._node_v;
			output_0 = (GRGEN_MODEL.IClass)(node_c);
			output_1 = (GRGEN_MODEL.IVariable)(node_v);
			return;
		}

		static Rule_getClassAndVariable() {
		}

		public interface IMatch_getClassAndVariable : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IClass node_c { get; }
			GRGEN_MODEL.IVariable node_v { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_getClassAndVariable : GRGEN_LGSP.ListElement<Match_getClassAndVariable>, IMatch_getClassAndVariable
		{
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_v;
			public enum getClassAndVariable_NodeNums { @c, @v, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)getClassAndVariable_NodeNums.@c: return _node_c;
				case (int)getClassAndVariable_NodeNums.@v: return _node_v;
				default: return null;
				}
			}
			
			public enum getClassAndVariable_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getClassAndVariable_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getClassAndVariable_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getClassAndVariable_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getClassAndVariable_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getClassAndVariable_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_getClassAndVariable.instance.pat_getClassAndVariable; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_variableInClass : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_variableInClass instance = null;
		public static Rule_variableInClass Instance { get { if (instance==null) { instance = new Rule_variableInClass(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] variableInClass_node_v_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] variableInClass_node_c_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] variableInClass_node__node0_AllowedTypes = null;
		public static bool[] variableInClass_node_v_IsAllowedType = null;
		public static bool[] variableInClass_node_c_IsAllowedType = null;
		public static bool[] variableInClass_node__node0_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] variableInClass_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] variableInClass_edge__edge1_AllowedTypes = null;
		public static bool[] variableInClass_edge__edge0_IsAllowedType = null;
		public static bool[] variableInClass_edge__edge1_IsAllowedType = null;
		public enum variableInClass_NodeNums { @v, @c, @_node0, };
		public enum variableInClass_EdgeNums { @_edge0, @_edge1, };
		public enum variableInClass_VariableNums { };
		public enum variableInClass_SubNums { };
		public enum variableInClass_AltNums { };
		public enum variableInClass_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_variableInClass;


		private Rule_variableInClass()
		{
			name = "variableInClass";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Variable.typeVar, };
			inputNames = new string[] { "variableInClass_node_c", "variableInClass_node_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(bool)), };

		}
		private void initialize()
		{
			bool[,] variableInClass_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] variableInClass_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] variableInClass_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] variableInClass_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternNode variableInClass_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "variableInClass_node_v", "v", variableInClass_node_v_AllowedTypes, variableInClass_node_v_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode variableInClass_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "variableInClass_node_c", "c", variableInClass_node_c_AllowedTypes, variableInClass_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode variableInClass_node__node0 = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "variableInClass_node__node0", "_node0", variableInClass_node__node0_AllowedTypes, variableInClass_node__node0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge variableInClass_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "variableInClass_edge__edge0", "_edge0", variableInClass_edge__edge0_AllowedTypes, variableInClass_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge variableInClass_edge__edge1 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@type_, "GRGEN_MODEL.Itype_", "variableInClass_edge__edge1", "_edge1", variableInClass_edge__edge1_AllowedTypes, variableInClass_edge__edge1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_variableInClass = new GRGEN_LGSP.PatternGraph(
				"variableInClass",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { variableInClass_node_v, variableInClass_node_c, variableInClass_node__node0 }, 
				new GRGEN_LGSP.PatternEdge[] { variableInClass_edge__edge0, variableInClass_edge__edge1 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				variableInClass_isNodeHomomorphicGlobal,
				variableInClass_isEdgeHomomorphicGlobal,
				variableInClass_isNodeTotallyHomomorphic,
				variableInClass_isEdgeTotallyHomomorphic
			);
			pat_variableInClass.edgeToSourceNode.Add(variableInClass_edge__edge0, variableInClass_node_v);
			pat_variableInClass.edgeToTargetNode.Add(variableInClass_edge__edge0, variableInClass_node_c);
			pat_variableInClass.edgeToSourceNode.Add(variableInClass_edge__edge1, variableInClass_node_v);
			pat_variableInClass.edgeToTargetNode.Add(variableInClass_edge__edge1, variableInClass_node__node0);

			variableInClass_node_v.pointOfDefinition = null;
			variableInClass_node_c.pointOfDefinition = null;
			variableInClass_node__node0.pointOfDefinition = pat_variableInClass;
			variableInClass_edge__edge0.pointOfDefinition = pat_variableInClass;
			variableInClass_edge__edge1.pointOfDefinition = pat_variableInClass;

			patternGraph = pat_variableInClass;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out bool output_0)
		{
			Match_variableInClass curMatch = (Match_variableInClass)_curMatch;
			GRGEN_MODEL.IVariable inode_v = curMatch.node_v;
			bool tempvar_node_v_isStatic = inode_v.@isStatic;
			output_0 = (bool) (tempvar_node_v_isStatic);
			return;
		}

		static Rule_variableInClass() {
		}

		public interface IMatch_variableInClass : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IVariable node_v { get; }
			GRGEN_MODEL.IClass node_c { get; }
			GRGEN_MODEL.IClass node__node0 { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge0 { get; }
			GRGEN_MODEL.Itype_ edge__edge1 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_variableInClass : GRGEN_LGSP.ListElement<Match_variableInClass>, IMatch_variableInClass
		{
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_MODEL.IClass node__node0 { get { return (GRGEN_MODEL.IClass)_node__node0; } }
			public GRGEN_LGSP.LGSPNode _node_v;
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node__node0;
			public enum variableInClass_NodeNums { @v, @c, @_node0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)variableInClass_NodeNums.@v: return _node_v;
				case (int)variableInClass_NodeNums.@c: return _node_c;
				case (int)variableInClass_NodeNums.@_node0: return _node__node0;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge0 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge0; } }
			public GRGEN_MODEL.Itype_ edge__edge1 { get { return (GRGEN_MODEL.Itype_)_edge__edge1; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge__edge1;
			public enum variableInClass_EdgeNums { @_edge0, @_edge1, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)variableInClass_EdgeNums.@_edge0: return _edge__edge0;
				case (int)variableInClass_EdgeNums.@_edge1: return _edge__edge1;
				default: return null;
				}
			}
			
			public enum variableInClass_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum variableInClass_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum variableInClass_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum variableInClass_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum variableInClass_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_variableInClass.instance.pat_variableInClass; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_methodExists : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_methodExists instance = null;
		public static Rule_methodExists Instance { get { if (instance==null) { instance = new Rule_methodExists(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] methodExists_node_mb_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] methodExists_node_c_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] methodExists_node_op_AllowedTypes = null;
		public static bool[] methodExists_node_mb_IsAllowedType = null;
		public static bool[] methodExists_node_c_IsAllowedType = null;
		public static bool[] methodExists_node_op_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] methodExists_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] methodExists_edge__edge1_AllowedTypes = null;
		public static bool[] methodExists_edge__edge0_IsAllowedType = null;
		public static bool[] methodExists_edge__edge1_IsAllowedType = null;
		public enum methodExists_NodeNums { @mb, @c, @op, };
		public enum methodExists_EdgeNums { @_edge0, @_edge1, };
		public enum methodExists_VariableNums { @name, };
		public enum methodExists_SubNums { };
		public enum methodExists_AltNums { };
		public enum methodExists_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_methodExists;


		private Rule_methodExists()
		{
			name = "methodExists";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_LIBGR.VarType.GetVarType(typeof(string)), };
			inputNames = new string[] { "methodExists_node_c", "methodExists_var_name", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, };

		}
		private void initialize()
		{
			bool[,] methodExists_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] methodExists_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] methodExists_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] methodExists_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternVariable methodExists_var_name = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(string)), "methodExists_var_name", "name", 1, false, null);
			GRGEN_LGSP.PatternNode methodExists_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "methodExists_node_mb", "mb", methodExists_node_mb_AllowedTypes, methodExists_node_mb_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode methodExists_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "methodExists_node_c", "c", methodExists_node_c_AllowedTypes, methodExists_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode methodExists_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "methodExists_node_op", "op", methodExists_node_op_AllowedTypes, methodExists_node_op_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge methodExists_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "methodExists_edge__edge0", "_edge0", methodExists_edge__edge0_AllowedTypes, methodExists_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge methodExists_edge__edge1 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@binding, "GRGEN_MODEL.Ibinding", "methodExists_edge__edge1", "_edge1", methodExists_edge__edge1_AllowedTypes, methodExists_edge__edge1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition methodExists_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.EQ(new GRGEN_EXPR.Qualification("GRGEN_MODEL.IOperation", "methodExists_node_op", "name"), new GRGEN_EXPR.VariableExpression("methodExists_var_name")),
				new string[] { "methodExists_node_op" }, new string[] {  }, new string[] { "methodExists_var_name" }, new GRGEN_LIBGR.VarType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(string)) });
			pat_methodExists = new GRGEN_LGSP.PatternGraph(
				"methodExists",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { methodExists_node_mb, methodExists_node_c, methodExists_node_op }, 
				new GRGEN_LGSP.PatternEdge[] { methodExists_edge__edge0, methodExists_edge__edge1 }, 
				new GRGEN_LGSP.PatternVariable[] { methodExists_var_name }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { methodExists_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				methodExists_isNodeHomomorphicGlobal,
				methodExists_isEdgeHomomorphicGlobal,
				methodExists_isNodeTotallyHomomorphic,
				methodExists_isEdgeTotallyHomomorphic
			);
			pat_methodExists.edgeToSourceNode.Add(methodExists_edge__edge0, methodExists_node_mb);
			pat_methodExists.edgeToTargetNode.Add(methodExists_edge__edge0, methodExists_node_c);
			pat_methodExists.edgeToSourceNode.Add(methodExists_edge__edge1, methodExists_node_op);
			pat_methodExists.edgeToTargetNode.Add(methodExists_edge__edge1, methodExists_node_mb);

			methodExists_node_mb.pointOfDefinition = pat_methodExists;
			methodExists_node_c.pointOfDefinition = null;
			methodExists_node_op.pointOfDefinition = pat_methodExists;
			methodExists_edge__edge0.pointOfDefinition = pat_methodExists;
			methodExists_edge__edge1.pointOfDefinition = pat_methodExists;

			patternGraph = pat_methodExists;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IOperation output_0)
		{
			Match_methodExists curMatch = (Match_methodExists)_curMatch;
			GRGEN_LGSP.LGSPNode node_op = curMatch._node_op;
			output_0 = (GRGEN_MODEL.IOperation)(node_op);
			return;
		}

		static Rule_methodExists() {
		}

		public interface IMatch_methodExists : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IMethodBody node_mb { get; }
			GRGEN_MODEL.IClass node_c { get; }
			GRGEN_MODEL.IOperation node_op { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge0 { get; }
			GRGEN_MODEL.Ibinding edge__edge1 { get; }
			//Variables
			string @var_name { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_methodExists : GRGEN_LGSP.ListElement<Match_methodExists>, IMatch_methodExists
		{
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_LGSP.LGSPNode _node_mb;
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_op;
			public enum methodExists_NodeNums { @mb, @c, @op, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)methodExists_NodeNums.@mb: return _node_mb;
				case (int)methodExists_NodeNums.@c: return _node_c;
				case (int)methodExists_NodeNums.@op: return _node_op;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge0 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge0; } }
			public GRGEN_MODEL.Ibinding edge__edge1 { get { return (GRGEN_MODEL.Ibinding)_edge__edge1; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge__edge1;
			public enum methodExists_EdgeNums { @_edge0, @_edge1, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)methodExists_EdgeNums.@_edge0: return _edge__edge0;
				case (int)methodExists_EdgeNums.@_edge1: return _edge__edge1;
				default: return null;
				}
			}
			
			public string var_name { get { return _var_name; } }
			public string _var_name;
			public enum methodExists_VariableNums { @name, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 1;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)methodExists_VariableNums.@name: return _var_name;
				default: return null;
				}
			}
			
			public enum methodExists_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodExists_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodExists_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodExists_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_methodExists.instance.pat_methodExists; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_sameStaticness : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_sameStaticness instance = null;
		public static Rule_sameStaticness Instance { get { if (instance==null) { instance = new Rule_sameStaticness(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] sameStaticness_node_v_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] sameStaticness_node_op_AllowedTypes = null;
		public static bool[] sameStaticness_node_v_IsAllowedType = null;
		public static bool[] sameStaticness_node_op_IsAllowedType = null;
		public enum sameStaticness_NodeNums { @v, @op, };
		public enum sameStaticness_EdgeNums { };
		public enum sameStaticness_VariableNums { };
		public enum sameStaticness_SubNums { };
		public enum sameStaticness_AltNums { };
		public enum sameStaticness_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_sameStaticness;


		private Rule_sameStaticness()
		{
			name = "sameStaticness";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Variable.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, };
			inputNames = new string[] { "sameStaticness_node_v", "sameStaticness_node_op", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] sameStaticness_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] sameStaticness_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] sameStaticness_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] sameStaticness_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode sameStaticness_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "sameStaticness_node_v", "v", sameStaticness_node_v_AllowedTypes, sameStaticness_node_v_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode sameStaticness_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "sameStaticness_node_op", "op", sameStaticness_node_op_AllowedTypes, sameStaticness_node_op_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition sameStaticness_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.EQ(new GRGEN_EXPR.Qualification("GRGEN_MODEL.IVariable", "sameStaticness_node_v", "isStatic"), new GRGEN_EXPR.Qualification("GRGEN_MODEL.IOperation", "sameStaticness_node_op", "isStatic")),
				new string[] { "sameStaticness_node_v", "sameStaticness_node_op" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			pat_sameStaticness = new GRGEN_LGSP.PatternGraph(
				"sameStaticness",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { sameStaticness_node_v, sameStaticness_node_op }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { sameStaticness_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[0, 0] ,
				sameStaticness_isNodeHomomorphicGlobal,
				sameStaticness_isEdgeHomomorphicGlobal,
				sameStaticness_isNodeTotallyHomomorphic,
				sameStaticness_isEdgeTotallyHomomorphic
			);

			sameStaticness_node_v.pointOfDefinition = null;
			sameStaticness_node_op.pointOfDefinition = null;

			patternGraph = pat_sameStaticness;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_sameStaticness curMatch = (Match_sameStaticness)_curMatch;
			return;
		}

		static Rule_sameStaticness() {
		}

		public interface IMatch_sameStaticness : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IVariable node_v { get; }
			GRGEN_MODEL.IOperation node_op { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_sameStaticness : GRGEN_LGSP.ListElement<Match_sameStaticness>, IMatch_sameStaticness
		{
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_LGSP.LGSPNode _node_v;
			public GRGEN_LGSP.LGSPNode _node_op;
			public enum sameStaticness_NodeNums { @v, @op, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)sameStaticness_NodeNums.@v: return _node_v;
				case (int)sameStaticness_NodeNums.@op: return _node_op;
				default: return null;
				}
			}
			
			public enum sameStaticness_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum sameStaticness_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum sameStaticness_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum sameStaticness_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum sameStaticness_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum sameStaticness_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_sameStaticness.instance.pat_sameStaticness; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_insertMethodGetter : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_insertMethodGetter instance = null;
		public static Rule_insertMethodGetter Instance { get { if (instance==null) { instance = new Rule_insertMethodGetter(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] insertMethodGetter_node_c_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] insertMethodGetter_node_v_AllowedTypes = null;
		public static bool[] insertMethodGetter_node_c_IsAllowedType = null;
		public static bool[] insertMethodGetter_node_v_IsAllowedType = null;
		public enum insertMethodGetter_NodeNums { @c, @v, };
		public enum insertMethodGetter_EdgeNums { };
		public enum insertMethodGetter_VariableNums { @name, @isStatic, };
		public enum insertMethodGetter_SubNums { };
		public enum insertMethodGetter_AltNums { };
		public enum insertMethodGetter_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_insertMethodGetter;


		private Rule_insertMethodGetter()
		{
			name = "insertMethodGetter";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Variable.typeVar, GRGEN_LIBGR.VarType.GetVarType(typeof(string)), GRGEN_LIBGR.VarType.GetVarType(typeof(bool)), };
			inputNames = new string[] { "insertMethodGetter_node_c", "insertMethodGetter_node_v", "insertMethodGetter_var_name", "insertMethodGetter_var_isStatic", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, };

		}
		private void initialize()
		{
			bool[,] insertMethodGetter_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] insertMethodGetter_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] insertMethodGetter_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] insertMethodGetter_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternVariable insertMethodGetter_var_name = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(string)), "insertMethodGetter_var_name", "name", 2, false, null);
			GRGEN_LGSP.PatternVariable insertMethodGetter_var_isStatic = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(bool)), "insertMethodGetter_var_isStatic", "isStatic", 3, false, null);
			GRGEN_LGSP.PatternNode insertMethodGetter_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "insertMethodGetter_node_c", "c", insertMethodGetter_node_c_AllowedTypes, insertMethodGetter_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode insertMethodGetter_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "insertMethodGetter_node_v", "v", insertMethodGetter_node_v_AllowedTypes, insertMethodGetter_node_v_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			pat_insertMethodGetter = new GRGEN_LGSP.PatternGraph(
				"insertMethodGetter",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { insertMethodGetter_node_c, insertMethodGetter_node_v }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] { insertMethodGetter_var_name, insertMethodGetter_var_isStatic }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[0, 0] ,
				insertMethodGetter_isNodeHomomorphicGlobal,
				insertMethodGetter_isEdgeHomomorphicGlobal,
				insertMethodGetter_isNodeTotallyHomomorphic,
				insertMethodGetter_isEdgeTotallyHomomorphic
			);

			insertMethodGetter_node_c.pointOfDefinition = null;
			insertMethodGetter_node_v.pointOfDefinition = null;

			patternGraph = pat_insertMethodGetter;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IOperation output_0)
		{
			Match_insertMethodGetter curMatch = (Match_insertMethodGetter)_curMatch;
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPNode node_v = curMatch._node_v;
			string var_name = curMatch._var_name;
			bool var_isStatic = curMatch._var_isStatic;
			graph.SettingAddedNodeNames( insertMethodGetter_addedNodeNames );
			GRGEN_MODEL.@MethodBody node_mb = GRGEN_MODEL.@MethodBody.CreateNode(graph);
			GRGEN_MODEL.@Operation node_op = GRGEN_MODEL.@Operation.CreateNode(graph);
			GRGEN_MODEL.@Block node__node0 = GRGEN_MODEL.@Block.CreateNode(graph);
			GRGEN_MODEL.@Return node__node1 = GRGEN_MODEL.@Return.CreateNode(graph);
			GRGEN_MODEL.@Access node__node2 = GRGEN_MODEL.@Access.CreateNode(graph);
			graph.SettingAddedEdgeNames( insertMethodGetter_addedEdgeNames );
			GRGEN_MODEL.@belongsTo edge__edge0 = GRGEN_MODEL.@belongsTo.CreateEdge(graph, node_mb, node_c);
			GRGEN_MODEL.@binding edge__edge1 = GRGEN_MODEL.@binding.CreateEdge(graph, node_op, node_mb);
			GRGEN_MODEL.@belongsTo edge__edge2 = GRGEN_MODEL.@belongsTo.CreateEdge(graph, node__node0, node_mb);
			GRGEN_MODEL.@expression edge__edge3 = GRGEN_MODEL.@expression.CreateEdge(graph, node__node0, node__node1);
			GRGEN_MODEL.@expression edge__edge4 = GRGEN_MODEL.@expression.CreateEdge(graph, node__node1, node__node2);
			GRGEN_MODEL.@link edge__edge5 = GRGEN_MODEL.@link.CreateEdge(graph, node__node2, node_v);
			string tempvar_string = var_name;
			graph.ChangingNodeAttribute(node_op, GRGEN_MODEL.NodeType_Operation.AttributeType_name, GRGEN_LIBGR.AttributeChangeType.Assign, tempvar_string, null);
			node_op.@name = tempvar_string;
			tempvar_string = "public";
			graph.ChangingNodeAttribute(node_op, GRGEN_MODEL.NodeType_Operation.AttributeType_visibility, GRGEN_LIBGR.AttributeChangeType.Assign, tempvar_string, null);
			node_op.@visibility = tempvar_string;
			bool tempvar_bool = false;
			graph.ChangingNodeAttribute(node_op, GRGEN_MODEL.NodeType_Operation.AttributeType_isAbstract, GRGEN_LIBGR.AttributeChangeType.Assign, tempvar_bool, null);
			node_op.@isAbstract = tempvar_bool;
			tempvar_bool = var_isStatic;
			graph.ChangingNodeAttribute(node_op, GRGEN_MODEL.NodeType_Operation.AttributeType_isStatic, GRGEN_LIBGR.AttributeChangeType.Assign, tempvar_bool, null);
			node_op.@isStatic = tempvar_bool;
			tempvar_bool = false;
			graph.ChangingNodeAttribute(node_op, GRGEN_MODEL.NodeType_Operation.AttributeType_isFinal, GRGEN_LIBGR.AttributeChangeType.Assign, tempvar_bool, null);
			node_op.@isFinal = tempvar_bool;
			output_0 = (GRGEN_MODEL.IOperation)(node_op);
			return;
		}
		private static string[] insertMethodGetter_addedNodeNames = new string[] { "mb", "op", "_node0", "_node1", "_node2" };
		private static string[] insertMethodGetter_addedEdgeNames = new string[] { "_edge0", "_edge1", "_edge2", "_edge3", "_edge4", "_edge5" };

		static Rule_insertMethodGetter() {
		}

		public interface IMatch_insertMethodGetter : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IClass node_c { get; }
			GRGEN_MODEL.IVariable node_v { get; }
			//Edges
			//Variables
			string @var_name { get; }
			bool @var_isStatic { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_insertMethodGetter : GRGEN_LGSP.ListElement<Match_insertMethodGetter>, IMatch_insertMethodGetter
		{
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_v;
			public enum insertMethodGetter_NodeNums { @c, @v, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)insertMethodGetter_NodeNums.@c: return _node_c;
				case (int)insertMethodGetter_NodeNums.@v: return _node_v;
				default: return null;
				}
			}
			
			public enum insertMethodGetter_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public string var_name { get { return _var_name; } }
			public bool var_isStatic { get { return _var_isStatic; } }
			public string _var_name;
			public bool _var_isStatic;
			public enum insertMethodGetter_VariableNums { @name, @isStatic, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 2;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)insertMethodGetter_VariableNums.@name: return _var_name;
				case (int)insertMethodGetter_VariableNums.@isStatic: return _var_isStatic;
				default: return null;
				}
			}
			
			public enum insertMethodGetter_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum insertMethodGetter_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum insertMethodGetter_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum insertMethodGetter_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_insertMethodGetter.instance.pat_insertMethodGetter; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_insertMethodSetter : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_insertMethodSetter instance = null;
		public static Rule_insertMethodSetter Instance { get { if (instance==null) { instance = new Rule_insertMethodSetter(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] insertMethodSetter_node_v_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] insertMethodSetter_node_type_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] insertMethodSetter_node_c_AllowedTypes = null;
		public static bool[] insertMethodSetter_node_v_IsAllowedType = null;
		public static bool[] insertMethodSetter_node_type_IsAllowedType = null;
		public static bool[] insertMethodSetter_node_c_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] insertMethodSetter_edge__edge0_AllowedTypes = null;
		public static bool[] insertMethodSetter_edge__edge0_IsAllowedType = null;
		public enum insertMethodSetter_NodeNums { @v, @type, @c, };
		public enum insertMethodSetter_EdgeNums { @_edge0, };
		public enum insertMethodSetter_VariableNums { @name, @isStatic, };
		public enum insertMethodSetter_SubNums { };
		public enum insertMethodSetter_AltNums { };
		public enum insertMethodSetter_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_insertMethodSetter;


		private Rule_insertMethodSetter()
		{
			name = "insertMethodSetter";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Variable.typeVar, GRGEN_LIBGR.VarType.GetVarType(typeof(string)), GRGEN_LIBGR.VarType.GetVarType(typeof(bool)), };
			inputNames = new string[] { "insertMethodSetter_node_c", "insertMethodSetter_node_v", "insertMethodSetter_var_name", "insertMethodSetter_var_isStatic", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, };

		}
		private void initialize()
		{
			bool[,] insertMethodSetter_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] insertMethodSetter_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] insertMethodSetter_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] insertMethodSetter_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable insertMethodSetter_var_name = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(string)), "insertMethodSetter_var_name", "name", 2, false, null);
			GRGEN_LGSP.PatternVariable insertMethodSetter_var_isStatic = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(bool)), "insertMethodSetter_var_isStatic", "isStatic", 3, false, null);
			GRGEN_LGSP.PatternNode insertMethodSetter_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "insertMethodSetter_node_v", "v", insertMethodSetter_node_v_AllowedTypes, insertMethodSetter_node_v_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode insertMethodSetter_node_type = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "insertMethodSetter_node_type", "type", insertMethodSetter_node_type_AllowedTypes, insertMethodSetter_node_type_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode insertMethodSetter_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "insertMethodSetter_node_c", "c", insertMethodSetter_node_c_AllowedTypes, insertMethodSetter_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge insertMethodSetter_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@type_, "GRGEN_MODEL.Itype_", "insertMethodSetter_edge__edge0", "_edge0", insertMethodSetter_edge__edge0_AllowedTypes, insertMethodSetter_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_insertMethodSetter = new GRGEN_LGSP.PatternGraph(
				"insertMethodSetter",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { insertMethodSetter_node_v, insertMethodSetter_node_type, insertMethodSetter_node_c }, 
				new GRGEN_LGSP.PatternEdge[] { insertMethodSetter_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] { insertMethodSetter_var_name, insertMethodSetter_var_isStatic }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				insertMethodSetter_isNodeHomomorphicGlobal,
				insertMethodSetter_isEdgeHomomorphicGlobal,
				insertMethodSetter_isNodeTotallyHomomorphic,
				insertMethodSetter_isEdgeTotallyHomomorphic
			);
			pat_insertMethodSetter.edgeToSourceNode.Add(insertMethodSetter_edge__edge0, insertMethodSetter_node_v);
			pat_insertMethodSetter.edgeToTargetNode.Add(insertMethodSetter_edge__edge0, insertMethodSetter_node_type);

			insertMethodSetter_node_v.pointOfDefinition = null;
			insertMethodSetter_node_type.pointOfDefinition = pat_insertMethodSetter;
			insertMethodSetter_node_c.pointOfDefinition = null;
			insertMethodSetter_edge__edge0.pointOfDefinition = pat_insertMethodSetter;

			patternGraph = pat_insertMethodSetter;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IOperation output_0)
		{
			Match_insertMethodSetter curMatch = (Match_insertMethodSetter)_curMatch;
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPNode node_type = curMatch._node_type;
			GRGEN_LGSP.LGSPNode node_v = curMatch._node_v;
			string var_name = curMatch._var_name;
			bool var_isStatic = curMatch._var_isStatic;
			graph.SettingAddedNodeNames( insertMethodSetter_addedNodeNames );
			GRGEN_MODEL.@MethodBody node_mb = GRGEN_MODEL.@MethodBody.CreateNode(graph);
			GRGEN_MODEL.@Operation node_op = GRGEN_MODEL.@Operation.CreateNode(graph);
			GRGEN_MODEL.@Parameter node_p = GRGEN_MODEL.@Parameter.CreateNode(graph);
			GRGEN_MODEL.@Block node__node0 = GRGEN_MODEL.@Block.CreateNode(graph);
			GRGEN_MODEL.@Update node_u = GRGEN_MODEL.@Update.CreateNode(graph);
			GRGEN_MODEL.@Access node__node1 = GRGEN_MODEL.@Access.CreateNode(graph);
			graph.SettingAddedEdgeNames( insertMethodSetter_addedEdgeNames );
			GRGEN_MODEL.@belongsTo edge__edge1 = GRGEN_MODEL.@belongsTo.CreateEdge(graph, node_mb, node_c);
			GRGEN_MODEL.@binding edge__edge2 = GRGEN_MODEL.@binding.CreateEdge(graph, node_op, node_mb);
			GRGEN_MODEL.@parameter edge__edge3 = GRGEN_MODEL.@parameter.CreateEdge(graph, node_op, node_p);
			GRGEN_MODEL.@type_ edge__edge4 = GRGEN_MODEL.@type_.CreateEdge(graph, node_p, node_type);
			GRGEN_MODEL.@belongsTo edge__edge5 = GRGEN_MODEL.@belongsTo.CreateEdge(graph, node__node0, node_mb);
			GRGEN_MODEL.@expression edge__edge6 = GRGEN_MODEL.@expression.CreateEdge(graph, node__node0, node_u);
			GRGEN_MODEL.@link edge__edge7 = GRGEN_MODEL.@link.CreateEdge(graph, node_u, node_v);
			GRGEN_MODEL.@expression edge__edge8 = GRGEN_MODEL.@expression.CreateEdge(graph, node_u, node__node1);
			GRGEN_MODEL.@link edge__edge9 = GRGEN_MODEL.@link.CreateEdge(graph, node__node1, node_p);
			string tempvar_string = var_name;
			graph.ChangingNodeAttribute(node_op, GRGEN_MODEL.NodeType_Operation.AttributeType_name, GRGEN_LIBGR.AttributeChangeType.Assign, tempvar_string, null);
			node_op.@name = tempvar_string;
			tempvar_string = "public";
			graph.ChangingNodeAttribute(node_op, GRGEN_MODEL.NodeType_Operation.AttributeType_visibility, GRGEN_LIBGR.AttributeChangeType.Assign, tempvar_string, null);
			node_op.@visibility = tempvar_string;
			bool tempvar_bool = false;
			graph.ChangingNodeAttribute(node_op, GRGEN_MODEL.NodeType_Operation.AttributeType_isAbstract, GRGEN_LIBGR.AttributeChangeType.Assign, tempvar_bool, null);
			node_op.@isAbstract = tempvar_bool;
			tempvar_bool = var_isStatic;
			graph.ChangingNodeAttribute(node_op, GRGEN_MODEL.NodeType_Operation.AttributeType_isStatic, GRGEN_LIBGR.AttributeChangeType.Assign, tempvar_bool, null);
			node_op.@isStatic = tempvar_bool;
			tempvar_bool = false;
			graph.ChangingNodeAttribute(node_op, GRGEN_MODEL.NodeType_Operation.AttributeType_isFinal, GRGEN_LIBGR.AttributeChangeType.Assign, tempvar_bool, null);
			node_op.@isFinal = tempvar_bool;
			output_0 = (GRGEN_MODEL.IOperation)(node_op);
			return;
		}
		private static string[] insertMethodSetter_addedNodeNames = new string[] { "mb", "op", "p", "_node0", "u", "_node1" };
		private static string[] insertMethodSetter_addedEdgeNames = new string[] { "_edge1", "_edge2", "_edge3", "_edge4", "_edge5", "_edge6", "_edge7", "_edge8", "_edge9" };

		static Rule_insertMethodSetter() {
		}

		public interface IMatch_insertMethodSetter : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IVariable node_v { get; }
			GRGEN_MODEL.IClass node_type { get; }
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			GRGEN_MODEL.Itype_ edge__edge0 { get; }
			//Variables
			string @var_name { get; }
			bool @var_isStatic { get; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_insertMethodSetter : GRGEN_LGSP.ListElement<Match_insertMethodSetter>, IMatch_insertMethodSetter
		{
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_MODEL.IClass node_type { get { return (GRGEN_MODEL.IClass)_node_type; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_v;
			public GRGEN_LGSP.LGSPNode _node_type;
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum insertMethodSetter_NodeNums { @v, @type, @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)insertMethodSetter_NodeNums.@v: return _node_v;
				case (int)insertMethodSetter_NodeNums.@type: return _node_type;
				case (int)insertMethodSetter_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Itype_ edge__edge0 { get { return (GRGEN_MODEL.Itype_)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum insertMethodSetter_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)insertMethodSetter_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public string var_name { get { return _var_name; } }
			public bool var_isStatic { get { return _var_isStatic; } }
			public string _var_name;
			public bool _var_isStatic;
			public enum insertMethodSetter_VariableNums { @name, @isStatic, END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 2;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				case (int)insertMethodSetter_VariableNums.@name: return _var_name;
				case (int)insertMethodSetter_VariableNums.@isStatic: return _var_isStatic;
				default: return null;
				}
			}
			
			public enum insertMethodSetter_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum insertMethodSetter_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum insertMethodSetter_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum insertMethodSetter_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_insertMethodSetter.instance.pat_insertMethodSetter; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_changeVisibility : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_changeVisibility instance = null;
		public static Rule_changeVisibility Instance { get { if (instance==null) { instance = new Rule_changeVisibility(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] changeVisibility_node_v_AllowedTypes = null;
		public static bool[] changeVisibility_node_v_IsAllowedType = null;
		public enum changeVisibility_NodeNums { @v, };
		public enum changeVisibility_EdgeNums { };
		public enum changeVisibility_VariableNums { };
		public enum changeVisibility_SubNums { };
		public enum changeVisibility_AltNums { };
		public enum changeVisibility_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_changeVisibility;


		private Rule_changeVisibility()
		{
			name = "changeVisibility";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Variable.typeVar, };
			inputNames = new string[] { "changeVisibility_node_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] changeVisibility_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] changeVisibility_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] changeVisibility_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] changeVisibility_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode changeVisibility_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "changeVisibility_node_v", "v", changeVisibility_node_v_AllowedTypes, changeVisibility_node_v_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			pat_changeVisibility = new GRGEN_LGSP.PatternGraph(
				"changeVisibility",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { changeVisibility_node_v }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				changeVisibility_isNodeHomomorphicGlobal,
				changeVisibility_isEdgeHomomorphicGlobal,
				changeVisibility_isNodeTotallyHomomorphic,
				changeVisibility_isEdgeTotallyHomomorphic
			);

			changeVisibility_node_v.pointOfDefinition = null;

			patternGraph = pat_changeVisibility;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_changeVisibility curMatch = (Match_changeVisibility)_curMatch;
			GRGEN_LGSP.LGSPNode node_v = curMatch._node_v;
			GRGEN_MODEL.IVariable inode_v = curMatch.node_v;
			graph.SettingAddedNodeNames( changeVisibility_addedNodeNames );
			graph.SettingAddedEdgeNames( changeVisibility_addedEdgeNames );
			string tempvar_string = "private";
			graph.ChangingNodeAttribute(node_v, GRGEN_MODEL.NodeType_Variable.AttributeType_visibility, GRGEN_LIBGR.AttributeChangeType.Assign, tempvar_string, null);
			inode_v.@visibility = tempvar_string;
			return;
		}
		private static string[] changeVisibility_addedNodeNames = new string[] {  };
		private static string[] changeVisibility_addedEdgeNames = new string[] {  };

		static Rule_changeVisibility() {
		}

		public interface IMatch_changeVisibility : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IVariable node_v { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_changeVisibility : GRGEN_LGSP.ListElement<Match_changeVisibility>, IMatch_changeVisibility
		{
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_LGSP.LGSPNode _node_v;
			public enum changeVisibility_NodeNums { @v, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)changeVisibility_NodeNums.@v: return _node_v;
				default: return null;
				}
			}
			
			public enum changeVisibility_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum changeVisibility_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum changeVisibility_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum changeVisibility_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum changeVisibility_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum changeVisibility_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_changeVisibility.instance.pat_changeVisibility; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_adaptAccess : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_adaptAccess instance = null;
		public static Rule_adaptAccess Instance { get { if (instance==null) { instance = new Rule_adaptAccess(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] adaptAccess_node_a_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptAccess_node_v_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptAccess_node_c_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptAccess_node_getter_AllowedTypes = null;
		public static bool[] adaptAccess_node_a_IsAllowedType = null;
		public static bool[] adaptAccess_node_v_IsAllowedType = null;
		public static bool[] adaptAccess_node_c_IsAllowedType = null;
		public static bool[] adaptAccess_node_getter_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] adaptAccess_edge_l_AllowedTypes = null;
		public static bool[] adaptAccess_edge_l_IsAllowedType = null;
		public enum adaptAccess_NodeNums { @a, @v, @c, @getter, };
		public enum adaptAccess_EdgeNums { @l, };
		public enum adaptAccess_VariableNums { };
		public enum adaptAccess_SubNums { };
		public enum adaptAccess_AltNums { };
		public enum adaptAccess_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_adaptAccess;

		public enum adaptAccess_neg_0_NodeNums { @a, @c, };
		public enum adaptAccess_neg_0_EdgeNums { };
		public enum adaptAccess_neg_0_VariableNums { };
		public enum adaptAccess_neg_0_SubNums { @_sub0, };
		public enum adaptAccess_neg_0_AltNums { };
		public enum adaptAccess_neg_0_IterNums { };

		public GRGEN_LGSP.PatternGraph adaptAccess_neg_0;


		private Rule_adaptAccess()
		{
			name = "adaptAccess";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Variable.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, };
			inputNames = new string[] { "adaptAccess_node_c", "adaptAccess_node_v", "adaptAccess_node_getter", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] adaptAccess_isNodeHomomorphicGlobal = new bool[4, 4] {
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
			};
			bool[,] adaptAccess_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] adaptAccess_isNodeTotallyHomomorphic = new bool[4] { false, false, false, false,  };
			bool[] adaptAccess_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode adaptAccess_node_a = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Access, "GRGEN_MODEL.IAccess", "adaptAccess_node_a", "a", adaptAccess_node_a_AllowedTypes, adaptAccess_node_a_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptAccess_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "adaptAccess_node_v", "v", adaptAccess_node_v_AllowedTypes, adaptAccess_node_v_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptAccess_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "adaptAccess_node_c", "c", adaptAccess_node_c_AllowedTypes, adaptAccess_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptAccess_node_getter = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "adaptAccess_node_getter", "getter", adaptAccess_node_getter_AllowedTypes, adaptAccess_node_getter_IsAllowedType, 5.5F, 2, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge adaptAccess_edge_l = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "adaptAccess_edge_l", "l", adaptAccess_edge_l_AllowedTypes, adaptAccess_edge_l_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			bool[,] adaptAccess_neg_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] adaptAccess_neg_0_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] adaptAccess_neg_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] adaptAccess_neg_0_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternGraphEmbedding adaptAccess_neg_0__sub0 = new GRGEN_LGSP.PatternGraphEmbedding("_sub0", Pattern_InClass.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("adaptAccess_node_a"),
					new GRGEN_EXPR.GraphEntityExpression("adaptAccess_node_c"),
				}, 
				new string[] { }, new string[] { "adaptAccess_node_a", "adaptAccess_node_c" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			adaptAccess_neg_0 = new GRGEN_LGSP.PatternGraph(
				"neg_0",
				"adaptAccess_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { adaptAccess_node_a, adaptAccess_node_c }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { adaptAccess_neg_0__sub0 }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, true, },
					{ true, true, },
				},
				new bool[0, 0] ,
				adaptAccess_neg_0_isNodeHomomorphicGlobal,
				adaptAccess_neg_0_isEdgeHomomorphicGlobal,
				adaptAccess_neg_0_isNodeTotallyHomomorphic,
				adaptAccess_neg_0_isEdgeTotallyHomomorphic
			);

			pat_adaptAccess = new GRGEN_LGSP.PatternGraph(
				"adaptAccess",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { adaptAccess_node_a, adaptAccess_node_v, adaptAccess_node_c, adaptAccess_node_getter }, 
				new GRGEN_LGSP.PatternEdge[] { adaptAccess_edge_l }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] { adaptAccess_neg_0,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[4, 4] {
					{ true, false, false, false, },
					{ false, true, false, false, },
					{ false, false, true, false, },
					{ false, false, false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				adaptAccess_isNodeHomomorphicGlobal,
				adaptAccess_isEdgeHomomorphicGlobal,
				adaptAccess_isNodeTotallyHomomorphic,
				adaptAccess_isEdgeTotallyHomomorphic
			);
			pat_adaptAccess.edgeToSourceNode.Add(adaptAccess_edge_l, adaptAccess_node_a);
			pat_adaptAccess.edgeToTargetNode.Add(adaptAccess_edge_l, adaptAccess_node_v);
			adaptAccess_neg_0.embeddingGraph = pat_adaptAccess;

			adaptAccess_node_a.pointOfDefinition = pat_adaptAccess;
			adaptAccess_node_v.pointOfDefinition = null;
			adaptAccess_node_c.pointOfDefinition = null;
			adaptAccess_node_getter.pointOfDefinition = null;
			adaptAccess_edge_l.pointOfDefinition = pat_adaptAccess;
			adaptAccess_neg_0__sub0.PointOfDefinition = adaptAccess_neg_0;

			patternGraph = pat_adaptAccess;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_adaptAccess curMatch = (Match_adaptAccess)_curMatch;
			GRGEN_LGSP.LGSPNode node_a = curMatch._node_a;
			GRGEN_LGSP.LGSPNode node_getter = curMatch._node_getter;
			GRGEN_LGSP.LGSPEdge edge_l = curMatch._edge_l;
			graph.SettingAddedNodeNames( adaptAccess_addedNodeNames );
			GRGEN_LGSP.LGSPNode node_call = graph.Retype(node_a, GRGEN_MODEL.NodeType_Call.typeVar);
			graph.SettingAddedEdgeNames( adaptAccess_addedEdgeNames );
			GRGEN_MODEL.@link edge__edge0 = GRGEN_MODEL.@link.CreateEdge(graph, node_call, node_getter);
			graph.Remove(edge_l);
			return;
		}
		private static string[] adaptAccess_addedNodeNames = new string[] {  };
		private static string[] adaptAccess_addedEdgeNames = new string[] { "_edge0" };

		static Rule_adaptAccess() {
		}

		public interface IMatch_adaptAccess : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_a { get; }
			GRGEN_MODEL.IVariable node_v { get; }
			GRGEN_MODEL.IClass node_c { get; }
			GRGEN_MODEL.IOperation node_getter { get; }
			//Edges
			GRGEN_MODEL.Ilink edge_l { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_adaptAccess_neg_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_a { get; }
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			@Pattern_InClass.Match_InClass @_sub0 { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_adaptAccess : GRGEN_LGSP.ListElement<Match_adaptAccess>, IMatch_adaptAccess
		{
			public GRGEN_MODEL.IAccess node_a { get { return (GRGEN_MODEL.IAccess)_node_a; } }
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_MODEL.IOperation node_getter { get { return (GRGEN_MODEL.IOperation)_node_getter; } }
			public GRGEN_LGSP.LGSPNode _node_a;
			public GRGEN_LGSP.LGSPNode _node_v;
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_getter;
			public enum adaptAccess_NodeNums { @a, @v, @c, @getter, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 4;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)adaptAccess_NodeNums.@a: return _node_a;
				case (int)adaptAccess_NodeNums.@v: return _node_v;
				case (int)adaptAccess_NodeNums.@c: return _node_c;
				case (int)adaptAccess_NodeNums.@getter: return _node_getter;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ilink edge_l { get { return (GRGEN_MODEL.Ilink)_edge_l; } }
			public GRGEN_LGSP.LGSPEdge _edge_l;
			public enum adaptAccess_EdgeNums { @l, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)adaptAccess_EdgeNums.@l: return _edge_l;
				default: return null;
				}
			}
			
			public enum adaptAccess_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptAccess_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptAccess_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptAccess_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptAccess_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_adaptAccess.instance.pat_adaptAccess; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_adaptAccess_neg_0 : GRGEN_LGSP.ListElement<Match_adaptAccess_neg_0>, IMatch_adaptAccess_neg_0
		{
			public GRGEN_MODEL.IAccess node_a { get { return (GRGEN_MODEL.IAccess)_node_a; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_a;
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum adaptAccess_neg_0_NodeNums { @a, @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)adaptAccess_neg_0_NodeNums.@a: return _node_a;
				case (int)adaptAccess_neg_0_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public enum adaptAccess_neg_0_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptAccess_neg_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_InClass.Match_InClass @_sub0 { get { return @__sub0; } }
			public @Pattern_InClass.Match_InClass @__sub0;
			public enum adaptAccess_neg_0_SubNums { @_sub0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)adaptAccess_neg_0_SubNums.@_sub0: return __sub0;
				default: return null;
				}
			}
			
			public enum adaptAccess_neg_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptAccess_neg_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptAccess_neg_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_adaptAccess.instance.adaptAccess_neg_0; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_adaptUpdate : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_adaptUpdate instance = null;
		public static Rule_adaptUpdate Instance { get { if (instance==null) { instance = new Rule_adaptUpdate(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] adaptUpdate_node_u_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptUpdate_node_v_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptUpdate_node_exp_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptUpdate_node_c_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptUpdate_node_setter_AllowedTypes = null;
		public static bool[] adaptUpdate_node_u_IsAllowedType = null;
		public static bool[] adaptUpdate_node_v_IsAllowedType = null;
		public static bool[] adaptUpdate_node_exp_IsAllowedType = null;
		public static bool[] adaptUpdate_node_c_IsAllowedType = null;
		public static bool[] adaptUpdate_node_setter_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] adaptUpdate_edge_l_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] adaptUpdate_edge_e_AllowedTypes = null;
		public static bool[] adaptUpdate_edge_l_IsAllowedType = null;
		public static bool[] adaptUpdate_edge_e_IsAllowedType = null;
		public enum adaptUpdate_NodeNums { @u, @v, @exp, @c, @setter, };
		public enum adaptUpdate_EdgeNums { @l, @e, };
		public enum adaptUpdate_VariableNums { };
		public enum adaptUpdate_SubNums { };
		public enum adaptUpdate_AltNums { };
		public enum adaptUpdate_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_adaptUpdate;

		public enum adaptUpdate_neg_0_NodeNums { @u, @c, };
		public enum adaptUpdate_neg_0_EdgeNums { };
		public enum adaptUpdate_neg_0_VariableNums { };
		public enum adaptUpdate_neg_0_SubNums { @_sub0, };
		public enum adaptUpdate_neg_0_AltNums { };
		public enum adaptUpdate_neg_0_IterNums { };

		public GRGEN_LGSP.PatternGraph adaptUpdate_neg_0;


		private Rule_adaptUpdate()
		{
			name = "adaptUpdate";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Variable.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, };
			inputNames = new string[] { "adaptUpdate_node_c", "adaptUpdate_node_v", "adaptUpdate_node_setter", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] adaptUpdate_isNodeHomomorphicGlobal = new bool[5, 5] {
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
			};
			bool[,] adaptUpdate_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] adaptUpdate_isNodeTotallyHomomorphic = new bool[5] { false, false, false, false, false,  };
			bool[] adaptUpdate_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternNode adaptUpdate_node_u = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Update, "GRGEN_MODEL.IUpdate", "adaptUpdate_node_u", "u", adaptUpdate_node_u_AllowedTypes, adaptUpdate_node_u_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptUpdate_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "adaptUpdate_node_v", "v", adaptUpdate_node_v_AllowedTypes, adaptUpdate_node_v_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptUpdate_node_exp = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "adaptUpdate_node_exp", "exp", adaptUpdate_node_exp_AllowedTypes, adaptUpdate_node_exp_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptUpdate_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "adaptUpdate_node_c", "c", adaptUpdate_node_c_AllowedTypes, adaptUpdate_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptUpdate_node_setter = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "adaptUpdate_node_setter", "setter", adaptUpdate_node_setter_AllowedTypes, adaptUpdate_node_setter_IsAllowedType, 5.5F, 2, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge adaptUpdate_edge_l = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "adaptUpdate_edge_l", "l", adaptUpdate_edge_l_AllowedTypes, adaptUpdate_edge_l_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge adaptUpdate_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "adaptUpdate_edge_e", "e", adaptUpdate_edge_e_AllowedTypes, adaptUpdate_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			bool[,] adaptUpdate_neg_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] adaptUpdate_neg_0_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] adaptUpdate_neg_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] adaptUpdate_neg_0_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternGraphEmbedding adaptUpdate_neg_0__sub0 = new GRGEN_LGSP.PatternGraphEmbedding("_sub0", Pattern_InClass.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("adaptUpdate_node_u"),
					new GRGEN_EXPR.GraphEntityExpression("adaptUpdate_node_c"),
				}, 
				new string[] { }, new string[] { "adaptUpdate_node_u", "adaptUpdate_node_c" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			adaptUpdate_neg_0 = new GRGEN_LGSP.PatternGraph(
				"neg_0",
				"adaptUpdate_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { adaptUpdate_node_u, adaptUpdate_node_c }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { adaptUpdate_neg_0__sub0 }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, true, },
					{ true, true, },
				},
				new bool[0, 0] ,
				adaptUpdate_neg_0_isNodeHomomorphicGlobal,
				adaptUpdate_neg_0_isEdgeHomomorphicGlobal,
				adaptUpdate_neg_0_isNodeTotallyHomomorphic,
				adaptUpdate_neg_0_isEdgeTotallyHomomorphic
			);

			pat_adaptUpdate = new GRGEN_LGSP.PatternGraph(
				"adaptUpdate",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { adaptUpdate_node_u, adaptUpdate_node_v, adaptUpdate_node_exp, adaptUpdate_node_c, adaptUpdate_node_setter }, 
				new GRGEN_LGSP.PatternEdge[] { adaptUpdate_edge_l, adaptUpdate_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] { adaptUpdate_neg_0,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[5, 5] {
					{ true, false, false, false, false, },
					{ false, true, false, false, false, },
					{ false, false, true, false, false, },
					{ false, false, false, true, false, },
					{ false, false, false, false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				adaptUpdate_isNodeHomomorphicGlobal,
				adaptUpdate_isEdgeHomomorphicGlobal,
				adaptUpdate_isNodeTotallyHomomorphic,
				adaptUpdate_isEdgeTotallyHomomorphic
			);
			pat_adaptUpdate.edgeToSourceNode.Add(adaptUpdate_edge_l, adaptUpdate_node_u);
			pat_adaptUpdate.edgeToTargetNode.Add(adaptUpdate_edge_l, adaptUpdate_node_v);
			pat_adaptUpdate.edgeToSourceNode.Add(adaptUpdate_edge_e, adaptUpdate_node_u);
			pat_adaptUpdate.edgeToTargetNode.Add(adaptUpdate_edge_e, adaptUpdate_node_exp);
			adaptUpdate_neg_0.embeddingGraph = pat_adaptUpdate;

			adaptUpdate_node_u.pointOfDefinition = pat_adaptUpdate;
			adaptUpdate_node_v.pointOfDefinition = null;
			adaptUpdate_node_exp.pointOfDefinition = pat_adaptUpdate;
			adaptUpdate_node_c.pointOfDefinition = null;
			adaptUpdate_node_setter.pointOfDefinition = null;
			adaptUpdate_edge_l.pointOfDefinition = pat_adaptUpdate;
			adaptUpdate_edge_e.pointOfDefinition = pat_adaptUpdate;
			adaptUpdate_neg_0__sub0.PointOfDefinition = adaptUpdate_neg_0;

			patternGraph = pat_adaptUpdate;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_adaptUpdate curMatch = (Match_adaptUpdate)_curMatch;
			GRGEN_LGSP.LGSPNode node_u = curMatch._node_u;
			GRGEN_LGSP.LGSPNode node_setter = curMatch._node_setter;
			GRGEN_LGSP.LGSPNode node_exp = curMatch._node_exp;
			GRGEN_LGSP.LGSPEdge edge_l = curMatch._edge_l;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			graph.SettingAddedNodeNames( adaptUpdate_addedNodeNames );
			GRGEN_LGSP.LGSPNode node_call = graph.Retype(node_u, GRGEN_MODEL.NodeType_Call.typeVar);
			graph.SettingAddedEdgeNames( adaptUpdate_addedEdgeNames );
			GRGEN_MODEL.@link edge__edge0 = GRGEN_MODEL.@link.CreateEdge(graph, node_call, node_setter);
			GRGEN_MODEL.@actualParameter edge__edge1 = GRGEN_MODEL.@actualParameter.CreateEdge(graph, node_call, node_exp);
			graph.Remove(edge_l);
			graph.Remove(edge_e);
			return;
		}
		private static string[] adaptUpdate_addedNodeNames = new string[] {  };
		private static string[] adaptUpdate_addedEdgeNames = new string[] { "_edge0", "_edge1" };

		static Rule_adaptUpdate() {
		}

		public interface IMatch_adaptUpdate : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IUpdate node_u { get; }
			GRGEN_MODEL.IVariable node_v { get; }
			GRGEN_MODEL.IExpression node_exp { get; }
			GRGEN_MODEL.IClass node_c { get; }
			GRGEN_MODEL.IOperation node_setter { get; }
			//Edges
			GRGEN_MODEL.Ilink edge_l { get; }
			GRGEN_MODEL.Iexpression edge_e { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_adaptUpdate_neg_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IUpdate node_u { get; }
			GRGEN_MODEL.IClass node_c { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			@Pattern_InClass.Match_InClass @_sub0 { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_adaptUpdate : GRGEN_LGSP.ListElement<Match_adaptUpdate>, IMatch_adaptUpdate
		{
			public GRGEN_MODEL.IUpdate node_u { get { return (GRGEN_MODEL.IUpdate)_node_u; } }
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_MODEL.IExpression node_exp { get { return (GRGEN_MODEL.IExpression)_node_exp; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_MODEL.IOperation node_setter { get { return (GRGEN_MODEL.IOperation)_node_setter; } }
			public GRGEN_LGSP.LGSPNode _node_u;
			public GRGEN_LGSP.LGSPNode _node_v;
			public GRGEN_LGSP.LGSPNode _node_exp;
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_setter;
			public enum adaptUpdate_NodeNums { @u, @v, @exp, @c, @setter, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 5;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)adaptUpdate_NodeNums.@u: return _node_u;
				case (int)adaptUpdate_NodeNums.@v: return _node_v;
				case (int)adaptUpdate_NodeNums.@exp: return _node_exp;
				case (int)adaptUpdate_NodeNums.@c: return _node_c;
				case (int)adaptUpdate_NodeNums.@setter: return _node_setter;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ilink edge_l { get { return (GRGEN_MODEL.Ilink)_edge_l; } }
			public GRGEN_MODEL.Iexpression edge_e { get { return (GRGEN_MODEL.Iexpression)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_l;
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum adaptUpdate_EdgeNums { @l, @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)adaptUpdate_EdgeNums.@l: return _edge_l;
				case (int)adaptUpdate_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public enum adaptUpdate_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptUpdate_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptUpdate_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptUpdate_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptUpdate_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_adaptUpdate.instance.pat_adaptUpdate; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_adaptUpdate_neg_0 : GRGEN_LGSP.ListElement<Match_adaptUpdate_neg_0>, IMatch_adaptUpdate_neg_0
		{
			public GRGEN_MODEL.IUpdate node_u { get { return (GRGEN_MODEL.IUpdate)_node_u; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_LGSP.LGSPNode _node_u;
			public GRGEN_LGSP.LGSPNode _node_c;
			public enum adaptUpdate_neg_0_NodeNums { @u, @c, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)adaptUpdate_neg_0_NodeNums.@u: return _node_u;
				case (int)adaptUpdate_neg_0_NodeNums.@c: return _node_c;
				default: return null;
				}
			}
			
			public enum adaptUpdate_neg_0_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptUpdate_neg_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_InClass.Match_InClass @_sub0 { get { return @__sub0; } }
			public @Pattern_InClass.Match_InClass @__sub0;
			public enum adaptUpdate_neg_0_SubNums { @_sub0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)adaptUpdate_neg_0_SubNums.@_sub0: return __sub0;
				default: return null;
				}
			}
			
			public enum adaptUpdate_neg_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptUpdate_neg_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptUpdate_neg_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_adaptUpdate.instance.adaptUpdate_neg_0; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_adaptAccessUseAccessorsAlways : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_adaptAccessUseAccessorsAlways instance = null;
		public static Rule_adaptAccessUseAccessorsAlways Instance { get { if (instance==null) { instance = new Rule_adaptAccessUseAccessorsAlways(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] adaptAccessUseAccessorsAlways_node_a_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptAccessUseAccessorsAlways_node_v_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptAccessUseAccessorsAlways_node_c_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptAccessUseAccessorsAlways_node_getter_AllowedTypes = null;
		public static bool[] adaptAccessUseAccessorsAlways_node_a_IsAllowedType = null;
		public static bool[] adaptAccessUseAccessorsAlways_node_v_IsAllowedType = null;
		public static bool[] adaptAccessUseAccessorsAlways_node_c_IsAllowedType = null;
		public static bool[] adaptAccessUseAccessorsAlways_node_getter_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] adaptAccessUseAccessorsAlways_edge_l_AllowedTypes = null;
		public static bool[] adaptAccessUseAccessorsAlways_edge_l_IsAllowedType = null;
		public enum adaptAccessUseAccessorsAlways_NodeNums { @a, @v, @c, @getter, };
		public enum adaptAccessUseAccessorsAlways_EdgeNums { @l, };
		public enum adaptAccessUseAccessorsAlways_VariableNums { };
		public enum adaptAccessUseAccessorsAlways_SubNums { };
		public enum adaptAccessUseAccessorsAlways_AltNums { };
		public enum adaptAccessUseAccessorsAlways_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_adaptAccessUseAccessorsAlways;


		private Rule_adaptAccessUseAccessorsAlways()
		{
			name = "adaptAccessUseAccessorsAlways";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Variable.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, };
			inputNames = new string[] { "adaptAccessUseAccessorsAlways_node_c", "adaptAccessUseAccessorsAlways_node_v", "adaptAccessUseAccessorsAlways_node_getter", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] adaptAccessUseAccessorsAlways_isNodeHomomorphicGlobal = new bool[4, 4] {
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
			};
			bool[,] adaptAccessUseAccessorsAlways_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] adaptAccessUseAccessorsAlways_isNodeTotallyHomomorphic = new bool[4] { false, false, false, false,  };
			bool[] adaptAccessUseAccessorsAlways_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode adaptAccessUseAccessorsAlways_node_a = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Access, "GRGEN_MODEL.IAccess", "adaptAccessUseAccessorsAlways_node_a", "a", adaptAccessUseAccessorsAlways_node_a_AllowedTypes, adaptAccessUseAccessorsAlways_node_a_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptAccessUseAccessorsAlways_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "adaptAccessUseAccessorsAlways_node_v", "v", adaptAccessUseAccessorsAlways_node_v_AllowedTypes, adaptAccessUseAccessorsAlways_node_v_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptAccessUseAccessorsAlways_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "adaptAccessUseAccessorsAlways_node_c", "c", adaptAccessUseAccessorsAlways_node_c_AllowedTypes, adaptAccessUseAccessorsAlways_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptAccessUseAccessorsAlways_node_getter = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "adaptAccessUseAccessorsAlways_node_getter", "getter", adaptAccessUseAccessorsAlways_node_getter_AllowedTypes, adaptAccessUseAccessorsAlways_node_getter_IsAllowedType, 5.5F, 2, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge adaptAccessUseAccessorsAlways_edge_l = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "adaptAccessUseAccessorsAlways_edge_l", "l", adaptAccessUseAccessorsAlways_edge_l_AllowedTypes, adaptAccessUseAccessorsAlways_edge_l_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_adaptAccessUseAccessorsAlways = new GRGEN_LGSP.PatternGraph(
				"adaptAccessUseAccessorsAlways",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { adaptAccessUseAccessorsAlways_node_a, adaptAccessUseAccessorsAlways_node_v, adaptAccessUseAccessorsAlways_node_c, adaptAccessUseAccessorsAlways_node_getter }, 
				new GRGEN_LGSP.PatternEdge[] { adaptAccessUseAccessorsAlways_edge_l }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[4, 4] {
					{ true, false, false, false, },
					{ false, true, false, false, },
					{ false, false, true, false, },
					{ false, false, false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				adaptAccessUseAccessorsAlways_isNodeHomomorphicGlobal,
				adaptAccessUseAccessorsAlways_isEdgeHomomorphicGlobal,
				adaptAccessUseAccessorsAlways_isNodeTotallyHomomorphic,
				adaptAccessUseAccessorsAlways_isEdgeTotallyHomomorphic
			);
			pat_adaptAccessUseAccessorsAlways.edgeToSourceNode.Add(adaptAccessUseAccessorsAlways_edge_l, adaptAccessUseAccessorsAlways_node_a);
			pat_adaptAccessUseAccessorsAlways.edgeToTargetNode.Add(adaptAccessUseAccessorsAlways_edge_l, adaptAccessUseAccessorsAlways_node_v);

			adaptAccessUseAccessorsAlways_node_a.pointOfDefinition = pat_adaptAccessUseAccessorsAlways;
			adaptAccessUseAccessorsAlways_node_v.pointOfDefinition = null;
			adaptAccessUseAccessorsAlways_node_c.pointOfDefinition = null;
			adaptAccessUseAccessorsAlways_node_getter.pointOfDefinition = null;
			adaptAccessUseAccessorsAlways_edge_l.pointOfDefinition = pat_adaptAccessUseAccessorsAlways;

			patternGraph = pat_adaptAccessUseAccessorsAlways;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_adaptAccessUseAccessorsAlways curMatch = (Match_adaptAccessUseAccessorsAlways)_curMatch;
			GRGEN_LGSP.LGSPNode node_a = curMatch._node_a;
			GRGEN_LGSP.LGSPNode node_getter = curMatch._node_getter;
			GRGEN_LGSP.LGSPEdge edge_l = curMatch._edge_l;
			graph.SettingAddedNodeNames( adaptAccessUseAccessorsAlways_addedNodeNames );
			GRGEN_LGSP.LGSPNode node_call = graph.Retype(node_a, GRGEN_MODEL.NodeType_Call.typeVar);
			graph.SettingAddedEdgeNames( adaptAccessUseAccessorsAlways_addedEdgeNames );
			GRGEN_MODEL.@link edge__edge0 = GRGEN_MODEL.@link.CreateEdge(graph, node_call, node_getter);
			graph.Remove(edge_l);
			return;
		}
		private static string[] adaptAccessUseAccessorsAlways_addedNodeNames = new string[] {  };
		private static string[] adaptAccessUseAccessorsAlways_addedEdgeNames = new string[] { "_edge0" };

		static Rule_adaptAccessUseAccessorsAlways() {
		}

		public interface IMatch_adaptAccessUseAccessorsAlways : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_a { get; }
			GRGEN_MODEL.IVariable node_v { get; }
			GRGEN_MODEL.IClass node_c { get; }
			GRGEN_MODEL.IOperation node_getter { get; }
			//Edges
			GRGEN_MODEL.Ilink edge_l { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_adaptAccessUseAccessorsAlways : GRGEN_LGSP.ListElement<Match_adaptAccessUseAccessorsAlways>, IMatch_adaptAccessUseAccessorsAlways
		{
			public GRGEN_MODEL.IAccess node_a { get { return (GRGEN_MODEL.IAccess)_node_a; } }
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_MODEL.IOperation node_getter { get { return (GRGEN_MODEL.IOperation)_node_getter; } }
			public GRGEN_LGSP.LGSPNode _node_a;
			public GRGEN_LGSP.LGSPNode _node_v;
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_getter;
			public enum adaptAccessUseAccessorsAlways_NodeNums { @a, @v, @c, @getter, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 4;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)adaptAccessUseAccessorsAlways_NodeNums.@a: return _node_a;
				case (int)adaptAccessUseAccessorsAlways_NodeNums.@v: return _node_v;
				case (int)adaptAccessUseAccessorsAlways_NodeNums.@c: return _node_c;
				case (int)adaptAccessUseAccessorsAlways_NodeNums.@getter: return _node_getter;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ilink edge_l { get { return (GRGEN_MODEL.Ilink)_edge_l; } }
			public GRGEN_LGSP.LGSPEdge _edge_l;
			public enum adaptAccessUseAccessorsAlways_EdgeNums { @l, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)adaptAccessUseAccessorsAlways_EdgeNums.@l: return _edge_l;
				default: return null;
				}
			}
			
			public enum adaptAccessUseAccessorsAlways_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptAccessUseAccessorsAlways_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptAccessUseAccessorsAlways_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptAccessUseAccessorsAlways_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptAccessUseAccessorsAlways_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_adaptAccessUseAccessorsAlways.instance.pat_adaptAccessUseAccessorsAlways; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_adaptUpdateUseAccessorsAlways : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_adaptUpdateUseAccessorsAlways instance = null;
		public static Rule_adaptUpdateUseAccessorsAlways Instance { get { if (instance==null) { instance = new Rule_adaptUpdateUseAccessorsAlways(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] adaptUpdateUseAccessorsAlways_node_u_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptUpdateUseAccessorsAlways_node_v_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptUpdateUseAccessorsAlways_node_exp_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptUpdateUseAccessorsAlways_node_c_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] adaptUpdateUseAccessorsAlways_node_setter_AllowedTypes = null;
		public static bool[] adaptUpdateUseAccessorsAlways_node_u_IsAllowedType = null;
		public static bool[] adaptUpdateUseAccessorsAlways_node_v_IsAllowedType = null;
		public static bool[] adaptUpdateUseAccessorsAlways_node_exp_IsAllowedType = null;
		public static bool[] adaptUpdateUseAccessorsAlways_node_c_IsAllowedType = null;
		public static bool[] adaptUpdateUseAccessorsAlways_node_setter_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] adaptUpdateUseAccessorsAlways_edge_l_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] adaptUpdateUseAccessorsAlways_edge_e_AllowedTypes = null;
		public static bool[] adaptUpdateUseAccessorsAlways_edge_l_IsAllowedType = null;
		public static bool[] adaptUpdateUseAccessorsAlways_edge_e_IsAllowedType = null;
		public enum adaptUpdateUseAccessorsAlways_NodeNums { @u, @v, @exp, @c, @setter, };
		public enum adaptUpdateUseAccessorsAlways_EdgeNums { @l, @e, };
		public enum adaptUpdateUseAccessorsAlways_VariableNums { };
		public enum adaptUpdateUseAccessorsAlways_SubNums { };
		public enum adaptUpdateUseAccessorsAlways_AltNums { };
		public enum adaptUpdateUseAccessorsAlways_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_adaptUpdateUseAccessorsAlways;


		private Rule_adaptUpdateUseAccessorsAlways()
		{
			name = "adaptUpdateUseAccessorsAlways";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Variable.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, };
			inputNames = new string[] { "adaptUpdateUseAccessorsAlways_node_c", "adaptUpdateUseAccessorsAlways_node_v", "adaptUpdateUseAccessorsAlways_node_setter", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] adaptUpdateUseAccessorsAlways_isNodeHomomorphicGlobal = new bool[5, 5] {
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
			};
			bool[,] adaptUpdateUseAccessorsAlways_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] adaptUpdateUseAccessorsAlways_isNodeTotallyHomomorphic = new bool[5] { false, false, false, false, false,  };
			bool[] adaptUpdateUseAccessorsAlways_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternNode adaptUpdateUseAccessorsAlways_node_u = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Update, "GRGEN_MODEL.IUpdate", "adaptUpdateUseAccessorsAlways_node_u", "u", adaptUpdateUseAccessorsAlways_node_u_AllowedTypes, adaptUpdateUseAccessorsAlways_node_u_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptUpdateUseAccessorsAlways_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "adaptUpdateUseAccessorsAlways_node_v", "v", adaptUpdateUseAccessorsAlways_node_v_AllowedTypes, adaptUpdateUseAccessorsAlways_node_v_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptUpdateUseAccessorsAlways_node_exp = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "adaptUpdateUseAccessorsAlways_node_exp", "exp", adaptUpdateUseAccessorsAlways_node_exp_AllowedTypes, adaptUpdateUseAccessorsAlways_node_exp_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptUpdateUseAccessorsAlways_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "adaptUpdateUseAccessorsAlways_node_c", "c", adaptUpdateUseAccessorsAlways_node_c_AllowedTypes, adaptUpdateUseAccessorsAlways_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode adaptUpdateUseAccessorsAlways_node_setter = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "adaptUpdateUseAccessorsAlways_node_setter", "setter", adaptUpdateUseAccessorsAlways_node_setter_AllowedTypes, adaptUpdateUseAccessorsAlways_node_setter_IsAllowedType, 5.5F, 2, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge adaptUpdateUseAccessorsAlways_edge_l = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "adaptUpdateUseAccessorsAlways_edge_l", "l", adaptUpdateUseAccessorsAlways_edge_l_AllowedTypes, adaptUpdateUseAccessorsAlways_edge_l_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge adaptUpdateUseAccessorsAlways_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "adaptUpdateUseAccessorsAlways_edge_e", "e", adaptUpdateUseAccessorsAlways_edge_e_AllowedTypes, adaptUpdateUseAccessorsAlways_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_adaptUpdateUseAccessorsAlways = new GRGEN_LGSP.PatternGraph(
				"adaptUpdateUseAccessorsAlways",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { adaptUpdateUseAccessorsAlways_node_u, adaptUpdateUseAccessorsAlways_node_v, adaptUpdateUseAccessorsAlways_node_exp, adaptUpdateUseAccessorsAlways_node_c, adaptUpdateUseAccessorsAlways_node_setter }, 
				new GRGEN_LGSP.PatternEdge[] { adaptUpdateUseAccessorsAlways_edge_l, adaptUpdateUseAccessorsAlways_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[5, 5] {
					{ true, false, false, false, false, },
					{ false, true, false, false, false, },
					{ false, false, true, false, false, },
					{ false, false, false, true, false, },
					{ false, false, false, false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				adaptUpdateUseAccessorsAlways_isNodeHomomorphicGlobal,
				adaptUpdateUseAccessorsAlways_isEdgeHomomorphicGlobal,
				adaptUpdateUseAccessorsAlways_isNodeTotallyHomomorphic,
				adaptUpdateUseAccessorsAlways_isEdgeTotallyHomomorphic
			);
			pat_adaptUpdateUseAccessorsAlways.edgeToSourceNode.Add(adaptUpdateUseAccessorsAlways_edge_l, adaptUpdateUseAccessorsAlways_node_u);
			pat_adaptUpdateUseAccessorsAlways.edgeToTargetNode.Add(adaptUpdateUseAccessorsAlways_edge_l, adaptUpdateUseAccessorsAlways_node_v);
			pat_adaptUpdateUseAccessorsAlways.edgeToSourceNode.Add(adaptUpdateUseAccessorsAlways_edge_e, adaptUpdateUseAccessorsAlways_node_u);
			pat_adaptUpdateUseAccessorsAlways.edgeToTargetNode.Add(adaptUpdateUseAccessorsAlways_edge_e, adaptUpdateUseAccessorsAlways_node_exp);

			adaptUpdateUseAccessorsAlways_node_u.pointOfDefinition = pat_adaptUpdateUseAccessorsAlways;
			adaptUpdateUseAccessorsAlways_node_v.pointOfDefinition = null;
			adaptUpdateUseAccessorsAlways_node_exp.pointOfDefinition = pat_adaptUpdateUseAccessorsAlways;
			adaptUpdateUseAccessorsAlways_node_c.pointOfDefinition = null;
			adaptUpdateUseAccessorsAlways_node_setter.pointOfDefinition = null;
			adaptUpdateUseAccessorsAlways_edge_l.pointOfDefinition = pat_adaptUpdateUseAccessorsAlways;
			adaptUpdateUseAccessorsAlways_edge_e.pointOfDefinition = pat_adaptUpdateUseAccessorsAlways;

			patternGraph = pat_adaptUpdateUseAccessorsAlways;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_adaptUpdateUseAccessorsAlways curMatch = (Match_adaptUpdateUseAccessorsAlways)_curMatch;
			GRGEN_LGSP.LGSPNode node_u = curMatch._node_u;
			GRGEN_LGSP.LGSPNode node_setter = curMatch._node_setter;
			GRGEN_LGSP.LGSPNode node_exp = curMatch._node_exp;
			GRGEN_LGSP.LGSPEdge edge_l = curMatch._edge_l;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			graph.SettingAddedNodeNames( adaptUpdateUseAccessorsAlways_addedNodeNames );
			GRGEN_LGSP.LGSPNode node_call = graph.Retype(node_u, GRGEN_MODEL.NodeType_Call.typeVar);
			graph.SettingAddedEdgeNames( adaptUpdateUseAccessorsAlways_addedEdgeNames );
			GRGEN_MODEL.@link edge__edge0 = GRGEN_MODEL.@link.CreateEdge(graph, node_call, node_setter);
			GRGEN_MODEL.@actualParameter edge__edge1 = GRGEN_MODEL.@actualParameter.CreateEdge(graph, node_call, node_exp);
			graph.Remove(edge_l);
			graph.Remove(edge_e);
			return;
		}
		private static string[] adaptUpdateUseAccessorsAlways_addedNodeNames = new string[] {  };
		private static string[] adaptUpdateUseAccessorsAlways_addedEdgeNames = new string[] { "_edge0", "_edge1" };

		static Rule_adaptUpdateUseAccessorsAlways() {
		}

		public interface IMatch_adaptUpdateUseAccessorsAlways : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IUpdate node_u { get; }
			GRGEN_MODEL.IVariable node_v { get; }
			GRGEN_MODEL.IExpression node_exp { get; }
			GRGEN_MODEL.IClass node_c { get; }
			GRGEN_MODEL.IOperation node_setter { get; }
			//Edges
			GRGEN_MODEL.Ilink edge_l { get; }
			GRGEN_MODEL.Iexpression edge_e { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_adaptUpdateUseAccessorsAlways : GRGEN_LGSP.ListElement<Match_adaptUpdateUseAccessorsAlways>, IMatch_adaptUpdateUseAccessorsAlways
		{
			public GRGEN_MODEL.IUpdate node_u { get { return (GRGEN_MODEL.IUpdate)_node_u; } }
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_MODEL.IExpression node_exp { get { return (GRGEN_MODEL.IExpression)_node_exp; } }
			public GRGEN_MODEL.IClass node_c { get { return (GRGEN_MODEL.IClass)_node_c; } }
			public GRGEN_MODEL.IOperation node_setter { get { return (GRGEN_MODEL.IOperation)_node_setter; } }
			public GRGEN_LGSP.LGSPNode _node_u;
			public GRGEN_LGSP.LGSPNode _node_v;
			public GRGEN_LGSP.LGSPNode _node_exp;
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_setter;
			public enum adaptUpdateUseAccessorsAlways_NodeNums { @u, @v, @exp, @c, @setter, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 5;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)adaptUpdateUseAccessorsAlways_NodeNums.@u: return _node_u;
				case (int)adaptUpdateUseAccessorsAlways_NodeNums.@v: return _node_v;
				case (int)adaptUpdateUseAccessorsAlways_NodeNums.@exp: return _node_exp;
				case (int)adaptUpdateUseAccessorsAlways_NodeNums.@c: return _node_c;
				case (int)adaptUpdateUseAccessorsAlways_NodeNums.@setter: return _node_setter;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ilink edge_l { get { return (GRGEN_MODEL.Ilink)_edge_l; } }
			public GRGEN_MODEL.Iexpression edge_e { get { return (GRGEN_MODEL.Iexpression)_edge_e; } }
			public GRGEN_LGSP.LGSPEdge _edge_l;
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum adaptUpdateUseAccessorsAlways_EdgeNums { @l, @e, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)adaptUpdateUseAccessorsAlways_EdgeNums.@l: return _edge_l;
				case (int)adaptUpdateUseAccessorsAlways_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			
			public enum adaptUpdateUseAccessorsAlways_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptUpdateUseAccessorsAlways_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptUpdateUseAccessorsAlways_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptUpdateUseAccessorsAlways_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum adaptUpdateUseAccessorsAlways_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_adaptUpdateUseAccessorsAlways.instance.pat_adaptUpdateUseAccessorsAlways; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_getSourceAndTargetAndMethodBody : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_getSourceAndTargetAndMethodBody instance = null;
		public static Rule_getSourceAndTargetAndMethodBody Instance { get { if (instance==null) { instance = new Rule_getSourceAndTargetAndMethodBody(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] getSourceAndTargetAndMethodBody_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] getSourceAndTargetAndMethodBody_node_tgt_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] getSourceAndTargetAndMethodBody_node_mb_AllowedTypes = null;
		public static bool[] getSourceAndTargetAndMethodBody_node_src_IsAllowedType = null;
		public static bool[] getSourceAndTargetAndMethodBody_node_tgt_IsAllowedType = null;
		public static bool[] getSourceAndTargetAndMethodBody_node_mb_IsAllowedType = null;
		public enum getSourceAndTargetAndMethodBody_NodeNums { @src, @tgt, @mb, };
		public enum getSourceAndTargetAndMethodBody_EdgeNums { };
		public enum getSourceAndTargetAndMethodBody_VariableNums { };
		public enum getSourceAndTargetAndMethodBody_SubNums { };
		public enum getSourceAndTargetAndMethodBody_AltNums { };
		public enum getSourceAndTargetAndMethodBody_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_getSourceAndTargetAndMethodBody;


		private Rule_getSourceAndTargetAndMethodBody()
		{
			name = "getSourceAndTargetAndMethodBody";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_MethodBody.typeVar, };
			inputNames = new string[] { "getSourceAndTargetAndMethodBody_node_src", "getSourceAndTargetAndMethodBody_node_tgt", "getSourceAndTargetAndMethodBody_node_mb", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_MethodBody.typeVar, };

		}
		private void initialize()
		{
			bool[,] getSourceAndTargetAndMethodBody_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] getSourceAndTargetAndMethodBody_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] getSourceAndTargetAndMethodBody_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] getSourceAndTargetAndMethodBody_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode getSourceAndTargetAndMethodBody_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "getSourceAndTargetAndMethodBody_node_src", "src", getSourceAndTargetAndMethodBody_node_src_AllowedTypes, getSourceAndTargetAndMethodBody_node_src_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode getSourceAndTargetAndMethodBody_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "getSourceAndTargetAndMethodBody_node_tgt", "tgt", getSourceAndTargetAndMethodBody_node_tgt_AllowedTypes, getSourceAndTargetAndMethodBody_node_tgt_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode getSourceAndTargetAndMethodBody_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "getSourceAndTargetAndMethodBody_node_mb", "mb", getSourceAndTargetAndMethodBody_node_mb_AllowedTypes, getSourceAndTargetAndMethodBody_node_mb_IsAllowedType, 5.5F, 2, false, null, null, null, null, null, false);
			pat_getSourceAndTargetAndMethodBody = new GRGEN_LGSP.PatternGraph(
				"getSourceAndTargetAndMethodBody",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { getSourceAndTargetAndMethodBody_node_src, getSourceAndTargetAndMethodBody_node_tgt, getSourceAndTargetAndMethodBody_node_mb }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[0, 0] ,
				getSourceAndTargetAndMethodBody_isNodeHomomorphicGlobal,
				getSourceAndTargetAndMethodBody_isEdgeHomomorphicGlobal,
				getSourceAndTargetAndMethodBody_isNodeTotallyHomomorphic,
				getSourceAndTargetAndMethodBody_isEdgeTotallyHomomorphic
			);

			getSourceAndTargetAndMethodBody_node_src.pointOfDefinition = null;
			getSourceAndTargetAndMethodBody_node_tgt.pointOfDefinition = null;
			getSourceAndTargetAndMethodBody_node_mb.pointOfDefinition = null;

			patternGraph = pat_getSourceAndTargetAndMethodBody;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IClass output_0, out GRGEN_MODEL.IClass output_1, out GRGEN_MODEL.IMethodBody output_2)
		{
			Match_getSourceAndTargetAndMethodBody curMatch = (Match_getSourceAndTargetAndMethodBody)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPNode node_mb = curMatch._node_mb;
			output_0 = (GRGEN_MODEL.IClass)(node_src);
			output_1 = (GRGEN_MODEL.IClass)(node_tgt);
			output_2 = (GRGEN_MODEL.IMethodBody)(node_mb);
			return;
		}

		static Rule_getSourceAndTargetAndMethodBody() {
		}

		public interface IMatch_getSourceAndTargetAndMethodBody : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IClass node_src { get; }
			GRGEN_MODEL.IClass node_tgt { get; }
			GRGEN_MODEL.IMethodBody node_mb { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_getSourceAndTargetAndMethodBody : GRGEN_LGSP.ListElement<Match_getSourceAndTargetAndMethodBody>, IMatch_getSourceAndTargetAndMethodBody
		{
			public GRGEN_MODEL.IClass node_src { get { return (GRGEN_MODEL.IClass)_node_src; } }
			public GRGEN_MODEL.IClass node_tgt { get { return (GRGEN_MODEL.IClass)_node_tgt; } }
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public GRGEN_LGSP.LGSPNode _node_mb;
			public enum getSourceAndTargetAndMethodBody_NodeNums { @src, @tgt, @mb, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)getSourceAndTargetAndMethodBody_NodeNums.@src: return _node_src;
				case (int)getSourceAndTargetAndMethodBody_NodeNums.@tgt: return _node_tgt;
				case (int)getSourceAndTargetAndMethodBody_NodeNums.@mb: return _node_mb;
				default: return null;
				}
			}
			
			public enum getSourceAndTargetAndMethodBody_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getSourceAndTargetAndMethodBody_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getSourceAndTargetAndMethodBody_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getSourceAndTargetAndMethodBody_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getSourceAndTargetAndMethodBody_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getSourceAndTargetAndMethodBody_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_getSourceAndTargetAndMethodBody.instance.pat_getSourceAndTargetAndMethodBody; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_getOperation : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_getOperation instance = null;
		public static Rule_getOperation Instance { get { if (instance==null) { instance = new Rule_getOperation(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] getOperation_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] getOperation_node_mb_AllowedTypes = null;
		public static bool[] getOperation_node_op_IsAllowedType = null;
		public static bool[] getOperation_node_mb_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] getOperation_edge__edge0_AllowedTypes = null;
		public static bool[] getOperation_edge__edge0_IsAllowedType = null;
		public enum getOperation_NodeNums { @op, @mb, };
		public enum getOperation_EdgeNums { @_edge0, };
		public enum getOperation_VariableNums { };
		public enum getOperation_SubNums { };
		public enum getOperation_AltNums { };
		public enum getOperation_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_getOperation;


		private Rule_getOperation()
		{
			name = "getOperation";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_MethodBody.typeVar, };
			inputNames = new string[] { "getOperation_node_mb", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, };

		}
		private void initialize()
		{
			bool[,] getOperation_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] getOperation_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] getOperation_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] getOperation_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode getOperation_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "getOperation_node_op", "op", getOperation_node_op_AllowedTypes, getOperation_node_op_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode getOperation_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "getOperation_node_mb", "mb", getOperation_node_mb_AllowedTypes, getOperation_node_mb_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge getOperation_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@binding, "GRGEN_MODEL.Ibinding", "getOperation_edge__edge0", "_edge0", getOperation_edge__edge0_AllowedTypes, getOperation_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_getOperation = new GRGEN_LGSP.PatternGraph(
				"getOperation",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { getOperation_node_op, getOperation_node_mb }, 
				new GRGEN_LGSP.PatternEdge[] { getOperation_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				getOperation_isNodeHomomorphicGlobal,
				getOperation_isEdgeHomomorphicGlobal,
				getOperation_isNodeTotallyHomomorphic,
				getOperation_isEdgeTotallyHomomorphic
			);
			pat_getOperation.edgeToSourceNode.Add(getOperation_edge__edge0, getOperation_node_op);
			pat_getOperation.edgeToTargetNode.Add(getOperation_edge__edge0, getOperation_node_mb);

			getOperation_node_op.pointOfDefinition = pat_getOperation;
			getOperation_node_mb.pointOfDefinition = null;
			getOperation_edge__edge0.pointOfDefinition = pat_getOperation;

			patternGraph = pat_getOperation;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IOperation output_0)
		{
			Match_getOperation curMatch = (Match_getOperation)_curMatch;
			GRGEN_LGSP.LGSPNode node_op = curMatch._node_op;
			output_0 = (GRGEN_MODEL.IOperation)(node_op);
			return;
		}

		static Rule_getOperation() {
		}

		public interface IMatch_getOperation : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IMethodBody node_mb { get; }
			//Edges
			GRGEN_MODEL.Ibinding edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_getOperation : GRGEN_LGSP.ListElement<Match_getOperation>, IMatch_getOperation
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_mb;
			public enum getOperation_NodeNums { @op, @mb, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)getOperation_NodeNums.@op: return _node_op;
				case (int)getOperation_NodeNums.@mb: return _node_mb;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ibinding edge__edge0 { get { return (GRGEN_MODEL.Ibinding)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum getOperation_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)getOperation_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum getOperation_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getOperation_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getOperation_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getOperation_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getOperation_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_getOperation.instance.pat_getOperation; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_someInstanceVariableOfTargetType : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_someInstanceVariableOfTargetType instance = null;
		public static Rule_someInstanceVariableOfTargetType Instance { get { if (instance==null) { instance = new Rule_someInstanceVariableOfTargetType(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] someInstanceVariableOfTargetType_node_mb_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] someInstanceVariableOfTargetType_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] someInstanceVariableOfTargetType_node_v_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] someInstanceVariableOfTargetType_node_tgt_AllowedTypes = null;
		public static bool[] someInstanceVariableOfTargetType_node_mb_IsAllowedType = null;
		public static bool[] someInstanceVariableOfTargetType_node_src_IsAllowedType = null;
		public static bool[] someInstanceVariableOfTargetType_node_v_IsAllowedType = null;
		public static bool[] someInstanceVariableOfTargetType_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] someInstanceVariableOfTargetType_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] someInstanceVariableOfTargetType_edge__edge1_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] someInstanceVariableOfTargetType_edge__edge2_AllowedTypes = null;
		public static bool[] someInstanceVariableOfTargetType_edge__edge0_IsAllowedType = null;
		public static bool[] someInstanceVariableOfTargetType_edge__edge1_IsAllowedType = null;
		public static bool[] someInstanceVariableOfTargetType_edge__edge2_IsAllowedType = null;
		public enum someInstanceVariableOfTargetType_NodeNums { @mb, @src, @v, @tgt, };
		public enum someInstanceVariableOfTargetType_EdgeNums { @_edge0, @_edge1, @_edge2, };
		public enum someInstanceVariableOfTargetType_VariableNums { };
		public enum someInstanceVariableOfTargetType_SubNums { };
		public enum someInstanceVariableOfTargetType_AltNums { };
		public enum someInstanceVariableOfTargetType_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_someInstanceVariableOfTargetType;


		private Rule_someInstanceVariableOfTargetType()
		{
			name = "someInstanceVariableOfTargetType";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_MethodBody.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, };
			inputNames = new string[] { "someInstanceVariableOfTargetType_node_mb", "someInstanceVariableOfTargetType_node_tgt", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Variable.typeVar, };

		}
		private void initialize()
		{
			bool[,] someInstanceVariableOfTargetType_isNodeHomomorphicGlobal = new bool[4, 4] {
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
			};
			bool[,] someInstanceVariableOfTargetType_isEdgeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[] someInstanceVariableOfTargetType_isNodeTotallyHomomorphic = new bool[4] { false, false, false, false,  };
			bool[] someInstanceVariableOfTargetType_isEdgeTotallyHomomorphic = new bool[3] { false, false, false,  };
			GRGEN_LGSP.PatternNode someInstanceVariableOfTargetType_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "someInstanceVariableOfTargetType_node_mb", "mb", someInstanceVariableOfTargetType_node_mb_AllowedTypes, someInstanceVariableOfTargetType_node_mb_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode someInstanceVariableOfTargetType_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "someInstanceVariableOfTargetType_node_src", "src", someInstanceVariableOfTargetType_node_src_AllowedTypes, someInstanceVariableOfTargetType_node_src_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode someInstanceVariableOfTargetType_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "someInstanceVariableOfTargetType_node_v", "v", someInstanceVariableOfTargetType_node_v_AllowedTypes, someInstanceVariableOfTargetType_node_v_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode someInstanceVariableOfTargetType_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "someInstanceVariableOfTargetType_node_tgt", "tgt", someInstanceVariableOfTargetType_node_tgt_AllowedTypes, someInstanceVariableOfTargetType_node_tgt_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge someInstanceVariableOfTargetType_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "someInstanceVariableOfTargetType_edge__edge0", "_edge0", someInstanceVariableOfTargetType_edge__edge0_AllowedTypes, someInstanceVariableOfTargetType_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge someInstanceVariableOfTargetType_edge__edge1 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "someInstanceVariableOfTargetType_edge__edge1", "_edge1", someInstanceVariableOfTargetType_edge__edge1_AllowedTypes, someInstanceVariableOfTargetType_edge__edge1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge someInstanceVariableOfTargetType_edge__edge2 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@type_, "GRGEN_MODEL.Itype_", "someInstanceVariableOfTargetType_edge__edge2", "_edge2", someInstanceVariableOfTargetType_edge__edge2_AllowedTypes, someInstanceVariableOfTargetType_edge__edge2_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_someInstanceVariableOfTargetType = new GRGEN_LGSP.PatternGraph(
				"someInstanceVariableOfTargetType",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { someInstanceVariableOfTargetType_node_mb, someInstanceVariableOfTargetType_node_src, someInstanceVariableOfTargetType_node_v, someInstanceVariableOfTargetType_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { someInstanceVariableOfTargetType_edge__edge0, someInstanceVariableOfTargetType_edge__edge1, someInstanceVariableOfTargetType_edge__edge2 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[4, 4] {
					{ true, false, false, false, },
					{ false, true, false, false, },
					{ false, false, true, false, },
					{ false, false, false, true, },
				},
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				someInstanceVariableOfTargetType_isNodeHomomorphicGlobal,
				someInstanceVariableOfTargetType_isEdgeHomomorphicGlobal,
				someInstanceVariableOfTargetType_isNodeTotallyHomomorphic,
				someInstanceVariableOfTargetType_isEdgeTotallyHomomorphic
			);
			pat_someInstanceVariableOfTargetType.edgeToSourceNode.Add(someInstanceVariableOfTargetType_edge__edge0, someInstanceVariableOfTargetType_node_mb);
			pat_someInstanceVariableOfTargetType.edgeToTargetNode.Add(someInstanceVariableOfTargetType_edge__edge0, someInstanceVariableOfTargetType_node_src);
			pat_someInstanceVariableOfTargetType.edgeToSourceNode.Add(someInstanceVariableOfTargetType_edge__edge1, someInstanceVariableOfTargetType_node_v);
			pat_someInstanceVariableOfTargetType.edgeToTargetNode.Add(someInstanceVariableOfTargetType_edge__edge1, someInstanceVariableOfTargetType_node_src);
			pat_someInstanceVariableOfTargetType.edgeToSourceNode.Add(someInstanceVariableOfTargetType_edge__edge2, someInstanceVariableOfTargetType_node_v);
			pat_someInstanceVariableOfTargetType.edgeToTargetNode.Add(someInstanceVariableOfTargetType_edge__edge2, someInstanceVariableOfTargetType_node_tgt);

			someInstanceVariableOfTargetType_node_mb.pointOfDefinition = null;
			someInstanceVariableOfTargetType_node_src.pointOfDefinition = pat_someInstanceVariableOfTargetType;
			someInstanceVariableOfTargetType_node_v.pointOfDefinition = pat_someInstanceVariableOfTargetType;
			someInstanceVariableOfTargetType_node_tgt.pointOfDefinition = null;
			someInstanceVariableOfTargetType_edge__edge0.pointOfDefinition = pat_someInstanceVariableOfTargetType;
			someInstanceVariableOfTargetType_edge__edge1.pointOfDefinition = pat_someInstanceVariableOfTargetType;
			someInstanceVariableOfTargetType_edge__edge2.pointOfDefinition = pat_someInstanceVariableOfTargetType;

			patternGraph = pat_someInstanceVariableOfTargetType;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IVariable output_0)
		{
			Match_someInstanceVariableOfTargetType curMatch = (Match_someInstanceVariableOfTargetType)_curMatch;
			GRGEN_LGSP.LGSPNode node_v = curMatch._node_v;
			output_0 = (GRGEN_MODEL.IVariable)(node_v);
			return;
		}

		static Rule_someInstanceVariableOfTargetType() {
		}

		public interface IMatch_someInstanceVariableOfTargetType : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IMethodBody node_mb { get; }
			GRGEN_MODEL.IClass node_src { get; }
			GRGEN_MODEL.IVariable node_v { get; }
			GRGEN_MODEL.IClass node_tgt { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge0 { get; }
			GRGEN_MODEL.IbelongsTo edge__edge1 { get; }
			GRGEN_MODEL.Itype_ edge__edge2 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_someInstanceVariableOfTargetType : GRGEN_LGSP.ListElement<Match_someInstanceVariableOfTargetType>, IMatch_someInstanceVariableOfTargetType
		{
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_MODEL.IClass node_src { get { return (GRGEN_MODEL.IClass)_node_src; } }
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_MODEL.IClass node_tgt { get { return (GRGEN_MODEL.IClass)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_mb;
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_v;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum someInstanceVariableOfTargetType_NodeNums { @mb, @src, @v, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 4;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)someInstanceVariableOfTargetType_NodeNums.@mb: return _node_mb;
				case (int)someInstanceVariableOfTargetType_NodeNums.@src: return _node_src;
				case (int)someInstanceVariableOfTargetType_NodeNums.@v: return _node_v;
				case (int)someInstanceVariableOfTargetType_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge0 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge0; } }
			public GRGEN_MODEL.IbelongsTo edge__edge1 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge1; } }
			public GRGEN_MODEL.Itype_ edge__edge2 { get { return (GRGEN_MODEL.Itype_)_edge__edge2; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge__edge1;
			public GRGEN_LGSP.LGSPEdge _edge__edge2;
			public enum someInstanceVariableOfTargetType_EdgeNums { @_edge0, @_edge1, @_edge2, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 3;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)someInstanceVariableOfTargetType_EdgeNums.@_edge0: return _edge__edge0;
				case (int)someInstanceVariableOfTargetType_EdgeNums.@_edge1: return _edge__edge1;
				case (int)someInstanceVariableOfTargetType_EdgeNums.@_edge2: return _edge__edge2;
				default: return null;
				}
			}
			
			public enum someInstanceVariableOfTargetType_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum someInstanceVariableOfTargetType_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum someInstanceVariableOfTargetType_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum someInstanceVariableOfTargetType_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum someInstanceVariableOfTargetType_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_someInstanceVariableOfTargetType.instance.pat_someInstanceVariableOfTargetType; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_someParameterOfTargetType : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_someParameterOfTargetType instance = null;
		public static Rule_someParameterOfTargetType Instance { get { if (instance==null) { instance = new Rule_someParameterOfTargetType(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] someParameterOfTargetType_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] someParameterOfTargetType_node_mb_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] someParameterOfTargetType_node_p_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] someParameterOfTargetType_node_tgt_AllowedTypes = null;
		public static bool[] someParameterOfTargetType_node_op_IsAllowedType = null;
		public static bool[] someParameterOfTargetType_node_mb_IsAllowedType = null;
		public static bool[] someParameterOfTargetType_node_p_IsAllowedType = null;
		public static bool[] someParameterOfTargetType_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] someParameterOfTargetType_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] someParameterOfTargetType_edge__edge1_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] someParameterOfTargetType_edge__edge2_AllowedTypes = null;
		public static bool[] someParameterOfTargetType_edge__edge0_IsAllowedType = null;
		public static bool[] someParameterOfTargetType_edge__edge1_IsAllowedType = null;
		public static bool[] someParameterOfTargetType_edge__edge2_IsAllowedType = null;
		public enum someParameterOfTargetType_NodeNums { @op, @mb, @p, @tgt, };
		public enum someParameterOfTargetType_EdgeNums { @_edge0, @_edge1, @_edge2, };
		public enum someParameterOfTargetType_VariableNums { };
		public enum someParameterOfTargetType_SubNums { };
		public enum someParameterOfTargetType_AltNums { };
		public enum someParameterOfTargetType_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_someParameterOfTargetType;


		private Rule_someParameterOfTargetType()
		{
			name = "someParameterOfTargetType";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_MethodBody.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, };
			inputNames = new string[] { "someParameterOfTargetType_node_mb", "someParameterOfTargetType_node_tgt", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Parameter.typeVar, };

		}
		private void initialize()
		{
			bool[,] someParameterOfTargetType_isNodeHomomorphicGlobal = new bool[4, 4] {
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
			};
			bool[,] someParameterOfTargetType_isEdgeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[] someParameterOfTargetType_isNodeTotallyHomomorphic = new bool[4] { false, false, false, false,  };
			bool[] someParameterOfTargetType_isEdgeTotallyHomomorphic = new bool[3] { false, false, false,  };
			GRGEN_LGSP.PatternNode someParameterOfTargetType_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "someParameterOfTargetType_node_op", "op", someParameterOfTargetType_node_op_AllowedTypes, someParameterOfTargetType_node_op_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode someParameterOfTargetType_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "someParameterOfTargetType_node_mb", "mb", someParameterOfTargetType_node_mb_AllowedTypes, someParameterOfTargetType_node_mb_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode someParameterOfTargetType_node_p = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Parameter, "GRGEN_MODEL.IParameter", "someParameterOfTargetType_node_p", "p", someParameterOfTargetType_node_p_AllowedTypes, someParameterOfTargetType_node_p_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode someParameterOfTargetType_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "someParameterOfTargetType_node_tgt", "tgt", someParameterOfTargetType_node_tgt_AllowedTypes, someParameterOfTargetType_node_tgt_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge someParameterOfTargetType_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@binding, "GRGEN_MODEL.Ibinding", "someParameterOfTargetType_edge__edge0", "_edge0", someParameterOfTargetType_edge__edge0_AllowedTypes, someParameterOfTargetType_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge someParameterOfTargetType_edge__edge1 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@parameter, "GRGEN_MODEL.Iparameter", "someParameterOfTargetType_edge__edge1", "_edge1", someParameterOfTargetType_edge__edge1_AllowedTypes, someParameterOfTargetType_edge__edge1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge someParameterOfTargetType_edge__edge2 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@type_, "GRGEN_MODEL.Itype_", "someParameterOfTargetType_edge__edge2", "_edge2", someParameterOfTargetType_edge__edge2_AllowedTypes, someParameterOfTargetType_edge__edge2_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_someParameterOfTargetType = new GRGEN_LGSP.PatternGraph(
				"someParameterOfTargetType",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { someParameterOfTargetType_node_op, someParameterOfTargetType_node_mb, someParameterOfTargetType_node_p, someParameterOfTargetType_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { someParameterOfTargetType_edge__edge0, someParameterOfTargetType_edge__edge1, someParameterOfTargetType_edge__edge2 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[4, 4] {
					{ true, false, false, false, },
					{ false, true, false, false, },
					{ false, false, true, false, },
					{ false, false, false, true, },
				},
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				someParameterOfTargetType_isNodeHomomorphicGlobal,
				someParameterOfTargetType_isEdgeHomomorphicGlobal,
				someParameterOfTargetType_isNodeTotallyHomomorphic,
				someParameterOfTargetType_isEdgeTotallyHomomorphic
			);
			pat_someParameterOfTargetType.edgeToSourceNode.Add(someParameterOfTargetType_edge__edge0, someParameterOfTargetType_node_op);
			pat_someParameterOfTargetType.edgeToTargetNode.Add(someParameterOfTargetType_edge__edge0, someParameterOfTargetType_node_mb);
			pat_someParameterOfTargetType.edgeToSourceNode.Add(someParameterOfTargetType_edge__edge1, someParameterOfTargetType_node_op);
			pat_someParameterOfTargetType.edgeToTargetNode.Add(someParameterOfTargetType_edge__edge1, someParameterOfTargetType_node_p);
			pat_someParameterOfTargetType.edgeToSourceNode.Add(someParameterOfTargetType_edge__edge2, someParameterOfTargetType_node_p);
			pat_someParameterOfTargetType.edgeToTargetNode.Add(someParameterOfTargetType_edge__edge2, someParameterOfTargetType_node_tgt);

			someParameterOfTargetType_node_op.pointOfDefinition = pat_someParameterOfTargetType;
			someParameterOfTargetType_node_mb.pointOfDefinition = null;
			someParameterOfTargetType_node_p.pointOfDefinition = pat_someParameterOfTargetType;
			someParameterOfTargetType_node_tgt.pointOfDefinition = null;
			someParameterOfTargetType_edge__edge0.pointOfDefinition = pat_someParameterOfTargetType;
			someParameterOfTargetType_edge__edge1.pointOfDefinition = pat_someParameterOfTargetType;
			someParameterOfTargetType_edge__edge2.pointOfDefinition = pat_someParameterOfTargetType;

			patternGraph = pat_someParameterOfTargetType;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IParameter output_0)
		{
			Match_someParameterOfTargetType curMatch = (Match_someParameterOfTargetType)_curMatch;
			GRGEN_LGSP.LGSPNode node_p = curMatch._node_p;
			output_0 = (GRGEN_MODEL.IParameter)(node_p);
			return;
		}

		static Rule_someParameterOfTargetType() {
		}

		public interface IMatch_someParameterOfTargetType : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IMethodBody node_mb { get; }
			GRGEN_MODEL.IParameter node_p { get; }
			GRGEN_MODEL.IClass node_tgt { get; }
			//Edges
			GRGEN_MODEL.Ibinding edge__edge0 { get; }
			GRGEN_MODEL.Iparameter edge__edge1 { get; }
			GRGEN_MODEL.Itype_ edge__edge2 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_someParameterOfTargetType : GRGEN_LGSP.ListElement<Match_someParameterOfTargetType>, IMatch_someParameterOfTargetType
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_MODEL.IParameter node_p { get { return (GRGEN_MODEL.IParameter)_node_p; } }
			public GRGEN_MODEL.IClass node_tgt { get { return (GRGEN_MODEL.IClass)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_mb;
			public GRGEN_LGSP.LGSPNode _node_p;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum someParameterOfTargetType_NodeNums { @op, @mb, @p, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 4;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)someParameterOfTargetType_NodeNums.@op: return _node_op;
				case (int)someParameterOfTargetType_NodeNums.@mb: return _node_mb;
				case (int)someParameterOfTargetType_NodeNums.@p: return _node_p;
				case (int)someParameterOfTargetType_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ibinding edge__edge0 { get { return (GRGEN_MODEL.Ibinding)_edge__edge0; } }
			public GRGEN_MODEL.Iparameter edge__edge1 { get { return (GRGEN_MODEL.Iparameter)_edge__edge1; } }
			public GRGEN_MODEL.Itype_ edge__edge2 { get { return (GRGEN_MODEL.Itype_)_edge__edge2; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge__edge1;
			public GRGEN_LGSP.LGSPEdge _edge__edge2;
			public enum someParameterOfTargetType_EdgeNums { @_edge0, @_edge1, @_edge2, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 3;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)someParameterOfTargetType_EdgeNums.@_edge0: return _edge__edge0;
				case (int)someParameterOfTargetType_EdgeNums.@_edge1: return _edge__edge1;
				case (int)someParameterOfTargetType_EdgeNums.@_edge2: return _edge__edge2;
				default: return null;
				}
			}
			
			public enum someParameterOfTargetType_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum someParameterOfTargetType_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum someParameterOfTargetType_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum someParameterOfTargetType_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum someParameterOfTargetType_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_someParameterOfTargetType.instance.pat_someParameterOfTargetType; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_markExpressionOfBody : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_markExpressionOfBody instance = null;
		public static Rule_markExpressionOfBody Instance { get { if (instance==null) { instance = new Rule_markExpressionOfBody(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] markExpressionOfBody_node__node0_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] markExpressionOfBody_node_mb_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] markExpressionOfBody_node_exp_AllowedTypes = null;
		public static bool[] markExpressionOfBody_node__node0_IsAllowedType = null;
		public static bool[] markExpressionOfBody_node_mb_IsAllowedType = null;
		public static bool[] markExpressionOfBody_node_exp_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] markExpressionOfBody_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] markExpressionOfBody_edge__edge1_AllowedTypes = null;
		public static bool[] markExpressionOfBody_edge__edge0_IsAllowedType = null;
		public static bool[] markExpressionOfBody_edge__edge1_IsAllowedType = null;
		public enum markExpressionOfBody_NodeNums { @_node0, @mb, @exp, };
		public enum markExpressionOfBody_EdgeNums { @_edge0, @_edge1, };
		public enum markExpressionOfBody_VariableNums { };
		public enum markExpressionOfBody_SubNums { };
		public enum markExpressionOfBody_AltNums { };
		public enum markExpressionOfBody_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_markExpressionOfBody;


		private Rule_markExpressionOfBody()
		{
			name = "markExpressionOfBody";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_MethodBody.typeVar, };
			inputNames = new string[] { "markExpressionOfBody_node_mb", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] markExpressionOfBody_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] markExpressionOfBody_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] markExpressionOfBody_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] markExpressionOfBody_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternNode markExpressionOfBody_node__node0 = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Block, "GRGEN_MODEL.IBlock", "markExpressionOfBody_node__node0", "_node0", markExpressionOfBody_node__node0_AllowedTypes, markExpressionOfBody_node__node0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode markExpressionOfBody_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "markExpressionOfBody_node_mb", "mb", markExpressionOfBody_node_mb_AllowedTypes, markExpressionOfBody_node_mb_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode markExpressionOfBody_node_exp = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "markExpressionOfBody_node_exp", "exp", markExpressionOfBody_node_exp_AllowedTypes, markExpressionOfBody_node_exp_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge markExpressionOfBody_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "markExpressionOfBody_edge__edge0", "_edge0", markExpressionOfBody_edge__edge0_AllowedTypes, markExpressionOfBody_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge markExpressionOfBody_edge__edge1 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "markExpressionOfBody_edge__edge1", "_edge1", markExpressionOfBody_edge__edge1_AllowedTypes, markExpressionOfBody_edge__edge1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition markExpressionOfBody_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("markExpressionOfBody_node_exp", new GRGEN_EXPR.Constant("0"))),
				new string[] { "markExpressionOfBody_node_exp" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			pat_markExpressionOfBody = new GRGEN_LGSP.PatternGraph(
				"markExpressionOfBody",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { markExpressionOfBody_node__node0, markExpressionOfBody_node_mb, markExpressionOfBody_node_exp }, 
				new GRGEN_LGSP.PatternEdge[] { markExpressionOfBody_edge__edge0, markExpressionOfBody_edge__edge1 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { markExpressionOfBody_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				markExpressionOfBody_isNodeHomomorphicGlobal,
				markExpressionOfBody_isEdgeHomomorphicGlobal,
				markExpressionOfBody_isNodeTotallyHomomorphic,
				markExpressionOfBody_isEdgeTotallyHomomorphic
			);
			pat_markExpressionOfBody.edgeToSourceNode.Add(markExpressionOfBody_edge__edge0, markExpressionOfBody_node__node0);
			pat_markExpressionOfBody.edgeToTargetNode.Add(markExpressionOfBody_edge__edge0, markExpressionOfBody_node_mb);
			pat_markExpressionOfBody.edgeToSourceNode.Add(markExpressionOfBody_edge__edge1, markExpressionOfBody_node__node0);
			pat_markExpressionOfBody.edgeToTargetNode.Add(markExpressionOfBody_edge__edge1, markExpressionOfBody_node_exp);

			markExpressionOfBody_node__node0.pointOfDefinition = pat_markExpressionOfBody;
			markExpressionOfBody_node_mb.pointOfDefinition = null;
			markExpressionOfBody_node_exp.pointOfDefinition = pat_markExpressionOfBody;
			markExpressionOfBody_edge__edge0.pointOfDefinition = pat_markExpressionOfBody;
			markExpressionOfBody_edge__edge1.pointOfDefinition = pat_markExpressionOfBody;

			patternGraph = pat_markExpressionOfBody;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_markExpressionOfBody curMatch = (Match_markExpressionOfBody)_curMatch;
			GRGEN_LGSP.LGSPNode node_exp = curMatch._node_exp;
			graph.SettingAddedNodeNames( markExpressionOfBody_addedNodeNames );
			graph.SettingAddedEdgeNames( markExpressionOfBody_addedEdgeNames );
			graph.SetVisited(node_exp, 0, true);
			ApplyXGRS_markExpressionOfBody_0(graph, (GRGEN_MODEL.IExpression)node_exp);
			return;
		}
		private static string[] markExpressionOfBody_addedNodeNames = new string[] {  };
		private static string[] markExpressionOfBody_addedEdgeNames = new string[] {  };

        public static bool ApplyXGRS_markExpressionOfBody_0(GRGEN_LGSP.LGSPGraph graph, GRGEN_MODEL.IExpression var_exp)
        {
            GRGEN_LGSP.LGSPActions actions = graph.curActions;
            bool res_62;
            bool res_61;
            bool res_59;
            Action_markExpressionFollowingExpression rule_markExpressionFollowingExpression = Action_markExpressionFollowingExpression.Instance;
            bool res_60;
            Action_markExpressionFollowingActualParameter rule_markExpressionFollowingActualParameter = Action_markExpressionFollowingActualParameter.Instance;
            long i_62 = 0;
            while(true)
            {
                GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> matches_59 = rule_markExpressionFollowingExpression.Match(graph, 1, (GRGEN_MODEL.IExpression)var_exp);
                graph.Matched(matches_59, false);
                if(matches_59.Count==0) {
                    res_59 = (bool)(false);
                } else {
                    res_59 = (bool)(true);
                    if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_59.Count;
                    graph.Finishing(matches_59, false);
                    Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression match_59 = matches_59.FirstExact;
                    rule_markExpressionFollowingExpression.Modify(graph, match_59);
                    if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                    graph.Finished(matches_59, false);
                }
                if(res_59)
                    res_61 = (bool)(true);
                else
                {
                    GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> matches_60 = rule_markExpressionFollowingActualParameter.Match(graph, 1, (GRGEN_MODEL.IExpression)var_exp);
                    graph.Matched(matches_60, false);
                    if(matches_60.Count==0) {
                        res_60 = (bool)(false);
                    } else {
                        res_60 = (bool)(true);
                        if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_60.Count;
                        graph.Finishing(matches_60, false);
                        Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter match_60 = matches_60.FirstExact;
                        rule_markExpressionFollowingActualParameter.Modify(graph, match_60);
                        if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                        graph.Finished(matches_60, false);
                    }
                    res_61 = (bool)(res_60);
                }
                if(!res_61) break;
                i_62++;
            }
            res_62 = (bool)(i_62 >= 0);
            return res_62;
        }

		static Rule_markExpressionOfBody() {
		}

		public interface IMatch_markExpressionOfBody : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IBlock node__node0 { get; }
			GRGEN_MODEL.IMethodBody node_mb { get; }
			GRGEN_MODEL.IExpression node_exp { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge__edge0 { get; }
			GRGEN_MODEL.Iexpression edge__edge1 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_markExpressionOfBody : GRGEN_LGSP.ListElement<Match_markExpressionOfBody>, IMatch_markExpressionOfBody
		{
			public GRGEN_MODEL.IBlock node__node0 { get { return (GRGEN_MODEL.IBlock)_node__node0; } }
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_MODEL.IExpression node_exp { get { return (GRGEN_MODEL.IExpression)_node_exp; } }
			public GRGEN_LGSP.LGSPNode _node__node0;
			public GRGEN_LGSP.LGSPNode _node_mb;
			public GRGEN_LGSP.LGSPNode _node_exp;
			public enum markExpressionOfBody_NodeNums { @_node0, @mb, @exp, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)markExpressionOfBody_NodeNums.@_node0: return _node__node0;
				case (int)markExpressionOfBody_NodeNums.@mb: return _node_mb;
				case (int)markExpressionOfBody_NodeNums.@exp: return _node_exp;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge__edge0 { get { return (GRGEN_MODEL.IbelongsTo)_edge__edge0; } }
			public GRGEN_MODEL.Iexpression edge__edge1 { get { return (GRGEN_MODEL.Iexpression)_edge__edge1; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge__edge1;
			public enum markExpressionOfBody_EdgeNums { @_edge0, @_edge1, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)markExpressionOfBody_EdgeNums.@_edge0: return _edge__edge0;
				case (int)markExpressionOfBody_EdgeNums.@_edge1: return _edge__edge1;
				default: return null;
				}
			}
			
			public enum markExpressionOfBody_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionOfBody_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionOfBody_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionOfBody_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionOfBody_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_markExpressionOfBody.instance.pat_markExpressionOfBody; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_markExpressionFollowingExpression : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_markExpressionFollowingExpression instance = null;
		public static Rule_markExpressionFollowingExpression Instance { get { if (instance==null) { instance = new Rule_markExpressionFollowingExpression(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] markExpressionFollowingExpression_node_root_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] markExpressionFollowingExpression_node_exp_AllowedTypes = null;
		public static bool[] markExpressionFollowingExpression_node_root_IsAllowedType = null;
		public static bool[] markExpressionFollowingExpression_node_exp_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] markExpressionFollowingExpression_edge__edge0_AllowedTypes = null;
		public static bool[] markExpressionFollowingExpression_edge__edge0_IsAllowedType = null;
		public enum markExpressionFollowingExpression_NodeNums { @root, @exp, };
		public enum markExpressionFollowingExpression_EdgeNums { @_edge0, };
		public enum markExpressionFollowingExpression_VariableNums { };
		public enum markExpressionFollowingExpression_SubNums { };
		public enum markExpressionFollowingExpression_AltNums { };
		public enum markExpressionFollowingExpression_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_markExpressionFollowingExpression;


		private Rule_markExpressionFollowingExpression()
		{
			name = "markExpressionFollowingExpression";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Expression.typeVar, };
			inputNames = new string[] { "markExpressionFollowingExpression_node_root", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] markExpressionFollowingExpression_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] markExpressionFollowingExpression_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] markExpressionFollowingExpression_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] markExpressionFollowingExpression_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode markExpressionFollowingExpression_node_root = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "markExpressionFollowingExpression_node_root", "root", markExpressionFollowingExpression_node_root_AllowedTypes, markExpressionFollowingExpression_node_root_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode markExpressionFollowingExpression_node_exp = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "markExpressionFollowingExpression_node_exp", "exp", markExpressionFollowingExpression_node_exp_AllowedTypes, markExpressionFollowingExpression_node_exp_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge markExpressionFollowingExpression_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "markExpressionFollowingExpression_edge__edge0", "_edge0", markExpressionFollowingExpression_edge__edge0_AllowedTypes, markExpressionFollowingExpression_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition markExpressionFollowingExpression_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("markExpressionFollowingExpression_node_exp", new GRGEN_EXPR.Constant("0"))),
				new string[] { "markExpressionFollowingExpression_node_exp" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			pat_markExpressionFollowingExpression = new GRGEN_LGSP.PatternGraph(
				"markExpressionFollowingExpression",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { markExpressionFollowingExpression_node_root, markExpressionFollowingExpression_node_exp }, 
				new GRGEN_LGSP.PatternEdge[] { markExpressionFollowingExpression_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { markExpressionFollowingExpression_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				markExpressionFollowingExpression_isNodeHomomorphicGlobal,
				markExpressionFollowingExpression_isEdgeHomomorphicGlobal,
				markExpressionFollowingExpression_isNodeTotallyHomomorphic,
				markExpressionFollowingExpression_isEdgeTotallyHomomorphic
			);
			pat_markExpressionFollowingExpression.edgeToSourceNode.Add(markExpressionFollowingExpression_edge__edge0, markExpressionFollowingExpression_node_root);
			pat_markExpressionFollowingExpression.edgeToTargetNode.Add(markExpressionFollowingExpression_edge__edge0, markExpressionFollowingExpression_node_exp);

			markExpressionFollowingExpression_node_root.pointOfDefinition = null;
			markExpressionFollowingExpression_node_exp.pointOfDefinition = pat_markExpressionFollowingExpression;
			markExpressionFollowingExpression_edge__edge0.pointOfDefinition = pat_markExpressionFollowingExpression;

			patternGraph = pat_markExpressionFollowingExpression;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_markExpressionFollowingExpression curMatch = (Match_markExpressionFollowingExpression)_curMatch;
			GRGEN_LGSP.LGSPNode node_exp = curMatch._node_exp;
			graph.SettingAddedNodeNames( markExpressionFollowingExpression_addedNodeNames );
			graph.SettingAddedEdgeNames( markExpressionFollowingExpression_addedEdgeNames );
			graph.SetVisited(node_exp, 0, true);
			ApplyXGRS_markExpressionFollowingExpression_0(graph, (GRGEN_MODEL.IExpression)node_exp);
			return;
		}
		private static string[] markExpressionFollowingExpression_addedNodeNames = new string[] {  };
		private static string[] markExpressionFollowingExpression_addedEdgeNames = new string[] {  };

        public static bool ApplyXGRS_markExpressionFollowingExpression_0(GRGEN_LGSP.LGSPGraph graph, GRGEN_MODEL.IExpression var_exp)
        {
            GRGEN_LGSP.LGSPActions actions = graph.curActions;
            bool res_66;
            bool res_65;
            bool res_63;
            Action_markExpressionFollowingExpression rule_markExpressionFollowingExpression = Action_markExpressionFollowingExpression.Instance;
            bool res_64;
            Action_markExpressionFollowingActualParameter rule_markExpressionFollowingActualParameter = Action_markExpressionFollowingActualParameter.Instance;
            long i_66 = 0;
            while(true)
            {
                GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> matches_63 = rule_markExpressionFollowingExpression.Match(graph, 1, (GRGEN_MODEL.IExpression)var_exp);
                graph.Matched(matches_63, false);
                if(matches_63.Count==0) {
                    res_63 = (bool)(false);
                } else {
                    res_63 = (bool)(true);
                    if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_63.Count;
                    graph.Finishing(matches_63, false);
                    Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression match_63 = matches_63.FirstExact;
                    rule_markExpressionFollowingExpression.Modify(graph, match_63);
                    if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                    graph.Finished(matches_63, false);
                }
                if(res_63)
                    res_65 = (bool)(true);
                else
                {
                    GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> matches_64 = rule_markExpressionFollowingActualParameter.Match(graph, 1, (GRGEN_MODEL.IExpression)var_exp);
                    graph.Matched(matches_64, false);
                    if(matches_64.Count==0) {
                        res_64 = (bool)(false);
                    } else {
                        res_64 = (bool)(true);
                        if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_64.Count;
                        graph.Finishing(matches_64, false);
                        Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter match_64 = matches_64.FirstExact;
                        rule_markExpressionFollowingActualParameter.Modify(graph, match_64);
                        if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                        graph.Finished(matches_64, false);
                    }
                    res_65 = (bool)(res_64);
                }
                if(!res_65) break;
                i_66++;
            }
            res_66 = (bool)(i_66 >= 0);
            return res_66;
        }

		static Rule_markExpressionFollowingExpression() {
		}

		public interface IMatch_markExpressionFollowingExpression : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IExpression node_root { get; }
			GRGEN_MODEL.IExpression node_exp { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_markExpressionFollowingExpression : GRGEN_LGSP.ListElement<Match_markExpressionFollowingExpression>, IMatch_markExpressionFollowingExpression
		{
			public GRGEN_MODEL.IExpression node_root { get { return (GRGEN_MODEL.IExpression)_node_root; } }
			public GRGEN_MODEL.IExpression node_exp { get { return (GRGEN_MODEL.IExpression)_node_exp; } }
			public GRGEN_LGSP.LGSPNode _node_root;
			public GRGEN_LGSP.LGSPNode _node_exp;
			public enum markExpressionFollowingExpression_NodeNums { @root, @exp, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)markExpressionFollowingExpression_NodeNums.@root: return _node_root;
				case (int)markExpressionFollowingExpression_NodeNums.@exp: return _node_exp;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge__edge0 { get { return (GRGEN_MODEL.Iexpression)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum markExpressionFollowingExpression_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)markExpressionFollowingExpression_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum markExpressionFollowingExpression_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionFollowingExpression_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionFollowingExpression_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionFollowingExpression_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionFollowingExpression_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_markExpressionFollowingExpression.instance.pat_markExpressionFollowingExpression; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_markExpressionFollowingActualParameter : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_markExpressionFollowingActualParameter instance = null;
		public static Rule_markExpressionFollowingActualParameter Instance { get { if (instance==null) { instance = new Rule_markExpressionFollowingActualParameter(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] markExpressionFollowingActualParameter_node_root_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] markExpressionFollowingActualParameter_node_exp_AllowedTypes = null;
		public static bool[] markExpressionFollowingActualParameter_node_root_IsAllowedType = null;
		public static bool[] markExpressionFollowingActualParameter_node_exp_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] markExpressionFollowingActualParameter_edge__edge0_AllowedTypes = null;
		public static bool[] markExpressionFollowingActualParameter_edge__edge0_IsAllowedType = null;
		public enum markExpressionFollowingActualParameter_NodeNums { @root, @exp, };
		public enum markExpressionFollowingActualParameter_EdgeNums { @_edge0, };
		public enum markExpressionFollowingActualParameter_VariableNums { };
		public enum markExpressionFollowingActualParameter_SubNums { };
		public enum markExpressionFollowingActualParameter_AltNums { };
		public enum markExpressionFollowingActualParameter_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_markExpressionFollowingActualParameter;


		private Rule_markExpressionFollowingActualParameter()
		{
			name = "markExpressionFollowingActualParameter";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Expression.typeVar, };
			inputNames = new string[] { "markExpressionFollowingActualParameter_node_root", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] markExpressionFollowingActualParameter_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] markExpressionFollowingActualParameter_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] markExpressionFollowingActualParameter_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] markExpressionFollowingActualParameter_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode markExpressionFollowingActualParameter_node_root = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "markExpressionFollowingActualParameter_node_root", "root", markExpressionFollowingActualParameter_node_root_AllowedTypes, markExpressionFollowingActualParameter_node_root_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode markExpressionFollowingActualParameter_node_exp = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "markExpressionFollowingActualParameter_node_exp", "exp", markExpressionFollowingActualParameter_node_exp_AllowedTypes, markExpressionFollowingActualParameter_node_exp_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge markExpressionFollowingActualParameter_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@actualParameter, "GRGEN_MODEL.IactualParameter", "markExpressionFollowingActualParameter_edge__edge0", "_edge0", markExpressionFollowingActualParameter_edge__edge0_AllowedTypes, markExpressionFollowingActualParameter_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition markExpressionFollowingActualParameter_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited("markExpressionFollowingActualParameter_node_exp", new GRGEN_EXPR.Constant("0"))),
				new string[] { "markExpressionFollowingActualParameter_node_exp" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			pat_markExpressionFollowingActualParameter = new GRGEN_LGSP.PatternGraph(
				"markExpressionFollowingActualParameter",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { markExpressionFollowingActualParameter_node_root, markExpressionFollowingActualParameter_node_exp }, 
				new GRGEN_LGSP.PatternEdge[] { markExpressionFollowingActualParameter_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { markExpressionFollowingActualParameter_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				markExpressionFollowingActualParameter_isNodeHomomorphicGlobal,
				markExpressionFollowingActualParameter_isEdgeHomomorphicGlobal,
				markExpressionFollowingActualParameter_isNodeTotallyHomomorphic,
				markExpressionFollowingActualParameter_isEdgeTotallyHomomorphic
			);
			pat_markExpressionFollowingActualParameter.edgeToSourceNode.Add(markExpressionFollowingActualParameter_edge__edge0, markExpressionFollowingActualParameter_node_root);
			pat_markExpressionFollowingActualParameter.edgeToTargetNode.Add(markExpressionFollowingActualParameter_edge__edge0, markExpressionFollowingActualParameter_node_exp);

			markExpressionFollowingActualParameter_node_root.pointOfDefinition = null;
			markExpressionFollowingActualParameter_node_exp.pointOfDefinition = pat_markExpressionFollowingActualParameter;
			markExpressionFollowingActualParameter_edge__edge0.pointOfDefinition = pat_markExpressionFollowingActualParameter;

			patternGraph = pat_markExpressionFollowingActualParameter;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_markExpressionFollowingActualParameter curMatch = (Match_markExpressionFollowingActualParameter)_curMatch;
			GRGEN_LGSP.LGSPNode node_exp = curMatch._node_exp;
			graph.SettingAddedNodeNames( markExpressionFollowingActualParameter_addedNodeNames );
			graph.SettingAddedEdgeNames( markExpressionFollowingActualParameter_addedEdgeNames );
			graph.SetVisited(node_exp, 0, true);
			ApplyXGRS_markExpressionFollowingActualParameter_0(graph, (GRGEN_MODEL.IExpression)node_exp);
			return;
		}
		private static string[] markExpressionFollowingActualParameter_addedNodeNames = new string[] {  };
		private static string[] markExpressionFollowingActualParameter_addedEdgeNames = new string[] {  };

        public static bool ApplyXGRS_markExpressionFollowingActualParameter_0(GRGEN_LGSP.LGSPGraph graph, GRGEN_MODEL.IExpression var_exp)
        {
            GRGEN_LGSP.LGSPActions actions = graph.curActions;
            bool res_70;
            bool res_69;
            bool res_67;
            Action_markExpressionFollowingExpression rule_markExpressionFollowingExpression = Action_markExpressionFollowingExpression.Instance;
            bool res_68;
            Action_markExpressionFollowingActualParameter rule_markExpressionFollowingActualParameter = Action_markExpressionFollowingActualParameter.Instance;
            long i_70 = 0;
            while(true)
            {
                GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> matches_67 = rule_markExpressionFollowingExpression.Match(graph, 1, (GRGEN_MODEL.IExpression)var_exp);
                graph.Matched(matches_67, false);
                if(matches_67.Count==0) {
                    res_67 = (bool)(false);
                } else {
                    res_67 = (bool)(true);
                    if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_67.Count;
                    graph.Finishing(matches_67, false);
                    Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression match_67 = matches_67.FirstExact;
                    rule_markExpressionFollowingExpression.Modify(graph, match_67);
                    if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                    graph.Finished(matches_67, false);
                }
                if(res_67)
                    res_69 = (bool)(true);
                else
                {
                    GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> matches_68 = rule_markExpressionFollowingActualParameter.Match(graph, 1, (GRGEN_MODEL.IExpression)var_exp);
                    graph.Matched(matches_68, false);
                    if(matches_68.Count==0) {
                        res_68 = (bool)(false);
                    } else {
                        res_68 = (bool)(true);
                        if(graph.PerformanceInfo!=null) graph.PerformanceInfo.MatchesFound += matches_68.Count;
                        graph.Finishing(matches_68, false);
                        Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter match_68 = matches_68.FirstExact;
                        rule_markExpressionFollowingActualParameter.Modify(graph, match_68);
                        if(graph.PerformanceInfo != null) graph.PerformanceInfo.RewritesPerformed++;
                        graph.Finished(matches_68, false);
                    }
                    res_69 = (bool)(res_68);
                }
                if(!res_69) break;
                i_70++;
            }
            res_70 = (bool)(i_70 >= 0);
            return res_70;
        }

		static Rule_markExpressionFollowingActualParameter() {
		}

		public interface IMatch_markExpressionFollowingActualParameter : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IExpression node_root { get; }
			GRGEN_MODEL.IExpression node_exp { get; }
			//Edges
			GRGEN_MODEL.IactualParameter edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_markExpressionFollowingActualParameter : GRGEN_LGSP.ListElement<Match_markExpressionFollowingActualParameter>, IMatch_markExpressionFollowingActualParameter
		{
			public GRGEN_MODEL.IExpression node_root { get { return (GRGEN_MODEL.IExpression)_node_root; } }
			public GRGEN_MODEL.IExpression node_exp { get { return (GRGEN_MODEL.IExpression)_node_exp; } }
			public GRGEN_LGSP.LGSPNode _node_root;
			public GRGEN_LGSP.LGSPNode _node_exp;
			public enum markExpressionFollowingActualParameter_NodeNums { @root, @exp, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)markExpressionFollowingActualParameter_NodeNums.@root: return _node_root;
				case (int)markExpressionFollowingActualParameter_NodeNums.@exp: return _node_exp;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IactualParameter edge__edge0 { get { return (GRGEN_MODEL.IactualParameter)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum markExpressionFollowingActualParameter_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)markExpressionFollowingActualParameter_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum markExpressionFollowingActualParameter_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionFollowingActualParameter_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionFollowingActualParameter_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionFollowingActualParameter_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum markExpressionFollowingActualParameter_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_markExpressionFollowingActualParameter.instance.pat_markExpressionFollowingActualParameter; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_unmarkExpression : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_unmarkExpression instance = null;
		public static Rule_unmarkExpression Instance { get { if (instance==null) { instance = new Rule_unmarkExpression(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] unmarkExpression_node_exp_AllowedTypes = null;
		public static bool[] unmarkExpression_node_exp_IsAllowedType = null;
		public enum unmarkExpression_NodeNums { @exp, };
		public enum unmarkExpression_EdgeNums { };
		public enum unmarkExpression_VariableNums { };
		public enum unmarkExpression_SubNums { };
		public enum unmarkExpression_AltNums { };
		public enum unmarkExpression_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_unmarkExpression;


		private Rule_unmarkExpression()
		{
			name = "unmarkExpression";

			inputs = new GRGEN_LIBGR.GrGenType[] { };
			inputNames = new string[] { };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] unmarkExpression_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] unmarkExpression_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] unmarkExpression_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] unmarkExpression_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode unmarkExpression_node_exp = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "unmarkExpression_node_exp", "exp", unmarkExpression_node_exp_AllowedTypes, unmarkExpression_node_exp_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition unmarkExpression_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.Visited("unmarkExpression_node_exp", new GRGEN_EXPR.Constant("0")),
				new string[] { "unmarkExpression_node_exp" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			pat_unmarkExpression = new GRGEN_LGSP.PatternGraph(
				"unmarkExpression",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { unmarkExpression_node_exp }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { unmarkExpression_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				unmarkExpression_isNodeHomomorphicGlobal,
				unmarkExpression_isEdgeHomomorphicGlobal,
				unmarkExpression_isNodeTotallyHomomorphic,
				unmarkExpression_isEdgeTotallyHomomorphic
			);

			unmarkExpression_node_exp.pointOfDefinition = pat_unmarkExpression;

			patternGraph = pat_unmarkExpression;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_unmarkExpression curMatch = (Match_unmarkExpression)_curMatch;
			GRGEN_LGSP.LGSPNode node_exp = curMatch._node_exp;
			graph.SettingAddedNodeNames( unmarkExpression_addedNodeNames );
			graph.SettingAddedEdgeNames( unmarkExpression_addedEdgeNames );
			graph.SetVisited(node_exp, 0, false);
			return;
		}
		private static string[] unmarkExpression_addedNodeNames = new string[] {  };
		private static string[] unmarkExpression_addedEdgeNames = new string[] {  };

		static Rule_unmarkExpression() {
		}

		public interface IMatch_unmarkExpression : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IExpression node_exp { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_unmarkExpression : GRGEN_LGSP.ListElement<Match_unmarkExpression>, IMatch_unmarkExpression
		{
			public GRGEN_MODEL.IExpression node_exp { get { return (GRGEN_MODEL.IExpression)_node_exp; } }
			public GRGEN_LGSP.LGSPNode _node_exp;
			public enum unmarkExpression_NodeNums { @exp, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)unmarkExpression_NodeNums.@exp: return _node_exp;
				default: return null;
				}
			}
			
			public enum unmarkExpression_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum unmarkExpression_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum unmarkExpression_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum unmarkExpression_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum unmarkExpression_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum unmarkExpression_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_unmarkExpression.instance.pat_unmarkExpression; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_callToSuperExists : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_callToSuperExists instance = null;
		public static Rule_callToSuperExists Instance { get { if (instance==null) { instance = new Rule_callToSuperExists(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] callToSuperExists_node_call_AllowedTypes = null;
		public static bool[] callToSuperExists_node_call_IsAllowedType = null;
		public enum callToSuperExists_NodeNums { @call, };
		public enum callToSuperExists_EdgeNums { };
		public enum callToSuperExists_VariableNums { };
		public enum callToSuperExists_SubNums { };
		public enum callToSuperExists_AltNums { };
		public enum callToSuperExists_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_callToSuperExists;


		private Rule_callToSuperExists()
		{
			name = "callToSuperExists";

			inputs = new GRGEN_LIBGR.GrGenType[] { };
			inputNames = new string[] { };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] callToSuperExists_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] callToSuperExists_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] callToSuperExists_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] callToSuperExists_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode callToSuperExists_node_call = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "callToSuperExists_node_call", "call", callToSuperExists_node_call_AllowedTypes, callToSuperExists_node_call_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition callToSuperExists_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_AND(new GRGEN_EXPR.Qualification("GRGEN_MODEL.ICall", "callToSuperExists_node_call", "super"), new GRGEN_EXPR.Visited("callToSuperExists_node_call", new GRGEN_EXPR.Constant("0"))),
				new string[] { "callToSuperExists_node_call" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			pat_callToSuperExists = new GRGEN_LGSP.PatternGraph(
				"callToSuperExists",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { callToSuperExists_node_call }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { callToSuperExists_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				callToSuperExists_isNodeHomomorphicGlobal,
				callToSuperExists_isEdgeHomomorphicGlobal,
				callToSuperExists_isNodeTotallyHomomorphic,
				callToSuperExists_isEdgeTotallyHomomorphic
			);

			callToSuperExists_node_call.pointOfDefinition = pat_callToSuperExists;

			patternGraph = pat_callToSuperExists;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_callToSuperExists curMatch = (Match_callToSuperExists)_curMatch;
			return;
		}

		static Rule_callToSuperExists() {
		}

		public interface IMatch_callToSuperExists : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.ICall node_call { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_callToSuperExists : GRGEN_LGSP.ListElement<Match_callToSuperExists>, IMatch_callToSuperExists
		{
			public GRGEN_MODEL.ICall node_call { get { return (GRGEN_MODEL.ICall)_node_call; } }
			public GRGEN_LGSP.LGSPNode _node_call;
			public enum callToSuperExists_NodeNums { @call, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)callToSuperExists_NodeNums.@call: return _node_call;
				default: return null;
				}
			}
			
			public enum callToSuperExists_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum callToSuperExists_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum callToSuperExists_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum callToSuperExists_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum callToSuperExists_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum callToSuperExists_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_callToSuperExists.instance.pat_callToSuperExists; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_isStatic : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_isStatic instance = null;
		public static Rule_isStatic Instance { get { if (instance==null) { instance = new Rule_isStatic(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] isStatic_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] isStatic_node_mb_AllowedTypes = null;
		public static bool[] isStatic_node_op_IsAllowedType = null;
		public static bool[] isStatic_node_mb_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] isStatic_edge__edge0_AllowedTypes = null;
		public static bool[] isStatic_edge__edge0_IsAllowedType = null;
		public enum isStatic_NodeNums { @op, @mb, };
		public enum isStatic_EdgeNums { @_edge0, };
		public enum isStatic_VariableNums { };
		public enum isStatic_SubNums { };
		public enum isStatic_AltNums { };
		public enum isStatic_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_isStatic;


		private Rule_isStatic()
		{
			name = "isStatic";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_MethodBody.typeVar, };
			inputNames = new string[] { "isStatic_node_mb", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] isStatic_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] isStatic_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] isStatic_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] isStatic_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode isStatic_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "isStatic_node_op", "op", isStatic_node_op_AllowedTypes, isStatic_node_op_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode isStatic_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "isStatic_node_mb", "mb", isStatic_node_mb_AllowedTypes, isStatic_node_mb_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge isStatic_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@binding, "GRGEN_MODEL.Ibinding", "isStatic_edge__edge0", "_edge0", isStatic_edge__edge0_AllowedTypes, isStatic_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition isStatic_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.Qualification("GRGEN_MODEL.IOperation", "isStatic_node_op", "isStatic"),
				new string[] { "isStatic_node_op" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			pat_isStatic = new GRGEN_LGSP.PatternGraph(
				"isStatic",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { isStatic_node_op, isStatic_node_mb }, 
				new GRGEN_LGSP.PatternEdge[] { isStatic_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { isStatic_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				isStatic_isNodeHomomorphicGlobal,
				isStatic_isEdgeHomomorphicGlobal,
				isStatic_isNodeTotallyHomomorphic,
				isStatic_isEdgeTotallyHomomorphic
			);
			pat_isStatic.edgeToSourceNode.Add(isStatic_edge__edge0, isStatic_node_op);
			pat_isStatic.edgeToTargetNode.Add(isStatic_edge__edge0, isStatic_node_mb);

			isStatic_node_op.pointOfDefinition = pat_isStatic;
			isStatic_node_mb.pointOfDefinition = null;
			isStatic_edge__edge0.pointOfDefinition = pat_isStatic;

			patternGraph = pat_isStatic;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_isStatic curMatch = (Match_isStatic)_curMatch;
			return;
		}

		static Rule_isStatic() {
		}

		public interface IMatch_isStatic : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IMethodBody node_mb { get; }
			//Edges
			GRGEN_MODEL.Ibinding edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_isStatic : GRGEN_LGSP.ListElement<Match_isStatic>, IMatch_isStatic
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_mb;
			public enum isStatic_NodeNums { @op, @mb, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)isStatic_NodeNums.@op: return _node_op;
				case (int)isStatic_NodeNums.@mb: return _node_mb;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ibinding edge__edge0 { get { return (GRGEN_MODEL.Ibinding)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum isStatic_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)isStatic_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum isStatic_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum isStatic_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum isStatic_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum isStatic_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum isStatic_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_isStatic.instance.pat_isStatic; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_methodNameExists : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_methodNameExists instance = null;
		public static Rule_methodNameExists Instance { get { if (instance==null) { instance = new Rule_methodNameExists(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] methodNameExists_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] methodNameExists_node_mb_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] methodNameExists_node_tgt_AllowedTypes = null;
		public static bool[] methodNameExists_node_op_IsAllowedType = null;
		public static bool[] methodNameExists_node_mb_IsAllowedType = null;
		public static bool[] methodNameExists_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] methodNameExists_edge__edge0_AllowedTypes = null;
		public static bool[] methodNameExists_edge__edge0_IsAllowedType = null;
		public enum methodNameExists_NodeNums { @op, @mb, @tgt, };
		public enum methodNameExists_EdgeNums { @_edge0, };
		public enum methodNameExists_VariableNums { };
		public enum methodNameExists_SubNums { @_sub0, };
		public enum methodNameExists_AltNums { };
		public enum methodNameExists_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_methodNameExists;


		private Rule_methodNameExists()
		{
			name = "methodNameExists";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_MethodBody.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, };
			inputNames = new string[] { "methodNameExists_node_mb", "methodNameExists_node_tgt", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] methodNameExists_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] methodNameExists_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] methodNameExists_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] methodNameExists_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode methodNameExists_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "methodNameExists_node_op", "op", methodNameExists_node_op_AllowedTypes, methodNameExists_node_op_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode methodNameExists_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "methodNameExists_node_mb", "mb", methodNameExists_node_mb_AllowedTypes, methodNameExists_node_mb_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode methodNameExists_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "methodNameExists_node_tgt", "tgt", methodNameExists_node_tgt_AllowedTypes, methodNameExists_node_tgt_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge methodNameExists_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@Edge, "GRGEN_LIBGR.IEdge", "methodNameExists_edge__edge0", "_edge0", methodNameExists_edge__edge0_AllowedTypes, methodNameExists_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternGraphEmbedding methodNameExists__sub0 = new GRGEN_LGSP.PatternGraphEmbedding("_sub0", Pattern_methodNameExistsSuper.Instance, 
				new GRGEN_EXPR.Expression[] {
					new GRGEN_EXPR.GraphEntityExpression("methodNameExists_node_op"),
					new GRGEN_EXPR.GraphEntityExpression("methodNameExists_node_tgt"),
				}, 
				new string[] { }, new string[] { "methodNameExists_node_op", "methodNameExists_node_tgt" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			pat_methodNameExists = new GRGEN_LGSP.PatternGraph(
				"methodNameExists",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { methodNameExists_node_op, methodNameExists_node_mb, methodNameExists_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { methodNameExists_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] { methodNameExists__sub0 }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				methodNameExists_isNodeHomomorphicGlobal,
				methodNameExists_isEdgeHomomorphicGlobal,
				methodNameExists_isNodeTotallyHomomorphic,
				methodNameExists_isEdgeTotallyHomomorphic
			);
			pat_methodNameExists.edgeToSourceNode.Add(methodNameExists_edge__edge0, methodNameExists_node_op);
			pat_methodNameExists.edgeToTargetNode.Add(methodNameExists_edge__edge0, methodNameExists_node_mb);

			methodNameExists_node_op.pointOfDefinition = pat_methodNameExists;
			methodNameExists_node_mb.pointOfDefinition = null;
			methodNameExists_node_tgt.pointOfDefinition = null;
			methodNameExists_edge__edge0.pointOfDefinition = pat_methodNameExists;
			methodNameExists__sub0.PointOfDefinition = pat_methodNameExists;

			patternGraph = pat_methodNameExists;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_methodNameExists curMatch = (Match_methodNameExists)_curMatch;
			GRGEN_LGSP.LGSPNode node_op = curMatch._node_op;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			Pattern_methodNameExistsSuper.Match_methodNameExistsSuper subpattern__sub0 = curMatch.@__sub0;
			return;
		}

		static Rule_methodNameExists() {
		}

		public interface IMatch_methodNameExists : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IMethodBody node_mb { get; }
			GRGEN_MODEL.IClass node_tgt { get; }
			//Edges
			GRGEN_LIBGR.IEdge edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			@Pattern_methodNameExistsSuper.Match_methodNameExistsSuper @_sub0 { get; }
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_methodNameExists : GRGEN_LGSP.ListElement<Match_methodNameExists>, IMatch_methodNameExists
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_MODEL.IClass node_tgt { get { return (GRGEN_MODEL.IClass)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_mb;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum methodNameExists_NodeNums { @op, @mb, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)methodNameExists_NodeNums.@op: return _node_op;
				case (int)methodNameExists_NodeNums.@mb: return _node_mb;
				case (int)methodNameExists_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IEdge edge__edge0 { get { return (GRGEN_LIBGR.IEdge)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum methodNameExists_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)methodNameExists_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum methodNameExists_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public @Pattern_methodNameExistsSuper.Match_methodNameExistsSuper @_sub0 { get { return @__sub0; } }
			public @Pattern_methodNameExistsSuper.Match_methodNameExistsSuper @__sub0;
			public enum methodNameExists_SubNums { @_sub0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 1;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				case (int)methodNameExists_SubNums.@_sub0: return __sub0;
				default: return null;
				}
			}
			
			public enum methodNameExists_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodNameExists_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum methodNameExists_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_methodNameExists.instance.pat_methodNameExists; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_thisIsAccessed : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_thisIsAccessed instance = null;
		public static Rule_thisIsAccessed Instance { get { if (instance==null) { instance = new Rule_thisIsAccessed(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] thisIsAccessed_node_access_AllowedTypes = null;
		public static bool[] thisIsAccessed_node_access_IsAllowedType = null;
		public enum thisIsAccessed_NodeNums { @access, };
		public enum thisIsAccessed_EdgeNums { };
		public enum thisIsAccessed_VariableNums { };
		public enum thisIsAccessed_SubNums { };
		public enum thisIsAccessed_AltNums { };
		public enum thisIsAccessed_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_thisIsAccessed;

		public static GRGEN_LIBGR.EdgeType[] thisIsAccessed_neg_0_edge__edge0_AllowedTypes = null;
		public static bool[] thisIsAccessed_neg_0_edge__edge0_IsAllowedType = null;
		public enum thisIsAccessed_neg_0_NodeNums { @access, };
		public enum thisIsAccessed_neg_0_EdgeNums { @_edge0, };
		public enum thisIsAccessed_neg_0_VariableNums { };
		public enum thisIsAccessed_neg_0_SubNums { };
		public enum thisIsAccessed_neg_0_AltNums { };
		public enum thisIsAccessed_neg_0_IterNums { };

		public GRGEN_LGSP.PatternGraph thisIsAccessed_neg_0;


		private Rule_thisIsAccessed()
		{
			name = "thisIsAccessed";

			inputs = new GRGEN_LIBGR.GrGenType[] { };
			inputNames = new string[] { };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] thisIsAccessed_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] thisIsAccessed_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] thisIsAccessed_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] thisIsAccessed_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode thisIsAccessed_node_access = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Access, "GRGEN_MODEL.IAccess", "thisIsAccessed_node_access", "access", thisIsAccessed_node_access_AllowedTypes, thisIsAccessed_node_access_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition thisIsAccessed_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.Visited("thisIsAccessed_node_access", new GRGEN_EXPR.Constant("0")),
				new string[] { "thisIsAccessed_node_access" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			bool[,] thisIsAccessed_neg_0_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] thisIsAccessed_neg_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] thisIsAccessed_neg_0_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] thisIsAccessed_neg_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternEdge thisIsAccessed_neg_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "thisIsAccessed_neg_0_edge__edge0", "_edge0", thisIsAccessed_neg_0_edge__edge0_AllowedTypes, thisIsAccessed_neg_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			thisIsAccessed_neg_0 = new GRGEN_LGSP.PatternGraph(
				"neg_0",
				"thisIsAccessed_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { thisIsAccessed_node_access }, 
				new GRGEN_LGSP.PatternEdge[] { thisIsAccessed_neg_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				thisIsAccessed_neg_0_isNodeHomomorphicGlobal,
				thisIsAccessed_neg_0_isEdgeHomomorphicGlobal,
				thisIsAccessed_neg_0_isNodeTotallyHomomorphic,
				thisIsAccessed_neg_0_isEdgeTotallyHomomorphic
			);
			thisIsAccessed_neg_0.edgeToSourceNode.Add(thisIsAccessed_neg_0_edge__edge0, thisIsAccessed_node_access);

			pat_thisIsAccessed = new GRGEN_LGSP.PatternGraph(
				"thisIsAccessed",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { thisIsAccessed_node_access }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] { thisIsAccessed_neg_0,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { thisIsAccessed_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[0, 0] ,
				thisIsAccessed_isNodeHomomorphicGlobal,
				thisIsAccessed_isEdgeHomomorphicGlobal,
				thisIsAccessed_isNodeTotallyHomomorphic,
				thisIsAccessed_isEdgeTotallyHomomorphic
			);
			thisIsAccessed_neg_0.embeddingGraph = pat_thisIsAccessed;

			thisIsAccessed_node_access.pointOfDefinition = pat_thisIsAccessed;
			thisIsAccessed_neg_0_edge__edge0.pointOfDefinition = thisIsAccessed_neg_0;

			patternGraph = pat_thisIsAccessed;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_thisIsAccessed curMatch = (Match_thisIsAccessed)_curMatch;
			return;
		}

		static Rule_thisIsAccessed() {
		}

		public interface IMatch_thisIsAccessed : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_access { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_thisIsAccessed_neg_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_access { get; }
			//Edges
			GRGEN_MODEL.Ilink edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_thisIsAccessed : GRGEN_LGSP.ListElement<Match_thisIsAccessed>, IMatch_thisIsAccessed
		{
			public GRGEN_MODEL.IAccess node_access { get { return (GRGEN_MODEL.IAccess)_node_access; } }
			public GRGEN_LGSP.LGSPNode _node_access;
			public enum thisIsAccessed_NodeNums { @access, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)thisIsAccessed_NodeNums.@access: return _node_access;
				default: return null;
				}
			}
			
			public enum thisIsAccessed_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum thisIsAccessed_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum thisIsAccessed_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum thisIsAccessed_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum thisIsAccessed_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum thisIsAccessed_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_thisIsAccessed.instance.pat_thisIsAccessed; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_thisIsAccessed_neg_0 : GRGEN_LGSP.ListElement<Match_thisIsAccessed_neg_0>, IMatch_thisIsAccessed_neg_0
		{
			public GRGEN_MODEL.IAccess node_access { get { return (GRGEN_MODEL.IAccess)_node_access; } }
			public GRGEN_LGSP.LGSPNode _node_access;
			public enum thisIsAccessed_neg_0_NodeNums { @access, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)thisIsAccessed_neg_0_NodeNums.@access: return _node_access;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ilink edge__edge0 { get { return (GRGEN_MODEL.Ilink)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum thisIsAccessed_neg_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)thisIsAccessed_neg_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum thisIsAccessed_neg_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum thisIsAccessed_neg_0_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum thisIsAccessed_neg_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum thisIsAccessed_neg_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum thisIsAccessed_neg_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_thisIsAccessed.instance.thisIsAccessed_neg_0; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_addSourceParameter : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_addSourceParameter instance = null;
		public static Rule_addSourceParameter Instance { get { if (instance==null) { instance = new Rule_addSourceParameter(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] addSourceParameter_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] addSourceParameter_node_src_AllowedTypes = null;
		public static bool[] addSourceParameter_node_op_IsAllowedType = null;
		public static bool[] addSourceParameter_node_src_IsAllowedType = null;
		public enum addSourceParameter_NodeNums { @op, @src, };
		public enum addSourceParameter_EdgeNums { };
		public enum addSourceParameter_VariableNums { };
		public enum addSourceParameter_SubNums { };
		public enum addSourceParameter_AltNums { };
		public enum addSourceParameter_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_addSourceParameter;


		private Rule_addSourceParameter()
		{
			name = "addSourceParameter";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, };
			inputNames = new string[] { "addSourceParameter_node_op", "addSourceParameter_node_src", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Parameter.typeVar, };

		}
		private void initialize()
		{
			bool[,] addSourceParameter_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] addSourceParameter_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] addSourceParameter_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] addSourceParameter_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode addSourceParameter_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "addSourceParameter_node_op", "op", addSourceParameter_node_op_AllowedTypes, addSourceParameter_node_op_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode addSourceParameter_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "addSourceParameter_node_src", "src", addSourceParameter_node_src_AllowedTypes, addSourceParameter_node_src_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			pat_addSourceParameter = new GRGEN_LGSP.PatternGraph(
				"addSourceParameter",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { addSourceParameter_node_op, addSourceParameter_node_src }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[0, 0] ,
				addSourceParameter_isNodeHomomorphicGlobal,
				addSourceParameter_isEdgeHomomorphicGlobal,
				addSourceParameter_isNodeTotallyHomomorphic,
				addSourceParameter_isEdgeTotallyHomomorphic
			);

			addSourceParameter_node_op.pointOfDefinition = null;
			addSourceParameter_node_src.pointOfDefinition = null;

			patternGraph = pat_addSourceParameter;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IParameter output_0)
		{
			Match_addSourceParameter curMatch = (Match_addSourceParameter)_curMatch;
			GRGEN_LGSP.LGSPNode node_op = curMatch._node_op;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			graph.SettingAddedNodeNames( addSourceParameter_addedNodeNames );
			GRGEN_MODEL.@Parameter node_p = GRGEN_MODEL.@Parameter.CreateNode(graph);
			graph.SettingAddedEdgeNames( addSourceParameter_addedEdgeNames );
			GRGEN_MODEL.@parameter edge__edge0 = GRGEN_MODEL.@parameter.CreateEdge(graph, node_op, node_p);
			GRGEN_MODEL.@type_ edge__edge1 = GRGEN_MODEL.@type_.CreateEdge(graph, node_p, node_src);
			output_0 = (GRGEN_MODEL.IParameter)(node_p);
			return;
		}
		private static string[] addSourceParameter_addedNodeNames = new string[] { "p" };
		private static string[] addSourceParameter_addedEdgeNames = new string[] { "_edge0", "_edge1" };

		static Rule_addSourceParameter() {
		}

		public interface IMatch_addSourceParameter : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IClass node_src { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_addSourceParameter : GRGEN_LGSP.ListElement<Match_addSourceParameter>, IMatch_addSourceParameter
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IClass node_src { get { return (GRGEN_MODEL.IClass)_node_src; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_src;
			public enum addSourceParameter_NodeNums { @op, @src, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)addSourceParameter_NodeNums.@op: return _node_op;
				case (int)addSourceParameter_NodeNums.@src: return _node_src;
				default: return null;
				}
			}
			
			public enum addSourceParameter_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addSourceParameter_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addSourceParameter_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addSourceParameter_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addSourceParameter_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addSourceParameter_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_addSourceParameter.instance.pat_addSourceParameter; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_useSourceParameter : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_useSourceParameter instance = null;
		public static Rule_useSourceParameter Instance { get { if (instance==null) { instance = new Rule_useSourceParameter(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] useSourceParameter_node_srcparam_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] useSourceParameter_node_access_AllowedTypes = null;
		public static bool[] useSourceParameter_node_srcparam_IsAllowedType = null;
		public static bool[] useSourceParameter_node_access_IsAllowedType = null;
		public enum useSourceParameter_NodeNums { @srcparam, @access, };
		public enum useSourceParameter_EdgeNums { };
		public enum useSourceParameter_VariableNums { };
		public enum useSourceParameter_SubNums { };
		public enum useSourceParameter_AltNums { };
		public enum useSourceParameter_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_useSourceParameter;

		public static GRGEN_LIBGR.EdgeType[] useSourceParameter_neg_0_edge__edge0_AllowedTypes = null;
		public static bool[] useSourceParameter_neg_0_edge__edge0_IsAllowedType = null;
		public enum useSourceParameter_neg_0_NodeNums { @access, };
		public enum useSourceParameter_neg_0_EdgeNums { @_edge0, };
		public enum useSourceParameter_neg_0_VariableNums { };
		public enum useSourceParameter_neg_0_SubNums { };
		public enum useSourceParameter_neg_0_AltNums { };
		public enum useSourceParameter_neg_0_IterNums { };

		public GRGEN_LGSP.PatternGraph useSourceParameter_neg_0;


		private Rule_useSourceParameter()
		{
			name = "useSourceParameter";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Parameter.typeVar, };
			inputNames = new string[] { "useSourceParameter_node_srcparam", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] useSourceParameter_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] useSourceParameter_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] useSourceParameter_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] useSourceParameter_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode useSourceParameter_node_srcparam = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Parameter, "GRGEN_MODEL.IParameter", "useSourceParameter_node_srcparam", "srcparam", useSourceParameter_node_srcparam_AllowedTypes, useSourceParameter_node_srcparam_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode useSourceParameter_node_access = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Access, "GRGEN_MODEL.IAccess", "useSourceParameter_node_access", "access", useSourceParameter_node_access_AllowedTypes, useSourceParameter_node_access_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternCondition useSourceParameter_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.Visited("useSourceParameter_node_access", new GRGEN_EXPR.Constant("0")),
				new string[] { "useSourceParameter_node_access" }, new string[] {  }, new string[] {  }, new GRGEN_LIBGR.VarType[] {  });
			bool[,] useSourceParameter_neg_0_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] useSourceParameter_neg_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] useSourceParameter_neg_0_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] useSourceParameter_neg_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternEdge useSourceParameter_neg_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "useSourceParameter_neg_0_edge__edge0", "_edge0", useSourceParameter_neg_0_edge__edge0_AllowedTypes, useSourceParameter_neg_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			useSourceParameter_neg_0 = new GRGEN_LGSP.PatternGraph(
				"neg_0",
				"useSourceParameter_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { useSourceParameter_node_access }, 
				new GRGEN_LGSP.PatternEdge[] { useSourceParameter_neg_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				useSourceParameter_neg_0_isNodeHomomorphicGlobal,
				useSourceParameter_neg_0_isEdgeHomomorphicGlobal,
				useSourceParameter_neg_0_isNodeTotallyHomomorphic,
				useSourceParameter_neg_0_isEdgeTotallyHomomorphic
			);
			useSourceParameter_neg_0.edgeToSourceNode.Add(useSourceParameter_neg_0_edge__edge0, useSourceParameter_node_access);

			pat_useSourceParameter = new GRGEN_LGSP.PatternGraph(
				"useSourceParameter",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { useSourceParameter_node_srcparam, useSourceParameter_node_access }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] { useSourceParameter_neg_0,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { useSourceParameter_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[0, 0] ,
				useSourceParameter_isNodeHomomorphicGlobal,
				useSourceParameter_isEdgeHomomorphicGlobal,
				useSourceParameter_isNodeTotallyHomomorphic,
				useSourceParameter_isEdgeTotallyHomomorphic
			);
			useSourceParameter_neg_0.embeddingGraph = pat_useSourceParameter;

			useSourceParameter_node_srcparam.pointOfDefinition = null;
			useSourceParameter_node_access.pointOfDefinition = pat_useSourceParameter;
			useSourceParameter_neg_0_edge__edge0.pointOfDefinition = useSourceParameter_neg_0;

			patternGraph = pat_useSourceParameter;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_useSourceParameter curMatch = (Match_useSourceParameter)_curMatch;
			GRGEN_LGSP.LGSPNode node_access = curMatch._node_access;
			GRGEN_LGSP.LGSPNode node_srcparam = curMatch._node_srcparam;
			graph.SettingAddedNodeNames( useSourceParameter_addedNodeNames );
			graph.SettingAddedEdgeNames( useSourceParameter_addedEdgeNames );
			GRGEN_MODEL.@link edge__edge0 = GRGEN_MODEL.@link.CreateEdge(graph, node_access, node_srcparam);
			return;
		}
		private static string[] useSourceParameter_addedNodeNames = new string[] {  };
		private static string[] useSourceParameter_addedEdgeNames = new string[] { "_edge0" };

		static Rule_useSourceParameter() {
		}

		public interface IMatch_useSourceParameter : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IParameter node_srcparam { get; }
			GRGEN_MODEL.IAccess node_access { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_useSourceParameter_neg_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_access { get; }
			//Edges
			GRGEN_MODEL.Ilink edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_useSourceParameter : GRGEN_LGSP.ListElement<Match_useSourceParameter>, IMatch_useSourceParameter
		{
			public GRGEN_MODEL.IParameter node_srcparam { get { return (GRGEN_MODEL.IParameter)_node_srcparam; } }
			public GRGEN_MODEL.IAccess node_access { get { return (GRGEN_MODEL.IAccess)_node_access; } }
			public GRGEN_LGSP.LGSPNode _node_srcparam;
			public GRGEN_LGSP.LGSPNode _node_access;
			public enum useSourceParameter_NodeNums { @srcparam, @access, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)useSourceParameter_NodeNums.@srcparam: return _node_srcparam;
				case (int)useSourceParameter_NodeNums.@access: return _node_access;
				default: return null;
				}
			}
			
			public enum useSourceParameter_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum useSourceParameter_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum useSourceParameter_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum useSourceParameter_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum useSourceParameter_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum useSourceParameter_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_useSourceParameter.instance.pat_useSourceParameter; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_useSourceParameter_neg_0 : GRGEN_LGSP.ListElement<Match_useSourceParameter_neg_0>, IMatch_useSourceParameter_neg_0
		{
			public GRGEN_MODEL.IAccess node_access { get { return (GRGEN_MODEL.IAccess)_node_access; } }
			public GRGEN_LGSP.LGSPNode _node_access;
			public enum useSourceParameter_neg_0_NodeNums { @access, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 1;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)useSourceParameter_neg_0_NodeNums.@access: return _node_access;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ilink edge__edge0 { get { return (GRGEN_MODEL.Ilink)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum useSourceParameter_neg_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)useSourceParameter_neg_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum useSourceParameter_neg_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum useSourceParameter_neg_0_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum useSourceParameter_neg_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum useSourceParameter_neg_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum useSourceParameter_neg_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_useSourceParameter.instance.useSourceParameter_neg_0; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_copyOperation : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_copyOperation instance = null;
		public static Rule_copyOperation Instance { get { if (instance==null) { instance = new Rule_copyOperation(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] copyOperation_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] copyOperation_node_tgt_AllowedTypes = null;
		public static bool[] copyOperation_node_op_IsAllowedType = null;
		public static bool[] copyOperation_node_tgt_IsAllowedType = null;
		public enum copyOperation_NodeNums { @op, @tgt, };
		public enum copyOperation_EdgeNums { };
		public enum copyOperation_VariableNums { };
		public enum copyOperation_SubNums { };
		public enum copyOperation_AltNums { };
		public enum copyOperation_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_copyOperation;


		private Rule_copyOperation()
		{
			name = "copyOperation";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, };
			inputNames = new string[] { "copyOperation_node_op", "copyOperation_node_tgt", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, };

		}
		private void initialize()
		{
			bool[,] copyOperation_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] copyOperation_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] copyOperation_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] copyOperation_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode copyOperation_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "copyOperation_node_op", "op", copyOperation_node_op_AllowedTypes, copyOperation_node_op_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode copyOperation_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "copyOperation_node_tgt", "tgt", copyOperation_node_tgt_AllowedTypes, copyOperation_node_tgt_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			pat_copyOperation = new GRGEN_LGSP.PatternGraph(
				"copyOperation",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { copyOperation_node_op, copyOperation_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[0, 0] ,
				copyOperation_isNodeHomomorphicGlobal,
				copyOperation_isEdgeHomomorphicGlobal,
				copyOperation_isNodeTotallyHomomorphic,
				copyOperation_isEdgeTotallyHomomorphic
			);

			copyOperation_node_op.pointOfDefinition = null;
			copyOperation_node_tgt.pointOfDefinition = null;

			patternGraph = pat_copyOperation;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IOperation output_0)
		{
			Match_copyOperation curMatch = (Match_copyOperation)_curMatch;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			graph.SettingAddedNodeNames( copyOperation_addedNodeNames );
			GRGEN_MODEL.@Operation node_newop = GRGEN_MODEL.@Operation.CreateNode(graph);
			graph.SettingAddedEdgeNames( copyOperation_addedEdgeNames );
			GRGEN_MODEL.@inClass edge__edge0 = GRGEN_MODEL.@inClass.CreateEdge(graph, node_newop, node_tgt);
			output_0 = (GRGEN_MODEL.IOperation)(node_newop);
			return;
		}
		private static string[] copyOperation_addedNodeNames = new string[] { "newop" };
		private static string[] copyOperation_addedEdgeNames = new string[] { "_edge0" };

		static Rule_copyOperation() {
		}

		public interface IMatch_copyOperation : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IClass node_tgt { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_copyOperation : GRGEN_LGSP.ListElement<Match_copyOperation>, IMatch_copyOperation
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IClass node_tgt { get { return (GRGEN_MODEL.IClass)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum copyOperation_NodeNums { @op, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)copyOperation_NodeNums.@op: return _node_op;
				case (int)copyOperation_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public enum copyOperation_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum copyOperation_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum copyOperation_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum copyOperation_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum copyOperation_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum copyOperation_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_copyOperation.instance.pat_copyOperation; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_copyOperationParameter : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_copyOperationParameter instance = null;
		public static Rule_copyOperationParameter Instance { get { if (instance==null) { instance = new Rule_copyOperationParameter(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] copyOperationParameter_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] copyOperationParameter_node_p_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] copyOperationParameter_node_newop_AllowedTypes = null;
		public static bool[] copyOperationParameter_node_op_IsAllowedType = null;
		public static bool[] copyOperationParameter_node_p_IsAllowedType = null;
		public static bool[] copyOperationParameter_node_newop_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] copyOperationParameter_edge__edge0_AllowedTypes = null;
		public static bool[] copyOperationParameter_edge__edge0_IsAllowedType = null;
		public enum copyOperationParameter_NodeNums { @op, @p, @newop, };
		public enum copyOperationParameter_EdgeNums { @_edge0, };
		public enum copyOperationParameter_VariableNums { };
		public enum copyOperationParameter_SubNums { };
		public enum copyOperationParameter_AltNums { };
		public enum copyOperationParameter_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_copyOperationParameter;


		private Rule_copyOperationParameter()
		{
			name = "copyOperationParameter";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, };
			inputNames = new string[] { "copyOperationParameter_node_op", "copyOperationParameter_node_newop", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] copyOperationParameter_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] copyOperationParameter_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] copyOperationParameter_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] copyOperationParameter_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode copyOperationParameter_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "copyOperationParameter_node_op", "op", copyOperationParameter_node_op_AllowedTypes, copyOperationParameter_node_op_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode copyOperationParameter_node_p = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Parameter, "GRGEN_MODEL.IParameter", "copyOperationParameter_node_p", "p", copyOperationParameter_node_p_AllowedTypes, copyOperationParameter_node_p_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode copyOperationParameter_node_newop = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "copyOperationParameter_node_newop", "newop", copyOperationParameter_node_newop_AllowedTypes, copyOperationParameter_node_newop_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge copyOperationParameter_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@parameter, "GRGEN_MODEL.Iparameter", "copyOperationParameter_edge__edge0", "_edge0", copyOperationParameter_edge__edge0_AllowedTypes, copyOperationParameter_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_copyOperationParameter = new GRGEN_LGSP.PatternGraph(
				"copyOperationParameter",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { copyOperationParameter_node_op, copyOperationParameter_node_p, copyOperationParameter_node_newop }, 
				new GRGEN_LGSP.PatternEdge[] { copyOperationParameter_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				copyOperationParameter_isNodeHomomorphicGlobal,
				copyOperationParameter_isEdgeHomomorphicGlobal,
				copyOperationParameter_isNodeTotallyHomomorphic,
				copyOperationParameter_isEdgeTotallyHomomorphic
			);
			pat_copyOperationParameter.edgeToSourceNode.Add(copyOperationParameter_edge__edge0, copyOperationParameter_node_op);
			pat_copyOperationParameter.edgeToTargetNode.Add(copyOperationParameter_edge__edge0, copyOperationParameter_node_p);

			copyOperationParameter_node_op.pointOfDefinition = null;
			copyOperationParameter_node_p.pointOfDefinition = pat_copyOperationParameter;
			copyOperationParameter_node_newop.pointOfDefinition = null;
			copyOperationParameter_edge__edge0.pointOfDefinition = pat_copyOperationParameter;

			patternGraph = pat_copyOperationParameter;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_copyOperationParameter curMatch = (Match_copyOperationParameter)_curMatch;
			GRGEN_LGSP.LGSPNode node_newop = curMatch._node_newop;
			graph.SettingAddedNodeNames( copyOperationParameter_addedNodeNames );
			GRGEN_MODEL.@Parameter node_newp = GRGEN_MODEL.@Parameter.CreateNode(graph);
			graph.SettingAddedEdgeNames( copyOperationParameter_addedEdgeNames );
			GRGEN_MODEL.@parameter edge__edge1 = GRGEN_MODEL.@parameter.CreateEdge(graph, node_newop, node_newp);
			return;
		}
		private static string[] copyOperationParameter_addedNodeNames = new string[] { "newp" };
		private static string[] copyOperationParameter_addedEdgeNames = new string[] { "_edge1" };

		static Rule_copyOperationParameter() {
		}

		public interface IMatch_copyOperationParameter : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IParameter node_p { get; }
			GRGEN_MODEL.IOperation node_newop { get; }
			//Edges
			GRGEN_MODEL.Iparameter edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_copyOperationParameter : GRGEN_LGSP.ListElement<Match_copyOperationParameter>, IMatch_copyOperationParameter
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IParameter node_p { get { return (GRGEN_MODEL.IParameter)_node_p; } }
			public GRGEN_MODEL.IOperation node_newop { get { return (GRGEN_MODEL.IOperation)_node_newop; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_p;
			public GRGEN_LGSP.LGSPNode _node_newop;
			public enum copyOperationParameter_NodeNums { @op, @p, @newop, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)copyOperationParameter_NodeNums.@op: return _node_op;
				case (int)copyOperationParameter_NodeNums.@p: return _node_p;
				case (int)copyOperationParameter_NodeNums.@newop: return _node_newop;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iparameter edge__edge0 { get { return (GRGEN_MODEL.Iparameter)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum copyOperationParameter_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)copyOperationParameter_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum copyOperationParameter_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum copyOperationParameter_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum copyOperationParameter_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum copyOperationParameter_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum copyOperationParameter_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_copyOperationParameter.instance.pat_copyOperationParameter; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_relinkMethodBody : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_relinkMethodBody instance = null;
		public static Rule_relinkMethodBody Instance { get { if (instance==null) { instance = new Rule_relinkMethodBody(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] relinkMethodBody_node_mb_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkMethodBody_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkMethodBody_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkMethodBody_node_tgt_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkMethodBody_node_newop_AllowedTypes = null;
		public static bool[] relinkMethodBody_node_mb_IsAllowedType = null;
		public static bool[] relinkMethodBody_node_src_IsAllowedType = null;
		public static bool[] relinkMethodBody_node_op_IsAllowedType = null;
		public static bool[] relinkMethodBody_node_tgt_IsAllowedType = null;
		public static bool[] relinkMethodBody_node_newop_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] relinkMethodBody_edge_b1_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] relinkMethodBody_edge_b_AllowedTypes = null;
		public static bool[] relinkMethodBody_edge_b1_IsAllowedType = null;
		public static bool[] relinkMethodBody_edge_b_IsAllowedType = null;
		public enum relinkMethodBody_NodeNums { @mb, @src, @op, @tgt, @newop, };
		public enum relinkMethodBody_EdgeNums { @b1, @b, };
		public enum relinkMethodBody_VariableNums { };
		public enum relinkMethodBody_SubNums { };
		public enum relinkMethodBody_AltNums { };
		public enum relinkMethodBody_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_relinkMethodBody;


		private Rule_relinkMethodBody()
		{
			name = "relinkMethodBody";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_MethodBody.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, };
			inputNames = new string[] { "relinkMethodBody_node_mb", "relinkMethodBody_node_src", "relinkMethodBody_node_tgt", "relinkMethodBody_node_op", "relinkMethodBody_node_newop", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] relinkMethodBody_isNodeHomomorphicGlobal = new bool[5, 5] {
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
			};
			bool[,] relinkMethodBody_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] relinkMethodBody_isNodeTotallyHomomorphic = new bool[5] { false, false, false, false, false,  };
			bool[] relinkMethodBody_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternNode relinkMethodBody_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "relinkMethodBody_node_mb", "mb", relinkMethodBody_node_mb_AllowedTypes, relinkMethodBody_node_mb_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkMethodBody_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "relinkMethodBody_node_src", "src", relinkMethodBody_node_src_AllowedTypes, relinkMethodBody_node_src_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkMethodBody_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "relinkMethodBody_node_op", "op", relinkMethodBody_node_op_AllowedTypes, relinkMethodBody_node_op_IsAllowedType, 5.5F, 3, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkMethodBody_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "relinkMethodBody_node_tgt", "tgt", relinkMethodBody_node_tgt_AllowedTypes, relinkMethodBody_node_tgt_IsAllowedType, 5.5F, 2, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkMethodBody_node_newop = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "relinkMethodBody_node_newop", "newop", relinkMethodBody_node_newop_AllowedTypes, relinkMethodBody_node_newop_IsAllowedType, 5.5F, 4, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge relinkMethodBody_edge_b1 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "relinkMethodBody_edge_b1", "b1", relinkMethodBody_edge_b1_AllowedTypes, relinkMethodBody_edge_b1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge relinkMethodBody_edge_b = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@binding, "GRGEN_MODEL.Ibinding", "relinkMethodBody_edge_b", "b", relinkMethodBody_edge_b_AllowedTypes, relinkMethodBody_edge_b_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_relinkMethodBody = new GRGEN_LGSP.PatternGraph(
				"relinkMethodBody",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { relinkMethodBody_node_mb, relinkMethodBody_node_src, relinkMethodBody_node_op, relinkMethodBody_node_tgt, relinkMethodBody_node_newop }, 
				new GRGEN_LGSP.PatternEdge[] { relinkMethodBody_edge_b1, relinkMethodBody_edge_b }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[5, 5] {
					{ true, false, false, false, false, },
					{ false, true, false, false, false, },
					{ false, false, true, false, false, },
					{ false, false, false, true, false, },
					{ false, false, false, false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				relinkMethodBody_isNodeHomomorphicGlobal,
				relinkMethodBody_isEdgeHomomorphicGlobal,
				relinkMethodBody_isNodeTotallyHomomorphic,
				relinkMethodBody_isEdgeTotallyHomomorphic
			);
			pat_relinkMethodBody.edgeToSourceNode.Add(relinkMethodBody_edge_b1, relinkMethodBody_node_mb);
			pat_relinkMethodBody.edgeToTargetNode.Add(relinkMethodBody_edge_b1, relinkMethodBody_node_src);
			pat_relinkMethodBody.edgeToSourceNode.Add(relinkMethodBody_edge_b, relinkMethodBody_node_op);
			pat_relinkMethodBody.edgeToTargetNode.Add(relinkMethodBody_edge_b, relinkMethodBody_node_mb);

			relinkMethodBody_node_mb.pointOfDefinition = null;
			relinkMethodBody_node_src.pointOfDefinition = null;
			relinkMethodBody_node_op.pointOfDefinition = null;
			relinkMethodBody_node_tgt.pointOfDefinition = null;
			relinkMethodBody_node_newop.pointOfDefinition = null;
			relinkMethodBody_edge_b1.pointOfDefinition = pat_relinkMethodBody;
			relinkMethodBody_edge_b.pointOfDefinition = pat_relinkMethodBody;

			patternGraph = pat_relinkMethodBody;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_relinkMethodBody curMatch = (Match_relinkMethodBody)_curMatch;
			GRGEN_LGSP.LGSPNode node_mb = curMatch._node_mb;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPNode node_newop = curMatch._node_newop;
			GRGEN_LGSP.LGSPEdge edge_b1 = curMatch._edge_b1;
			GRGEN_LGSP.LGSPEdge edge_b = curMatch._edge_b;
			graph.SettingAddedNodeNames( relinkMethodBody_addedNodeNames );
			graph.SettingAddedEdgeNames( relinkMethodBody_addedEdgeNames );
			GRGEN_MODEL.@belongsTo edge_newb1 = GRGEN_MODEL.@belongsTo.CreateEdge(graph, node_mb, node_tgt);
			GRGEN_MODEL.@binding edge_newb = GRGEN_MODEL.@binding.CreateEdge(graph, node_newop, node_mb);
			graph.Remove(edge_b1);
			graph.Remove(edge_b);
			return;
		}
		private static string[] relinkMethodBody_addedNodeNames = new string[] {  };
		private static string[] relinkMethodBody_addedEdgeNames = new string[] { "newb1", "newb" };

		static Rule_relinkMethodBody() {
		}

		public interface IMatch_relinkMethodBody : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IMethodBody node_mb { get; }
			GRGEN_MODEL.IClass node_src { get; }
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IClass node_tgt { get; }
			GRGEN_MODEL.IOperation node_newop { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge_b1 { get; }
			GRGEN_MODEL.Ibinding edge_b { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_relinkMethodBody : GRGEN_LGSP.ListElement<Match_relinkMethodBody>, IMatch_relinkMethodBody
		{
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_MODEL.IClass node_src { get { return (GRGEN_MODEL.IClass)_node_src; } }
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IClass node_tgt { get { return (GRGEN_MODEL.IClass)_node_tgt; } }
			public GRGEN_MODEL.IOperation node_newop { get { return (GRGEN_MODEL.IOperation)_node_newop; } }
			public GRGEN_LGSP.LGSPNode _node_mb;
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public GRGEN_LGSP.LGSPNode _node_newop;
			public enum relinkMethodBody_NodeNums { @mb, @src, @op, @tgt, @newop, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 5;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)relinkMethodBody_NodeNums.@mb: return _node_mb;
				case (int)relinkMethodBody_NodeNums.@src: return _node_src;
				case (int)relinkMethodBody_NodeNums.@op: return _node_op;
				case (int)relinkMethodBody_NodeNums.@tgt: return _node_tgt;
				case (int)relinkMethodBody_NodeNums.@newop: return _node_newop;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge_b1 { get { return (GRGEN_MODEL.IbelongsTo)_edge_b1; } }
			public GRGEN_MODEL.Ibinding edge_b { get { return (GRGEN_MODEL.Ibinding)_edge_b; } }
			public GRGEN_LGSP.LGSPEdge _edge_b1;
			public GRGEN_LGSP.LGSPEdge _edge_b;
			public enum relinkMethodBody_EdgeNums { @b1, @b, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)relinkMethodBody_EdgeNums.@b1: return _edge_b1;
				case (int)relinkMethodBody_EdgeNums.@b: return _edge_b;
				default: return null;
				}
			}
			
			public enum relinkMethodBody_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkMethodBody_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkMethodBody_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkMethodBody_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkMethodBody_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_relinkMethodBody.instance.pat_relinkMethodBody; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_relinkParameter : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_relinkParameter instance = null;
		public static Rule_relinkParameter Instance { get { if (instance==null) { instance = new Rule_relinkParameter(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] relinkParameter_node_exp_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkParameter_node_p_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkParameter_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkParameter_node_newop_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkParameter_node_newp_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkParameter_node_mb_AllowedTypes = null;
		public static bool[] relinkParameter_node_exp_IsAllowedType = null;
		public static bool[] relinkParameter_node_p_IsAllowedType = null;
		public static bool[] relinkParameter_node_op_IsAllowedType = null;
		public static bool[] relinkParameter_node_newop_IsAllowedType = null;
		public static bool[] relinkParameter_node_newp_IsAllowedType = null;
		public static bool[] relinkParameter_node_mb_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] relinkParameter_edge_l_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] relinkParameter_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] relinkParameter_edge__edge1_AllowedTypes = null;
		public static bool[] relinkParameter_edge_l_IsAllowedType = null;
		public static bool[] relinkParameter_edge__edge0_IsAllowedType = null;
		public static bool[] relinkParameter_edge__edge1_IsAllowedType = null;
		public enum relinkParameter_NodeNums { @exp, @p, @op, @newop, @newp, @mb, };
		public enum relinkParameter_EdgeNums { @l, @_edge0, @_edge1, };
		public enum relinkParameter_VariableNums { };
		public enum relinkParameter_SubNums { };
		public enum relinkParameter_AltNums { };
		public enum relinkParameter_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_relinkParameter;


		private Rule_relinkParameter()
		{
			name = "relinkParameter";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_MethodBody.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, };
			inputNames = new string[] { "relinkParameter_node_mb", "relinkParameter_node_op", "relinkParameter_node_newop", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] relinkParameter_isNodeHomomorphicGlobal = new bool[6, 6] {
				{ false, false, false, false, false, false, },
				{ false, false, false, false, false, false, },
				{ false, false, false, false, false, false, },
				{ false, false, false, false, false, false, },
				{ false, false, false, false, false, false, },
				{ false, false, false, false, false, false, },
			};
			bool[,] relinkParameter_isEdgeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[] relinkParameter_isNodeTotallyHomomorphic = new bool[6] { false, false, false, false, false, false,  };
			bool[] relinkParameter_isEdgeTotallyHomomorphic = new bool[3] { false, false, false,  };
			GRGEN_LGSP.PatternNode relinkParameter_node_exp = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "relinkParameter_node_exp", "exp", relinkParameter_node_exp_AllowedTypes, relinkParameter_node_exp_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkParameter_node_p = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Parameter, "GRGEN_MODEL.IParameter", "relinkParameter_node_p", "p", relinkParameter_node_p_AllowedTypes, relinkParameter_node_p_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkParameter_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "relinkParameter_node_op", "op", relinkParameter_node_op_AllowedTypes, relinkParameter_node_op_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkParameter_node_newop = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "relinkParameter_node_newop", "newop", relinkParameter_node_newop_AllowedTypes, relinkParameter_node_newop_IsAllowedType, 5.5F, 2, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkParameter_node_newp = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Parameter, "GRGEN_MODEL.IParameter", "relinkParameter_node_newp", "newp", relinkParameter_node_newp_AllowedTypes, relinkParameter_node_newp_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkParameter_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "relinkParameter_node_mb", "mb", relinkParameter_node_mb_AllowedTypes, relinkParameter_node_mb_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge relinkParameter_edge_l = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "relinkParameter_edge_l", "l", relinkParameter_edge_l_AllowedTypes, relinkParameter_edge_l_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge relinkParameter_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@parameter, "GRGEN_MODEL.Iparameter", "relinkParameter_edge__edge0", "_edge0", relinkParameter_edge__edge0_AllowedTypes, relinkParameter_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge relinkParameter_edge__edge1 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@parameter, "GRGEN_MODEL.Iparameter", "relinkParameter_edge__edge1", "_edge1", relinkParameter_edge__edge1_AllowedTypes, relinkParameter_edge__edge1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_relinkParameter = new GRGEN_LGSP.PatternGraph(
				"relinkParameter",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { relinkParameter_node_exp, relinkParameter_node_p, relinkParameter_node_op, relinkParameter_node_newop, relinkParameter_node_newp, relinkParameter_node_mb }, 
				new GRGEN_LGSP.PatternEdge[] { relinkParameter_edge_l, relinkParameter_edge__edge0, relinkParameter_edge__edge1 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[6, 6] {
					{ true, false, false, false, false, false, },
					{ false, true, false, false, false, false, },
					{ false, false, true, false, false, false, },
					{ false, false, false, true, false, false, },
					{ false, false, false, false, true, false, },
					{ false, false, false, false, false, true, },
				},
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				relinkParameter_isNodeHomomorphicGlobal,
				relinkParameter_isEdgeHomomorphicGlobal,
				relinkParameter_isNodeTotallyHomomorphic,
				relinkParameter_isEdgeTotallyHomomorphic
			);
			pat_relinkParameter.edgeToSourceNode.Add(relinkParameter_edge_l, relinkParameter_node_exp);
			pat_relinkParameter.edgeToTargetNode.Add(relinkParameter_edge_l, relinkParameter_node_p);
			pat_relinkParameter.edgeToSourceNode.Add(relinkParameter_edge__edge0, relinkParameter_node_op);
			pat_relinkParameter.edgeToTargetNode.Add(relinkParameter_edge__edge0, relinkParameter_node_p);
			pat_relinkParameter.edgeToSourceNode.Add(relinkParameter_edge__edge1, relinkParameter_node_newop);
			pat_relinkParameter.edgeToTargetNode.Add(relinkParameter_edge__edge1, relinkParameter_node_newp);

			relinkParameter_node_exp.pointOfDefinition = pat_relinkParameter;
			relinkParameter_node_p.pointOfDefinition = pat_relinkParameter;
			relinkParameter_node_op.pointOfDefinition = null;
			relinkParameter_node_newop.pointOfDefinition = null;
			relinkParameter_node_newp.pointOfDefinition = pat_relinkParameter;
			relinkParameter_node_mb.pointOfDefinition = null;
			relinkParameter_edge_l.pointOfDefinition = pat_relinkParameter;
			relinkParameter_edge__edge0.pointOfDefinition = pat_relinkParameter;
			relinkParameter_edge__edge1.pointOfDefinition = pat_relinkParameter;

			patternGraph = pat_relinkParameter;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_relinkParameter curMatch = (Match_relinkParameter)_curMatch;
			GRGEN_LGSP.LGSPNode node_exp = curMatch._node_exp;
			GRGEN_LGSP.LGSPNode node_newp = curMatch._node_newp;
			GRGEN_LGSP.LGSPEdge edge_l = curMatch._edge_l;
			graph.SettingAddedNodeNames( relinkParameter_addedNodeNames );
			graph.SettingAddedEdgeNames( relinkParameter_addedEdgeNames );
			GRGEN_MODEL.@link edge_newl = GRGEN_MODEL.@link.CreateEdge(graph, node_exp, node_newp);
			graph.Remove(edge_l);
			return;
		}
		private static string[] relinkParameter_addedNodeNames = new string[] {  };
		private static string[] relinkParameter_addedEdgeNames = new string[] { "newl" };

		static Rule_relinkParameter() {
		}

		public interface IMatch_relinkParameter : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IExpression node_exp { get; }
			GRGEN_MODEL.IParameter node_p { get; }
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IOperation node_newop { get; }
			GRGEN_MODEL.IParameter node_newp { get; }
			GRGEN_MODEL.IMethodBody node_mb { get; }
			//Edges
			GRGEN_MODEL.Ilink edge_l { get; }
			GRGEN_MODEL.Iparameter edge__edge0 { get; }
			GRGEN_MODEL.Iparameter edge__edge1 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_relinkParameter : GRGEN_LGSP.ListElement<Match_relinkParameter>, IMatch_relinkParameter
		{
			public GRGEN_MODEL.IExpression node_exp { get { return (GRGEN_MODEL.IExpression)_node_exp; } }
			public GRGEN_MODEL.IParameter node_p { get { return (GRGEN_MODEL.IParameter)_node_p; } }
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IOperation node_newop { get { return (GRGEN_MODEL.IOperation)_node_newop; } }
			public GRGEN_MODEL.IParameter node_newp { get { return (GRGEN_MODEL.IParameter)_node_newp; } }
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_LGSP.LGSPNode _node_exp;
			public GRGEN_LGSP.LGSPNode _node_p;
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_newop;
			public GRGEN_LGSP.LGSPNode _node_newp;
			public GRGEN_LGSP.LGSPNode _node_mb;
			public enum relinkParameter_NodeNums { @exp, @p, @op, @newop, @newp, @mb, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 6;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)relinkParameter_NodeNums.@exp: return _node_exp;
				case (int)relinkParameter_NodeNums.@p: return _node_p;
				case (int)relinkParameter_NodeNums.@op: return _node_op;
				case (int)relinkParameter_NodeNums.@newop: return _node_newop;
				case (int)relinkParameter_NodeNums.@newp: return _node_newp;
				case (int)relinkParameter_NodeNums.@mb: return _node_mb;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ilink edge_l { get { return (GRGEN_MODEL.Ilink)_edge_l; } }
			public GRGEN_MODEL.Iparameter edge__edge0 { get { return (GRGEN_MODEL.Iparameter)_edge__edge0; } }
			public GRGEN_MODEL.Iparameter edge__edge1 { get { return (GRGEN_MODEL.Iparameter)_edge__edge1; } }
			public GRGEN_LGSP.LGSPEdge _edge_l;
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge__edge1;
			public enum relinkParameter_EdgeNums { @l, @_edge0, @_edge1, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 3;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)relinkParameter_EdgeNums.@l: return _edge_l;
				case (int)relinkParameter_EdgeNums.@_edge0: return _edge__edge0;
				case (int)relinkParameter_EdgeNums.@_edge1: return _edge__edge1;
				default: return null;
				}
			}
			
			public enum relinkParameter_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkParameter_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkParameter_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkParameter_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkParameter_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_relinkParameter.instance.pat_relinkParameter; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_relinkOperationAndMethodBody : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_relinkOperationAndMethodBody instance = null;
		public static Rule_relinkOperationAndMethodBody Instance { get { if (instance==null) { instance = new Rule_relinkOperationAndMethodBody(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] relinkOperationAndMethodBody_node_mb_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkOperationAndMethodBody_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkOperationAndMethodBody_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] relinkOperationAndMethodBody_node_tgt_AllowedTypes = null;
		public static bool[] relinkOperationAndMethodBody_node_mb_IsAllowedType = null;
		public static bool[] relinkOperationAndMethodBody_node_src_IsAllowedType = null;
		public static bool[] relinkOperationAndMethodBody_node_op_IsAllowedType = null;
		public static bool[] relinkOperationAndMethodBody_node_tgt_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] relinkOperationAndMethodBody_edge_bc_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] relinkOperationAndMethodBody_edge_b_AllowedTypes = null;
		public static bool[] relinkOperationAndMethodBody_edge_bc_IsAllowedType = null;
		public static bool[] relinkOperationAndMethodBody_edge_b_IsAllowedType = null;
		public enum relinkOperationAndMethodBody_NodeNums { @mb, @src, @op, @tgt, };
		public enum relinkOperationAndMethodBody_EdgeNums { @bc, @b, };
		public enum relinkOperationAndMethodBody_VariableNums { };
		public enum relinkOperationAndMethodBody_SubNums { };
		public enum relinkOperationAndMethodBody_AltNums { };
		public enum relinkOperationAndMethodBody_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_relinkOperationAndMethodBody;


		private Rule_relinkOperationAndMethodBody()
		{
			name = "relinkOperationAndMethodBody";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_MethodBody.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Class.typeVar, };
			inputNames = new string[] { "relinkOperationAndMethodBody_node_op", "relinkOperationAndMethodBody_node_mb", "relinkOperationAndMethodBody_node_src", "relinkOperationAndMethodBody_node_tgt", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] relinkOperationAndMethodBody_isNodeHomomorphicGlobal = new bool[4, 4] {
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
			};
			bool[,] relinkOperationAndMethodBody_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] relinkOperationAndMethodBody_isNodeTotallyHomomorphic = new bool[4] { false, false, false, false,  };
			bool[] relinkOperationAndMethodBody_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternNode relinkOperationAndMethodBody_node_mb = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@MethodBody, "GRGEN_MODEL.IMethodBody", "relinkOperationAndMethodBody_node_mb", "mb", relinkOperationAndMethodBody_node_mb_AllowedTypes, relinkOperationAndMethodBody_node_mb_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkOperationAndMethodBody_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "relinkOperationAndMethodBody_node_src", "src", relinkOperationAndMethodBody_node_src_AllowedTypes, relinkOperationAndMethodBody_node_src_IsAllowedType, 5.5F, 2, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkOperationAndMethodBody_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "relinkOperationAndMethodBody_node_op", "op", relinkOperationAndMethodBody_node_op_AllowedTypes, relinkOperationAndMethodBody_node_op_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode relinkOperationAndMethodBody_node_tgt = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "relinkOperationAndMethodBody_node_tgt", "tgt", relinkOperationAndMethodBody_node_tgt_AllowedTypes, relinkOperationAndMethodBody_node_tgt_IsAllowedType, 5.5F, 3, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge relinkOperationAndMethodBody_edge_bc = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@belongsTo, "GRGEN_MODEL.IbelongsTo", "relinkOperationAndMethodBody_edge_bc", "bc", relinkOperationAndMethodBody_edge_bc_AllowedTypes, relinkOperationAndMethodBody_edge_bc_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge relinkOperationAndMethodBody_edge_b = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@binding, "GRGEN_MODEL.Ibinding", "relinkOperationAndMethodBody_edge_b", "b", relinkOperationAndMethodBody_edge_b_AllowedTypes, relinkOperationAndMethodBody_edge_b_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_relinkOperationAndMethodBody = new GRGEN_LGSP.PatternGraph(
				"relinkOperationAndMethodBody",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { relinkOperationAndMethodBody_node_mb, relinkOperationAndMethodBody_node_src, relinkOperationAndMethodBody_node_op, relinkOperationAndMethodBody_node_tgt }, 
				new GRGEN_LGSP.PatternEdge[] { relinkOperationAndMethodBody_edge_bc, relinkOperationAndMethodBody_edge_b }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[4, 4] {
					{ true, false, false, false, },
					{ false, true, false, false, },
					{ false, false, true, false, },
					{ false, false, false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				relinkOperationAndMethodBody_isNodeHomomorphicGlobal,
				relinkOperationAndMethodBody_isEdgeHomomorphicGlobal,
				relinkOperationAndMethodBody_isNodeTotallyHomomorphic,
				relinkOperationAndMethodBody_isEdgeTotallyHomomorphic
			);
			pat_relinkOperationAndMethodBody.edgeToSourceNode.Add(relinkOperationAndMethodBody_edge_bc, relinkOperationAndMethodBody_node_mb);
			pat_relinkOperationAndMethodBody.edgeToTargetNode.Add(relinkOperationAndMethodBody_edge_bc, relinkOperationAndMethodBody_node_src);
			pat_relinkOperationAndMethodBody.edgeToSourceNode.Add(relinkOperationAndMethodBody_edge_b, relinkOperationAndMethodBody_node_op);
			pat_relinkOperationAndMethodBody.edgeToTargetNode.Add(relinkOperationAndMethodBody_edge_b, relinkOperationAndMethodBody_node_mb);

			relinkOperationAndMethodBody_node_mb.pointOfDefinition = null;
			relinkOperationAndMethodBody_node_src.pointOfDefinition = null;
			relinkOperationAndMethodBody_node_op.pointOfDefinition = null;
			relinkOperationAndMethodBody_node_tgt.pointOfDefinition = null;
			relinkOperationAndMethodBody_edge_bc.pointOfDefinition = pat_relinkOperationAndMethodBody;
			relinkOperationAndMethodBody_edge_b.pointOfDefinition = pat_relinkOperationAndMethodBody;

			patternGraph = pat_relinkOperationAndMethodBody;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_relinkOperationAndMethodBody curMatch = (Match_relinkOperationAndMethodBody)_curMatch;
			GRGEN_LGSP.LGSPNode node_mb = curMatch._node_mb;
			GRGEN_LGSP.LGSPNode node_tgt = curMatch._node_tgt;
			GRGEN_LGSP.LGSPNode node_op = curMatch._node_op;
			GRGEN_LGSP.LGSPEdge edge_bc = curMatch._edge_bc;
			graph.SettingAddedNodeNames( relinkOperationAndMethodBody_addedNodeNames );
			graph.SettingAddedEdgeNames( relinkOperationAndMethodBody_addedEdgeNames );
			GRGEN_MODEL.@belongsTo edge_newbc = GRGEN_MODEL.@belongsTo.CreateEdge(graph, node_mb, node_tgt);
			GRGEN_MODEL.@inClass edge__edge0 = GRGEN_MODEL.@inClass.CreateEdge(graph, node_op, node_tgt);
			graph.Remove(edge_bc);
			return;
		}
		private static string[] relinkOperationAndMethodBody_addedNodeNames = new string[] {  };
		private static string[] relinkOperationAndMethodBody_addedEdgeNames = new string[] { "newbc", "_edge0" };

		static Rule_relinkOperationAndMethodBody() {
		}

		public interface IMatch_relinkOperationAndMethodBody : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IMethodBody node_mb { get; }
			GRGEN_MODEL.IClass node_src { get; }
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IClass node_tgt { get; }
			//Edges
			GRGEN_MODEL.IbelongsTo edge_bc { get; }
			GRGEN_MODEL.Ibinding edge_b { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_relinkOperationAndMethodBody : GRGEN_LGSP.ListElement<Match_relinkOperationAndMethodBody>, IMatch_relinkOperationAndMethodBody
		{
			public GRGEN_MODEL.IMethodBody node_mb { get { return (GRGEN_MODEL.IMethodBody)_node_mb; } }
			public GRGEN_MODEL.IClass node_src { get { return (GRGEN_MODEL.IClass)_node_src; } }
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IClass node_tgt { get { return (GRGEN_MODEL.IClass)_node_tgt; } }
			public GRGEN_LGSP.LGSPNode _node_mb;
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_tgt;
			public enum relinkOperationAndMethodBody_NodeNums { @mb, @src, @op, @tgt, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 4;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)relinkOperationAndMethodBody_NodeNums.@mb: return _node_mb;
				case (int)relinkOperationAndMethodBody_NodeNums.@src: return _node_src;
				case (int)relinkOperationAndMethodBody_NodeNums.@op: return _node_op;
				case (int)relinkOperationAndMethodBody_NodeNums.@tgt: return _node_tgt;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.IbelongsTo edge_bc { get { return (GRGEN_MODEL.IbelongsTo)_edge_bc; } }
			public GRGEN_MODEL.Ibinding edge_b { get { return (GRGEN_MODEL.Ibinding)_edge_b; } }
			public GRGEN_LGSP.LGSPEdge _edge_bc;
			public GRGEN_LGSP.LGSPEdge _edge_b;
			public enum relinkOperationAndMethodBody_EdgeNums { @bc, @b, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)relinkOperationAndMethodBody_EdgeNums.@bc: return _edge_bc;
				case (int)relinkOperationAndMethodBody_EdgeNums.@b: return _edge_b;
				default: return null;
				}
			}
			
			public enum relinkOperationAndMethodBody_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkOperationAndMethodBody_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkOperationAndMethodBody_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkOperationAndMethodBody_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum relinkOperationAndMethodBody_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_relinkOperationAndMethodBody.instance.pat_relinkOperationAndMethodBody; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_addDelegateBody : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_addDelegateBody instance = null;
		public static Rule_addDelegateBody Instance { get { if (instance==null) { instance = new Rule_addDelegateBody(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] addDelegateBody_node_src_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] addDelegateBody_node_own_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] addDelegateBody_node_orig_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] addDelegateBody_node_vp_AllowedTypes = null;
		public static bool[] addDelegateBody_node_src_IsAllowedType = null;
		public static bool[] addDelegateBody_node_own_IsAllowedType = null;
		public static bool[] addDelegateBody_node_orig_IsAllowedType = null;
		public static bool[] addDelegateBody_node_vp_IsAllowedType = null;
		public enum addDelegateBody_NodeNums { @src, @own, @orig, @vp, };
		public enum addDelegateBody_EdgeNums { };
		public enum addDelegateBody_VariableNums { };
		public enum addDelegateBody_SubNums { };
		public enum addDelegateBody_AltNums { };
		public enum addDelegateBody_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_addDelegateBody;


		private Rule_addDelegateBody()
		{
			name = "addDelegateBody";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Class.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_Node.typeVar, };
			inputNames = new string[] { "addDelegateBody_node_src", "addDelegateBody_node_own", "addDelegateBody_node_orig", "addDelegateBody_node_vp", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Call.typeVar, };

		}
		private void initialize()
		{
			bool[,] addDelegateBody_isNodeHomomorphicGlobal = new bool[4, 4] {
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
			};
			bool[,] addDelegateBody_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] addDelegateBody_isNodeTotallyHomomorphic = new bool[4] { false, false, false, false,  };
			bool[] addDelegateBody_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode addDelegateBody_node_src = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Class, "GRGEN_MODEL.IClass", "addDelegateBody_node_src", "src", addDelegateBody_node_src_AllowedTypes, addDelegateBody_node_src_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode addDelegateBody_node_own = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "addDelegateBody_node_own", "own", addDelegateBody_node_own_AllowedTypes, addDelegateBody_node_own_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode addDelegateBody_node_orig = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "addDelegateBody_node_orig", "orig", addDelegateBody_node_orig_AllowedTypes, addDelegateBody_node_orig_IsAllowedType, 5.5F, 2, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode addDelegateBody_node_vp = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, "GRGEN_LIBGR.INode", "addDelegateBody_node_vp", "vp", addDelegateBody_node_vp_AllowedTypes, addDelegateBody_node_vp_IsAllowedType, 5.5F, 3, false, null, null, null, null, null, false);
			pat_addDelegateBody = new GRGEN_LGSP.PatternGraph(
				"addDelegateBody",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { addDelegateBody_node_src, addDelegateBody_node_own, addDelegateBody_node_orig, addDelegateBody_node_vp }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[4, 4] {
					{ true, false, false, false, },
					{ false, true, false, false, },
					{ false, false, true, false, },
					{ false, false, false, true, },
				},
				new bool[0, 0] ,
				addDelegateBody_isNodeHomomorphicGlobal,
				addDelegateBody_isEdgeHomomorphicGlobal,
				addDelegateBody_isNodeTotallyHomomorphic,
				addDelegateBody_isEdgeTotallyHomomorphic
			);

			addDelegateBody_node_src.pointOfDefinition = null;
			addDelegateBody_node_own.pointOfDefinition = null;
			addDelegateBody_node_orig.pointOfDefinition = null;
			addDelegateBody_node_vp.pointOfDefinition = null;

			patternGraph = pat_addDelegateBody;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.ICall output_0)
		{
			Match_addDelegateBody curMatch = (Match_addDelegateBody)_curMatch;
			GRGEN_LGSP.LGSPNode node_src = curMatch._node_src;
			GRGEN_LGSP.LGSPNode node_own = curMatch._node_own;
			GRGEN_LGSP.LGSPNode node_orig = curMatch._node_orig;
			GRGEN_LGSP.LGSPNode node_vp = curMatch._node_vp;
			graph.SettingAddedNodeNames( addDelegateBody_addedNodeNames );
			GRGEN_MODEL.@MethodBody node_mb = GRGEN_MODEL.@MethodBody.CreateNode(graph);
			GRGEN_MODEL.@Block node_bl = GRGEN_MODEL.@Block.CreateNode(graph);
			GRGEN_MODEL.@Access node_access = GRGEN_MODEL.@Access.CreateNode(graph);
			GRGEN_MODEL.@Call node_call = GRGEN_MODEL.@Call.CreateNode(graph);
			graph.SettingAddedEdgeNames( addDelegateBody_addedEdgeNames );
			GRGEN_MODEL.@belongsTo edge__edge0 = GRGEN_MODEL.@belongsTo.CreateEdge(graph, node_mb, node_src);
			GRGEN_MODEL.@belongsTo edge__edge1 = GRGEN_MODEL.@belongsTo.CreateEdge(graph, node_bl, node_mb);
			GRGEN_MODEL.@binding edge_b = GRGEN_MODEL.@binding.CreateEdge(graph, node_own, node_mb);
			GRGEN_MODEL.@expression edge__edge2 = GRGEN_MODEL.@expression.CreateEdge(graph, node_bl, node_access);
			GRGEN_MODEL.@expression edge__edge3 = GRGEN_MODEL.@expression.CreateEdge(graph, node_access, node_call);
			GRGEN_MODEL.@link edge__edge4 = GRGEN_MODEL.@link.CreateEdge(graph, node_call, node_orig);
			GRGEN_MODEL.@link edge__edge5 = GRGEN_MODEL.@link.CreateEdge(graph, node_access, node_vp);
			GRGEN_MODEL.@inBlock edge__edge6 = GRGEN_MODEL.@inBlock.CreateEdge(graph, node_access, node_bl);
			GRGEN_MODEL.@inBlock edge__edge7 = GRGEN_MODEL.@inBlock.CreateEdge(graph, node_call, node_bl);
			output_0 = (GRGEN_MODEL.ICall)(node_call);
			return;
		}
		private static string[] addDelegateBody_addedNodeNames = new string[] { "mb", "bl", "access", "call" };
		private static string[] addDelegateBody_addedEdgeNames = new string[] { "_edge0", "_edge1", "b", "_edge2", "_edge3", "_edge4", "_edge5", "_edge6", "_edge7" };

		static Rule_addDelegateBody() {
		}

		public interface IMatch_addDelegateBody : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IClass node_src { get; }
			GRGEN_MODEL.IOperation node_own { get; }
			GRGEN_MODEL.IOperation node_orig { get; }
			GRGEN_LIBGR.INode node_vp { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_addDelegateBody : GRGEN_LGSP.ListElement<Match_addDelegateBody>, IMatch_addDelegateBody
		{
			public GRGEN_MODEL.IClass node_src { get { return (GRGEN_MODEL.IClass)_node_src; } }
			public GRGEN_MODEL.IOperation node_own { get { return (GRGEN_MODEL.IOperation)_node_own; } }
			public GRGEN_MODEL.IOperation node_orig { get { return (GRGEN_MODEL.IOperation)_node_orig; } }
			public GRGEN_LIBGR.INode node_vp { get { return (GRGEN_LIBGR.INode)_node_vp; } }
			public GRGEN_LGSP.LGSPNode _node_src;
			public GRGEN_LGSP.LGSPNode _node_own;
			public GRGEN_LGSP.LGSPNode _node_orig;
			public GRGEN_LGSP.LGSPNode _node_vp;
			public enum addDelegateBody_NodeNums { @src, @own, @orig, @vp, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 4;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)addDelegateBody_NodeNums.@src: return _node_src;
				case (int)addDelegateBody_NodeNums.@own: return _node_own;
				case (int)addDelegateBody_NodeNums.@orig: return _node_orig;
				case (int)addDelegateBody_NodeNums.@vp: return _node_vp;
				default: return null;
				}
			}
			
			public enum addDelegateBody_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addDelegateBody_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addDelegateBody_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addDelegateBody_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addDelegateBody_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addDelegateBody_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_addDelegateBody.instance.pat_addDelegateBody; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_linkDelegateBodyToOperation : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_linkDelegateBodyToOperation instance = null;
		public static Rule_linkDelegateBodyToOperation Instance { get { if (instance==null) { instance = new Rule_linkDelegateBodyToOperation(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] linkDelegateBodyToOperation_node_op_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] linkDelegateBodyToOperation_node_param_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] linkDelegateBodyToOperation_node_call_AllowedTypes = null;
		public static bool[] linkDelegateBodyToOperation_node_op_IsAllowedType = null;
		public static bool[] linkDelegateBodyToOperation_node_param_IsAllowedType = null;
		public static bool[] linkDelegateBodyToOperation_node_call_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] linkDelegateBodyToOperation_edge__edge0_AllowedTypes = null;
		public static bool[] linkDelegateBodyToOperation_edge__edge0_IsAllowedType = null;
		public enum linkDelegateBodyToOperation_NodeNums { @op, @param, @call, };
		public enum linkDelegateBodyToOperation_EdgeNums { @_edge0, };
		public enum linkDelegateBodyToOperation_VariableNums { };
		public enum linkDelegateBodyToOperation_SubNums { };
		public enum linkDelegateBodyToOperation_AltNums { };
		public enum linkDelegateBodyToOperation_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_linkDelegateBodyToOperation;


		private Rule_linkDelegateBodyToOperation()
		{
			name = "linkDelegateBodyToOperation";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Call.typeVar, GRGEN_MODEL.NodeType_Operation.typeVar, };
			inputNames = new string[] { "linkDelegateBodyToOperation_node_call", "linkDelegateBodyToOperation_node_op", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] linkDelegateBodyToOperation_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] linkDelegateBodyToOperation_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] linkDelegateBodyToOperation_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] linkDelegateBodyToOperation_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode linkDelegateBodyToOperation_node_op = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "linkDelegateBodyToOperation_node_op", "op", linkDelegateBodyToOperation_node_op_AllowedTypes, linkDelegateBodyToOperation_node_op_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode linkDelegateBodyToOperation_node_param = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Parameter, "GRGEN_MODEL.IParameter", "linkDelegateBodyToOperation_node_param", "param", linkDelegateBodyToOperation_node_param_AllowedTypes, linkDelegateBodyToOperation_node_param_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode linkDelegateBodyToOperation_node_call = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "linkDelegateBodyToOperation_node_call", "call", linkDelegateBodyToOperation_node_call_AllowedTypes, linkDelegateBodyToOperation_node_call_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge linkDelegateBodyToOperation_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@parameter, "GRGEN_MODEL.Iparameter", "linkDelegateBodyToOperation_edge__edge0", "_edge0", linkDelegateBodyToOperation_edge__edge0_AllowedTypes, linkDelegateBodyToOperation_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_linkDelegateBodyToOperation = new GRGEN_LGSP.PatternGraph(
				"linkDelegateBodyToOperation",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { linkDelegateBodyToOperation_node_op, linkDelegateBodyToOperation_node_param, linkDelegateBodyToOperation_node_call }, 
				new GRGEN_LGSP.PatternEdge[] { linkDelegateBodyToOperation_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				linkDelegateBodyToOperation_isNodeHomomorphicGlobal,
				linkDelegateBodyToOperation_isEdgeHomomorphicGlobal,
				linkDelegateBodyToOperation_isNodeTotallyHomomorphic,
				linkDelegateBodyToOperation_isEdgeTotallyHomomorphic
			);
			pat_linkDelegateBodyToOperation.edgeToSourceNode.Add(linkDelegateBodyToOperation_edge__edge0, linkDelegateBodyToOperation_node_op);
			pat_linkDelegateBodyToOperation.edgeToTargetNode.Add(linkDelegateBodyToOperation_edge__edge0, linkDelegateBodyToOperation_node_param);

			linkDelegateBodyToOperation_node_op.pointOfDefinition = null;
			linkDelegateBodyToOperation_node_param.pointOfDefinition = pat_linkDelegateBodyToOperation;
			linkDelegateBodyToOperation_node_call.pointOfDefinition = null;
			linkDelegateBodyToOperation_edge__edge0.pointOfDefinition = pat_linkDelegateBodyToOperation;

			patternGraph = pat_linkDelegateBodyToOperation;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_linkDelegateBodyToOperation curMatch = (Match_linkDelegateBodyToOperation)_curMatch;
			GRGEN_LGSP.LGSPNode node_call = curMatch._node_call;
			GRGEN_LGSP.LGSPNode node_param = curMatch._node_param;
			graph.SettingAddedNodeNames( linkDelegateBodyToOperation_addedNodeNames );
			GRGEN_MODEL.@Access node_access = GRGEN_MODEL.@Access.CreateNode(graph);
			graph.SettingAddedEdgeNames( linkDelegateBodyToOperation_addedEdgeNames );
			GRGEN_MODEL.@actualParameter edge__edge1 = GRGEN_MODEL.@actualParameter.CreateEdge(graph, node_call, node_access);
			GRGEN_MODEL.@link edge__edge2 = GRGEN_MODEL.@link.CreateEdge(graph, node_access, node_param);
			return;
		}
		private static string[] linkDelegateBodyToOperation_addedNodeNames = new string[] { "access" };
		private static string[] linkDelegateBodyToOperation_addedEdgeNames = new string[] { "_edge1", "_edge2" };

		static Rule_linkDelegateBodyToOperation() {
		}

		public interface IMatch_linkDelegateBodyToOperation : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IOperation node_op { get; }
			GRGEN_MODEL.IParameter node_param { get; }
			GRGEN_MODEL.ICall node_call { get; }
			//Edges
			GRGEN_MODEL.Iparameter edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_linkDelegateBodyToOperation : GRGEN_LGSP.ListElement<Match_linkDelegateBodyToOperation>, IMatch_linkDelegateBodyToOperation
		{
			public GRGEN_MODEL.IOperation node_op { get { return (GRGEN_MODEL.IOperation)_node_op; } }
			public GRGEN_MODEL.IParameter node_param { get { return (GRGEN_MODEL.IParameter)_node_param; } }
			public GRGEN_MODEL.ICall node_call { get { return (GRGEN_MODEL.ICall)_node_call; } }
			public GRGEN_LGSP.LGSPNode _node_op;
			public GRGEN_LGSP.LGSPNode _node_param;
			public GRGEN_LGSP.LGSPNode _node_call;
			public enum linkDelegateBodyToOperation_NodeNums { @op, @param, @call, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)linkDelegateBodyToOperation_NodeNums.@op: return _node_op;
				case (int)linkDelegateBodyToOperation_NodeNums.@param: return _node_param;
				case (int)linkDelegateBodyToOperation_NodeNums.@call: return _node_call;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iparameter edge__edge0 { get { return (GRGEN_MODEL.Iparameter)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum linkDelegateBodyToOperation_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)linkDelegateBodyToOperation_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum linkDelegateBodyToOperation_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum linkDelegateBodyToOperation_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum linkDelegateBodyToOperation_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum linkDelegateBodyToOperation_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum linkDelegateBodyToOperation_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_linkDelegateBodyToOperation.instance.pat_linkDelegateBodyToOperation; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_replaceAccess_Variable : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_replaceAccess_Variable instance = null;
		public static Rule_replaceAccess_Variable Instance { get { if (instance==null) { instance = new Rule_replaceAccess_Variable(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] replaceAccess_Variable_node_a_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Variable_node_call_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Variable_node_movedOperation_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Variable_node_b_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Variable_node_v_AllowedTypes = null;
		public static bool[] replaceAccess_Variable_node_a_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_node_call_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_node_movedOperation_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_node_b_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_node_v_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Variable_edge_e_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Variable_edge_l_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Variable_edge__edge0_AllowedTypes = null;
		public static bool[] replaceAccess_Variable_edge_e_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_edge_l_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_edge__edge0_IsAllowedType = null;
		public enum replaceAccess_Variable_NodeNums { @a, @call, @movedOperation, @b, @v, };
		public enum replaceAccess_Variable_EdgeNums { @e, @l, @_edge0, };
		public enum replaceAccess_Variable_VariableNums { };
		public enum replaceAccess_Variable_SubNums { };
		public enum replaceAccess_Variable_AltNums { };
		public enum replaceAccess_Variable_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_replaceAccess_Variable;


		private Rule_replaceAccess_Variable()
		{
			name = "replaceAccess_Variable";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_Variable.typeVar, };
			inputNames = new string[] { "replaceAccess_Variable_node_movedOperation", "replaceAccess_Variable_node_v", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] replaceAccess_Variable_isNodeHomomorphicGlobal = new bool[5, 5] {
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
			};
			bool[,] replaceAccess_Variable_isEdgeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[] replaceAccess_Variable_isNodeTotallyHomomorphic = new bool[5] { false, false, false, false, false,  };
			bool[] replaceAccess_Variable_isEdgeTotallyHomomorphic = new bool[3] { false, false, false,  };
			GRGEN_LGSP.PatternNode replaceAccess_Variable_node_a = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Access, "GRGEN_MODEL.IAccess", "replaceAccess_Variable_node_a", "a", replaceAccess_Variable_node_a_AllowedTypes, replaceAccess_Variable_node_a_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Variable_node_call = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "replaceAccess_Variable_node_call", "call", replaceAccess_Variable_node_call_AllowedTypes, replaceAccess_Variable_node_call_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Variable_node_movedOperation = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "replaceAccess_Variable_node_movedOperation", "movedOperation", replaceAccess_Variable_node_movedOperation_AllowedTypes, replaceAccess_Variable_node_movedOperation_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Variable_node_b = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Block, "GRGEN_MODEL.IBlock", "replaceAccess_Variable_node_b", "b", replaceAccess_Variable_node_b_AllowedTypes, replaceAccess_Variable_node_b_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Variable_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "replaceAccess_Variable_node_v", "v", replaceAccess_Variable_node_v_AllowedTypes, replaceAccess_Variable_node_v_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Variable_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "replaceAccess_Variable_edge_e", "e", replaceAccess_Variable_edge_e_AllowedTypes, replaceAccess_Variable_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Variable_edge_l = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "replaceAccess_Variable_edge_l", "l", replaceAccess_Variable_edge_l_AllowedTypes, replaceAccess_Variable_edge_l_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Variable_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@inBlock, "GRGEN_MODEL.IinBlock", "replaceAccess_Variable_edge__edge0", "_edge0", replaceAccess_Variable_edge__edge0_AllowedTypes, replaceAccess_Variable_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_replaceAccess_Variable = new GRGEN_LGSP.PatternGraph(
				"replaceAccess_Variable",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { replaceAccess_Variable_node_a, replaceAccess_Variable_node_call, replaceAccess_Variable_node_movedOperation, replaceAccess_Variable_node_b, replaceAccess_Variable_node_v }, 
				new GRGEN_LGSP.PatternEdge[] { replaceAccess_Variable_edge_e, replaceAccess_Variable_edge_l, replaceAccess_Variable_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[5, 5] {
					{ true, false, false, false, false, },
					{ false, true, false, false, false, },
					{ false, false, true, false, false, },
					{ false, false, false, true, false, },
					{ false, false, false, false, true, },
				},
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				replaceAccess_Variable_isNodeHomomorphicGlobal,
				replaceAccess_Variable_isEdgeHomomorphicGlobal,
				replaceAccess_Variable_isNodeTotallyHomomorphic,
				replaceAccess_Variable_isEdgeTotallyHomomorphic
			);
			pat_replaceAccess_Variable.edgeToSourceNode.Add(replaceAccess_Variable_edge_e, replaceAccess_Variable_node_a);
			pat_replaceAccess_Variable.edgeToTargetNode.Add(replaceAccess_Variable_edge_e, replaceAccess_Variable_node_call);
			pat_replaceAccess_Variable.edgeToSourceNode.Add(replaceAccess_Variable_edge_l, replaceAccess_Variable_node_call);
			pat_replaceAccess_Variable.edgeToTargetNode.Add(replaceAccess_Variable_edge_l, replaceAccess_Variable_node_movedOperation);
			pat_replaceAccess_Variable.edgeToSourceNode.Add(replaceAccess_Variable_edge__edge0, replaceAccess_Variable_node_call);
			pat_replaceAccess_Variable.edgeToTargetNode.Add(replaceAccess_Variable_edge__edge0, replaceAccess_Variable_node_b);

			replaceAccess_Variable_node_a.pointOfDefinition = pat_replaceAccess_Variable;
			replaceAccess_Variable_node_call.pointOfDefinition = pat_replaceAccess_Variable;
			replaceAccess_Variable_node_movedOperation.pointOfDefinition = null;
			replaceAccess_Variable_node_b.pointOfDefinition = pat_replaceAccess_Variable;
			replaceAccess_Variable_node_v.pointOfDefinition = null;
			replaceAccess_Variable_edge_e.pointOfDefinition = pat_replaceAccess_Variable;
			replaceAccess_Variable_edge_l.pointOfDefinition = pat_replaceAccess_Variable;
			replaceAccess_Variable_edge__edge0.pointOfDefinition = pat_replaceAccess_Variable;

			patternGraph = pat_replaceAccess_Variable;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_replaceAccess_Variable curMatch = (Match_replaceAccess_Variable)_curMatch;
			GRGEN_LGSP.LGSPNode node_a = curMatch._node_a;
			GRGEN_LGSP.LGSPNode node_call = curMatch._node_call;
			GRGEN_LGSP.LGSPNode node_v = curMatch._node_v;
			GRGEN_LGSP.LGSPNode node_b = curMatch._node_b;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			graph.SettingAddedNodeNames( replaceAccess_Variable_addedNodeNames );
			GRGEN_MODEL.@Access node_targetAccess = GRGEN_MODEL.@Access.CreateNode(graph);
			graph.SettingAddedEdgeNames( replaceAccess_Variable_addedEdgeNames );
			GRGEN_MODEL.@expression edge__edge1 = GRGEN_MODEL.@expression.CreateEdge(graph, node_a, node_targetAccess);
			GRGEN_MODEL.@expression edge__edge2 = GRGEN_MODEL.@expression.CreateEdge(graph, node_targetAccess, node_call);
			GRGEN_MODEL.@link edge__edge3 = GRGEN_MODEL.@link.CreateEdge(graph, node_targetAccess, node_v);
			GRGEN_MODEL.@inBlock edge__edge4 = GRGEN_MODEL.@inBlock.CreateEdge(graph, node_targetAccess, node_b);
			graph.Remove(edge_e);
			return;
		}
		private static string[] replaceAccess_Variable_addedNodeNames = new string[] { "targetAccess" };
		private static string[] replaceAccess_Variable_addedEdgeNames = new string[] { "_edge1", "_edge2", "_edge3", "_edge4" };

		static Rule_replaceAccess_Variable() {
		}

		public interface IMatch_replaceAccess_Variable : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_a { get; }
			GRGEN_MODEL.ICall node_call { get; }
			GRGEN_MODEL.IOperation node_movedOperation { get; }
			GRGEN_MODEL.IBlock node_b { get; }
			GRGEN_MODEL.IVariable node_v { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge_e { get; }
			GRGEN_MODEL.Ilink edge_l { get; }
			GRGEN_MODEL.IinBlock edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_replaceAccess_Variable : GRGEN_LGSP.ListElement<Match_replaceAccess_Variable>, IMatch_replaceAccess_Variable
		{
			public GRGEN_MODEL.IAccess node_a { get { return (GRGEN_MODEL.IAccess)_node_a; } }
			public GRGEN_MODEL.ICall node_call { get { return (GRGEN_MODEL.ICall)_node_call; } }
			public GRGEN_MODEL.IOperation node_movedOperation { get { return (GRGEN_MODEL.IOperation)_node_movedOperation; } }
			public GRGEN_MODEL.IBlock node_b { get { return (GRGEN_MODEL.IBlock)_node_b; } }
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_LGSP.LGSPNode _node_a;
			public GRGEN_LGSP.LGSPNode _node_call;
			public GRGEN_LGSP.LGSPNode _node_movedOperation;
			public GRGEN_LGSP.LGSPNode _node_b;
			public GRGEN_LGSP.LGSPNode _node_v;
			public enum replaceAccess_Variable_NodeNums { @a, @call, @movedOperation, @b, @v, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 5;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)replaceAccess_Variable_NodeNums.@a: return _node_a;
				case (int)replaceAccess_Variable_NodeNums.@call: return _node_call;
				case (int)replaceAccess_Variable_NodeNums.@movedOperation: return _node_movedOperation;
				case (int)replaceAccess_Variable_NodeNums.@b: return _node_b;
				case (int)replaceAccess_Variable_NodeNums.@v: return _node_v;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge_e { get { return (GRGEN_MODEL.Iexpression)_edge_e; } }
			public GRGEN_MODEL.Ilink edge_l { get { return (GRGEN_MODEL.Ilink)_edge_l; } }
			public GRGEN_MODEL.IinBlock edge__edge0 { get { return (GRGEN_MODEL.IinBlock)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public GRGEN_LGSP.LGSPEdge _edge_l;
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum replaceAccess_Variable_EdgeNums { @e, @l, @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 3;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)replaceAccess_Variable_EdgeNums.@e: return _edge_e;
				case (int)replaceAccess_Variable_EdgeNums.@l: return _edge_l;
				case (int)replaceAccess_Variable_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum replaceAccess_Variable_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Variable_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Variable_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Variable_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Variable_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_replaceAccess_Variable.instance.pat_replaceAccess_Variable; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_replaceAccess_Variable_WithSource : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_replaceAccess_Variable_WithSource instance = null;
		public static Rule_replaceAccess_Variable_WithSource Instance { get { if (instance==null) { instance = new Rule_replaceAccess_Variable_WithSource(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] replaceAccess_Variable_WithSource_node_a_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Variable_WithSource_node_call_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Variable_WithSource_node_movedOperation_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Variable_WithSource_node_b_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Variable_WithSource_node_v_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Variable_WithSource_node_srcparam_AllowedTypes = null;
		public static bool[] replaceAccess_Variable_WithSource_node_a_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_WithSource_node_call_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_WithSource_node_movedOperation_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_WithSource_node_b_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_WithSource_node_v_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_WithSource_node_srcparam_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Variable_WithSource_edge_e_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Variable_WithSource_edge_l_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Variable_WithSource_edge__edge0_AllowedTypes = null;
		public static bool[] replaceAccess_Variable_WithSource_edge_e_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_WithSource_edge_l_IsAllowedType = null;
		public static bool[] replaceAccess_Variable_WithSource_edge__edge0_IsAllowedType = null;
		public enum replaceAccess_Variable_WithSource_NodeNums { @a, @call, @movedOperation, @b, @v, @srcparam, };
		public enum replaceAccess_Variable_WithSource_EdgeNums { @e, @l, @_edge0, };
		public enum replaceAccess_Variable_WithSource_VariableNums { };
		public enum replaceAccess_Variable_WithSource_SubNums { };
		public enum replaceAccess_Variable_WithSource_AltNums { };
		public enum replaceAccess_Variable_WithSource_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_replaceAccess_Variable_WithSource;


		private Rule_replaceAccess_Variable_WithSource()
		{
			name = "replaceAccess_Variable_WithSource";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_Variable.typeVar, GRGEN_MODEL.NodeType_Parameter.typeVar, };
			inputNames = new string[] { "replaceAccess_Variable_WithSource_node_movedOperation", "replaceAccess_Variable_WithSource_node_v", "replaceAccess_Variable_WithSource_node_srcparam", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] replaceAccess_Variable_WithSource_isNodeHomomorphicGlobal = new bool[6, 6] {
				{ false, false, false, false, false, false, },
				{ false, false, false, false, false, false, },
				{ false, false, false, false, false, false, },
				{ false, false, false, false, false, false, },
				{ false, false, false, false, false, false, },
				{ false, false, false, false, false, false, },
			};
			bool[,] replaceAccess_Variable_WithSource_isEdgeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[] replaceAccess_Variable_WithSource_isNodeTotallyHomomorphic = new bool[6] { false, false, false, false, false, false,  };
			bool[] replaceAccess_Variable_WithSource_isEdgeTotallyHomomorphic = new bool[3] { false, false, false,  };
			GRGEN_LGSP.PatternNode replaceAccess_Variable_WithSource_node_a = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Access, "GRGEN_MODEL.IAccess", "replaceAccess_Variable_WithSource_node_a", "a", replaceAccess_Variable_WithSource_node_a_AllowedTypes, replaceAccess_Variable_WithSource_node_a_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Variable_WithSource_node_call = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "replaceAccess_Variable_WithSource_node_call", "call", replaceAccess_Variable_WithSource_node_call_AllowedTypes, replaceAccess_Variable_WithSource_node_call_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Variable_WithSource_node_movedOperation = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "replaceAccess_Variable_WithSource_node_movedOperation", "movedOperation", replaceAccess_Variable_WithSource_node_movedOperation_AllowedTypes, replaceAccess_Variable_WithSource_node_movedOperation_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Variable_WithSource_node_b = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Block, "GRGEN_MODEL.IBlock", "replaceAccess_Variable_WithSource_node_b", "b", replaceAccess_Variable_WithSource_node_b_AllowedTypes, replaceAccess_Variable_WithSource_node_b_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Variable_WithSource_node_v = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Variable, "GRGEN_MODEL.IVariable", "replaceAccess_Variable_WithSource_node_v", "v", replaceAccess_Variable_WithSource_node_v_AllowedTypes, replaceAccess_Variable_WithSource_node_v_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Variable_WithSource_node_srcparam = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Parameter, "GRGEN_MODEL.IParameter", "replaceAccess_Variable_WithSource_node_srcparam", "srcparam", replaceAccess_Variable_WithSource_node_srcparam_AllowedTypes, replaceAccess_Variable_WithSource_node_srcparam_IsAllowedType, 5.5F, 2, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Variable_WithSource_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "replaceAccess_Variable_WithSource_edge_e", "e", replaceAccess_Variable_WithSource_edge_e_AllowedTypes, replaceAccess_Variable_WithSource_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Variable_WithSource_edge_l = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "replaceAccess_Variable_WithSource_edge_l", "l", replaceAccess_Variable_WithSource_edge_l_AllowedTypes, replaceAccess_Variable_WithSource_edge_l_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Variable_WithSource_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@inBlock, "GRGEN_MODEL.IinBlock", "replaceAccess_Variable_WithSource_edge__edge0", "_edge0", replaceAccess_Variable_WithSource_edge__edge0_AllowedTypes, replaceAccess_Variable_WithSource_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_replaceAccess_Variable_WithSource = new GRGEN_LGSP.PatternGraph(
				"replaceAccess_Variable_WithSource",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { replaceAccess_Variable_WithSource_node_a, replaceAccess_Variable_WithSource_node_call, replaceAccess_Variable_WithSource_node_movedOperation, replaceAccess_Variable_WithSource_node_b, replaceAccess_Variable_WithSource_node_v, replaceAccess_Variable_WithSource_node_srcparam }, 
				new GRGEN_LGSP.PatternEdge[] { replaceAccess_Variable_WithSource_edge_e, replaceAccess_Variable_WithSource_edge_l, replaceAccess_Variable_WithSource_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[6, 6] {
					{ true, false, false, false, false, false, },
					{ false, true, false, false, false, false, },
					{ false, false, true, false, false, false, },
					{ false, false, false, true, false, false, },
					{ false, false, false, false, true, false, },
					{ false, false, false, false, false, true, },
				},
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				replaceAccess_Variable_WithSource_isNodeHomomorphicGlobal,
				replaceAccess_Variable_WithSource_isEdgeHomomorphicGlobal,
				replaceAccess_Variable_WithSource_isNodeTotallyHomomorphic,
				replaceAccess_Variable_WithSource_isEdgeTotallyHomomorphic
			);
			pat_replaceAccess_Variable_WithSource.edgeToSourceNode.Add(replaceAccess_Variable_WithSource_edge_e, replaceAccess_Variable_WithSource_node_a);
			pat_replaceAccess_Variable_WithSource.edgeToTargetNode.Add(replaceAccess_Variable_WithSource_edge_e, replaceAccess_Variable_WithSource_node_call);
			pat_replaceAccess_Variable_WithSource.edgeToSourceNode.Add(replaceAccess_Variable_WithSource_edge_l, replaceAccess_Variable_WithSource_node_call);
			pat_replaceAccess_Variable_WithSource.edgeToTargetNode.Add(replaceAccess_Variable_WithSource_edge_l, replaceAccess_Variable_WithSource_node_movedOperation);
			pat_replaceAccess_Variable_WithSource.edgeToSourceNode.Add(replaceAccess_Variable_WithSource_edge__edge0, replaceAccess_Variable_WithSource_node_call);
			pat_replaceAccess_Variable_WithSource.edgeToTargetNode.Add(replaceAccess_Variable_WithSource_edge__edge0, replaceAccess_Variable_WithSource_node_b);

			replaceAccess_Variable_WithSource_node_a.pointOfDefinition = pat_replaceAccess_Variable_WithSource;
			replaceAccess_Variable_WithSource_node_call.pointOfDefinition = pat_replaceAccess_Variable_WithSource;
			replaceAccess_Variable_WithSource_node_movedOperation.pointOfDefinition = null;
			replaceAccess_Variable_WithSource_node_b.pointOfDefinition = pat_replaceAccess_Variable_WithSource;
			replaceAccess_Variable_WithSource_node_v.pointOfDefinition = null;
			replaceAccess_Variable_WithSource_node_srcparam.pointOfDefinition = null;
			replaceAccess_Variable_WithSource_edge_e.pointOfDefinition = pat_replaceAccess_Variable_WithSource;
			replaceAccess_Variable_WithSource_edge_l.pointOfDefinition = pat_replaceAccess_Variable_WithSource;
			replaceAccess_Variable_WithSource_edge__edge0.pointOfDefinition = pat_replaceAccess_Variable_WithSource;

			patternGraph = pat_replaceAccess_Variable_WithSource;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_replaceAccess_Variable_WithSource curMatch = (Match_replaceAccess_Variable_WithSource)_curMatch;
			GRGEN_LGSP.LGSPNode node_a = curMatch._node_a;
			GRGEN_LGSP.LGSPNode node_call = curMatch._node_call;
			GRGEN_LGSP.LGSPNode node_v = curMatch._node_v;
			GRGEN_LGSP.LGSPNode node_srcparam = curMatch._node_srcparam;
			GRGEN_LGSP.LGSPNode node_b = curMatch._node_b;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			graph.SettingAddedNodeNames( replaceAccess_Variable_WithSource_addedNodeNames );
			GRGEN_MODEL.@Access node_targetAccess = GRGEN_MODEL.@Access.CreateNode(graph);
			graph.SettingAddedEdgeNames( replaceAccess_Variable_WithSource_addedEdgeNames );
			GRGEN_MODEL.@expression edge__edge1 = GRGEN_MODEL.@expression.CreateEdge(graph, node_a, node_targetAccess);
			GRGEN_MODEL.@expression edge__edge2 = GRGEN_MODEL.@expression.CreateEdge(graph, node_targetAccess, node_call);
			GRGEN_MODEL.@link edge__edge3 = GRGEN_MODEL.@link.CreateEdge(graph, node_targetAccess, node_v);
			GRGEN_MODEL.@actualParameter edge__edge4 = GRGEN_MODEL.@actualParameter.CreateEdge(graph, node_call, node_srcparam);
			GRGEN_MODEL.@inBlock edge__edge5 = GRGEN_MODEL.@inBlock.CreateEdge(graph, node_targetAccess, node_b);
			graph.Remove(edge_e);
			return;
		}
		private static string[] replaceAccess_Variable_WithSource_addedNodeNames = new string[] { "targetAccess" };
		private static string[] replaceAccess_Variable_WithSource_addedEdgeNames = new string[] { "_edge1", "_edge2", "_edge3", "_edge4", "_edge5" };

		static Rule_replaceAccess_Variable_WithSource() {
		}

		public interface IMatch_replaceAccess_Variable_WithSource : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_a { get; }
			GRGEN_MODEL.ICall node_call { get; }
			GRGEN_MODEL.IOperation node_movedOperation { get; }
			GRGEN_MODEL.IBlock node_b { get; }
			GRGEN_MODEL.IVariable node_v { get; }
			GRGEN_MODEL.IParameter node_srcparam { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge_e { get; }
			GRGEN_MODEL.Ilink edge_l { get; }
			GRGEN_MODEL.IinBlock edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_replaceAccess_Variable_WithSource : GRGEN_LGSP.ListElement<Match_replaceAccess_Variable_WithSource>, IMatch_replaceAccess_Variable_WithSource
		{
			public GRGEN_MODEL.IAccess node_a { get { return (GRGEN_MODEL.IAccess)_node_a; } }
			public GRGEN_MODEL.ICall node_call { get { return (GRGEN_MODEL.ICall)_node_call; } }
			public GRGEN_MODEL.IOperation node_movedOperation { get { return (GRGEN_MODEL.IOperation)_node_movedOperation; } }
			public GRGEN_MODEL.IBlock node_b { get { return (GRGEN_MODEL.IBlock)_node_b; } }
			public GRGEN_MODEL.IVariable node_v { get { return (GRGEN_MODEL.IVariable)_node_v; } }
			public GRGEN_MODEL.IParameter node_srcparam { get { return (GRGEN_MODEL.IParameter)_node_srcparam; } }
			public GRGEN_LGSP.LGSPNode _node_a;
			public GRGEN_LGSP.LGSPNode _node_call;
			public GRGEN_LGSP.LGSPNode _node_movedOperation;
			public GRGEN_LGSP.LGSPNode _node_b;
			public GRGEN_LGSP.LGSPNode _node_v;
			public GRGEN_LGSP.LGSPNode _node_srcparam;
			public enum replaceAccess_Variable_WithSource_NodeNums { @a, @call, @movedOperation, @b, @v, @srcparam, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 6;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)replaceAccess_Variable_WithSource_NodeNums.@a: return _node_a;
				case (int)replaceAccess_Variable_WithSource_NodeNums.@call: return _node_call;
				case (int)replaceAccess_Variable_WithSource_NodeNums.@movedOperation: return _node_movedOperation;
				case (int)replaceAccess_Variable_WithSource_NodeNums.@b: return _node_b;
				case (int)replaceAccess_Variable_WithSource_NodeNums.@v: return _node_v;
				case (int)replaceAccess_Variable_WithSource_NodeNums.@srcparam: return _node_srcparam;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge_e { get { return (GRGEN_MODEL.Iexpression)_edge_e; } }
			public GRGEN_MODEL.Ilink edge_l { get { return (GRGEN_MODEL.Ilink)_edge_l; } }
			public GRGEN_MODEL.IinBlock edge__edge0 { get { return (GRGEN_MODEL.IinBlock)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public GRGEN_LGSP.LGSPEdge _edge_l;
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum replaceAccess_Variable_WithSource_EdgeNums { @e, @l, @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 3;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)replaceAccess_Variable_WithSource_EdgeNums.@e: return _edge_e;
				case (int)replaceAccess_Variable_WithSource_EdgeNums.@l: return _edge_l;
				case (int)replaceAccess_Variable_WithSource_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum replaceAccess_Variable_WithSource_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Variable_WithSource_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Variable_WithSource_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Variable_WithSource_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Variable_WithSource_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_replaceAccess_Variable_WithSource.instance.pat_replaceAccess_Variable_WithSource; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_addSourceToCall : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_addSourceToCall instance = null;
		public static Rule_addSourceToCall Instance { get { if (instance==null) { instance = new Rule_addSourceToCall(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] addSourceToCall_node_call_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] addSourceToCall_node_srcparam_AllowedTypes = null;
		public static bool[] addSourceToCall_node_call_IsAllowedType = null;
		public static bool[] addSourceToCall_node_srcparam_IsAllowedType = null;
		public enum addSourceToCall_NodeNums { @call, @srcparam, };
		public enum addSourceToCall_EdgeNums { };
		public enum addSourceToCall_VariableNums { };
		public enum addSourceToCall_SubNums { };
		public enum addSourceToCall_AltNums { };
		public enum addSourceToCall_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_addSourceToCall;


		private Rule_addSourceToCall()
		{
			name = "addSourceToCall";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Call.typeVar, GRGEN_MODEL.NodeType_Parameter.typeVar, };
			inputNames = new string[] { "addSourceToCall_node_call", "addSourceToCall_node_srcparam", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] addSourceToCall_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] addSourceToCall_isEdgeHomomorphicGlobal = new bool[0, 0] ;
			bool[] addSourceToCall_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] addSourceToCall_isEdgeTotallyHomomorphic = new bool[0] ;
			GRGEN_LGSP.PatternNode addSourceToCall_node_call = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "addSourceToCall_node_call", "call", addSourceToCall_node_call_AllowedTypes, addSourceToCall_node_call_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode addSourceToCall_node_srcparam = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Parameter, "GRGEN_MODEL.IParameter", "addSourceToCall_node_srcparam", "srcparam", addSourceToCall_node_srcparam_AllowedTypes, addSourceToCall_node_srcparam_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			pat_addSourceToCall = new GRGEN_LGSP.PatternGraph(
				"addSourceToCall",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { addSourceToCall_node_call, addSourceToCall_node_srcparam }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[0, 0] ,
				addSourceToCall_isNodeHomomorphicGlobal,
				addSourceToCall_isEdgeHomomorphicGlobal,
				addSourceToCall_isNodeTotallyHomomorphic,
				addSourceToCall_isEdgeTotallyHomomorphic
			);

			addSourceToCall_node_call.pointOfDefinition = null;
			addSourceToCall_node_srcparam.pointOfDefinition = null;

			patternGraph = pat_addSourceToCall;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_addSourceToCall curMatch = (Match_addSourceToCall)_curMatch;
			GRGEN_LGSP.LGSPNode node_call = curMatch._node_call;
			GRGEN_LGSP.LGSPNode node_srcparam = curMatch._node_srcparam;
			graph.SettingAddedNodeNames( addSourceToCall_addedNodeNames );
			graph.SettingAddedEdgeNames( addSourceToCall_addedEdgeNames );
			GRGEN_MODEL.@actualParameter edge__edge0 = GRGEN_MODEL.@actualParameter.CreateEdge(graph, node_call, node_srcparam);
			return;
		}
		private static string[] addSourceToCall_addedNodeNames = new string[] {  };
		private static string[] addSourceToCall_addedEdgeNames = new string[] { "_edge0" };

		static Rule_addSourceToCall() {
		}

		public interface IMatch_addSourceToCall : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.ICall node_call { get; }
			GRGEN_MODEL.IParameter node_srcparam { get; }
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_addSourceToCall : GRGEN_LGSP.ListElement<Match_addSourceToCall>, IMatch_addSourceToCall
		{
			public GRGEN_MODEL.ICall node_call { get { return (GRGEN_MODEL.ICall)_node_call; } }
			public GRGEN_MODEL.IParameter node_srcparam { get { return (GRGEN_MODEL.IParameter)_node_srcparam; } }
			public GRGEN_LGSP.LGSPNode _node_call;
			public GRGEN_LGSP.LGSPNode _node_srcparam;
			public enum addSourceToCall_NodeNums { @call, @srcparam, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)addSourceToCall_NodeNums.@call: return _node_call;
				case (int)addSourceToCall_NodeNums.@srcparam: return _node_srcparam;
				default: return null;
				}
			}
			
			public enum addSourceToCall_EdgeNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 0;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addSourceToCall_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addSourceToCall_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addSourceToCall_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addSourceToCall_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum addSourceToCall_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_addSourceToCall.instance.pat_addSourceToCall; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_getUnprocessedCallWithActualParameter : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_getUnprocessedCallWithActualParameter instance = null;
		public static Rule_getUnprocessedCallWithActualParameter Instance { get { if (instance==null) { instance = new Rule_getUnprocessedCallWithActualParameter(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] getUnprocessedCallWithActualParameter_node_a_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] getUnprocessedCallWithActualParameter_node_c_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] getUnprocessedCallWithActualParameter_node_movedOperation_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] getUnprocessedCallWithActualParameter_node_p_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] getUnprocessedCallWithActualParameter_node_pe_AllowedTypes = null;
		public static bool[] getUnprocessedCallWithActualParameter_node_a_IsAllowedType = null;
		public static bool[] getUnprocessedCallWithActualParameter_node_c_IsAllowedType = null;
		public static bool[] getUnprocessedCallWithActualParameter_node_movedOperation_IsAllowedType = null;
		public static bool[] getUnprocessedCallWithActualParameter_node_p_IsAllowedType = null;
		public static bool[] getUnprocessedCallWithActualParameter_node_pe_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] getUnprocessedCallWithActualParameter_edge_e_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] getUnprocessedCallWithActualParameter_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] getUnprocessedCallWithActualParameter_edge__edge1_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] getUnprocessedCallWithActualParameter_edge__edge2_AllowedTypes = null;
		public static bool[] getUnprocessedCallWithActualParameter_edge_e_IsAllowedType = null;
		public static bool[] getUnprocessedCallWithActualParameter_edge__edge0_IsAllowedType = null;
		public static bool[] getUnprocessedCallWithActualParameter_edge__edge1_IsAllowedType = null;
		public static bool[] getUnprocessedCallWithActualParameter_edge__edge2_IsAllowedType = null;
		public enum getUnprocessedCallWithActualParameter_NodeNums { @a, @c, @movedOperation, @p, @pe, };
		public enum getUnprocessedCallWithActualParameter_EdgeNums { @e, @_edge0, @_edge1, @_edge2, };
		public enum getUnprocessedCallWithActualParameter_VariableNums { };
		public enum getUnprocessedCallWithActualParameter_SubNums { };
		public enum getUnprocessedCallWithActualParameter_AltNums { };
		public enum getUnprocessedCallWithActualParameter_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_getUnprocessedCallWithActualParameter;

		public static GRGEN_LIBGR.EdgeType[] getUnprocessedCallWithActualParameter_neg_0_edge__edge0_AllowedTypes = null;
		public static bool[] getUnprocessedCallWithActualParameter_neg_0_edge__edge0_IsAllowedType = null;
		public enum getUnprocessedCallWithActualParameter_neg_0_NodeNums { @a, @pe, };
		public enum getUnprocessedCallWithActualParameter_neg_0_EdgeNums { @_edge0, };
		public enum getUnprocessedCallWithActualParameter_neg_0_VariableNums { };
		public enum getUnprocessedCallWithActualParameter_neg_0_SubNums { };
		public enum getUnprocessedCallWithActualParameter_neg_0_AltNums { };
		public enum getUnprocessedCallWithActualParameter_neg_0_IterNums { };

		public GRGEN_LGSP.PatternGraph getUnprocessedCallWithActualParameter_neg_0;


		private Rule_getUnprocessedCallWithActualParameter()
		{
			name = "getUnprocessedCallWithActualParameter";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Operation.typeVar, GRGEN_MODEL.NodeType_Parameter.typeVar, };
			inputNames = new string[] { "getUnprocessedCallWithActualParameter_node_movedOperation", "getUnprocessedCallWithActualParameter_node_p", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Call.typeVar, GRGEN_MODEL.NodeType_Expression.typeVar, };

		}
		private void initialize()
		{
			bool[,] getUnprocessedCallWithActualParameter_isNodeHomomorphicGlobal = new bool[5, 5] {
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
				{ false, false, false, false, false, },
			};
			bool[,] getUnprocessedCallWithActualParameter_isEdgeHomomorphicGlobal = new bool[4, 4] {
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
			};
			bool[] getUnprocessedCallWithActualParameter_isNodeTotallyHomomorphic = new bool[5] { false, false, false, false, false,  };
			bool[] getUnprocessedCallWithActualParameter_isEdgeTotallyHomomorphic = new bool[4] { false, false, false, false,  };
			GRGEN_LGSP.PatternNode getUnprocessedCallWithActualParameter_node_a = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Access, "GRGEN_MODEL.IAccess", "getUnprocessedCallWithActualParameter_node_a", "a", getUnprocessedCallWithActualParameter_node_a_AllowedTypes, getUnprocessedCallWithActualParameter_node_a_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode getUnprocessedCallWithActualParameter_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "getUnprocessedCallWithActualParameter_node_c", "c", getUnprocessedCallWithActualParameter_node_c_AllowedTypes, getUnprocessedCallWithActualParameter_node_c_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode getUnprocessedCallWithActualParameter_node_movedOperation = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Operation, "GRGEN_MODEL.IOperation", "getUnprocessedCallWithActualParameter_node_movedOperation", "movedOperation", getUnprocessedCallWithActualParameter_node_movedOperation_AllowedTypes, getUnprocessedCallWithActualParameter_node_movedOperation_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode getUnprocessedCallWithActualParameter_node_p = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Parameter, "GRGEN_MODEL.IParameter", "getUnprocessedCallWithActualParameter_node_p", "p", getUnprocessedCallWithActualParameter_node_p_AllowedTypes, getUnprocessedCallWithActualParameter_node_p_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode getUnprocessedCallWithActualParameter_node_pe = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "getUnprocessedCallWithActualParameter_node_pe", "pe", getUnprocessedCallWithActualParameter_node_pe_AllowedTypes, getUnprocessedCallWithActualParameter_node_pe_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge getUnprocessedCallWithActualParameter_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "getUnprocessedCallWithActualParameter_edge_e", "e", getUnprocessedCallWithActualParameter_edge_e_AllowedTypes, getUnprocessedCallWithActualParameter_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge getUnprocessedCallWithActualParameter_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "getUnprocessedCallWithActualParameter_edge__edge0", "_edge0", getUnprocessedCallWithActualParameter_edge__edge0_AllowedTypes, getUnprocessedCallWithActualParameter_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge getUnprocessedCallWithActualParameter_edge__edge1 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@parameter, "GRGEN_MODEL.Iparameter", "getUnprocessedCallWithActualParameter_edge__edge1", "_edge1", getUnprocessedCallWithActualParameter_edge__edge1_AllowedTypes, getUnprocessedCallWithActualParameter_edge__edge1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge getUnprocessedCallWithActualParameter_edge__edge2 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@actualParameter, "GRGEN_MODEL.IactualParameter", "getUnprocessedCallWithActualParameter_edge__edge2", "_edge2", getUnprocessedCallWithActualParameter_edge__edge2_AllowedTypes, getUnprocessedCallWithActualParameter_edge__edge2_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			bool[,] getUnprocessedCallWithActualParameter_neg_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] getUnprocessedCallWithActualParameter_neg_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] getUnprocessedCallWithActualParameter_neg_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] getUnprocessedCallWithActualParameter_neg_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternEdge getUnprocessedCallWithActualParameter_neg_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "getUnprocessedCallWithActualParameter_neg_0_edge__edge0", "_edge0", getUnprocessedCallWithActualParameter_neg_0_edge__edge0_AllowedTypes, getUnprocessedCallWithActualParameter_neg_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			getUnprocessedCallWithActualParameter_neg_0 = new GRGEN_LGSP.PatternGraph(
				"neg_0",
				"getUnprocessedCallWithActualParameter_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { getUnprocessedCallWithActualParameter_node_a, getUnprocessedCallWithActualParameter_node_pe }, 
				new GRGEN_LGSP.PatternEdge[] { getUnprocessedCallWithActualParameter_neg_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				getUnprocessedCallWithActualParameter_neg_0_isNodeHomomorphicGlobal,
				getUnprocessedCallWithActualParameter_neg_0_isEdgeHomomorphicGlobal,
				getUnprocessedCallWithActualParameter_neg_0_isNodeTotallyHomomorphic,
				getUnprocessedCallWithActualParameter_neg_0_isEdgeTotallyHomomorphic
			);
			getUnprocessedCallWithActualParameter_neg_0.edgeToSourceNode.Add(getUnprocessedCallWithActualParameter_neg_0_edge__edge0, getUnprocessedCallWithActualParameter_node_a);
			getUnprocessedCallWithActualParameter_neg_0.edgeToTargetNode.Add(getUnprocessedCallWithActualParameter_neg_0_edge__edge0, getUnprocessedCallWithActualParameter_node_pe);

			pat_getUnprocessedCallWithActualParameter = new GRGEN_LGSP.PatternGraph(
				"getUnprocessedCallWithActualParameter",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { getUnprocessedCallWithActualParameter_node_a, getUnprocessedCallWithActualParameter_node_c, getUnprocessedCallWithActualParameter_node_movedOperation, getUnprocessedCallWithActualParameter_node_p, getUnprocessedCallWithActualParameter_node_pe }, 
				new GRGEN_LGSP.PatternEdge[] { getUnprocessedCallWithActualParameter_edge_e, getUnprocessedCallWithActualParameter_edge__edge0, getUnprocessedCallWithActualParameter_edge__edge1, getUnprocessedCallWithActualParameter_edge__edge2 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] { getUnprocessedCallWithActualParameter_neg_0,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[5, 5] {
					{ true, false, false, false, false, },
					{ false, true, false, false, false, },
					{ false, false, true, false, false, },
					{ false, false, false, true, false, },
					{ false, false, false, false, true, },
				},
				new bool[4, 4] {
					{ true, false, false, false, },
					{ false, true, false, false, },
					{ false, false, true, false, },
					{ false, false, false, true, },
				},
				getUnprocessedCallWithActualParameter_isNodeHomomorphicGlobal,
				getUnprocessedCallWithActualParameter_isEdgeHomomorphicGlobal,
				getUnprocessedCallWithActualParameter_isNodeTotallyHomomorphic,
				getUnprocessedCallWithActualParameter_isEdgeTotallyHomomorphic
			);
			pat_getUnprocessedCallWithActualParameter.edgeToSourceNode.Add(getUnprocessedCallWithActualParameter_edge_e, getUnprocessedCallWithActualParameter_node_a);
			pat_getUnprocessedCallWithActualParameter.edgeToTargetNode.Add(getUnprocessedCallWithActualParameter_edge_e, getUnprocessedCallWithActualParameter_node_c);
			pat_getUnprocessedCallWithActualParameter.edgeToSourceNode.Add(getUnprocessedCallWithActualParameter_edge__edge0, getUnprocessedCallWithActualParameter_node_c);
			pat_getUnprocessedCallWithActualParameter.edgeToTargetNode.Add(getUnprocessedCallWithActualParameter_edge__edge0, getUnprocessedCallWithActualParameter_node_movedOperation);
			pat_getUnprocessedCallWithActualParameter.edgeToSourceNode.Add(getUnprocessedCallWithActualParameter_edge__edge1, getUnprocessedCallWithActualParameter_node_movedOperation);
			pat_getUnprocessedCallWithActualParameter.edgeToTargetNode.Add(getUnprocessedCallWithActualParameter_edge__edge1, getUnprocessedCallWithActualParameter_node_p);
			pat_getUnprocessedCallWithActualParameter.edgeToSourceNode.Add(getUnprocessedCallWithActualParameter_edge__edge2, getUnprocessedCallWithActualParameter_node_c);
			pat_getUnprocessedCallWithActualParameter.edgeToTargetNode.Add(getUnprocessedCallWithActualParameter_edge__edge2, getUnprocessedCallWithActualParameter_node_pe);
			getUnprocessedCallWithActualParameter_neg_0.embeddingGraph = pat_getUnprocessedCallWithActualParameter;

			getUnprocessedCallWithActualParameter_node_a.pointOfDefinition = pat_getUnprocessedCallWithActualParameter;
			getUnprocessedCallWithActualParameter_node_c.pointOfDefinition = pat_getUnprocessedCallWithActualParameter;
			getUnprocessedCallWithActualParameter_node_movedOperation.pointOfDefinition = null;
			getUnprocessedCallWithActualParameter_node_p.pointOfDefinition = null;
			getUnprocessedCallWithActualParameter_node_pe.pointOfDefinition = pat_getUnprocessedCallWithActualParameter;
			getUnprocessedCallWithActualParameter_edge_e.pointOfDefinition = pat_getUnprocessedCallWithActualParameter;
			getUnprocessedCallWithActualParameter_edge__edge0.pointOfDefinition = pat_getUnprocessedCallWithActualParameter;
			getUnprocessedCallWithActualParameter_edge__edge1.pointOfDefinition = pat_getUnprocessedCallWithActualParameter;
			getUnprocessedCallWithActualParameter_edge__edge2.pointOfDefinition = pat_getUnprocessedCallWithActualParameter;
			getUnprocessedCallWithActualParameter_neg_0_edge__edge0.pointOfDefinition = getUnprocessedCallWithActualParameter_neg_0;

			patternGraph = pat_getUnprocessedCallWithActualParameter;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.ICall output_0, out GRGEN_MODEL.IExpression output_1)
		{
			Match_getUnprocessedCallWithActualParameter curMatch = (Match_getUnprocessedCallWithActualParameter)_curMatch;
			GRGEN_LGSP.LGSPNode node_c = curMatch._node_c;
			GRGEN_LGSP.LGSPNode node_pe = curMatch._node_pe;
			output_0 = (GRGEN_MODEL.ICall)(node_c);
			output_1 = (GRGEN_MODEL.IExpression)(node_pe);
			return;
		}

		static Rule_getUnprocessedCallWithActualParameter() {
		}

		public interface IMatch_getUnprocessedCallWithActualParameter : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_a { get; }
			GRGEN_MODEL.ICall node_c { get; }
			GRGEN_MODEL.IOperation node_movedOperation { get; }
			GRGEN_MODEL.IParameter node_p { get; }
			GRGEN_MODEL.IExpression node_pe { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge_e { get; }
			GRGEN_MODEL.Ilink edge__edge0 { get; }
			GRGEN_MODEL.Iparameter edge__edge1 { get; }
			GRGEN_MODEL.IactualParameter edge__edge2 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_getUnprocessedCallWithActualParameter_neg_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_a { get; }
			GRGEN_MODEL.IExpression node_pe { get; }
			//Edges
			GRGEN_MODEL.Ilink edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_getUnprocessedCallWithActualParameter : GRGEN_LGSP.ListElement<Match_getUnprocessedCallWithActualParameter>, IMatch_getUnprocessedCallWithActualParameter
		{
			public GRGEN_MODEL.IAccess node_a { get { return (GRGEN_MODEL.IAccess)_node_a; } }
			public GRGEN_MODEL.ICall node_c { get { return (GRGEN_MODEL.ICall)_node_c; } }
			public GRGEN_MODEL.IOperation node_movedOperation { get { return (GRGEN_MODEL.IOperation)_node_movedOperation; } }
			public GRGEN_MODEL.IParameter node_p { get { return (GRGEN_MODEL.IParameter)_node_p; } }
			public GRGEN_MODEL.IExpression node_pe { get { return (GRGEN_MODEL.IExpression)_node_pe; } }
			public GRGEN_LGSP.LGSPNode _node_a;
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_movedOperation;
			public GRGEN_LGSP.LGSPNode _node_p;
			public GRGEN_LGSP.LGSPNode _node_pe;
			public enum getUnprocessedCallWithActualParameter_NodeNums { @a, @c, @movedOperation, @p, @pe, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 5;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)getUnprocessedCallWithActualParameter_NodeNums.@a: return _node_a;
				case (int)getUnprocessedCallWithActualParameter_NodeNums.@c: return _node_c;
				case (int)getUnprocessedCallWithActualParameter_NodeNums.@movedOperation: return _node_movedOperation;
				case (int)getUnprocessedCallWithActualParameter_NodeNums.@p: return _node_p;
				case (int)getUnprocessedCallWithActualParameter_NodeNums.@pe: return _node_pe;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge_e { get { return (GRGEN_MODEL.Iexpression)_edge_e; } }
			public GRGEN_MODEL.Ilink edge__edge0 { get { return (GRGEN_MODEL.Ilink)_edge__edge0; } }
			public GRGEN_MODEL.Iparameter edge__edge1 { get { return (GRGEN_MODEL.Iparameter)_edge__edge1; } }
			public GRGEN_MODEL.IactualParameter edge__edge2 { get { return (GRGEN_MODEL.IactualParameter)_edge__edge2; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge__edge1;
			public GRGEN_LGSP.LGSPEdge _edge__edge2;
			public enum getUnprocessedCallWithActualParameter_EdgeNums { @e, @_edge0, @_edge1, @_edge2, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 4;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)getUnprocessedCallWithActualParameter_EdgeNums.@e: return _edge_e;
				case (int)getUnprocessedCallWithActualParameter_EdgeNums.@_edge0: return _edge__edge0;
				case (int)getUnprocessedCallWithActualParameter_EdgeNums.@_edge1: return _edge__edge1;
				case (int)getUnprocessedCallWithActualParameter_EdgeNums.@_edge2: return _edge__edge2;
				default: return null;
				}
			}
			
			public enum getUnprocessedCallWithActualParameter_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getUnprocessedCallWithActualParameter_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getUnprocessedCallWithActualParameter_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getUnprocessedCallWithActualParameter_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getUnprocessedCallWithActualParameter_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_getUnprocessedCallWithActualParameter.instance.pat_getUnprocessedCallWithActualParameter; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_getUnprocessedCallWithActualParameter_neg_0 : GRGEN_LGSP.ListElement<Match_getUnprocessedCallWithActualParameter_neg_0>, IMatch_getUnprocessedCallWithActualParameter_neg_0
		{
			public GRGEN_MODEL.IAccess node_a { get { return (GRGEN_MODEL.IAccess)_node_a; } }
			public GRGEN_MODEL.IExpression node_pe { get { return (GRGEN_MODEL.IExpression)_node_pe; } }
			public GRGEN_LGSP.LGSPNode _node_a;
			public GRGEN_LGSP.LGSPNode _node_pe;
			public enum getUnprocessedCallWithActualParameter_neg_0_NodeNums { @a, @pe, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)getUnprocessedCallWithActualParameter_neg_0_NodeNums.@a: return _node_a;
				case (int)getUnprocessedCallWithActualParameter_neg_0_NodeNums.@pe: return _node_pe;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ilink edge__edge0 { get { return (GRGEN_MODEL.Ilink)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum getUnprocessedCallWithActualParameter_neg_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)getUnprocessedCallWithActualParameter_neg_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum getUnprocessedCallWithActualParameter_neg_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getUnprocessedCallWithActualParameter_neg_0_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getUnprocessedCallWithActualParameter_neg_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getUnprocessedCallWithActualParameter_neg_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum getUnprocessedCallWithActualParameter_neg_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_getUnprocessedCallWithActualParameter.instance.getUnprocessedCallWithActualParameter_neg_0; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_replaceAccess_Parameter_AccessWithoutLink : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_replaceAccess_Parameter_AccessWithoutLink instance = null;
		public static Rule_replaceAccess_Parameter_AccessWithoutLink Instance { get { if (instance==null) { instance = new Rule_replaceAccess_Parameter_AccessWithoutLink(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] replaceAccess_Parameter_AccessWithoutLink_node_a_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Parameter_AccessWithoutLink_node_c_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Parameter_AccessWithoutLink_node_pe_AllowedTypes = null;
		public static bool[] replaceAccess_Parameter_AccessWithoutLink_node_a_IsAllowedType = null;
		public static bool[] replaceAccess_Parameter_AccessWithoutLink_node_c_IsAllowedType = null;
		public static bool[] replaceAccess_Parameter_AccessWithoutLink_node_pe_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Parameter_AccessWithoutLink_edge_e_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Parameter_AccessWithoutLink_edge__edge0_AllowedTypes = null;
		public static bool[] replaceAccess_Parameter_AccessWithoutLink_edge_e_IsAllowedType = null;
		public static bool[] replaceAccess_Parameter_AccessWithoutLink_edge__edge0_IsAllowedType = null;
		public enum replaceAccess_Parameter_AccessWithoutLink_NodeNums { @a, @c, @pe, };
		public enum replaceAccess_Parameter_AccessWithoutLink_EdgeNums { @e, @_edge0, };
		public enum replaceAccess_Parameter_AccessWithoutLink_VariableNums { };
		public enum replaceAccess_Parameter_AccessWithoutLink_SubNums { };
		public enum replaceAccess_Parameter_AccessWithoutLink_AltNums { };
		public enum replaceAccess_Parameter_AccessWithoutLink_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_replaceAccess_Parameter_AccessWithoutLink;

		public static GRGEN_LIBGR.NodeType[] replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0_AllowedTypes = null;
		public static bool[] replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0_AllowedTypes = null;
		public static bool[] replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0_IsAllowedType = null;
		public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_NodeNums { @a, @_node0, };
		public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_EdgeNums { @_edge0, };
		public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_VariableNums { };
		public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_SubNums { };
		public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_AltNums { };
		public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_IterNums { };

		public GRGEN_LGSP.PatternGraph replaceAccess_Parameter_AccessWithoutLink_neg_0;


		private Rule_replaceAccess_Parameter_AccessWithoutLink()
		{
			name = "replaceAccess_Parameter_AccessWithoutLink";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Call.typeVar, GRGEN_MODEL.NodeType_Expression.typeVar, };
			inputNames = new string[] { "replaceAccess_Parameter_AccessWithoutLink_node_c", "replaceAccess_Parameter_AccessWithoutLink_node_pe", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] replaceAccess_Parameter_AccessWithoutLink_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] replaceAccess_Parameter_AccessWithoutLink_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] replaceAccess_Parameter_AccessWithoutLink_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] replaceAccess_Parameter_AccessWithoutLink_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternNode replaceAccess_Parameter_AccessWithoutLink_node_a = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Access, "GRGEN_MODEL.IAccess", "replaceAccess_Parameter_AccessWithoutLink_node_a", "a", replaceAccess_Parameter_AccessWithoutLink_node_a_AllowedTypes, replaceAccess_Parameter_AccessWithoutLink_node_a_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Parameter_AccessWithoutLink_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "replaceAccess_Parameter_AccessWithoutLink_node_c", "c", replaceAccess_Parameter_AccessWithoutLink_node_c_AllowedTypes, replaceAccess_Parameter_AccessWithoutLink_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Parameter_AccessWithoutLink_node_pe = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "replaceAccess_Parameter_AccessWithoutLink_node_pe", "pe", replaceAccess_Parameter_AccessWithoutLink_node_pe_AllowedTypes, replaceAccess_Parameter_AccessWithoutLink_node_pe_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Parameter_AccessWithoutLink_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "replaceAccess_Parameter_AccessWithoutLink_edge_e", "e", replaceAccess_Parameter_AccessWithoutLink_edge_e_AllowedTypes, replaceAccess_Parameter_AccessWithoutLink_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Parameter_AccessWithoutLink_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@actualParameter, "GRGEN_MODEL.IactualParameter", "replaceAccess_Parameter_AccessWithoutLink_edge__edge0", "_edge0", replaceAccess_Parameter_AccessWithoutLink_edge__edge0_AllowedTypes, replaceAccess_Parameter_AccessWithoutLink_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			bool[,] replaceAccess_Parameter_AccessWithoutLink_neg_0_isNodeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[,] replaceAccess_Parameter_AccessWithoutLink_neg_0_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] replaceAccess_Parameter_AccessWithoutLink_neg_0_isNodeTotallyHomomorphic = new bool[2] { false, false,  };
			bool[] replaceAccess_Parameter_AccessWithoutLink_neg_0_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0 = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0", "_node0", replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0_AllowedTypes, replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0", "_edge0", replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0_AllowedTypes, replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			replaceAccess_Parameter_AccessWithoutLink_neg_0 = new GRGEN_LGSP.PatternGraph(
				"neg_0",
				"replaceAccess_Parameter_AccessWithoutLink_",
				false, false,
				new GRGEN_LGSP.PatternNode[] { replaceAccess_Parameter_AccessWithoutLink_node_a, replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0 }, 
				new GRGEN_LGSP.PatternEdge[] { replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				replaceAccess_Parameter_AccessWithoutLink_neg_0_isNodeHomomorphicGlobal,
				replaceAccess_Parameter_AccessWithoutLink_neg_0_isEdgeHomomorphicGlobal,
				replaceAccess_Parameter_AccessWithoutLink_neg_0_isNodeTotallyHomomorphic,
				replaceAccess_Parameter_AccessWithoutLink_neg_0_isEdgeTotallyHomomorphic
			);
			replaceAccess_Parameter_AccessWithoutLink_neg_0.edgeToSourceNode.Add(replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0, replaceAccess_Parameter_AccessWithoutLink_node_a);
			replaceAccess_Parameter_AccessWithoutLink_neg_0.edgeToTargetNode.Add(replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0, replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0);

			pat_replaceAccess_Parameter_AccessWithoutLink = new GRGEN_LGSP.PatternGraph(
				"replaceAccess_Parameter_AccessWithoutLink",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { replaceAccess_Parameter_AccessWithoutLink_node_a, replaceAccess_Parameter_AccessWithoutLink_node_c, replaceAccess_Parameter_AccessWithoutLink_node_pe }, 
				new GRGEN_LGSP.PatternEdge[] { replaceAccess_Parameter_AccessWithoutLink_edge_e, replaceAccess_Parameter_AccessWithoutLink_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] { replaceAccess_Parameter_AccessWithoutLink_neg_0,  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				replaceAccess_Parameter_AccessWithoutLink_isNodeHomomorphicGlobal,
				replaceAccess_Parameter_AccessWithoutLink_isEdgeHomomorphicGlobal,
				replaceAccess_Parameter_AccessWithoutLink_isNodeTotallyHomomorphic,
				replaceAccess_Parameter_AccessWithoutLink_isEdgeTotallyHomomorphic
			);
			pat_replaceAccess_Parameter_AccessWithoutLink.edgeToSourceNode.Add(replaceAccess_Parameter_AccessWithoutLink_edge_e, replaceAccess_Parameter_AccessWithoutLink_node_a);
			pat_replaceAccess_Parameter_AccessWithoutLink.edgeToTargetNode.Add(replaceAccess_Parameter_AccessWithoutLink_edge_e, replaceAccess_Parameter_AccessWithoutLink_node_c);
			pat_replaceAccess_Parameter_AccessWithoutLink.edgeToSourceNode.Add(replaceAccess_Parameter_AccessWithoutLink_edge__edge0, replaceAccess_Parameter_AccessWithoutLink_node_c);
			pat_replaceAccess_Parameter_AccessWithoutLink.edgeToTargetNode.Add(replaceAccess_Parameter_AccessWithoutLink_edge__edge0, replaceAccess_Parameter_AccessWithoutLink_node_pe);
			replaceAccess_Parameter_AccessWithoutLink_neg_0.embeddingGraph = pat_replaceAccess_Parameter_AccessWithoutLink;

			replaceAccess_Parameter_AccessWithoutLink_node_a.pointOfDefinition = pat_replaceAccess_Parameter_AccessWithoutLink;
			replaceAccess_Parameter_AccessWithoutLink_node_c.pointOfDefinition = null;
			replaceAccess_Parameter_AccessWithoutLink_node_pe.pointOfDefinition = null;
			replaceAccess_Parameter_AccessWithoutLink_edge_e.pointOfDefinition = pat_replaceAccess_Parameter_AccessWithoutLink;
			replaceAccess_Parameter_AccessWithoutLink_edge__edge0.pointOfDefinition = pat_replaceAccess_Parameter_AccessWithoutLink;
			replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0.pointOfDefinition = replaceAccess_Parameter_AccessWithoutLink_neg_0;
			replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0.pointOfDefinition = replaceAccess_Parameter_AccessWithoutLink_neg_0;

			patternGraph = pat_replaceAccess_Parameter_AccessWithoutLink;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_replaceAccess_Parameter_AccessWithoutLink curMatch = (Match_replaceAccess_Parameter_AccessWithoutLink)_curMatch;
			GRGEN_LGSP.LGSPNode node_a = curMatch._node_a;
			GRGEN_LGSP.LGSPNode node_pe = curMatch._node_pe;
			graph.SettingAddedNodeNames( replaceAccess_Parameter_AccessWithoutLink_addedNodeNames );
			graph.SettingAddedEdgeNames( replaceAccess_Parameter_AccessWithoutLink_addedEdgeNames );
			GRGEN_MODEL.@link edge__edge1 = GRGEN_MODEL.@link.CreateEdge(graph, node_a, node_pe);
			return;
		}
		private static string[] replaceAccess_Parameter_AccessWithoutLink_addedNodeNames = new string[] {  };
		private static string[] replaceAccess_Parameter_AccessWithoutLink_addedEdgeNames = new string[] { "_edge1" };

		static Rule_replaceAccess_Parameter_AccessWithoutLink() {
		}

		public interface IMatch_replaceAccess_Parameter_AccessWithoutLink : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_a { get; }
			GRGEN_MODEL.ICall node_c { get; }
			GRGEN_MODEL.IExpression node_pe { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge_e { get; }
			GRGEN_MODEL.IactualParameter edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public interface IMatch_replaceAccess_Parameter_AccessWithoutLink_neg_0 : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_a { get; }
			GRGEN_MODEL.IExpression node__node0 { get; }
			//Edges
			GRGEN_MODEL.Ilink edge__edge0 { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_replaceAccess_Parameter_AccessWithoutLink : GRGEN_LGSP.ListElement<Match_replaceAccess_Parameter_AccessWithoutLink>, IMatch_replaceAccess_Parameter_AccessWithoutLink
		{
			public GRGEN_MODEL.IAccess node_a { get { return (GRGEN_MODEL.IAccess)_node_a; } }
			public GRGEN_MODEL.ICall node_c { get { return (GRGEN_MODEL.ICall)_node_c; } }
			public GRGEN_MODEL.IExpression node_pe { get { return (GRGEN_MODEL.IExpression)_node_pe; } }
			public GRGEN_LGSP.LGSPNode _node_a;
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_pe;
			public enum replaceAccess_Parameter_AccessWithoutLink_NodeNums { @a, @c, @pe, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 3;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)replaceAccess_Parameter_AccessWithoutLink_NodeNums.@a: return _node_a;
				case (int)replaceAccess_Parameter_AccessWithoutLink_NodeNums.@c: return _node_c;
				case (int)replaceAccess_Parameter_AccessWithoutLink_NodeNums.@pe: return _node_pe;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge_e { get { return (GRGEN_MODEL.Iexpression)_edge_e; } }
			public GRGEN_MODEL.IactualParameter edge__edge0 { get { return (GRGEN_MODEL.IactualParameter)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum replaceAccess_Parameter_AccessWithoutLink_EdgeNums { @e, @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 2;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)replaceAccess_Parameter_AccessWithoutLink_EdgeNums.@e: return _edge_e;
				case (int)replaceAccess_Parameter_AccessWithoutLink_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithoutLink_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithoutLink_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithoutLink_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithoutLink_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithoutLink_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_replaceAccess_Parameter_AccessWithoutLink.instance.pat_replaceAccess_Parameter_AccessWithoutLink; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

		public class Match_replaceAccess_Parameter_AccessWithoutLink_neg_0 : GRGEN_LGSP.ListElement<Match_replaceAccess_Parameter_AccessWithoutLink_neg_0>, IMatch_replaceAccess_Parameter_AccessWithoutLink_neg_0
		{
			public GRGEN_MODEL.IAccess node_a { get { return (GRGEN_MODEL.IAccess)_node_a; } }
			public GRGEN_MODEL.IExpression node__node0 { get { return (GRGEN_MODEL.IExpression)_node__node0; } }
			public GRGEN_LGSP.LGSPNode _node_a;
			public GRGEN_LGSP.LGSPNode _node__node0;
			public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_NodeNums { @a, @_node0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 2;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)replaceAccess_Parameter_AccessWithoutLink_neg_0_NodeNums.@a: return _node_a;
				case (int)replaceAccess_Parameter_AccessWithoutLink_neg_0_NodeNums.@_node0: return _node__node0;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Ilink edge__edge0 { get { return (GRGEN_MODEL.Ilink)_edge__edge0; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_EdgeNums { @_edge0, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 1;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)replaceAccess_Parameter_AccessWithoutLink_neg_0_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithoutLink_neg_0_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_replaceAccess_Parameter_AccessWithoutLink.instance.replaceAccess_Parameter_AccessWithoutLink_neg_0; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class Rule_replaceAccess_Parameter_AccessWithLinkToExpression : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_replaceAccess_Parameter_AccessWithLinkToExpression instance = null;
		public static Rule_replaceAccess_Parameter_AccessWithLinkToExpression Instance { get { if (instance==null) { instance = new Rule_replaceAccess_Parameter_AccessWithLinkToExpression(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] replaceAccess_Parameter_AccessWithLinkToExpression_node_a_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Parameter_AccessWithLinkToExpression_node_c_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Parameter_AccessWithLinkToExpression_node_pe_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] replaceAccess_Parameter_AccessWithLinkToExpression_node_le_AllowedTypes = null;
		public static bool[] replaceAccess_Parameter_AccessWithLinkToExpression_node_a_IsAllowedType = null;
		public static bool[] replaceAccess_Parameter_AccessWithLinkToExpression_node_c_IsAllowedType = null;
		public static bool[] replaceAccess_Parameter_AccessWithLinkToExpression_node_pe_IsAllowedType = null;
		public static bool[] replaceAccess_Parameter_AccessWithLinkToExpression_node_le_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Parameter_AccessWithLinkToExpression_edge_e_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] replaceAccess_Parameter_AccessWithLinkToExpression_edge_old_AllowedTypes = null;
		public static bool[] replaceAccess_Parameter_AccessWithLinkToExpression_edge_e_IsAllowedType = null;
		public static bool[] replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0_IsAllowedType = null;
		public static bool[] replaceAccess_Parameter_AccessWithLinkToExpression_edge_old_IsAllowedType = null;
		public enum replaceAccess_Parameter_AccessWithLinkToExpression_NodeNums { @a, @c, @pe, @le, };
		public enum replaceAccess_Parameter_AccessWithLinkToExpression_EdgeNums { @e, @_edge0, @old, };
		public enum replaceAccess_Parameter_AccessWithLinkToExpression_VariableNums { };
		public enum replaceAccess_Parameter_AccessWithLinkToExpression_SubNums { };
		public enum replaceAccess_Parameter_AccessWithLinkToExpression_AltNums { };
		public enum replaceAccess_Parameter_AccessWithLinkToExpression_IterNums { };




		public GRGEN_LGSP.PatternGraph pat_replaceAccess_Parameter_AccessWithLinkToExpression;


		private Rule_replaceAccess_Parameter_AccessWithLinkToExpression()
		{
			name = "replaceAccess_Parameter_AccessWithLinkToExpression";

			inputs = new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Call.typeVar, GRGEN_MODEL.NodeType_Expression.typeVar, };
			inputNames = new string[] { "replaceAccess_Parameter_AccessWithLinkToExpression_node_c", "replaceAccess_Parameter_AccessWithLinkToExpression_node_pe", };
			defs = new GRGEN_LIBGR.GrGenType[] { };
			defNames = new string[] { };
			outputs = new GRGEN_LIBGR.GrGenType[] { };

		}
		private void initialize()
		{
			bool[,] replaceAccess_Parameter_AccessWithLinkToExpression_isNodeHomomorphicGlobal = new bool[4, 4] {
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
			};
			bool[,] replaceAccess_Parameter_AccessWithLinkToExpression_isEdgeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[] replaceAccess_Parameter_AccessWithLinkToExpression_isNodeTotallyHomomorphic = new bool[4] { false, false, false, false,  };
			bool[] replaceAccess_Parameter_AccessWithLinkToExpression_isEdgeTotallyHomomorphic = new bool[3] { false, false, false,  };
			GRGEN_LGSP.PatternNode replaceAccess_Parameter_AccessWithLinkToExpression_node_a = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Access, "GRGEN_MODEL.IAccess", "replaceAccess_Parameter_AccessWithLinkToExpression_node_a", "a", replaceAccess_Parameter_AccessWithLinkToExpression_node_a_AllowedTypes, replaceAccess_Parameter_AccessWithLinkToExpression_node_a_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Parameter_AccessWithLinkToExpression_node_c = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Call, "GRGEN_MODEL.ICall", "replaceAccess_Parameter_AccessWithLinkToExpression_node_c", "c", replaceAccess_Parameter_AccessWithLinkToExpression_node_c_AllowedTypes, replaceAccess_Parameter_AccessWithLinkToExpression_node_c_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Parameter_AccessWithLinkToExpression_node_pe = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "replaceAccess_Parameter_AccessWithLinkToExpression_node_pe", "pe", replaceAccess_Parameter_AccessWithLinkToExpression_node_pe_AllowedTypes, replaceAccess_Parameter_AccessWithLinkToExpression_node_pe_IsAllowedType, 5.5F, 1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternNode replaceAccess_Parameter_AccessWithLinkToExpression_node_le = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Expression, "GRGEN_MODEL.IExpression", "replaceAccess_Parameter_AccessWithLinkToExpression_node_le", "le", replaceAccess_Parameter_AccessWithLinkToExpression_node_le_AllowedTypes, replaceAccess_Parameter_AccessWithLinkToExpression_node_le_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Parameter_AccessWithLinkToExpression_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@expression, "GRGEN_MODEL.Iexpression", "replaceAccess_Parameter_AccessWithLinkToExpression_edge_e", "e", replaceAccess_Parameter_AccessWithLinkToExpression_edge_e_AllowedTypes, replaceAccess_Parameter_AccessWithLinkToExpression_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@actualParameter, "GRGEN_MODEL.IactualParameter", "replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0", "_edge0", replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0_AllowedTypes, replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			GRGEN_LGSP.PatternEdge replaceAccess_Parameter_AccessWithLinkToExpression_edge_old = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@link, "GRGEN_MODEL.Ilink", "replaceAccess_Parameter_AccessWithLinkToExpression_edge_old", "old", replaceAccess_Parameter_AccessWithLinkToExpression_edge_old_AllowedTypes, replaceAccess_Parameter_AccessWithLinkToExpression_edge_old_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, false);
			pat_replaceAccess_Parameter_AccessWithLinkToExpression = new GRGEN_LGSP.PatternGraph(
				"replaceAccess_Parameter_AccessWithLinkToExpression",
				"",
				false, false,
				new GRGEN_LGSP.PatternNode[] { replaceAccess_Parameter_AccessWithLinkToExpression_node_a, replaceAccess_Parameter_AccessWithLinkToExpression_node_c, replaceAccess_Parameter_AccessWithLinkToExpression_node_pe, replaceAccess_Parameter_AccessWithLinkToExpression_node_le }, 
				new GRGEN_LGSP.PatternEdge[] { replaceAccess_Parameter_AccessWithLinkToExpression_edge_e, replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0, replaceAccess_Parameter_AccessWithLinkToExpression_edge_old }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[4, 4] {
					{ true, false, false, false, },
					{ false, true, false, false, },
					{ false, false, true, false, },
					{ false, false, false, true, },
				},
				new bool[3, 3] {
					{ true, false, false, },
					{ false, true, false, },
					{ false, false, true, },
				},
				replaceAccess_Parameter_AccessWithLinkToExpression_isNodeHomomorphicGlobal,
				replaceAccess_Parameter_AccessWithLinkToExpression_isEdgeHomomorphicGlobal,
				replaceAccess_Parameter_AccessWithLinkToExpression_isNodeTotallyHomomorphic,
				replaceAccess_Parameter_AccessWithLinkToExpression_isEdgeTotallyHomomorphic
			);
			pat_replaceAccess_Parameter_AccessWithLinkToExpression.edgeToSourceNode.Add(replaceAccess_Parameter_AccessWithLinkToExpression_edge_e, replaceAccess_Parameter_AccessWithLinkToExpression_node_a);
			pat_replaceAccess_Parameter_AccessWithLinkToExpression.edgeToTargetNode.Add(replaceAccess_Parameter_AccessWithLinkToExpression_edge_e, replaceAccess_Parameter_AccessWithLinkToExpression_node_c);
			pat_replaceAccess_Parameter_AccessWithLinkToExpression.edgeToSourceNode.Add(replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0, replaceAccess_Parameter_AccessWithLinkToExpression_node_c);
			pat_replaceAccess_Parameter_AccessWithLinkToExpression.edgeToTargetNode.Add(replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0, replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
			pat_replaceAccess_Parameter_AccessWithLinkToExpression.edgeToSourceNode.Add(replaceAccess_Parameter_AccessWithLinkToExpression_edge_old, replaceAccess_Parameter_AccessWithLinkToExpression_node_a);
			pat_replaceAccess_Parameter_AccessWithLinkToExpression.edgeToTargetNode.Add(replaceAccess_Parameter_AccessWithLinkToExpression_edge_old, replaceAccess_Parameter_AccessWithLinkToExpression_node_le);

			replaceAccess_Parameter_AccessWithLinkToExpression_node_a.pointOfDefinition = pat_replaceAccess_Parameter_AccessWithLinkToExpression;
			replaceAccess_Parameter_AccessWithLinkToExpression_node_c.pointOfDefinition = null;
			replaceAccess_Parameter_AccessWithLinkToExpression_node_pe.pointOfDefinition = null;
			replaceAccess_Parameter_AccessWithLinkToExpression_node_le.pointOfDefinition = pat_replaceAccess_Parameter_AccessWithLinkToExpression;
			replaceAccess_Parameter_AccessWithLinkToExpression_edge_e.pointOfDefinition = pat_replaceAccess_Parameter_AccessWithLinkToExpression;
			replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0.pointOfDefinition = pat_replaceAccess_Parameter_AccessWithLinkToExpression;
			replaceAccess_Parameter_AccessWithLinkToExpression_edge_old.pointOfDefinition = pat_replaceAccess_Parameter_AccessWithLinkToExpression;

			patternGraph = pat_replaceAccess_Parameter_AccessWithLinkToExpression;
		}


		public void Modify(GRGEN_LGSP.LGSPGraph graph, GRGEN_LIBGR.IMatch _curMatch)
		{
			Match_replaceAccess_Parameter_AccessWithLinkToExpression curMatch = (Match_replaceAccess_Parameter_AccessWithLinkToExpression)_curMatch;
			GRGEN_LGSP.LGSPNode node_a = curMatch._node_a;
			GRGEN_LGSP.LGSPNode node_pe = curMatch._node_pe;
			GRGEN_LGSP.LGSPEdge edge_old = curMatch._edge_old;
			graph.SettingAddedNodeNames( replaceAccess_Parameter_AccessWithLinkToExpression_addedNodeNames );
			graph.SettingAddedEdgeNames( replaceAccess_Parameter_AccessWithLinkToExpression_addedEdgeNames );
			GRGEN_MODEL.@link edge_new = GRGEN_MODEL.@link.CreateEdge(graph, node_a, node_pe);
			graph.Remove(edge_old);
			return;
		}
		private static string[] replaceAccess_Parameter_AccessWithLinkToExpression_addedNodeNames = new string[] {  };
		private static string[] replaceAccess_Parameter_AccessWithLinkToExpression_addedEdgeNames = new string[] { "new" };

		static Rule_replaceAccess_Parameter_AccessWithLinkToExpression() {
		}

		public interface IMatch_replaceAccess_Parameter_AccessWithLinkToExpression : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IAccess node_a { get; }
			GRGEN_MODEL.ICall node_c { get; }
			GRGEN_MODEL.IExpression node_pe { get; }
			GRGEN_MODEL.IExpression node_le { get; }
			//Edges
			GRGEN_MODEL.Iexpression edge_e { get; }
			GRGEN_MODEL.IactualParameter edge__edge0 { get; }
			GRGEN_MODEL.Ilink edge_old { get; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_replaceAccess_Parameter_AccessWithLinkToExpression : GRGEN_LGSP.ListElement<Match_replaceAccess_Parameter_AccessWithLinkToExpression>, IMatch_replaceAccess_Parameter_AccessWithLinkToExpression
		{
			public GRGEN_MODEL.IAccess node_a { get { return (GRGEN_MODEL.IAccess)_node_a; } }
			public GRGEN_MODEL.ICall node_c { get { return (GRGEN_MODEL.ICall)_node_c; } }
			public GRGEN_MODEL.IExpression node_pe { get { return (GRGEN_MODEL.IExpression)_node_pe; } }
			public GRGEN_MODEL.IExpression node_le { get { return (GRGEN_MODEL.IExpression)_node_le; } }
			public GRGEN_LGSP.LGSPNode _node_a;
			public GRGEN_LGSP.LGSPNode _node_c;
			public GRGEN_LGSP.LGSPNode _node_pe;
			public GRGEN_LGSP.LGSPNode _node_le;
			public enum replaceAccess_Parameter_AccessWithLinkToExpression_NodeNums { @a, @c, @pe, @le, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public int NumberOfNodes { get { return 4;} }
			public GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)replaceAccess_Parameter_AccessWithLinkToExpression_NodeNums.@a: return _node_a;
				case (int)replaceAccess_Parameter_AccessWithLinkToExpression_NodeNums.@c: return _node_c;
				case (int)replaceAccess_Parameter_AccessWithLinkToExpression_NodeNums.@pe: return _node_pe;
				case (int)replaceAccess_Parameter_AccessWithLinkToExpression_NodeNums.@le: return _node_le;
				default: return null;
				}
			}
			
			public GRGEN_MODEL.Iexpression edge_e { get { return (GRGEN_MODEL.Iexpression)_edge_e; } }
			public GRGEN_MODEL.IactualParameter edge__edge0 { get { return (GRGEN_MODEL.IactualParameter)_edge__edge0; } }
			public GRGEN_MODEL.Ilink edge_old { get { return (GRGEN_MODEL.Ilink)_edge_old; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge_old;
			public enum replaceAccess_Parameter_AccessWithLinkToExpression_EdgeNums { @e, @_edge0, @old, END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public int NumberOfEdges { get { return 3;} }
			public GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)replaceAccess_Parameter_AccessWithLinkToExpression_EdgeNums.@e: return _edge_e;
				case (int)replaceAccess_Parameter_AccessWithLinkToExpression_EdgeNums.@_edge0: return _edge__edge0;
				case (int)replaceAccess_Parameter_AccessWithLinkToExpression_EdgeNums.@old: return _edge_old;
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithLinkToExpression_VariableNums { END_OF_ENUM };
			public IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public int NumberOfVariables { get { return 0;} }
			public object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithLinkToExpression_SubNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public int NumberOfEmbeddedGraphs { get { return 0;} }
			public GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithLinkToExpression_AltNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public int NumberOfAlternatives { get { return 0;} }
			public GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithLinkToExpression_IterNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public int NumberOfIterateds { get { return 0;} }
			public GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public enum replaceAccess_Parameter_AccessWithLinkToExpression_IdptNums { END_OF_ENUM };
			public IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public int NumberOfIndependents { get { return 0;} }
			public GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			
			public GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_replaceAccess_Parameter_AccessWithLinkToExpression.instance.pat_replaceAccess_Parameter_AccessWithLinkToExpression; } }
			public GRGEN_LIBGR.IMatch MatchOfEnclosingPattern { get { return _matchOfEnclosingPattern; } }
			public GRGEN_LIBGR.IMatch _matchOfEnclosingPattern;
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public override string ToString() { return "Match of " + Pattern.Name; }
		}

	}

	public class JavaProgramGraphs_RuleAndMatchingPatterns : GRGEN_LGSP.LGSPRuleAndMatchingPatterns
	{
		public JavaProgramGraphs_RuleAndMatchingPatterns()
		{
			subpatterns = new GRGEN_LGSP.LGSPMatchingPattern[11];
			rules = new GRGEN_LGSP.LGSPRulePattern[69];
			rulesAndSubpatterns = new GRGEN_LGSP.LGSPMatchingPattern[11+69];
			definedSequences = new GRGEN_LIBGR.DefinedSequenceInfo[0];
			subpatterns[0] = Pattern_MultipleContainedPackagesOrClasses.Instance;
			rulesAndSubpatterns[0] = Pattern_MultipleContainedPackagesOrClasses.Instance;
			subpatterns[1] = Pattern_MultipleVariables.Instance;
			rulesAndSubpatterns[1] = Pattern_MultipleVariables.Instance;
			subpatterns[2] = Pattern_MultipleMethodBodies.Instance;
			rulesAndSubpatterns[2] = Pattern_MultipleMethodBodies.Instance;
			subpatterns[3] = Pattern_MethodBodyAndImplementation.Instance;
			rulesAndSubpatterns[3] = Pattern_MethodBodyAndImplementation.Instance;
			subpatterns[4] = Pattern_MultipleParameters.Instance;
			rulesAndSubpatterns[4] = Pattern_MultipleParameters.Instance;
			subpatterns[5] = Pattern_MultipleExpressions.Instance;
			rulesAndSubpatterns[5] = Pattern_MultipleExpressions.Instance;
			subpatterns[6] = Pattern_ExpressionChain.Instance;
			rulesAndSubpatterns[6] = Pattern_ExpressionChain.Instance;
			subpatterns[7] = Pattern_MultipleActualParameters.Instance;
			rulesAndSubpatterns[7] = Pattern_MultipleActualParameters.Instance;
			subpatterns[8] = Pattern_MultipleExtendingClasses.Instance;
			rulesAndSubpatterns[8] = Pattern_MultipleExtendingClasses.Instance;
			subpatterns[9] = Pattern_InClass.Instance;
			rulesAndSubpatterns[9] = Pattern_InClass.Instance;
			subpatterns[10] = Pattern_methodNameExistsSuper.Instance;
			rulesAndSubpatterns[10] = Pattern_methodNameExistsSuper.Instance;
			rules[0] = Rule_dumpGxl.Instance;
			rulesAndSubpatterns[11+0] = Rule_dumpGxl.Instance;
			rules[1] = Rule_dumpNodePackage.Instance;
			rulesAndSubpatterns[11+1] = Rule_dumpNodePackage.Instance;
			rules[2] = Rule_dumpNodeClass.Instance;
			rulesAndSubpatterns[11+2] = Rule_dumpNodeClass.Instance;
			rules[3] = Rule_dumpNodeInterface.Instance;
			rulesAndSubpatterns[11+3] = Rule_dumpNodeInterface.Instance;
			rules[4] = Rule_dumpNodeVariable.Instance;
			rulesAndSubpatterns[11+4] = Rule_dumpNodeVariable.Instance;
			rules[5] = Rule_dumpNodeOperation.Instance;
			rulesAndSubpatterns[11+5] = Rule_dumpNodeOperation.Instance;
			rules[6] = Rule_dumpNodeMethodBody.Instance;
			rulesAndSubpatterns[11+6] = Rule_dumpNodeMethodBody.Instance;
			rules[7] = Rule_dumpNodeAccess.Instance;
			rulesAndSubpatterns[11+7] = Rule_dumpNodeAccess.Instance;
			rules[8] = Rule_dumpNodeUpdate.Instance;
			rulesAndSubpatterns[11+8] = Rule_dumpNodeUpdate.Instance;
			rules[9] = Rule_dumpNodeCall.Instance;
			rulesAndSubpatterns[11+9] = Rule_dumpNodeCall.Instance;
			rules[10] = Rule_dumpNodeIstantiation.Instance;
			rulesAndSubpatterns[11+10] = Rule_dumpNodeIstantiation.Instance;
			rules[11] = Rule_dumpNodeOperator.Instance;
			rulesAndSubpatterns[11+11] = Rule_dumpNodeOperator.Instance;
			rules[12] = Rule_dumpNodeReturn.Instance;
			rulesAndSubpatterns[11+12] = Rule_dumpNodeReturn.Instance;
			rules[13] = Rule_dumpNodeBlock.Instance;
			rulesAndSubpatterns[11+13] = Rule_dumpNodeBlock.Instance;
			rules[14] = Rule_dumpNodeLiteral.Instance;
			rulesAndSubpatterns[11+14] = Rule_dumpNodeLiteral.Instance;
			rules[15] = Rule_dumpNodeParameter.Instance;
			rulesAndSubpatterns[11+15] = Rule_dumpNodeParameter.Instance;
			rules[16] = Rule_dumpEdgeBelongsTo.Instance;
			rulesAndSubpatterns[11+16] = Rule_dumpEdgeBelongsTo.Instance;
			rules[17] = Rule_dumpEdgeType.Instance;
			rulesAndSubpatterns[11+17] = Rule_dumpEdgeType.Instance;
			rules[18] = Rule_dumpEdgeExtends.Instance;
			rulesAndSubpatterns[11+18] = Rule_dumpEdgeExtends.Instance;
			rules[19] = Rule_dumpEdgeImports.Instance;
			rulesAndSubpatterns[11+19] = Rule_dumpEdgeImports.Instance;
			rules[20] = Rule_dumpEdgeImplements.Instance;
			rulesAndSubpatterns[11+20] = Rule_dumpEdgeImplements.Instance;
			rules[21] = Rule_dumpEdgeParameter.Instance;
			rulesAndSubpatterns[11+21] = Rule_dumpEdgeParameter.Instance;
			rules[22] = Rule_dumpEdgeBinding.Instance;
			rulesAndSubpatterns[11+22] = Rule_dumpEdgeBinding.Instance;
			rules[23] = Rule_dumpEdgeLink.Instance;
			rulesAndSubpatterns[11+23] = Rule_dumpEdgeLink.Instance;
			rules[24] = Rule_dumpEdgeExpression.Instance;
			rulesAndSubpatterns[11+24] = Rule_dumpEdgeExpression.Instance;
			rules[25] = Rule_dumpEdgeActualParameter.Instance;
			rulesAndSubpatterns[11+25] = Rule_dumpEdgeActualParameter.Instance;
			rules[26] = Rule_emitSpanningTree.Instance;
			rulesAndSubpatterns[11+26] = Rule_emitSpanningTree.Instance;
			rules[27] = Rule_InsertHelperEdgesForNestedLayout.Instance;
			rulesAndSubpatterns[11+27] = Rule_InsertHelperEdgesForNestedLayout.Instance;
			rules[28] = Rule_BindOperations.Instance;
			rulesAndSubpatterns[11+28] = Rule_BindOperations.Instance;
			rules[29] = Rule_InitMoveIntoBlocks.Instance;
			rulesAndSubpatterns[11+29] = Rule_InitMoveIntoBlocks.Instance;
			rules[30] = Rule_MoveIntoBlocks.Instance;
			rulesAndSubpatterns[11+30] = Rule_MoveIntoBlocks.Instance;
			rules[31] = Rule_getClassAndVariable.Instance;
			rulesAndSubpatterns[11+31] = Rule_getClassAndVariable.Instance;
			rules[32] = Rule_variableInClass.Instance;
			rulesAndSubpatterns[11+32] = Rule_variableInClass.Instance;
			rules[33] = Rule_methodExists.Instance;
			rulesAndSubpatterns[11+33] = Rule_methodExists.Instance;
			rules[34] = Rule_sameStaticness.Instance;
			rulesAndSubpatterns[11+34] = Rule_sameStaticness.Instance;
			rules[35] = Rule_insertMethodGetter.Instance;
			rulesAndSubpatterns[11+35] = Rule_insertMethodGetter.Instance;
			rules[36] = Rule_insertMethodSetter.Instance;
			rulesAndSubpatterns[11+36] = Rule_insertMethodSetter.Instance;
			rules[37] = Rule_changeVisibility.Instance;
			rulesAndSubpatterns[11+37] = Rule_changeVisibility.Instance;
			rules[38] = Rule_adaptAccess.Instance;
			rulesAndSubpatterns[11+38] = Rule_adaptAccess.Instance;
			rules[39] = Rule_adaptUpdate.Instance;
			rulesAndSubpatterns[11+39] = Rule_adaptUpdate.Instance;
			rules[40] = Rule_adaptAccessUseAccessorsAlways.Instance;
			rulesAndSubpatterns[11+40] = Rule_adaptAccessUseAccessorsAlways.Instance;
			rules[41] = Rule_adaptUpdateUseAccessorsAlways.Instance;
			rulesAndSubpatterns[11+41] = Rule_adaptUpdateUseAccessorsAlways.Instance;
			rules[42] = Rule_getSourceAndTargetAndMethodBody.Instance;
			rulesAndSubpatterns[11+42] = Rule_getSourceAndTargetAndMethodBody.Instance;
			rules[43] = Rule_getOperation.Instance;
			rulesAndSubpatterns[11+43] = Rule_getOperation.Instance;
			rules[44] = Rule_someInstanceVariableOfTargetType.Instance;
			rulesAndSubpatterns[11+44] = Rule_someInstanceVariableOfTargetType.Instance;
			rules[45] = Rule_someParameterOfTargetType.Instance;
			rulesAndSubpatterns[11+45] = Rule_someParameterOfTargetType.Instance;
			rules[46] = Rule_markExpressionOfBody.Instance;
			rulesAndSubpatterns[11+46] = Rule_markExpressionOfBody.Instance;
			rules[47] = Rule_markExpressionFollowingExpression.Instance;
			rulesAndSubpatterns[11+47] = Rule_markExpressionFollowingExpression.Instance;
			rules[48] = Rule_markExpressionFollowingActualParameter.Instance;
			rulesAndSubpatterns[11+48] = Rule_markExpressionFollowingActualParameter.Instance;
			rules[49] = Rule_unmarkExpression.Instance;
			rulesAndSubpatterns[11+49] = Rule_unmarkExpression.Instance;
			rules[50] = Rule_callToSuperExists.Instance;
			rulesAndSubpatterns[11+50] = Rule_callToSuperExists.Instance;
			rules[51] = Rule_isStatic.Instance;
			rulesAndSubpatterns[11+51] = Rule_isStatic.Instance;
			rules[52] = Rule_methodNameExists.Instance;
			rulesAndSubpatterns[11+52] = Rule_methodNameExists.Instance;
			rules[53] = Rule_thisIsAccessed.Instance;
			rulesAndSubpatterns[11+53] = Rule_thisIsAccessed.Instance;
			rules[54] = Rule_addSourceParameter.Instance;
			rulesAndSubpatterns[11+54] = Rule_addSourceParameter.Instance;
			rules[55] = Rule_useSourceParameter.Instance;
			rulesAndSubpatterns[11+55] = Rule_useSourceParameter.Instance;
			rules[56] = Rule_copyOperation.Instance;
			rulesAndSubpatterns[11+56] = Rule_copyOperation.Instance;
			rules[57] = Rule_copyOperationParameter.Instance;
			rulesAndSubpatterns[11+57] = Rule_copyOperationParameter.Instance;
			rules[58] = Rule_relinkMethodBody.Instance;
			rulesAndSubpatterns[11+58] = Rule_relinkMethodBody.Instance;
			rules[59] = Rule_relinkParameter.Instance;
			rulesAndSubpatterns[11+59] = Rule_relinkParameter.Instance;
			rules[60] = Rule_relinkOperationAndMethodBody.Instance;
			rulesAndSubpatterns[11+60] = Rule_relinkOperationAndMethodBody.Instance;
			rules[61] = Rule_addDelegateBody.Instance;
			rulesAndSubpatterns[11+61] = Rule_addDelegateBody.Instance;
			rules[62] = Rule_linkDelegateBodyToOperation.Instance;
			rulesAndSubpatterns[11+62] = Rule_linkDelegateBodyToOperation.Instance;
			rules[63] = Rule_replaceAccess_Variable.Instance;
			rulesAndSubpatterns[11+63] = Rule_replaceAccess_Variable.Instance;
			rules[64] = Rule_replaceAccess_Variable_WithSource.Instance;
			rulesAndSubpatterns[11+64] = Rule_replaceAccess_Variable_WithSource.Instance;
			rules[65] = Rule_addSourceToCall.Instance;
			rulesAndSubpatterns[11+65] = Rule_addSourceToCall.Instance;
			rules[66] = Rule_getUnprocessedCallWithActualParameter.Instance;
			rulesAndSubpatterns[11+66] = Rule_getUnprocessedCallWithActualParameter.Instance;
			rules[67] = Rule_replaceAccess_Parameter_AccessWithoutLink.Instance;
			rulesAndSubpatterns[11+67] = Rule_replaceAccess_Parameter_AccessWithoutLink.Instance;
			rules[68] = Rule_replaceAccess_Parameter_AccessWithLinkToExpression.Instance;
			rulesAndSubpatterns[11+68] = Rule_replaceAccess_Parameter_AccessWithLinkToExpression.Instance;
		}
		public override GRGEN_LGSP.LGSPRulePattern[] Rules { get { return rules; } }
		private GRGEN_LGSP.LGSPRulePattern[] rules;
		public override GRGEN_LGSP.LGSPMatchingPattern[] Subpatterns { get { return subpatterns; } }
		private GRGEN_LGSP.LGSPMatchingPattern[] subpatterns;
		public override GRGEN_LGSP.LGSPMatchingPattern[] RulesAndSubpatterns { get { return rulesAndSubpatterns; } }
		private GRGEN_LGSP.LGSPMatchingPattern[] rulesAndSubpatterns;
		public override GRGEN_LIBGR.DefinedSequenceInfo[] DefinedSequences { get { return definedSequences; } }
		private GRGEN_LIBGR.DefinedSequenceInfo[] definedSequences;
	}


    public class PatternAction_MultipleContainedPackagesOrClasses : GRGEN_LGSP.LGSPSubpatternAction
    {
        private PatternAction_MultipleContainedPackagesOrClasses(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleContainedPackagesOrClasses.Instance.patternGraph;
        }

        public static PatternAction_MultipleContainedPackagesOrClasses getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            PatternAction_MultipleContainedPackagesOrClasses newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new PatternAction_MultipleContainedPackagesOrClasses(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(PatternAction_MultipleContainedPackagesOrClasses oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static PatternAction_MultipleContainedPackagesOrClasses freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private PatternAction_MultipleContainedPackagesOrClasses next = null;

        public GRGEN_LGSP.LGSPNode MultipleContainedPackagesOrClasses_node_p;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // SubPreset MultipleContainedPackagesOrClasses_node_p 
            GRGEN_LGSP.LGSPNode candidate_MultipleContainedPackagesOrClasses_node_p = MultipleContainedPackagesOrClasses_node_p;
            // Push iterated matching task for MultipleContainedPackagesOrClasses_iter_1
            IteratedAction_MultipleContainedPackagesOrClasses_iter_1 taskFor_iter_1 = IteratedAction_MultipleContainedPackagesOrClasses_iter_1.getNewTask(graph, openTasks);
            taskFor_iter_1.MultipleContainedPackagesOrClasses_node_p = candidate_MultipleContainedPackagesOrClasses_node_p;
            taskFor_iter_1.searchPatternpath = false;
            taskFor_iter_1.matchOfNestingPattern = null;
            taskFor_iter_1.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_1);
            // Push iterated matching task for MultipleContainedPackagesOrClasses_iter_0
            IteratedAction_MultipleContainedPackagesOrClasses_iter_0 taskFor_iter_0 = IteratedAction_MultipleContainedPackagesOrClasses_iter_0.getNewTask(graph, openTasks);
            taskFor_iter_0.MultipleContainedPackagesOrClasses_node_p = candidate_MultipleContainedPackagesOrClasses_node_p;
            taskFor_iter_0.searchPatternpath = false;
            taskFor_iter_0.matchOfNestingPattern = null;
            taskFor_iter_0.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_0);
            // Match subpatterns 
            openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
            // Pop iterated matching task for MultipleContainedPackagesOrClasses_iter_0
            openTasks.Pop();
            IteratedAction_MultipleContainedPackagesOrClasses_iter_0.releaseTask(taskFor_iter_0);
            // Pop iterated matching task for MultipleContainedPackagesOrClasses_iter_1
            openTasks.Pop();
            IteratedAction_MultipleContainedPackagesOrClasses_iter_1.releaseTask(taskFor_iter_1);
            // Check whether subpatterns were found 
            if(matchesList.Count>0) {
                // subpatterns/alternatives were found, extend the partial matches by our local match object
                foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                {
                    Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses match = new Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses();
                    match._node_p = candidate_MultipleContainedPackagesOrClasses_node_p;
                    match._iter_0 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_0, Pattern_MultipleContainedPackagesOrClasses.IMatch_MultipleContainedPackagesOrClasses_iter_0>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MultipleContainedPackagesOrClasses.IMatch_MultipleContainedPackagesOrClasses_iter_0) {
                        Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_0 cfpm = (Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_0)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_0.Add(cfpm);
                    }
                    match._iter_1 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_1, Pattern_MultipleContainedPackagesOrClasses.IMatch_MultipleContainedPackagesOrClasses_iter_1>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MultipleContainedPackagesOrClasses.IMatch_MultipleContainedPackagesOrClasses_iter_1) {
                        Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_1 cfpm = (Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_1)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_1.Add(cfpm);
                    }
                    currentFoundPartialMatch.Push(match);
                }
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
                // if enough matches were found, we leave
                if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                {
                    openTasks.Push(this);
                    return;
                }
                openTasks.Push(this);
                return;
            }
            openTasks.Push(this);
            return;
        }
    }

    public class IteratedAction_MultipleContainedPackagesOrClasses_iter_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MultipleContainedPackagesOrClasses_iter_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleContainedPackagesOrClasses.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 0;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MultipleContainedPackagesOrClasses_iter_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MultipleContainedPackagesOrClasses_iter_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MultipleContainedPackagesOrClasses_iter_0(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MultipleContainedPackagesOrClasses_iter_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MultipleContainedPackagesOrClasses_iter_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MultipleContainedPackagesOrClasses_iter_0 next = null;

        public GRGEN_LGSP.LGSPNode MultipleContainedPackagesOrClasses_node_p;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MultipleContainedPackagesOrClasses_node_p 
                GRGEN_LGSP.LGSPNode candidate_MultipleContainedPackagesOrClasses_node_p = MultipleContainedPackagesOrClasses_node_p;
                // Extend Incoming MultipleContainedPackagesOrClasses_iter_0_edge__edge0 from MultipleContainedPackagesOrClasses_node_p 
                GRGEN_LGSP.LGSPEdge head_candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0 = candidate_MultipleContainedPackagesOrClasses_node_p.lgspInhead;
                if(head_candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0 = head_candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0;
                    do
                    {
                        if(candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspType.TypeID!=3) {
                            continue;
                        }
                        if((candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Source MultipleContainedPackagesOrClasses_iter_0_node_sub from MultipleContainedPackagesOrClasses_iter_0_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub = candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspSource;
                        if(candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub.lgspType.TypeID!=1) {
                            continue;
                        }
                        if((candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        if((candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        // Push subpattern matching task for mpc
                        PatternAction_MultipleContainedPackagesOrClasses taskFor_mpc = PatternAction_MultipleContainedPackagesOrClasses.getNewTask(graph, openTasks);
                        taskFor_mpc.MultipleContainedPackagesOrClasses_node_p = candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub;
                        taskFor_mpc.searchPatternpath = false;
                        taskFor_mpc.matchOfNestingPattern = null;
                        taskFor_mpc.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor_mpc);
                        uint prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub;
                        prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub = candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0;
                        prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0 = candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for mpc
                        openTasks.Pop();
                        PatternAction_MultipleContainedPackagesOrClasses.releaseTask(taskFor_mpc);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_0 match = new Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_0();
                                match._node_sub = candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub;
                                match._node_p = candidate_MultipleContainedPackagesOrClasses_node_p;
                                match._edge__edge0 = candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0;
                                match._mpc = (@Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses)currentFoundPartialMatch.Pop();
                                match._mpc._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0;
                                candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0;
                            candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_0_node_sub;
                        candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0 = candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0.lgspInNext) != head_candidate_MultipleContainedPackagesOrClasses_iter_0_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_0 match = new Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_0();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_0 match = new Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_0();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class IteratedAction_MultipleContainedPackagesOrClasses_iter_1 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MultipleContainedPackagesOrClasses_iter_1(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleContainedPackagesOrClasses.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 0;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MultipleContainedPackagesOrClasses_iter_1 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MultipleContainedPackagesOrClasses_iter_1 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MultipleContainedPackagesOrClasses_iter_1(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MultipleContainedPackagesOrClasses_iter_1 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MultipleContainedPackagesOrClasses_iter_1 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MultipleContainedPackagesOrClasses_iter_1 next = null;

        public GRGEN_LGSP.LGSPNode MultipleContainedPackagesOrClasses_node_p;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MultipleContainedPackagesOrClasses_node_p 
                GRGEN_LGSP.LGSPNode candidate_MultipleContainedPackagesOrClasses_node_p = MultipleContainedPackagesOrClasses_node_p;
                // Extend Incoming MultipleContainedPackagesOrClasses_iter_1_edge__edge0 from MultipleContainedPackagesOrClasses_node_p 
                GRGEN_LGSP.LGSPEdge head_candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0 = candidate_MultipleContainedPackagesOrClasses_node_p.lgspInhead;
                if(head_candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0 = head_candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0;
                    do
                    {
                        if(candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspType.TypeID!=3) {
                            continue;
                        }
                        if((candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Source MultipleContainedPackagesOrClasses_iter_1_node_c from MultipleContainedPackagesOrClasses_iter_1_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MultipleContainedPackagesOrClasses_iter_1_node_c = candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspSource;
                        if(candidate_MultipleContainedPackagesOrClasses_iter_1_node_c.lgspType.TypeID!=3) {
                            continue;
                        }
                        if((candidate_MultipleContainedPackagesOrClasses_iter_1_node_c.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        // Push subpattern matching task for mv
                        PatternAction_MultipleVariables taskFor_mv = PatternAction_MultipleVariables.getNewTask(graph, openTasks);
                        taskFor_mv.MultipleVariables_node_c = candidate_MultipleContainedPackagesOrClasses_iter_1_node_c;
                        taskFor_mv.searchPatternpath = false;
                        taskFor_mv.matchOfNestingPattern = null;
                        taskFor_mv.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor_mv);
                        // Push subpattern matching task for mm
                        PatternAction_MultipleMethodBodies taskFor_mm = PatternAction_MultipleMethodBodies.getNewTask(graph, openTasks);
                        taskFor_mm.MultipleMethodBodies_node_c = candidate_MultipleContainedPackagesOrClasses_iter_1_node_c;
                        taskFor_mm.searchPatternpath = false;
                        taskFor_mm.matchOfNestingPattern = null;
                        taskFor_mm.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor_mm);
                        uint prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_1_node_c;
                        prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_1_node_c = candidate_MultipleContainedPackagesOrClasses_iter_1_node_c.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleContainedPackagesOrClasses_iter_1_node_c.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0;
                        prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0 = candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for mm
                        openTasks.Pop();
                        PatternAction_MultipleMethodBodies.releaseTask(taskFor_mm);
                        // Pop subpattern matching task for mv
                        openTasks.Pop();
                        PatternAction_MultipleVariables.releaseTask(taskFor_mv);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_1 match = new Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_1();
                                match._node_c = candidate_MultipleContainedPackagesOrClasses_iter_1_node_c;
                                match._node_p = candidate_MultipleContainedPackagesOrClasses_node_p;
                                match._edge__edge0 = candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0;
                                match._mm = (@Pattern_MultipleMethodBodies.Match_MultipleMethodBodies)currentFoundPartialMatch.Pop();
                                match._mm._matchOfEnclosingPattern = match;
                                match._mv = (@Pattern_MultipleVariables.Match_MultipleVariables)currentFoundPartialMatch.Pop();
                                match._mv._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0;
                                candidate_MultipleContainedPackagesOrClasses_iter_1_node_c.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_1_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_1_node_c;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0;
                            candidate_MultipleContainedPackagesOrClasses_iter_1_node_c.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_1_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_1_node_c;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MultipleContainedPackagesOrClasses_iter_1_node_c.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_1_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_1_node_c;
                        candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspFlags = candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0 = candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0.lgspInNext) != head_candidate_MultipleContainedPackagesOrClasses_iter_1_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_1 match = new Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_1();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_1 match = new Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses_iter_1();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class PatternAction_MultipleVariables : GRGEN_LGSP.LGSPSubpatternAction
    {
        private PatternAction_MultipleVariables(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleVariables.Instance.patternGraph;
        }

        public static PatternAction_MultipleVariables getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            PatternAction_MultipleVariables newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new PatternAction_MultipleVariables(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(PatternAction_MultipleVariables oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static PatternAction_MultipleVariables freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private PatternAction_MultipleVariables next = null;

        public GRGEN_LGSP.LGSPNode MultipleVariables_node_c;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // SubPreset MultipleVariables_node_c 
            GRGEN_LGSP.LGSPNode candidate_MultipleVariables_node_c = MultipleVariables_node_c;
            // Push iterated matching task for MultipleVariables_iter_0
            IteratedAction_MultipleVariables_iter_0 taskFor_iter_0 = IteratedAction_MultipleVariables_iter_0.getNewTask(graph, openTasks);
            taskFor_iter_0.MultipleVariables_node_c = candidate_MultipleVariables_node_c;
            taskFor_iter_0.searchPatternpath = false;
            taskFor_iter_0.matchOfNestingPattern = null;
            taskFor_iter_0.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_0);
            // Match subpatterns 
            openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
            // Pop iterated matching task for MultipleVariables_iter_0
            openTasks.Pop();
            IteratedAction_MultipleVariables_iter_0.releaseTask(taskFor_iter_0);
            // Check whether subpatterns were found 
            if(matchesList.Count>0) {
                // subpatterns/alternatives were found, extend the partial matches by our local match object
                foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                {
                    Pattern_MultipleVariables.Match_MultipleVariables match = new Pattern_MultipleVariables.Match_MultipleVariables();
                    match._node_c = candidate_MultipleVariables_node_c;
                    match._iter_0 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MultipleVariables.Match_MultipleVariables_iter_0, Pattern_MultipleVariables.IMatch_MultipleVariables_iter_0>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MultipleVariables.IMatch_MultipleVariables_iter_0) {
                        Pattern_MultipleVariables.Match_MultipleVariables_iter_0 cfpm = (Pattern_MultipleVariables.Match_MultipleVariables_iter_0)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_0.Add(cfpm);
                    }
                    currentFoundPartialMatch.Push(match);
                }
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
                // if enough matches were found, we leave
                if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                {
                    openTasks.Push(this);
                    return;
                }
                openTasks.Push(this);
                return;
            }
            openTasks.Push(this);
            return;
        }
    }

    public class IteratedAction_MultipleVariables_iter_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MultipleVariables_iter_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleVariables.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 0;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MultipleVariables_iter_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MultipleVariables_iter_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MultipleVariables_iter_0(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MultipleVariables_iter_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MultipleVariables_iter_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MultipleVariables_iter_0 next = null;

        public GRGEN_LGSP.LGSPNode MultipleVariables_node_c;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MultipleVariables_node_c 
                GRGEN_LGSP.LGSPNode candidate_MultipleVariables_node_c = MultipleVariables_node_c;
                // Extend Incoming MultipleVariables_iter_0_edge__edge0 from MultipleVariables_node_c 
                GRGEN_LGSP.LGSPEdge head_candidate_MultipleVariables_iter_0_edge__edge0 = candidate_MultipleVariables_node_c.lgspInhead;
                if(head_candidate_MultipleVariables_iter_0_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MultipleVariables_iter_0_edge__edge0 = head_candidate_MultipleVariables_iter_0_edge__edge0;
                    do
                    {
                        if(candidate_MultipleVariables_iter_0_edge__edge0.lgspType.TypeID!=3) {
                            continue;
                        }
                        if((candidate_MultipleVariables_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Source MultipleVariables_iter_0_node_v from MultipleVariables_iter_0_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MultipleVariables_iter_0_node_v = candidate_MultipleVariables_iter_0_edge__edge0.lgspSource;
                        if(candidate_MultipleVariables_iter_0_node_v.lgspType.TypeID!=5) {
                            continue;
                        }
                        if((candidate_MultipleVariables_iter_0_node_v.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        uint prevGlobal__candidate_MultipleVariables_iter_0_node_v;
                        prevGlobal__candidate_MultipleVariables_iter_0_node_v = candidate_MultipleVariables_iter_0_node_v.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleVariables_iter_0_node_v.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MultipleVariables_iter_0_edge__edge0;
                        prevGlobal__candidate_MultipleVariables_iter_0_edge__edge0 = candidate_MultipleVariables_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleVariables_iter_0_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MultipleVariables.Match_MultipleVariables_iter_0 match = new Pattern_MultipleVariables.Match_MultipleVariables_iter_0();
                                match._node_v = candidate_MultipleVariables_iter_0_node_v;
                                match._node_c = candidate_MultipleVariables_node_c;
                                match._edge__edge0 = candidate_MultipleVariables_iter_0_edge__edge0;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MultipleVariables_iter_0_edge__edge0.lgspFlags = candidate_MultipleVariables_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleVariables_iter_0_edge__edge0;
                                candidate_MultipleVariables_iter_0_node_v.lgspFlags = candidate_MultipleVariables_iter_0_node_v.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleVariables_iter_0_node_v;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MultipleVariables_iter_0_edge__edge0.lgspFlags = candidate_MultipleVariables_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleVariables_iter_0_edge__edge0;
                            candidate_MultipleVariables_iter_0_node_v.lgspFlags = candidate_MultipleVariables_iter_0_node_v.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleVariables_iter_0_node_v;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MultipleVariables_iter_0_node_v.lgspFlags = candidate_MultipleVariables_iter_0_node_v.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleVariables_iter_0_node_v;
                        candidate_MultipleVariables_iter_0_edge__edge0.lgspFlags = candidate_MultipleVariables_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleVariables_iter_0_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MultipleVariables_iter_0_edge__edge0 = candidate_MultipleVariables_iter_0_edge__edge0.lgspInNext) != head_candidate_MultipleVariables_iter_0_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MultipleVariables.Match_MultipleVariables_iter_0 match = new Pattern_MultipleVariables.Match_MultipleVariables_iter_0();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MultipleVariables.Match_MultipleVariables_iter_0 match = new Pattern_MultipleVariables.Match_MultipleVariables_iter_0();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class PatternAction_MultipleMethodBodies : GRGEN_LGSP.LGSPSubpatternAction
    {
        private PatternAction_MultipleMethodBodies(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleMethodBodies.Instance.patternGraph;
        }

        public static PatternAction_MultipleMethodBodies getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            PatternAction_MultipleMethodBodies newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new PatternAction_MultipleMethodBodies(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(PatternAction_MultipleMethodBodies oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static PatternAction_MultipleMethodBodies freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private PatternAction_MultipleMethodBodies next = null;

        public GRGEN_LGSP.LGSPNode MultipleMethodBodies_node_c;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // SubPreset MultipleMethodBodies_node_c 
            GRGEN_LGSP.LGSPNode candidate_MultipleMethodBodies_node_c = MultipleMethodBodies_node_c;
            // Push iterated matching task for MultipleMethodBodies_iter_0
            IteratedAction_MultipleMethodBodies_iter_0 taskFor_iter_0 = IteratedAction_MultipleMethodBodies_iter_0.getNewTask(graph, openTasks);
            taskFor_iter_0.MultipleMethodBodies_node_c = candidate_MultipleMethodBodies_node_c;
            taskFor_iter_0.searchPatternpath = false;
            taskFor_iter_0.matchOfNestingPattern = null;
            taskFor_iter_0.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_0);
            // Match subpatterns 
            openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
            // Pop iterated matching task for MultipleMethodBodies_iter_0
            openTasks.Pop();
            IteratedAction_MultipleMethodBodies_iter_0.releaseTask(taskFor_iter_0);
            // Check whether subpatterns were found 
            if(matchesList.Count>0) {
                // subpatterns/alternatives were found, extend the partial matches by our local match object
                foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                {
                    Pattern_MultipleMethodBodies.Match_MultipleMethodBodies match = new Pattern_MultipleMethodBodies.Match_MultipleMethodBodies();
                    match._node_c = candidate_MultipleMethodBodies_node_c;
                    match._iter_0 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MultipleMethodBodies.Match_MultipleMethodBodies_iter_0, Pattern_MultipleMethodBodies.IMatch_MultipleMethodBodies_iter_0>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MultipleMethodBodies.IMatch_MultipleMethodBodies_iter_0) {
                        Pattern_MultipleMethodBodies.Match_MultipleMethodBodies_iter_0 cfpm = (Pattern_MultipleMethodBodies.Match_MultipleMethodBodies_iter_0)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_0.Add(cfpm);
                    }
                    currentFoundPartialMatch.Push(match);
                }
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
                // if enough matches were found, we leave
                if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                {
                    openTasks.Push(this);
                    return;
                }
                openTasks.Push(this);
                return;
            }
            openTasks.Push(this);
            return;
        }
    }

    public class IteratedAction_MultipleMethodBodies_iter_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MultipleMethodBodies_iter_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleMethodBodies.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 0;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MultipleMethodBodies_iter_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MultipleMethodBodies_iter_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MultipleMethodBodies_iter_0(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MultipleMethodBodies_iter_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MultipleMethodBodies_iter_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MultipleMethodBodies_iter_0 next = null;

        public GRGEN_LGSP.LGSPNode MultipleMethodBodies_node_c;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MultipleMethodBodies_node_c 
                GRGEN_LGSP.LGSPNode candidate_MultipleMethodBodies_node_c = MultipleMethodBodies_node_c;
                // Extend Incoming MultipleMethodBodies_iter_0_edge__edge0 from MultipleMethodBodies_node_c 
                GRGEN_LGSP.LGSPEdge head_candidate_MultipleMethodBodies_iter_0_edge__edge0 = candidate_MultipleMethodBodies_node_c.lgspInhead;
                if(head_candidate_MultipleMethodBodies_iter_0_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MultipleMethodBodies_iter_0_edge__edge0 = head_candidate_MultipleMethodBodies_iter_0_edge__edge0;
                    do
                    {
                        if(candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspType.TypeID!=3) {
                            continue;
                        }
                        if((candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Source MultipleMethodBodies_iter_0_node_mb from MultipleMethodBodies_iter_0_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MultipleMethodBodies_iter_0_node_mb = candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspSource;
                        if(candidate_MultipleMethodBodies_iter_0_node_mb.lgspType.TypeID!=7) {
                            continue;
                        }
                        if((candidate_MultipleMethodBodies_iter_0_node_mb.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        // Push subpattern matching task for bi
                        PatternAction_MethodBodyAndImplementation taskFor_bi = PatternAction_MethodBodyAndImplementation.getNewTask(graph, openTasks);
                        taskFor_bi.MethodBodyAndImplementation_node_mb = candidate_MultipleMethodBodies_iter_0_node_mb;
                        taskFor_bi.searchPatternpath = false;
                        taskFor_bi.matchOfNestingPattern = null;
                        taskFor_bi.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor_bi);
                        uint prevGlobal__candidate_MultipleMethodBodies_iter_0_node_mb;
                        prevGlobal__candidate_MultipleMethodBodies_iter_0_node_mb = candidate_MultipleMethodBodies_iter_0_node_mb.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleMethodBodies_iter_0_node_mb.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MultipleMethodBodies_iter_0_edge__edge0;
                        prevGlobal__candidate_MultipleMethodBodies_iter_0_edge__edge0 = candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for bi
                        openTasks.Pop();
                        PatternAction_MethodBodyAndImplementation.releaseTask(taskFor_bi);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MultipleMethodBodies.Match_MultipleMethodBodies_iter_0 match = new Pattern_MultipleMethodBodies.Match_MultipleMethodBodies_iter_0();
                                match._node_mb = candidate_MultipleMethodBodies_iter_0_node_mb;
                                match._node_c = candidate_MultipleMethodBodies_node_c;
                                match._edge__edge0 = candidate_MultipleMethodBodies_iter_0_edge__edge0;
                                match._bi = (@Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation)currentFoundPartialMatch.Pop();
                                match._bi._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspFlags = candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleMethodBodies_iter_0_edge__edge0;
                                candidate_MultipleMethodBodies_iter_0_node_mb.lgspFlags = candidate_MultipleMethodBodies_iter_0_node_mb.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleMethodBodies_iter_0_node_mb;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspFlags = candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleMethodBodies_iter_0_edge__edge0;
                            candidate_MultipleMethodBodies_iter_0_node_mb.lgspFlags = candidate_MultipleMethodBodies_iter_0_node_mb.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleMethodBodies_iter_0_node_mb;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MultipleMethodBodies_iter_0_node_mb.lgspFlags = candidate_MultipleMethodBodies_iter_0_node_mb.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleMethodBodies_iter_0_node_mb;
                        candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspFlags = candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleMethodBodies_iter_0_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MultipleMethodBodies_iter_0_edge__edge0 = candidate_MultipleMethodBodies_iter_0_edge__edge0.lgspInNext) != head_candidate_MultipleMethodBodies_iter_0_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MultipleMethodBodies.Match_MultipleMethodBodies_iter_0 match = new Pattern_MultipleMethodBodies.Match_MultipleMethodBodies_iter_0();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MultipleMethodBodies.Match_MultipleMethodBodies_iter_0 match = new Pattern_MultipleMethodBodies.Match_MultipleMethodBodies_iter_0();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class PatternAction_MethodBodyAndImplementation : GRGEN_LGSP.LGSPSubpatternAction
    {
        private PatternAction_MethodBodyAndImplementation(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MethodBodyAndImplementation.Instance.patternGraph;
        }

        public static PatternAction_MethodBodyAndImplementation getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            PatternAction_MethodBodyAndImplementation newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new PatternAction_MethodBodyAndImplementation(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(PatternAction_MethodBodyAndImplementation oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static PatternAction_MethodBodyAndImplementation freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private PatternAction_MethodBodyAndImplementation next = null;

        public GRGEN_LGSP.LGSPNode MethodBodyAndImplementation_node_mb;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // SubPreset MethodBodyAndImplementation_node_mb 
            GRGEN_LGSP.LGSPNode candidate_MethodBodyAndImplementation_node_mb = MethodBodyAndImplementation_node_mb;
            // Push iterated matching task for MethodBodyAndImplementation_iter_1
            IteratedAction_MethodBodyAndImplementation_iter_1 taskFor_iter_1 = IteratedAction_MethodBodyAndImplementation_iter_1.getNewTask(graph, openTasks);
            taskFor_iter_1.MethodBodyAndImplementation_node_mb = candidate_MethodBodyAndImplementation_node_mb;
            taskFor_iter_1.searchPatternpath = false;
            taskFor_iter_1.matchOfNestingPattern = null;
            taskFor_iter_1.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_1);
            // Push iterated matching task for MethodBodyAndImplementation_iter_0
            IteratedAction_MethodBodyAndImplementation_iter_0 taskFor_iter_0 = IteratedAction_MethodBodyAndImplementation_iter_0.getNewTask(graph, openTasks);
            taskFor_iter_0.MethodBodyAndImplementation_node_mb = candidate_MethodBodyAndImplementation_node_mb;
            taskFor_iter_0.searchPatternpath = false;
            taskFor_iter_0.matchOfNestingPattern = null;
            taskFor_iter_0.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_0);
            // Match subpatterns 
            openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
            // Pop iterated matching task for MethodBodyAndImplementation_iter_0
            openTasks.Pop();
            IteratedAction_MethodBodyAndImplementation_iter_0.releaseTask(taskFor_iter_0);
            // Pop iterated matching task for MethodBodyAndImplementation_iter_1
            openTasks.Pop();
            IteratedAction_MethodBodyAndImplementation_iter_1.releaseTask(taskFor_iter_1);
            // Check whether subpatterns were found 
            if(matchesList.Count>0) {
                // subpatterns/alternatives were found, extend the partial matches by our local match object
                foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                {
                    Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation match = new Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation();
                    match._node_mb = candidate_MethodBodyAndImplementation_node_mb;
                    match._iter_0 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_0, Pattern_MethodBodyAndImplementation.IMatch_MethodBodyAndImplementation_iter_0>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MethodBodyAndImplementation.IMatch_MethodBodyAndImplementation_iter_0) {
                        Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_0 cfpm = (Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_0)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_0.Add(cfpm);
                    }
                    match._iter_1 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_1, Pattern_MethodBodyAndImplementation.IMatch_MethodBodyAndImplementation_iter_1>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MethodBodyAndImplementation.IMatch_MethodBodyAndImplementation_iter_1) {
                        Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_1 cfpm = (Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_1)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_1.Add(cfpm);
                    }
                    currentFoundPartialMatch.Push(match);
                }
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
                // if enough matches were found, we leave
                if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                {
                    openTasks.Push(this);
                    return;
                }
                openTasks.Push(this);
                return;
            }
            openTasks.Push(this);
            return;
        }
    }

    public class IteratedAction_MethodBodyAndImplementation_iter_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MethodBodyAndImplementation_iter_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MethodBodyAndImplementation.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 1;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MethodBodyAndImplementation_iter_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MethodBodyAndImplementation_iter_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MethodBodyAndImplementation_iter_0(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MethodBodyAndImplementation_iter_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MethodBodyAndImplementation_iter_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MethodBodyAndImplementation_iter_0 next = null;

        public GRGEN_LGSP.LGSPNode MethodBodyAndImplementation_node_mb;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MethodBodyAndImplementation_node_mb 
                GRGEN_LGSP.LGSPNode candidate_MethodBodyAndImplementation_node_mb = MethodBodyAndImplementation_node_mb;
                // Extend Incoming MethodBodyAndImplementation_iter_0_edge__edge0 from MethodBodyAndImplementation_node_mb 
                GRGEN_LGSP.LGSPEdge head_candidate_MethodBodyAndImplementation_iter_0_edge__edge0 = candidate_MethodBodyAndImplementation_node_mb.lgspInhead;
                if(head_candidate_MethodBodyAndImplementation_iter_0_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MethodBodyAndImplementation_iter_0_edge__edge0 = head_candidate_MethodBodyAndImplementation_iter_0_edge__edge0;
                    do
                    {
                        if(candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspType.TypeID!=10) {
                            continue;
                        }
                        if((candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Source MethodBodyAndImplementation_iter_0_node_op from MethodBodyAndImplementation_iter_0_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MethodBodyAndImplementation_iter_0_node_op = candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspSource;
                        if(candidate_MethodBodyAndImplementation_iter_0_node_op.lgspType.TypeID!=6) {
                            continue;
                        }
                        if((candidate_MethodBodyAndImplementation_iter_0_node_op.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        // Push subpattern matching task for _sub0
                        PatternAction_MultipleParameters taskFor__sub0 = PatternAction_MultipleParameters.getNewTask(graph, openTasks);
                        taskFor__sub0.MultipleParameters_node_op = candidate_MethodBodyAndImplementation_iter_0_node_op;
                        taskFor__sub0.searchPatternpath = false;
                        taskFor__sub0.matchOfNestingPattern = null;
                        taskFor__sub0.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor__sub0);
                        uint prevGlobal__candidate_MethodBodyAndImplementation_iter_0_node_op;
                        prevGlobal__candidate_MethodBodyAndImplementation_iter_0_node_op = candidate_MethodBodyAndImplementation_iter_0_node_op.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MethodBodyAndImplementation_iter_0_node_op.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MethodBodyAndImplementation_iter_0_edge__edge0;
                        prevGlobal__candidate_MethodBodyAndImplementation_iter_0_edge__edge0 = candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for _sub0
                        openTasks.Pop();
                        PatternAction_MultipleParameters.releaseTask(taskFor__sub0);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_0 match = new Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_0();
                                match._node_op = candidate_MethodBodyAndImplementation_iter_0_node_op;
                                match._node_mb = candidate_MethodBodyAndImplementation_node_mb;
                                match._edge__edge0 = candidate_MethodBodyAndImplementation_iter_0_edge__edge0;
                                match.__sub0 = (@Pattern_MultipleParameters.Match_MultipleParameters)currentFoundPartialMatch.Pop();
                                match.__sub0._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspFlags = candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_0_edge__edge0;
                                candidate_MethodBodyAndImplementation_iter_0_node_op.lgspFlags = candidate_MethodBodyAndImplementation_iter_0_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_0_node_op;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspFlags = candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_0_edge__edge0;
                            candidate_MethodBodyAndImplementation_iter_0_node_op.lgspFlags = candidate_MethodBodyAndImplementation_iter_0_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_0_node_op;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MethodBodyAndImplementation_iter_0_node_op.lgspFlags = candidate_MethodBodyAndImplementation_iter_0_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_0_node_op;
                        candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspFlags = candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_0_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MethodBodyAndImplementation_iter_0_edge__edge0 = candidate_MethodBodyAndImplementation_iter_0_edge__edge0.lgspInNext) != head_candidate_MethodBodyAndImplementation_iter_0_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_0 match = new Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_0();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_0 match = new Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_0();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class IteratedAction_MethodBodyAndImplementation_iter_1 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MethodBodyAndImplementation_iter_1(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MethodBodyAndImplementation.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 1;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MethodBodyAndImplementation_iter_1 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MethodBodyAndImplementation_iter_1 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MethodBodyAndImplementation_iter_1(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MethodBodyAndImplementation_iter_1 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MethodBodyAndImplementation_iter_1 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MethodBodyAndImplementation_iter_1 next = null;

        public GRGEN_LGSP.LGSPNode MethodBodyAndImplementation_node_mb;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MethodBodyAndImplementation_node_mb 
                GRGEN_LGSP.LGSPNode candidate_MethodBodyAndImplementation_node_mb = MethodBodyAndImplementation_node_mb;
                // Extend Incoming MethodBodyAndImplementation_iter_1_edge__edge0 from MethodBodyAndImplementation_node_mb 
                GRGEN_LGSP.LGSPEdge head_candidate_MethodBodyAndImplementation_iter_1_edge__edge0 = candidate_MethodBodyAndImplementation_node_mb.lgspInhead;
                if(head_candidate_MethodBodyAndImplementation_iter_1_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MethodBodyAndImplementation_iter_1_edge__edge0 = head_candidate_MethodBodyAndImplementation_iter_1_edge__edge0;
                    do
                    {
                        if(candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspType.TypeID!=3) {
                            continue;
                        }
                        if((candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Source MethodBodyAndImplementation_iter_1_node_b from MethodBodyAndImplementation_iter_1_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MethodBodyAndImplementation_iter_1_node_b = candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspSource;
                        if(candidate_MethodBodyAndImplementation_iter_1_node_b.lgspType.TypeID!=15) {
                            continue;
                        }
                        if((candidate_MethodBodyAndImplementation_iter_1_node_b.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        // Push subpattern matching task for me
                        PatternAction_MultipleExpressions taskFor_me = PatternAction_MultipleExpressions.getNewTask(graph, openTasks);
                        taskFor_me.MultipleExpressions_node_b = candidate_MethodBodyAndImplementation_iter_1_node_b;
                        taskFor_me.searchPatternpath = false;
                        taskFor_me.matchOfNestingPattern = null;
                        taskFor_me.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor_me);
                        uint prevGlobal__candidate_MethodBodyAndImplementation_iter_1_node_b;
                        prevGlobal__candidate_MethodBodyAndImplementation_iter_1_node_b = candidate_MethodBodyAndImplementation_iter_1_node_b.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MethodBodyAndImplementation_iter_1_node_b.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MethodBodyAndImplementation_iter_1_edge__edge0;
                        prevGlobal__candidate_MethodBodyAndImplementation_iter_1_edge__edge0 = candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for me
                        openTasks.Pop();
                        PatternAction_MultipleExpressions.releaseTask(taskFor_me);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_1 match = new Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_1();
                                match._node_b = candidate_MethodBodyAndImplementation_iter_1_node_b;
                                match._node_mb = candidate_MethodBodyAndImplementation_node_mb;
                                match._edge__edge0 = candidate_MethodBodyAndImplementation_iter_1_edge__edge0;
                                match._me = (@Pattern_MultipleExpressions.Match_MultipleExpressions)currentFoundPartialMatch.Pop();
                                match._me._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspFlags = candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_1_edge__edge0;
                                candidate_MethodBodyAndImplementation_iter_1_node_b.lgspFlags = candidate_MethodBodyAndImplementation_iter_1_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_1_node_b;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspFlags = candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_1_edge__edge0;
                            candidate_MethodBodyAndImplementation_iter_1_node_b.lgspFlags = candidate_MethodBodyAndImplementation_iter_1_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_1_node_b;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MethodBodyAndImplementation_iter_1_node_b.lgspFlags = candidate_MethodBodyAndImplementation_iter_1_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_1_node_b;
                        candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspFlags = candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MethodBodyAndImplementation_iter_1_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MethodBodyAndImplementation_iter_1_edge__edge0 = candidate_MethodBodyAndImplementation_iter_1_edge__edge0.lgspInNext) != head_candidate_MethodBodyAndImplementation_iter_1_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_1 match = new Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_1();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_1 match = new Pattern_MethodBodyAndImplementation.Match_MethodBodyAndImplementation_iter_1();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class PatternAction_MultipleParameters : GRGEN_LGSP.LGSPSubpatternAction
    {
        private PatternAction_MultipleParameters(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleParameters.Instance.patternGraph;
        }

        public static PatternAction_MultipleParameters getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            PatternAction_MultipleParameters newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new PatternAction_MultipleParameters(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(PatternAction_MultipleParameters oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static PatternAction_MultipleParameters freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private PatternAction_MultipleParameters next = null;

        public GRGEN_LGSP.LGSPNode MultipleParameters_node_op;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // SubPreset MultipleParameters_node_op 
            GRGEN_LGSP.LGSPNode candidate_MultipleParameters_node_op = MultipleParameters_node_op;
            // Push iterated matching task for MultipleParameters_iter_0
            IteratedAction_MultipleParameters_iter_0 taskFor_iter_0 = IteratedAction_MultipleParameters_iter_0.getNewTask(graph, openTasks);
            taskFor_iter_0.MultipleParameters_node_op = candidate_MultipleParameters_node_op;
            taskFor_iter_0.searchPatternpath = false;
            taskFor_iter_0.matchOfNestingPattern = null;
            taskFor_iter_0.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_0);
            // Match subpatterns 
            openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
            // Pop iterated matching task for MultipleParameters_iter_0
            openTasks.Pop();
            IteratedAction_MultipleParameters_iter_0.releaseTask(taskFor_iter_0);
            // Check whether subpatterns were found 
            if(matchesList.Count>0) {
                // subpatterns/alternatives were found, extend the partial matches by our local match object
                foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                {
                    Pattern_MultipleParameters.Match_MultipleParameters match = new Pattern_MultipleParameters.Match_MultipleParameters();
                    match._node_op = candidate_MultipleParameters_node_op;
                    match._iter_0 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MultipleParameters.Match_MultipleParameters_iter_0, Pattern_MultipleParameters.IMatch_MultipleParameters_iter_0>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MultipleParameters.IMatch_MultipleParameters_iter_0) {
                        Pattern_MultipleParameters.Match_MultipleParameters_iter_0 cfpm = (Pattern_MultipleParameters.Match_MultipleParameters_iter_0)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_0.Add(cfpm);
                    }
                    currentFoundPartialMatch.Push(match);
                }
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
                // if enough matches were found, we leave
                if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                {
                    openTasks.Push(this);
                    return;
                }
                openTasks.Push(this);
                return;
            }
            openTasks.Push(this);
            return;
        }
    }

    public class IteratedAction_MultipleParameters_iter_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MultipleParameters_iter_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleParameters.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 0;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MultipleParameters_iter_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MultipleParameters_iter_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MultipleParameters_iter_0(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MultipleParameters_iter_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MultipleParameters_iter_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MultipleParameters_iter_0 next = null;

        public GRGEN_LGSP.LGSPNode MultipleParameters_node_op;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MultipleParameters_node_op 
                GRGEN_LGSP.LGSPNode candidate_MultipleParameters_node_op = MultipleParameters_node_op;
                // Extend Outgoing MultipleParameters_iter_0_edge__edge0 from MultipleParameters_node_op 
                GRGEN_LGSP.LGSPEdge head_candidate_MultipleParameters_iter_0_edge__edge0 = candidate_MultipleParameters_node_op.lgspOuthead;
                if(head_candidate_MultipleParameters_iter_0_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MultipleParameters_iter_0_edge__edge0 = head_candidate_MultipleParameters_iter_0_edge__edge0;
                    do
                    {
                        if(candidate_MultipleParameters_iter_0_edge__edge0.lgspType.TypeID!=8) {
                            continue;
                        }
                        if((candidate_MultipleParameters_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Target MultipleParameters_iter_0_node__node0 from MultipleParameters_iter_0_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MultipleParameters_iter_0_node__node0 = candidate_MultipleParameters_iter_0_edge__edge0.lgspTarget;
                        if(candidate_MultipleParameters_iter_0_node__node0.lgspType.TypeID!=17) {
                            continue;
                        }
                        if((candidate_MultipleParameters_iter_0_node__node0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        uint prevGlobal__candidate_MultipleParameters_iter_0_node__node0;
                        prevGlobal__candidate_MultipleParameters_iter_0_node__node0 = candidate_MultipleParameters_iter_0_node__node0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleParameters_iter_0_node__node0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MultipleParameters_iter_0_edge__edge0;
                        prevGlobal__candidate_MultipleParameters_iter_0_edge__edge0 = candidate_MultipleParameters_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleParameters_iter_0_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MultipleParameters.Match_MultipleParameters_iter_0 match = new Pattern_MultipleParameters.Match_MultipleParameters_iter_0();
                                match._node_op = candidate_MultipleParameters_node_op;
                                match._node__node0 = candidate_MultipleParameters_iter_0_node__node0;
                                match._edge__edge0 = candidate_MultipleParameters_iter_0_edge__edge0;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MultipleParameters_iter_0_edge__edge0.lgspFlags = candidate_MultipleParameters_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleParameters_iter_0_edge__edge0;
                                candidate_MultipleParameters_iter_0_node__node0.lgspFlags = candidate_MultipleParameters_iter_0_node__node0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleParameters_iter_0_node__node0;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MultipleParameters_iter_0_edge__edge0.lgspFlags = candidate_MultipleParameters_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleParameters_iter_0_edge__edge0;
                            candidate_MultipleParameters_iter_0_node__node0.lgspFlags = candidate_MultipleParameters_iter_0_node__node0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleParameters_iter_0_node__node0;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MultipleParameters_iter_0_node__node0.lgspFlags = candidate_MultipleParameters_iter_0_node__node0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleParameters_iter_0_node__node0;
                        candidate_MultipleParameters_iter_0_edge__edge0.lgspFlags = candidate_MultipleParameters_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleParameters_iter_0_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MultipleParameters_iter_0_edge__edge0 = candidate_MultipleParameters_iter_0_edge__edge0.lgspOutNext) != head_candidate_MultipleParameters_iter_0_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MultipleParameters.Match_MultipleParameters_iter_0 match = new Pattern_MultipleParameters.Match_MultipleParameters_iter_0();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MultipleParameters.Match_MultipleParameters_iter_0 match = new Pattern_MultipleParameters.Match_MultipleParameters_iter_0();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class PatternAction_MultipleExpressions : GRGEN_LGSP.LGSPSubpatternAction
    {
        private PatternAction_MultipleExpressions(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleExpressions.Instance.patternGraph;
        }

        public static PatternAction_MultipleExpressions getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            PatternAction_MultipleExpressions newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new PatternAction_MultipleExpressions(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(PatternAction_MultipleExpressions oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static PatternAction_MultipleExpressions freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private PatternAction_MultipleExpressions next = null;

        public GRGEN_LGSP.LGSPNode MultipleExpressions_node_b;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // SubPreset MultipleExpressions_node_b 
            GRGEN_LGSP.LGSPNode candidate_MultipleExpressions_node_b = MultipleExpressions_node_b;
            // Push iterated matching task for MultipleExpressions_iter_1
            IteratedAction_MultipleExpressions_iter_1 taskFor_iter_1 = IteratedAction_MultipleExpressions_iter_1.getNewTask(graph, openTasks);
            taskFor_iter_1.MultipleExpressions_node_b = candidate_MultipleExpressions_node_b;
            taskFor_iter_1.searchPatternpath = false;
            taskFor_iter_1.matchOfNestingPattern = null;
            taskFor_iter_1.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_1);
            // Push iterated matching task for MultipleExpressions_iter_0
            IteratedAction_MultipleExpressions_iter_0 taskFor_iter_0 = IteratedAction_MultipleExpressions_iter_0.getNewTask(graph, openTasks);
            taskFor_iter_0.MultipleExpressions_node_b = candidate_MultipleExpressions_node_b;
            taskFor_iter_0.searchPatternpath = false;
            taskFor_iter_0.matchOfNestingPattern = null;
            taskFor_iter_0.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_0);
            // Match subpatterns 
            openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
            // Pop iterated matching task for MultipleExpressions_iter_0
            openTasks.Pop();
            IteratedAction_MultipleExpressions_iter_0.releaseTask(taskFor_iter_0);
            // Pop iterated matching task for MultipleExpressions_iter_1
            openTasks.Pop();
            IteratedAction_MultipleExpressions_iter_1.releaseTask(taskFor_iter_1);
            // Check whether subpatterns were found 
            if(matchesList.Count>0) {
                // subpatterns/alternatives were found, extend the partial matches by our local match object
                foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                {
                    Pattern_MultipleExpressions.Match_MultipleExpressions match = new Pattern_MultipleExpressions.Match_MultipleExpressions();
                    match._node_b = candidate_MultipleExpressions_node_b;
                    match._iter_0 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MultipleExpressions.Match_MultipleExpressions_iter_0, Pattern_MultipleExpressions.IMatch_MultipleExpressions_iter_0>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MultipleExpressions.IMatch_MultipleExpressions_iter_0) {
                        Pattern_MultipleExpressions.Match_MultipleExpressions_iter_0 cfpm = (Pattern_MultipleExpressions.Match_MultipleExpressions_iter_0)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_0.Add(cfpm);
                    }
                    match._iter_1 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MultipleExpressions.Match_MultipleExpressions_iter_1, Pattern_MultipleExpressions.IMatch_MultipleExpressions_iter_1>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MultipleExpressions.IMatch_MultipleExpressions_iter_1) {
                        Pattern_MultipleExpressions.Match_MultipleExpressions_iter_1 cfpm = (Pattern_MultipleExpressions.Match_MultipleExpressions_iter_1)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_1.Add(cfpm);
                    }
                    currentFoundPartialMatch.Push(match);
                }
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
                // if enough matches were found, we leave
                if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                {
                    openTasks.Push(this);
                    return;
                }
                openTasks.Push(this);
                return;
            }
            openTasks.Push(this);
            return;
        }
    }

    public class IteratedAction_MultipleExpressions_iter_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MultipleExpressions_iter_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleExpressions.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 0;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MultipleExpressions_iter_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MultipleExpressions_iter_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MultipleExpressions_iter_0(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MultipleExpressions_iter_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MultipleExpressions_iter_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MultipleExpressions_iter_0 next = null;

        public GRGEN_LGSP.LGSPNode MultipleExpressions_node_b;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MultipleExpressions_node_b 
                GRGEN_LGSP.LGSPNode candidate_MultipleExpressions_node_b = MultipleExpressions_node_b;
                // Extend Outgoing MultipleExpressions_iter_0_edge__edge0 from MultipleExpressions_node_b 
                GRGEN_LGSP.LGSPEdge head_candidate_MultipleExpressions_iter_0_edge__edge0 = candidate_MultipleExpressions_node_b.lgspOuthead;
                if(head_candidate_MultipleExpressions_iter_0_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MultipleExpressions_iter_0_edge__edge0 = head_candidate_MultipleExpressions_iter_0_edge__edge0;
                    do
                    {
                        if(candidate_MultipleExpressions_iter_0_edge__edge0.lgspType.TypeID!=12) {
                            continue;
                        }
                        if((candidate_MultipleExpressions_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Target MultipleExpressions_iter_0_node_next from MultipleExpressions_iter_0_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MultipleExpressions_iter_0_node_next = candidate_MultipleExpressions_iter_0_edge__edge0.lgspTarget;
                        if(!Pattern_MultipleExpressions.MultipleExpressions_iter_0_node_next_IsAllowedType[candidate_MultipleExpressions_iter_0_node_next.lgspType.TypeID]) {
                            continue;
                        }
                        if((candidate_MultipleExpressions_iter_0_node_next.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        if((candidate_MultipleExpressions_iter_0_node_next.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        // Push subpattern matching task for ec
                        PatternAction_ExpressionChain taskFor_ec = PatternAction_ExpressionChain.getNewTask(graph, openTasks);
                        taskFor_ec.ExpressionChain_node_e = candidate_MultipleExpressions_iter_0_node_next;
                        taskFor_ec.searchPatternpath = false;
                        taskFor_ec.matchOfNestingPattern = null;
                        taskFor_ec.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor_ec);
                        uint prevGlobal__candidate_MultipleExpressions_iter_0_node_next;
                        prevGlobal__candidate_MultipleExpressions_iter_0_node_next = candidate_MultipleExpressions_iter_0_node_next.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleExpressions_iter_0_node_next.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MultipleExpressions_iter_0_edge__edge0;
                        prevGlobal__candidate_MultipleExpressions_iter_0_edge__edge0 = candidate_MultipleExpressions_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleExpressions_iter_0_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for ec
                        openTasks.Pop();
                        PatternAction_ExpressionChain.releaseTask(taskFor_ec);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MultipleExpressions.Match_MultipleExpressions_iter_0 match = new Pattern_MultipleExpressions.Match_MultipleExpressions_iter_0();
                                match._node_b = candidate_MultipleExpressions_node_b;
                                match._node_next = candidate_MultipleExpressions_iter_0_node_next;
                                match._edge__edge0 = candidate_MultipleExpressions_iter_0_edge__edge0;
                                match._ec = (@Pattern_ExpressionChain.Match_ExpressionChain)currentFoundPartialMatch.Pop();
                                match._ec._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MultipleExpressions_iter_0_edge__edge0.lgspFlags = candidate_MultipleExpressions_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_0_edge__edge0;
                                candidate_MultipleExpressions_iter_0_node_next.lgspFlags = candidate_MultipleExpressions_iter_0_node_next.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_0_node_next;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MultipleExpressions_iter_0_edge__edge0.lgspFlags = candidate_MultipleExpressions_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_0_edge__edge0;
                            candidate_MultipleExpressions_iter_0_node_next.lgspFlags = candidate_MultipleExpressions_iter_0_node_next.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_0_node_next;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MultipleExpressions_iter_0_node_next.lgspFlags = candidate_MultipleExpressions_iter_0_node_next.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_0_node_next;
                        candidate_MultipleExpressions_iter_0_edge__edge0.lgspFlags = candidate_MultipleExpressions_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_0_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MultipleExpressions_iter_0_edge__edge0 = candidate_MultipleExpressions_iter_0_edge__edge0.lgspOutNext) != head_candidate_MultipleExpressions_iter_0_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MultipleExpressions.Match_MultipleExpressions_iter_0 match = new Pattern_MultipleExpressions.Match_MultipleExpressions_iter_0();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MultipleExpressions.Match_MultipleExpressions_iter_0 match = new Pattern_MultipleExpressions.Match_MultipleExpressions_iter_0();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class IteratedAction_MultipleExpressions_iter_1 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MultipleExpressions_iter_1(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleExpressions.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 0;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MultipleExpressions_iter_1 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MultipleExpressions_iter_1 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MultipleExpressions_iter_1(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MultipleExpressions_iter_1 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MultipleExpressions_iter_1 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MultipleExpressions_iter_1 next = null;

        public GRGEN_LGSP.LGSPNode MultipleExpressions_node_b;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MultipleExpressions_node_b 
                GRGEN_LGSP.LGSPNode candidate_MultipleExpressions_node_b = MultipleExpressions_node_b;
                // Extend Outgoing MultipleExpressions_iter_1_edge__edge0 from MultipleExpressions_node_b 
                GRGEN_LGSP.LGSPEdge head_candidate_MultipleExpressions_iter_1_edge__edge0 = candidate_MultipleExpressions_node_b.lgspOuthead;
                if(head_candidate_MultipleExpressions_iter_1_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MultipleExpressions_iter_1_edge__edge0 = head_candidate_MultipleExpressions_iter_1_edge__edge0;
                    do
                    {
                        if(candidate_MultipleExpressions_iter_1_edge__edge0.lgspType.TypeID!=12) {
                            continue;
                        }
                        if((candidate_MultipleExpressions_iter_1_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Target MultipleExpressions_iter_1_node_call from MultipleExpressions_iter_1_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MultipleExpressions_iter_1_node_call = candidate_MultipleExpressions_iter_1_edge__edge0.lgspTarget;
                        if(candidate_MultipleExpressions_iter_1_node_call.lgspType.TypeID!=11) {
                            continue;
                        }
                        if((candidate_MultipleExpressions_iter_1_node_call.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        // Push subpattern matching task for _sub0
                        PatternAction_MultipleActualParameters taskFor__sub0 = PatternAction_MultipleActualParameters.getNewTask(graph, openTasks);
                        taskFor__sub0.MultipleActualParameters_node_c = candidate_MultipleExpressions_iter_1_node_call;
                        taskFor__sub0.searchPatternpath = false;
                        taskFor__sub0.matchOfNestingPattern = null;
                        taskFor__sub0.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor__sub0);
                        // Push subpattern matching task for ec
                        PatternAction_ExpressionChain taskFor_ec = PatternAction_ExpressionChain.getNewTask(graph, openTasks);
                        taskFor_ec.ExpressionChain_node_e = candidate_MultipleExpressions_iter_1_node_call;
                        taskFor_ec.searchPatternpath = false;
                        taskFor_ec.matchOfNestingPattern = null;
                        taskFor_ec.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor_ec);
                        uint prevGlobal__candidate_MultipleExpressions_iter_1_node_call;
                        prevGlobal__candidate_MultipleExpressions_iter_1_node_call = candidate_MultipleExpressions_iter_1_node_call.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleExpressions_iter_1_node_call.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MultipleExpressions_iter_1_edge__edge0;
                        prevGlobal__candidate_MultipleExpressions_iter_1_edge__edge0 = candidate_MultipleExpressions_iter_1_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleExpressions_iter_1_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for ec
                        openTasks.Pop();
                        PatternAction_ExpressionChain.releaseTask(taskFor_ec);
                        // Pop subpattern matching task for _sub0
                        openTasks.Pop();
                        PatternAction_MultipleActualParameters.releaseTask(taskFor__sub0);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MultipleExpressions.Match_MultipleExpressions_iter_1 match = new Pattern_MultipleExpressions.Match_MultipleExpressions_iter_1();
                                match._node_b = candidate_MultipleExpressions_node_b;
                                match._node_call = candidate_MultipleExpressions_iter_1_node_call;
                                match._edge__edge0 = candidate_MultipleExpressions_iter_1_edge__edge0;
                                match._ec = (@Pattern_ExpressionChain.Match_ExpressionChain)currentFoundPartialMatch.Pop();
                                match._ec._matchOfEnclosingPattern = match;
                                match.__sub0 = (@Pattern_MultipleActualParameters.Match_MultipleActualParameters)currentFoundPartialMatch.Pop();
                                match.__sub0._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MultipleExpressions_iter_1_edge__edge0.lgspFlags = candidate_MultipleExpressions_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_1_edge__edge0;
                                candidate_MultipleExpressions_iter_1_node_call.lgspFlags = candidate_MultipleExpressions_iter_1_node_call.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_1_node_call;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MultipleExpressions_iter_1_edge__edge0.lgspFlags = candidate_MultipleExpressions_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_1_edge__edge0;
                            candidate_MultipleExpressions_iter_1_node_call.lgspFlags = candidate_MultipleExpressions_iter_1_node_call.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_1_node_call;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MultipleExpressions_iter_1_node_call.lgspFlags = candidate_MultipleExpressions_iter_1_node_call.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_1_node_call;
                        candidate_MultipleExpressions_iter_1_edge__edge0.lgspFlags = candidate_MultipleExpressions_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExpressions_iter_1_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MultipleExpressions_iter_1_edge__edge0 = candidate_MultipleExpressions_iter_1_edge__edge0.lgspOutNext) != head_candidate_MultipleExpressions_iter_1_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MultipleExpressions.Match_MultipleExpressions_iter_1 match = new Pattern_MultipleExpressions.Match_MultipleExpressions_iter_1();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MultipleExpressions.Match_MultipleExpressions_iter_1 match = new Pattern_MultipleExpressions.Match_MultipleExpressions_iter_1();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class PatternAction_ExpressionChain : GRGEN_LGSP.LGSPSubpatternAction
    {
        private PatternAction_ExpressionChain(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_ExpressionChain.Instance.patternGraph;
        }

        public static PatternAction_ExpressionChain getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            PatternAction_ExpressionChain newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new PatternAction_ExpressionChain(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(PatternAction_ExpressionChain oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static PatternAction_ExpressionChain freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private PatternAction_ExpressionChain next = null;

        public GRGEN_LGSP.LGSPNode ExpressionChain_node_e;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // SubPreset ExpressionChain_node_e 
            GRGEN_LGSP.LGSPNode candidate_ExpressionChain_node_e = ExpressionChain_node_e;
            // Push alternative matching task for ExpressionChain_alt_0
            AlternativeAction_ExpressionChain_alt_0 taskFor_alt_0 = AlternativeAction_ExpressionChain_alt_0.getNewTask(graph, openTasks, Pattern_ExpressionChain.Instance.patternGraph.alternatives[(int)Pattern_ExpressionChain.ExpressionChain_AltNums.@alt_0].alternativeCases);
            taskFor_alt_0.ExpressionChain_node_e = candidate_ExpressionChain_node_e;
            taskFor_alt_0.searchPatternpath = false;
            taskFor_alt_0.matchOfNestingPattern = null;
            taskFor_alt_0.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_alt_0);
            // Match subpatterns 
            openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
            // Pop alternative matching task for ExpressionChain_alt_0
            openTasks.Pop();
            AlternativeAction_ExpressionChain_alt_0.releaseTask(taskFor_alt_0);
            // Check whether subpatterns were found 
            if(matchesList.Count>0) {
                // subpatterns/alternatives were found, extend the partial matches by our local match object
                foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                {
                    Pattern_ExpressionChain.Match_ExpressionChain match = new Pattern_ExpressionChain.Match_ExpressionChain();
                    match._node_e = candidate_ExpressionChain_node_e;
                    match._alt_0 = (Pattern_ExpressionChain.IMatch_ExpressionChain_alt_0)currentFoundPartialMatch.Pop();
                    match._alt_0.SetMatchOfEnclosingPattern(match);
                    currentFoundPartialMatch.Push(match);
                }
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
                // if enough matches were found, we leave
                if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                {
                    openTasks.Push(this);
                    return;
                }
                openTasks.Push(this);
                return;
            }
            openTasks.Push(this);
            return;
        }
    }

    public class AlternativeAction_ExpressionChain_alt_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private AlternativeAction_ExpressionChain_alt_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_, GRGEN_LGSP.PatternGraph[] patternGraphs_) {
            graph = graph_; openTasks = openTasks_;
            patternGraphs = patternGraphs_;
        }

        public static AlternativeAction_ExpressionChain_alt_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_, GRGEN_LGSP.PatternGraph[] patternGraphs_) {
            AlternativeAction_ExpressionChain_alt_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                newTask.patternGraphs = patternGraphs_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new AlternativeAction_ExpressionChain_alt_0(graph_, openTasks_, patternGraphs_);
            }
            return newTask;
        }

        public static void releaseTask(AlternativeAction_ExpressionChain_alt_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static AlternativeAction_ExpressionChain_alt_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private AlternativeAction_ExpressionChain_alt_0 next = null;

        public GRGEN_LGSP.LGSPNode ExpressionChain_node_e;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // Alternative case ExpressionChain_alt_0_ExprAndAgain 
            do {
                patternGraph = patternGraphs[(int)Pattern_ExpressionChain.ExpressionChain_alt_0_CaseNums.@ExprAndAgain];
                // SubPreset ExpressionChain_node_e 
                GRGEN_LGSP.LGSPNode candidate_ExpressionChain_node_e = ExpressionChain_node_e;
                // Extend Outgoing ExpressionChain_alt_0_ExprAndAgain_edge__edge0 from ExpressionChain_node_e 
                GRGEN_LGSP.LGSPEdge head_candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0 = candidate_ExpressionChain_node_e.lgspOuthead;
                if(head_candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0 = head_candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0;
                    do
                    {
                        if(candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspType.TypeID!=12) {
                            continue;
                        }
                        if((candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Target ExpressionChain_alt_0_ExprAndAgain_node_next from ExpressionChain_alt_0_ExprAndAgain_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_ExpressionChain_alt_0_ExprAndAgain_node_next = candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspTarget;
                        if(!Pattern_ExpressionChain.ExpressionChain_alt_0_ExprAndAgain_node_next_IsAllowedType[candidate_ExpressionChain_alt_0_ExprAndAgain_node_next.lgspType.TypeID]) {
                            continue;
                        }
                        if((candidate_ExpressionChain_alt_0_ExprAndAgain_node_next.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        if((candidate_ExpressionChain_alt_0_ExprAndAgain_node_next.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Push subpattern matching task for ec
                        PatternAction_ExpressionChain taskFor_ec = PatternAction_ExpressionChain.getNewTask(graph, openTasks);
                        taskFor_ec.ExpressionChain_node_e = candidate_ExpressionChain_alt_0_ExprAndAgain_node_next;
                        taskFor_ec.searchPatternpath = false;
                        taskFor_ec.matchOfNestingPattern = null;
                        taskFor_ec.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor_ec);
                        uint prevGlobal__candidate_ExpressionChain_alt_0_ExprAndAgain_node_next;
                        prevGlobal__candidate_ExpressionChain_alt_0_ExprAndAgain_node_next = candidate_ExpressionChain_alt_0_ExprAndAgain_node_next.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_ExpressionChain_alt_0_ExprAndAgain_node_next.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0;
                        prevGlobal__candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0 = candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for ec
                        openTasks.Pop();
                        PatternAction_ExpressionChain.releaseTask(taskFor_ec);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_ExpressionChain.Match_ExpressionChain_alt_0_ExprAndAgain match = new Pattern_ExpressionChain.Match_ExpressionChain_alt_0_ExprAndAgain();
                                match._node_e = candidate_ExpressionChain_node_e;
                                match._node_next = candidate_ExpressionChain_alt_0_ExprAndAgain_node_next;
                                match._edge__edge0 = candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0;
                                match._ec = (@Pattern_ExpressionChain.Match_ExpressionChain)currentFoundPartialMatch.Pop();
                                match._ec._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            if(matchesList==foundPartialMatches) {
                                matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                            } else {
                                foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                                    foundPartialMatches.Add(match);
                                }
                                matchesList.Clear();
                            }
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                            {
                                candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspFlags = candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0;
                                candidate_ExpressionChain_alt_0_ExprAndAgain_node_next.lgspFlags = candidate_ExpressionChain_alt_0_ExprAndAgain_node_next.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_ExprAndAgain_node_next;
                                openTasks.Push(this);
                                return;
                            }
                            candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspFlags = candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0;
                            candidate_ExpressionChain_alt_0_ExprAndAgain_node_next.lgspFlags = candidate_ExpressionChain_alt_0_ExprAndAgain_node_next.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_ExprAndAgain_node_next;
                            continue;
                        }
                        candidate_ExpressionChain_alt_0_ExprAndAgain_node_next.lgspFlags = candidate_ExpressionChain_alt_0_ExprAndAgain_node_next.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_ExprAndAgain_node_next;
                        candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspFlags = candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0;
                    }
                    while( (candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0 = candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0.lgspOutNext) != head_candidate_ExpressionChain_alt_0_ExprAndAgain_edge__edge0 );
                }
            } while(false);
            if(matchesList.Count>0) {
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
            }
            // Alternative case ExpressionChain_alt_0_CallAndAgain 
            do {
                patternGraph = patternGraphs[(int)Pattern_ExpressionChain.ExpressionChain_alt_0_CaseNums.@CallAndAgain];
                // SubPreset ExpressionChain_node_e 
                GRGEN_LGSP.LGSPNode candidate_ExpressionChain_node_e = ExpressionChain_node_e;
                // Extend Outgoing ExpressionChain_alt_0_CallAndAgain_edge__edge0 from ExpressionChain_node_e 
                GRGEN_LGSP.LGSPEdge head_candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0 = candidate_ExpressionChain_node_e.lgspOuthead;
                if(head_candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0 = head_candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0;
                    do
                    {
                        if(candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspType.TypeID!=12) {
                            continue;
                        }
                        if((candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Target ExpressionChain_alt_0_CallAndAgain_node_call from ExpressionChain_alt_0_CallAndAgain_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_ExpressionChain_alt_0_CallAndAgain_node_call = candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspTarget;
                        if(candidate_ExpressionChain_alt_0_CallAndAgain_node_call.lgspType.TypeID!=11) {
                            continue;
                        }
                        if((candidate_ExpressionChain_alt_0_CallAndAgain_node_call.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        if((candidate_ExpressionChain_alt_0_CallAndAgain_node_call.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Push subpattern matching task for _sub0
                        PatternAction_MultipleActualParameters taskFor__sub0 = PatternAction_MultipleActualParameters.getNewTask(graph, openTasks);
                        taskFor__sub0.MultipleActualParameters_node_c = candidate_ExpressionChain_alt_0_CallAndAgain_node_call;
                        taskFor__sub0.searchPatternpath = false;
                        taskFor__sub0.matchOfNestingPattern = null;
                        taskFor__sub0.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor__sub0);
                        // Push subpattern matching task for ec
                        PatternAction_ExpressionChain taskFor_ec = PatternAction_ExpressionChain.getNewTask(graph, openTasks);
                        taskFor_ec.ExpressionChain_node_e = candidate_ExpressionChain_alt_0_CallAndAgain_node_call;
                        taskFor_ec.searchPatternpath = false;
                        taskFor_ec.matchOfNestingPattern = null;
                        taskFor_ec.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor_ec);
                        uint prevGlobal__candidate_ExpressionChain_alt_0_CallAndAgain_node_call;
                        prevGlobal__candidate_ExpressionChain_alt_0_CallAndAgain_node_call = candidate_ExpressionChain_alt_0_CallAndAgain_node_call.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_ExpressionChain_alt_0_CallAndAgain_node_call.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0;
                        prevGlobal__candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0 = candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for ec
                        openTasks.Pop();
                        PatternAction_ExpressionChain.releaseTask(taskFor_ec);
                        // Pop subpattern matching task for _sub0
                        openTasks.Pop();
                        PatternAction_MultipleActualParameters.releaseTask(taskFor__sub0);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_ExpressionChain.Match_ExpressionChain_alt_0_CallAndAgain match = new Pattern_ExpressionChain.Match_ExpressionChain_alt_0_CallAndAgain();
                                match._node_e = candidate_ExpressionChain_node_e;
                                match._node_call = candidate_ExpressionChain_alt_0_CallAndAgain_node_call;
                                match._edge__edge0 = candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0;
                                match._ec = (@Pattern_ExpressionChain.Match_ExpressionChain)currentFoundPartialMatch.Pop();
                                match._ec._matchOfEnclosingPattern = match;
                                match.__sub0 = (@Pattern_MultipleActualParameters.Match_MultipleActualParameters)currentFoundPartialMatch.Pop();
                                match.__sub0._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            if(matchesList==foundPartialMatches) {
                                matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                            } else {
                                foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                                    foundPartialMatches.Add(match);
                                }
                                matchesList.Clear();
                            }
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                            {
                                candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspFlags = candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0;
                                candidate_ExpressionChain_alt_0_CallAndAgain_node_call.lgspFlags = candidate_ExpressionChain_alt_0_CallAndAgain_node_call.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_CallAndAgain_node_call;
                                openTasks.Push(this);
                                return;
                            }
                            candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspFlags = candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0;
                            candidate_ExpressionChain_alt_0_CallAndAgain_node_call.lgspFlags = candidate_ExpressionChain_alt_0_CallAndAgain_node_call.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_CallAndAgain_node_call;
                            continue;
                        }
                        candidate_ExpressionChain_alt_0_CallAndAgain_node_call.lgspFlags = candidate_ExpressionChain_alt_0_CallAndAgain_node_call.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_CallAndAgain_node_call;
                        candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspFlags = candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0;
                    }
                    while( (candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0 = candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0.lgspOutNext) != head_candidate_ExpressionChain_alt_0_CallAndAgain_edge__edge0 );
                }
            } while(false);
            if(matchesList.Count>0) {
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
            }
            // Alternative case ExpressionChain_alt_0_End 
            do {
                patternGraph = patternGraphs[(int)Pattern_ExpressionChain.ExpressionChain_alt_0_CaseNums.@End];
                // SubPreset ExpressionChain_node_e 
                GRGEN_LGSP.LGSPNode candidate_ExpressionChain_node_e = ExpressionChain_node_e;
                // NegativePattern 
                {
                    ++negLevel;
                    // Extend Outgoing ExpressionChain_alt_0_End_neg_0_edge__edge0 from ExpressionChain_node_e 
                    GRGEN_LGSP.LGSPEdge head_candidate_ExpressionChain_alt_0_End_neg_0_edge__edge0 = candidate_ExpressionChain_node_e.lgspOuthead;
                    if(head_candidate_ExpressionChain_alt_0_End_neg_0_edge__edge0 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_ExpressionChain_alt_0_End_neg_0_edge__edge0 = head_candidate_ExpressionChain_alt_0_End_neg_0_edge__edge0;
                        do
                        {
                            if(candidate_ExpressionChain_alt_0_End_neg_0_edge__edge0.lgspType.TypeID!=12) {
                                continue;
                            }
                            if((candidate_ExpressionChain_alt_0_End_neg_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                            {
                                continue;
                            }
                            // negative pattern found
                            --negLevel;
                            goto label0;
                        }
                        while( (candidate_ExpressionChain_alt_0_End_neg_0_edge__edge0 = candidate_ExpressionChain_alt_0_End_neg_0_edge__edge0.lgspOutNext) != head_candidate_ExpressionChain_alt_0_End_neg_0_edge__edge0 );
                    }
                    --negLevel;
                }
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_ExpressionChain.Match_ExpressionChain_alt_0_End match = new Pattern_ExpressionChain.Match_ExpressionChain_alt_0_End();
                    match._node_e = candidate_ExpressionChain_node_e;
                    currentFoundPartialMatch.Push(match);
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                    {
                        openTasks.Push(this);
                        return;
                    }
                    goto label1;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_ExpressionChain.Match_ExpressionChain_alt_0_End match = new Pattern_ExpressionChain.Match_ExpressionChain_alt_0_End();
                        match._node_e = candidate_ExpressionChain_node_e;
                        currentFoundPartialMatch.Push(match);
                    }
                    if(matchesList==foundPartialMatches) {
                        matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                    } else {
                        foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                            foundPartialMatches.Add(match);
                        }
                        matchesList.Clear();
                    }
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                    {
                        openTasks.Push(this);
                        return;
                    }
                    goto label2;
                }
label0: ;
label1: ;
label2: ;
            } while(false);
            openTasks.Push(this);
            return;
        }
    }

    public class PatternAction_MultipleActualParameters : GRGEN_LGSP.LGSPSubpatternAction
    {
        private PatternAction_MultipleActualParameters(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleActualParameters.Instance.patternGraph;
        }

        public static PatternAction_MultipleActualParameters getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            PatternAction_MultipleActualParameters newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new PatternAction_MultipleActualParameters(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(PatternAction_MultipleActualParameters oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static PatternAction_MultipleActualParameters freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private PatternAction_MultipleActualParameters next = null;

        public GRGEN_LGSP.LGSPNode MultipleActualParameters_node_c;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // SubPreset MultipleActualParameters_node_c 
            GRGEN_LGSP.LGSPNode candidate_MultipleActualParameters_node_c = MultipleActualParameters_node_c;
            // Push iterated matching task for MultipleActualParameters_iter_1
            IteratedAction_MultipleActualParameters_iter_1 taskFor_iter_1 = IteratedAction_MultipleActualParameters_iter_1.getNewTask(graph, openTasks);
            taskFor_iter_1.MultipleActualParameters_node_c = candidate_MultipleActualParameters_node_c;
            taskFor_iter_1.searchPatternpath = false;
            taskFor_iter_1.matchOfNestingPattern = null;
            taskFor_iter_1.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_1);
            // Push iterated matching task for MultipleActualParameters_iter_0
            IteratedAction_MultipleActualParameters_iter_0 taskFor_iter_0 = IteratedAction_MultipleActualParameters_iter_0.getNewTask(graph, openTasks);
            taskFor_iter_0.MultipleActualParameters_node_c = candidate_MultipleActualParameters_node_c;
            taskFor_iter_0.searchPatternpath = false;
            taskFor_iter_0.matchOfNestingPattern = null;
            taskFor_iter_0.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_0);
            // Match subpatterns 
            openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
            // Pop iterated matching task for MultipleActualParameters_iter_0
            openTasks.Pop();
            IteratedAction_MultipleActualParameters_iter_0.releaseTask(taskFor_iter_0);
            // Pop iterated matching task for MultipleActualParameters_iter_1
            openTasks.Pop();
            IteratedAction_MultipleActualParameters_iter_1.releaseTask(taskFor_iter_1);
            // Check whether subpatterns were found 
            if(matchesList.Count>0) {
                // subpatterns/alternatives were found, extend the partial matches by our local match object
                foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                {
                    Pattern_MultipleActualParameters.Match_MultipleActualParameters match = new Pattern_MultipleActualParameters.Match_MultipleActualParameters();
                    match._node_c = candidate_MultipleActualParameters_node_c;
                    match._iter_0 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_0, Pattern_MultipleActualParameters.IMatch_MultipleActualParameters_iter_0>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MultipleActualParameters.IMatch_MultipleActualParameters_iter_0) {
                        Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_0 cfpm = (Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_0)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_0.Add(cfpm);
                    }
                    match._iter_1 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_1, Pattern_MultipleActualParameters.IMatch_MultipleActualParameters_iter_1>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MultipleActualParameters.IMatch_MultipleActualParameters_iter_1) {
                        Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_1 cfpm = (Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_1)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_1.Add(cfpm);
                    }
                    currentFoundPartialMatch.Push(match);
                }
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
                // if enough matches were found, we leave
                if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                {
                    openTasks.Push(this);
                    return;
                }
                openTasks.Push(this);
                return;
            }
            openTasks.Push(this);
            return;
        }
    }

    public class IteratedAction_MultipleActualParameters_iter_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MultipleActualParameters_iter_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleActualParameters.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 0;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MultipleActualParameters_iter_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MultipleActualParameters_iter_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MultipleActualParameters_iter_0(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MultipleActualParameters_iter_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MultipleActualParameters_iter_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MultipleActualParameters_iter_0 next = null;

        public GRGEN_LGSP.LGSPNode MultipleActualParameters_node_c;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MultipleActualParameters_node_c 
                GRGEN_LGSP.LGSPNode candidate_MultipleActualParameters_node_c = MultipleActualParameters_node_c;
                // Extend Outgoing MultipleActualParameters_iter_0_edge__edge0 from MultipleActualParameters_node_c 
                GRGEN_LGSP.LGSPEdge head_candidate_MultipleActualParameters_iter_0_edge__edge0 = candidate_MultipleActualParameters_node_c.lgspOuthead;
                if(head_candidate_MultipleActualParameters_iter_0_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MultipleActualParameters_iter_0_edge__edge0 = head_candidate_MultipleActualParameters_iter_0_edge__edge0;
                    do
                    {
                        if(candidate_MultipleActualParameters_iter_0_edge__edge0.lgspType.TypeID!=9) {
                            continue;
                        }
                        if((candidate_MultipleActualParameters_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Target MultipleActualParameters_iter_0_node_next from MultipleActualParameters_iter_0_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MultipleActualParameters_iter_0_node_next = candidate_MultipleActualParameters_iter_0_edge__edge0.lgspTarget;
                        if(!Pattern_MultipleActualParameters.MultipleActualParameters_iter_0_node_next_IsAllowedType[candidate_MultipleActualParameters_iter_0_node_next.lgspType.TypeID]) {
                            continue;
                        }
                        if((candidate_MultipleActualParameters_iter_0_node_next.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        if((candidate_MultipleActualParameters_iter_0_node_next.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        // Push subpattern matching task for _sub0
                        PatternAction_ExpressionChain taskFor__sub0 = PatternAction_ExpressionChain.getNewTask(graph, openTasks);
                        taskFor__sub0.ExpressionChain_node_e = candidate_MultipleActualParameters_iter_0_node_next;
                        taskFor__sub0.searchPatternpath = false;
                        taskFor__sub0.matchOfNestingPattern = null;
                        taskFor__sub0.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor__sub0);
                        uint prevGlobal__candidate_MultipleActualParameters_iter_0_node_next;
                        prevGlobal__candidate_MultipleActualParameters_iter_0_node_next = candidate_MultipleActualParameters_iter_0_node_next.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleActualParameters_iter_0_node_next.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MultipleActualParameters_iter_0_edge__edge0;
                        prevGlobal__candidate_MultipleActualParameters_iter_0_edge__edge0 = candidate_MultipleActualParameters_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleActualParameters_iter_0_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for _sub0
                        openTasks.Pop();
                        PatternAction_ExpressionChain.releaseTask(taskFor__sub0);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_0 match = new Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_0();
                                match._node_c = candidate_MultipleActualParameters_node_c;
                                match._node_next = candidate_MultipleActualParameters_iter_0_node_next;
                                match._edge__edge0 = candidate_MultipleActualParameters_iter_0_edge__edge0;
                                match.__sub0 = (@Pattern_ExpressionChain.Match_ExpressionChain)currentFoundPartialMatch.Pop();
                                match.__sub0._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MultipleActualParameters_iter_0_edge__edge0.lgspFlags = candidate_MultipleActualParameters_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_0_edge__edge0;
                                candidate_MultipleActualParameters_iter_0_node_next.lgspFlags = candidate_MultipleActualParameters_iter_0_node_next.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_0_node_next;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MultipleActualParameters_iter_0_edge__edge0.lgspFlags = candidate_MultipleActualParameters_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_0_edge__edge0;
                            candidate_MultipleActualParameters_iter_0_node_next.lgspFlags = candidate_MultipleActualParameters_iter_0_node_next.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_0_node_next;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MultipleActualParameters_iter_0_node_next.lgspFlags = candidate_MultipleActualParameters_iter_0_node_next.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_0_node_next;
                        candidate_MultipleActualParameters_iter_0_edge__edge0.lgspFlags = candidate_MultipleActualParameters_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_0_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MultipleActualParameters_iter_0_edge__edge0 = candidate_MultipleActualParameters_iter_0_edge__edge0.lgspOutNext) != head_candidate_MultipleActualParameters_iter_0_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_0 match = new Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_0();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_0 match = new Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_0();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class IteratedAction_MultipleActualParameters_iter_1 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MultipleActualParameters_iter_1(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleActualParameters.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 0;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MultipleActualParameters_iter_1 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MultipleActualParameters_iter_1 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MultipleActualParameters_iter_1(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MultipleActualParameters_iter_1 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MultipleActualParameters_iter_1 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MultipleActualParameters_iter_1 next = null;

        public GRGEN_LGSP.LGSPNode MultipleActualParameters_node_c;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MultipleActualParameters_node_c 
                GRGEN_LGSP.LGSPNode candidate_MultipleActualParameters_node_c = MultipleActualParameters_node_c;
                // Extend Outgoing MultipleActualParameters_iter_1_edge__edge0 from MultipleActualParameters_node_c 
                GRGEN_LGSP.LGSPEdge head_candidate_MultipleActualParameters_iter_1_edge__edge0 = candidate_MultipleActualParameters_node_c.lgspOuthead;
                if(head_candidate_MultipleActualParameters_iter_1_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MultipleActualParameters_iter_1_edge__edge0 = head_candidate_MultipleActualParameters_iter_1_edge__edge0;
                    do
                    {
                        if(candidate_MultipleActualParameters_iter_1_edge__edge0.lgspType.TypeID!=9) {
                            continue;
                        }
                        if((candidate_MultipleActualParameters_iter_1_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Target MultipleActualParameters_iter_1_node_call from MultipleActualParameters_iter_1_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MultipleActualParameters_iter_1_node_call = candidate_MultipleActualParameters_iter_1_edge__edge0.lgspTarget;
                        if(candidate_MultipleActualParameters_iter_1_node_call.lgspType.TypeID!=11) {
                            continue;
                        }
                        if((candidate_MultipleActualParameters_iter_1_node_call.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        if((candidate_MultipleActualParameters_iter_1_node_call.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        // Push subpattern matching task for _sub1
                        PatternAction_MultipleActualParameters taskFor__sub1 = PatternAction_MultipleActualParameters.getNewTask(graph, openTasks);
                        taskFor__sub1.MultipleActualParameters_node_c = candidate_MultipleActualParameters_iter_1_node_call;
                        taskFor__sub1.searchPatternpath = false;
                        taskFor__sub1.matchOfNestingPattern = null;
                        taskFor__sub1.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor__sub1);
                        // Push subpattern matching task for _sub0
                        PatternAction_ExpressionChain taskFor__sub0 = PatternAction_ExpressionChain.getNewTask(graph, openTasks);
                        taskFor__sub0.ExpressionChain_node_e = candidate_MultipleActualParameters_iter_1_node_call;
                        taskFor__sub0.searchPatternpath = false;
                        taskFor__sub0.matchOfNestingPattern = null;
                        taskFor__sub0.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor__sub0);
                        uint prevGlobal__candidate_MultipleActualParameters_iter_1_node_call;
                        prevGlobal__candidate_MultipleActualParameters_iter_1_node_call = candidate_MultipleActualParameters_iter_1_node_call.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleActualParameters_iter_1_node_call.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MultipleActualParameters_iter_1_edge__edge0;
                        prevGlobal__candidate_MultipleActualParameters_iter_1_edge__edge0 = candidate_MultipleActualParameters_iter_1_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleActualParameters_iter_1_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for _sub0
                        openTasks.Pop();
                        PatternAction_ExpressionChain.releaseTask(taskFor__sub0);
                        // Pop subpattern matching task for _sub1
                        openTasks.Pop();
                        PatternAction_MultipleActualParameters.releaseTask(taskFor__sub1);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_1 match = new Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_1();
                                match._node_c = candidate_MultipleActualParameters_node_c;
                                match._node_call = candidate_MultipleActualParameters_iter_1_node_call;
                                match._edge__edge0 = candidate_MultipleActualParameters_iter_1_edge__edge0;
                                match.__sub0 = (@Pattern_ExpressionChain.Match_ExpressionChain)currentFoundPartialMatch.Pop();
                                match.__sub0._matchOfEnclosingPattern = match;
                                match.__sub1 = (@Pattern_MultipleActualParameters.Match_MultipleActualParameters)currentFoundPartialMatch.Pop();
                                match.__sub1._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MultipleActualParameters_iter_1_edge__edge0.lgspFlags = candidate_MultipleActualParameters_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_1_edge__edge0;
                                candidate_MultipleActualParameters_iter_1_node_call.lgspFlags = candidate_MultipleActualParameters_iter_1_node_call.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_1_node_call;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MultipleActualParameters_iter_1_edge__edge0.lgspFlags = candidate_MultipleActualParameters_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_1_edge__edge0;
                            candidate_MultipleActualParameters_iter_1_node_call.lgspFlags = candidate_MultipleActualParameters_iter_1_node_call.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_1_node_call;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MultipleActualParameters_iter_1_node_call.lgspFlags = candidate_MultipleActualParameters_iter_1_node_call.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_1_node_call;
                        candidate_MultipleActualParameters_iter_1_edge__edge0.lgspFlags = candidate_MultipleActualParameters_iter_1_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleActualParameters_iter_1_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MultipleActualParameters_iter_1_edge__edge0 = candidate_MultipleActualParameters_iter_1_edge__edge0.lgspOutNext) != head_candidate_MultipleActualParameters_iter_1_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_1 match = new Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_1();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_1 match = new Pattern_MultipleActualParameters.Match_MultipleActualParameters_iter_1();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class PatternAction_MultipleExtendingClasses : GRGEN_LGSP.LGSPSubpatternAction
    {
        private PatternAction_MultipleExtendingClasses(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleExtendingClasses.Instance.patternGraph;
        }

        public static PatternAction_MultipleExtendingClasses getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            PatternAction_MultipleExtendingClasses newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new PatternAction_MultipleExtendingClasses(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(PatternAction_MultipleExtendingClasses oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static PatternAction_MultipleExtendingClasses freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private PatternAction_MultipleExtendingClasses next = null;

        public GRGEN_LGSP.LGSPNode MultipleExtendingClasses_node_c;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // SubPreset MultipleExtendingClasses_node_c 
            GRGEN_LGSP.LGSPNode candidate_MultipleExtendingClasses_node_c = MultipleExtendingClasses_node_c;
            // Push iterated matching task for MultipleExtendingClasses_iter_0
            IteratedAction_MultipleExtendingClasses_iter_0 taskFor_iter_0 = IteratedAction_MultipleExtendingClasses_iter_0.getNewTask(graph, openTasks);
            taskFor_iter_0.MultipleExtendingClasses_node_c = candidate_MultipleExtendingClasses_node_c;
            taskFor_iter_0.searchPatternpath = false;
            taskFor_iter_0.matchOfNestingPattern = null;
            taskFor_iter_0.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_0);
            // Match subpatterns 
            openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
            // Pop iterated matching task for MultipleExtendingClasses_iter_0
            openTasks.Pop();
            IteratedAction_MultipleExtendingClasses_iter_0.releaseTask(taskFor_iter_0);
            // Check whether subpatterns were found 
            if(matchesList.Count>0) {
                // subpatterns/alternatives were found, extend the partial matches by our local match object
                foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                {
                    Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses match = new Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses();
                    match._node_c = candidate_MultipleExtendingClasses_node_c;
                    match._iter_0 = new GRGEN_LGSP.LGSPMatchesList<Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses_iter_0, Pattern_MultipleExtendingClasses.IMatch_MultipleExtendingClasses_iter_0>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Pattern_MultipleExtendingClasses.IMatch_MultipleExtendingClasses_iter_0) {
                        Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses_iter_0 cfpm = (Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses_iter_0)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_0.Add(cfpm);
                    }
                    currentFoundPartialMatch.Push(match);
                }
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
                // if enough matches were found, we leave
                if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                {
                    openTasks.Push(this);
                    return;
                }
                openTasks.Push(this);
                return;
            }
            openTasks.Push(this);
            return;
        }
    }

    public class IteratedAction_MultipleExtendingClasses_iter_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_MultipleExtendingClasses_iter_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_MultipleExtendingClasses.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 0;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_MultipleExtendingClasses_iter_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_MultipleExtendingClasses_iter_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_MultipleExtendingClasses_iter_0(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_MultipleExtendingClasses_iter_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_MultipleExtendingClasses_iter_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_MultipleExtendingClasses_iter_0 next = null;

        public GRGEN_LGSP.LGSPNode MultipleExtendingClasses_node_c;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // SubPreset MultipleExtendingClasses_node_c 
                GRGEN_LGSP.LGSPNode candidate_MultipleExtendingClasses_node_c = MultipleExtendingClasses_node_c;
                // Extend Incoming MultipleExtendingClasses_iter_0_edge__edge0 from MultipleExtendingClasses_node_c 
                GRGEN_LGSP.LGSPEdge head_candidate_MultipleExtendingClasses_iter_0_edge__edge0 = candidate_MultipleExtendingClasses_node_c.lgspInhead;
                if(head_candidate_MultipleExtendingClasses_iter_0_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MultipleExtendingClasses_iter_0_edge__edge0 = head_candidate_MultipleExtendingClasses_iter_0_edge__edge0;
                    do
                    {
                        if(candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspType.TypeID!=5) {
                            continue;
                        }
                        if((candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Source MultipleExtendingClasses_iter_0_node_sub from MultipleExtendingClasses_iter_0_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_MultipleExtendingClasses_iter_0_node_sub = candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspSource;
                        if(candidate_MultipleExtendingClasses_iter_0_node_sub.lgspType.TypeID!=3) {
                            continue;
                        }
                        if((candidate_MultipleExtendingClasses_iter_0_node_sub.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        if((candidate_MultipleExtendingClasses_iter_0_node_sub.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // accept iterated instance match
                        ++numMatchesIter;
                        // Push subpattern matching task for _sub0
                        PatternAction_MultipleExtendingClasses taskFor__sub0 = PatternAction_MultipleExtendingClasses.getNewTask(graph, openTasks);
                        taskFor__sub0.MultipleExtendingClasses_node_c = candidate_MultipleExtendingClasses_iter_0_node_sub;
                        taskFor__sub0.searchPatternpath = false;
                        taskFor__sub0.matchOfNestingPattern = null;
                        taskFor__sub0.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor__sub0);
                        uint prevGlobal__candidate_MultipleExtendingClasses_iter_0_node_sub;
                        prevGlobal__candidate_MultipleExtendingClasses_iter_0_node_sub = candidate_MultipleExtendingClasses_iter_0_node_sub.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleExtendingClasses_iter_0_node_sub.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_MultipleExtendingClasses_iter_0_edge__edge0;
                        prevGlobal__candidate_MultipleExtendingClasses_iter_0_edge__edge0 = candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for _sub0
                        openTasks.Pop();
                        PatternAction_MultipleExtendingClasses.releaseTask(taskFor__sub0);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            patternFound = true;
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses_iter_0 match = new Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses_iter_0();
                                match._node_sub = candidate_MultipleExtendingClasses_iter_0_node_sub;
                                match._node_c = candidate_MultipleExtendingClasses_node_c;
                                match._edge__edge0 = candidate_MultipleExtendingClasses_iter_0_edge__edge0;
                                match.__sub0 = (@Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses)currentFoundPartialMatch.Pop();
                                match.__sub0._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            // if enough matches were found, we leave
                            if(true) // as soon as there's a match, it's enough for iterated
                            {
                                candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspFlags = candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExtendingClasses_iter_0_edge__edge0;
                                candidate_MultipleExtendingClasses_iter_0_node_sub.lgspFlags = candidate_MultipleExtendingClasses_iter_0_node_sub.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExtendingClasses_iter_0_node_sub;
                                --numMatchesIter;
                                goto maxMatchesIterReached;
                            }
                            candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspFlags = candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExtendingClasses_iter_0_edge__edge0;
                            candidate_MultipleExtendingClasses_iter_0_node_sub.lgspFlags = candidate_MultipleExtendingClasses_iter_0_node_sub.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExtendingClasses_iter_0_node_sub;
                            --numMatchesIter;
                            continue;
                        }
                        candidate_MultipleExtendingClasses_iter_0_node_sub.lgspFlags = candidate_MultipleExtendingClasses_iter_0_node_sub.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExtendingClasses_iter_0_node_sub;
                        candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspFlags = candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_MultipleExtendingClasses_iter_0_edge__edge0;
                        --numMatchesIter;
                    }
                    while( (candidate_MultipleExtendingClasses_iter_0_edge__edge0 = candidate_MultipleExtendingClasses_iter_0_edge__edge0.lgspInNext) != head_candidate_MultipleExtendingClasses_iter_0_edge__edge0 );
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses_iter_0 match = new Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses_iter_0();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses_iter_0 match = new Pattern_MultipleExtendingClasses.Match_MultipleExtendingClasses_iter_0();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    public class PatternAction_InClass : GRGEN_LGSP.LGSPSubpatternAction
    {
        private PatternAction_InClass(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_InClass.Instance.patternGraph;
        }

        public static PatternAction_InClass getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            PatternAction_InClass newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new PatternAction_InClass(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(PatternAction_InClass oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static PatternAction_InClass freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private PatternAction_InClass next = null;

        public GRGEN_LGSP.LGSPNode InClass_node_e;
        public GRGEN_LGSP.LGSPNode InClass_node_c;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // SubPreset InClass_node_e 
            GRGEN_LGSP.LGSPNode candidate_InClass_node_e = InClass_node_e;
            // SubPreset InClass_node_c 
            GRGEN_LGSP.LGSPNode candidate_InClass_node_c = InClass_node_c;
            // Push alternative matching task for InClass_alt_0
            AlternativeAction_InClass_alt_0 taskFor_alt_0 = AlternativeAction_InClass_alt_0.getNewTask(graph, openTasks, Pattern_InClass.Instance.patternGraph.alternatives[(int)Pattern_InClass.InClass_AltNums.@alt_0].alternativeCases);
            taskFor_alt_0.InClass_node_e = candidate_InClass_node_e;
            taskFor_alt_0.InClass_node_c = candidate_InClass_node_c;
            taskFor_alt_0.searchPatternpath = false;
            taskFor_alt_0.matchOfNestingPattern = null;
            taskFor_alt_0.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_alt_0);
            // Match subpatterns 
            openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
            // Pop alternative matching task for InClass_alt_0
            openTasks.Pop();
            AlternativeAction_InClass_alt_0.releaseTask(taskFor_alt_0);
            // Check whether subpatterns were found 
            if(matchesList.Count>0) {
                // subpatterns/alternatives were found, extend the partial matches by our local match object
                foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                {
                    Pattern_InClass.Match_InClass match = new Pattern_InClass.Match_InClass();
                    match._node_e = candidate_InClass_node_e;
                    match._node_c = candidate_InClass_node_c;
                    match._alt_0 = (Pattern_InClass.IMatch_InClass_alt_0)currentFoundPartialMatch.Pop();
                    match._alt_0.SetMatchOfEnclosingPattern(match);
                    currentFoundPartialMatch.Push(match);
                }
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
                // if enough matches were found, we leave
                if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                {
                    openTasks.Push(this);
                    return;
                }
                openTasks.Push(this);
                return;
            }
            openTasks.Push(this);
            return;
        }
    }

    public class AlternativeAction_InClass_alt_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private AlternativeAction_InClass_alt_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_, GRGEN_LGSP.PatternGraph[] patternGraphs_) {
            graph = graph_; openTasks = openTasks_;
            patternGraphs = patternGraphs_;
        }

        public static AlternativeAction_InClass_alt_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_, GRGEN_LGSP.PatternGraph[] patternGraphs_) {
            AlternativeAction_InClass_alt_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                newTask.patternGraphs = patternGraphs_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new AlternativeAction_InClass_alt_0(graph_, openTasks_, patternGraphs_);
            }
            return newTask;
        }

        public static void releaseTask(AlternativeAction_InClass_alt_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static AlternativeAction_InClass_alt_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private AlternativeAction_InClass_alt_0 next = null;

        public GRGEN_LGSP.LGSPNode InClass_node_e;
        public GRGEN_LGSP.LGSPNode InClass_node_c;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // Alternative case InClass_alt_0_Previous 
            do {
                patternGraph = patternGraphs[(int)Pattern_InClass.InClass_alt_0_CaseNums.@Previous];
                // SubPreset InClass_node_e 
                GRGEN_LGSP.LGSPNode candidate_InClass_node_e = InClass_node_e;
                // SubPreset InClass_node_c 
                GRGEN_LGSP.LGSPNode candidate_InClass_node_c = InClass_node_c;
                // Extend Incoming InClass_alt_0_Previous_edge__edge0 from InClass_node_e 
                GRGEN_LGSP.LGSPEdge head_candidate_InClass_alt_0_Previous_edge__edge0 = candidate_InClass_node_e.lgspInhead;
                if(head_candidate_InClass_alt_0_Previous_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_InClass_alt_0_Previous_edge__edge0 = head_candidate_InClass_alt_0_Previous_edge__edge0;
                    do
                    {
                        if(candidate_InClass_alt_0_Previous_edge__edge0.lgspType.TypeID!=12) {
                            continue;
                        }
                        if((candidate_InClass_alt_0_Previous_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Source InClass_alt_0_Previous_node_prev from InClass_alt_0_Previous_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_InClass_alt_0_Previous_node_prev = candidate_InClass_alt_0_Previous_edge__edge0.lgspSource;
                        if(!Pattern_InClass.InClass_alt_0_Previous_node_prev_IsAllowedType[candidate_InClass_alt_0_Previous_node_prev.lgspType.TypeID]) {
                            continue;
                        }
                        if((candidate_InClass_alt_0_Previous_node_prev.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        if((candidate_InClass_alt_0_Previous_node_prev.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Push subpattern matching task for _sub0
                        PatternAction_InClass taskFor__sub0 = PatternAction_InClass.getNewTask(graph, openTasks);
                        taskFor__sub0.InClass_node_e = candidate_InClass_alt_0_Previous_node_prev;
                        taskFor__sub0.InClass_node_c = candidate_InClass_node_c;
                        taskFor__sub0.searchPatternpath = false;
                        taskFor__sub0.matchOfNestingPattern = null;
                        taskFor__sub0.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor__sub0);
                        uint prevGlobal__candidate_InClass_alt_0_Previous_node_prev;
                        prevGlobal__candidate_InClass_alt_0_Previous_node_prev = candidate_InClass_alt_0_Previous_node_prev.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_InClass_alt_0_Previous_node_prev.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_InClass_alt_0_Previous_edge__edge0;
                        prevGlobal__candidate_InClass_alt_0_Previous_edge__edge0 = candidate_InClass_alt_0_Previous_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_InClass_alt_0_Previous_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for _sub0
                        openTasks.Pop();
                        PatternAction_InClass.releaseTask(taskFor__sub0);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_InClass.Match_InClass_alt_0_Previous match = new Pattern_InClass.Match_InClass_alt_0_Previous();
                                match._node_prev = candidate_InClass_alt_0_Previous_node_prev;
                                match._node_e = candidate_InClass_node_e;
                                match._node_c = candidate_InClass_node_c;
                                match._edge__edge0 = candidate_InClass_alt_0_Previous_edge__edge0;
                                match.__sub0 = (@Pattern_InClass.Match_InClass)currentFoundPartialMatch.Pop();
                                match.__sub0._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            if(matchesList==foundPartialMatches) {
                                matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                            } else {
                                foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                                    foundPartialMatches.Add(match);
                                }
                                matchesList.Clear();
                            }
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                            {
                                candidate_InClass_alt_0_Previous_edge__edge0.lgspFlags = candidate_InClass_alt_0_Previous_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_Previous_edge__edge0;
                                candidate_InClass_alt_0_Previous_node_prev.lgspFlags = candidate_InClass_alt_0_Previous_node_prev.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_Previous_node_prev;
                                openTasks.Push(this);
                                return;
                            }
                            candidate_InClass_alt_0_Previous_edge__edge0.lgspFlags = candidate_InClass_alt_0_Previous_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_Previous_edge__edge0;
                            candidate_InClass_alt_0_Previous_node_prev.lgspFlags = candidate_InClass_alt_0_Previous_node_prev.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_Previous_node_prev;
                            continue;
                        }
                        candidate_InClass_alt_0_Previous_node_prev.lgspFlags = candidate_InClass_alt_0_Previous_node_prev.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_Previous_node_prev;
                        candidate_InClass_alt_0_Previous_edge__edge0.lgspFlags = candidate_InClass_alt_0_Previous_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_Previous_edge__edge0;
                    }
                    while( (candidate_InClass_alt_0_Previous_edge__edge0 = candidate_InClass_alt_0_Previous_edge__edge0.lgspInNext) != head_candidate_InClass_alt_0_Previous_edge__edge0 );
                }
            } while(false);
            if(matchesList.Count>0) {
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
            }
            // Alternative case InClass_alt_0_End 
            do {
                patternGraph = patternGraphs[(int)Pattern_InClass.InClass_alt_0_CaseNums.@End];
                // SubPreset InClass_node_e 
                GRGEN_LGSP.LGSPNode candidate_InClass_node_e = InClass_node_e;
                // SubPreset InClass_node_c 
                GRGEN_LGSP.LGSPNode candidate_InClass_node_c = InClass_node_c;
                // Extend Incoming InClass_alt_0_End_edge__edge0 from InClass_node_e 
                GRGEN_LGSP.LGSPEdge head_candidate_InClass_alt_0_End_edge__edge0 = candidate_InClass_node_e.lgspInhead;
                if(head_candidate_InClass_alt_0_End_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_InClass_alt_0_End_edge__edge0 = head_candidate_InClass_alt_0_End_edge__edge0;
                    do
                    {
                        if(candidate_InClass_alt_0_End_edge__edge0.lgspType.TypeID!=12) {
                            continue;
                        }
                        if((candidate_InClass_alt_0_End_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Source InClass_alt_0_End_node_prev from InClass_alt_0_End_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_InClass_alt_0_End_node_prev = candidate_InClass_alt_0_End_edge__edge0.lgspSource;
                        if(candidate_InClass_alt_0_End_node_prev.lgspType.TypeID!=15) {
                            continue;
                        }
                        if((candidate_InClass_alt_0_End_node_prev.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        if((candidate_InClass_alt_0_End_node_prev.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        uint prev__candidate_InClass_alt_0_End_node_prev;
                        prev__candidate_InClass_alt_0_End_node_prev = candidate_InClass_alt_0_End_node_prev.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                        candidate_InClass_alt_0_End_node_prev.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                        // Extend Incoming InClass_alt_0_End_edge__edge2 from InClass_node_c 
                        GRGEN_LGSP.LGSPEdge head_candidate_InClass_alt_0_End_edge__edge2 = candidate_InClass_node_c.lgspInhead;
                        if(head_candidate_InClass_alt_0_End_edge__edge2 != null)
                        {
                            GRGEN_LGSP.LGSPEdge candidate_InClass_alt_0_End_edge__edge2 = head_candidate_InClass_alt_0_End_edge__edge2;
                            do
                            {
                                if(candidate_InClass_alt_0_End_edge__edge2.lgspType.TypeID!=3) {
                                    continue;
                                }
                                if((candidate_InClass_alt_0_End_edge__edge2.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                                {
                                    continue;
                                }
                                uint prev__candidate_InClass_alt_0_End_edge__edge2;
                                prev__candidate_InClass_alt_0_End_edge__edge2 = candidate_InClass_alt_0_End_edge__edge2.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                                candidate_InClass_alt_0_End_edge__edge2.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                                // Implicit Source InClass_alt_0_End_node_mb from InClass_alt_0_End_edge__edge2 
                                GRGEN_LGSP.LGSPNode candidate_InClass_alt_0_End_node_mb = candidate_InClass_alt_0_End_edge__edge2.lgspSource;
                                if(candidate_InClass_alt_0_End_node_mb.lgspType.TypeID!=7) {
                                    candidate_InClass_alt_0_End_edge__edge2.lgspFlags = candidate_InClass_alt_0_End_edge__edge2.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InClass_alt_0_End_edge__edge2;
                                    continue;
                                }
                                if((candidate_InClass_alt_0_End_node_mb.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                                {
                                    candidate_InClass_alt_0_End_edge__edge2.lgspFlags = candidate_InClass_alt_0_End_edge__edge2.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InClass_alt_0_End_edge__edge2;
                                    continue;
                                }
                                // Extend Incoming InClass_alt_0_End_edge__edge1 from InClass_alt_0_End_node_mb 
                                GRGEN_LGSP.LGSPEdge head_candidate_InClass_alt_0_End_edge__edge1 = candidate_InClass_alt_0_End_node_mb.lgspInhead;
                                if(head_candidate_InClass_alt_0_End_edge__edge1 != null)
                                {
                                    GRGEN_LGSP.LGSPEdge candidate_InClass_alt_0_End_edge__edge1 = head_candidate_InClass_alt_0_End_edge__edge1;
                                    do
                                    {
                                        if(candidate_InClass_alt_0_End_edge__edge1.lgspType.TypeID!=3) {
                                            continue;
                                        }
                                        if((candidate_InClass_alt_0_End_edge__edge1.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                                        {
                                            continue;
                                        }
                                        if((candidate_InClass_alt_0_End_edge__edge1.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                                        {
                                            continue;
                                        }
                                        // Implicit Source InClass_alt_0_End_node_b from InClass_alt_0_End_edge__edge1 
                                        GRGEN_LGSP.LGSPNode candidate_InClass_alt_0_End_node_b = candidate_InClass_alt_0_End_edge__edge1.lgspSource;
                                        if(candidate_InClass_alt_0_End_node_b.lgspType.TypeID!=15) {
                                            continue;
                                        }
                                        if((candidate_InClass_alt_0_End_node_b.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                                        {
                                            continue;
                                        }
                                        if((candidate_InClass_alt_0_End_node_b.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                                        {
                                            continue;
                                        }
                                        // Check whether there are subpattern matching tasks left to execute
                                        if(openTasks.Count==0)
                                        {
                                            Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                                            foundPartialMatches.Add(currentFoundPartialMatch);
                                            Pattern_InClass.Match_InClass_alt_0_End match = new Pattern_InClass.Match_InClass_alt_0_End();
                                            match._node_prev = candidate_InClass_alt_0_End_node_prev;
                                            match._node_e = candidate_InClass_node_e;
                                            match._node_b = candidate_InClass_alt_0_End_node_b;
                                            match._node_mb = candidate_InClass_alt_0_End_node_mb;
                                            match._node_c = candidate_InClass_node_c;
                                            match._edge__edge0 = candidate_InClass_alt_0_End_edge__edge0;
                                            match._edge__edge1 = candidate_InClass_alt_0_End_edge__edge1;
                                            match._edge__edge2 = candidate_InClass_alt_0_End_edge__edge2;
                                            currentFoundPartialMatch.Push(match);
                                            // if enough matches were found, we leave
                                            if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                                            {
                                                candidate_InClass_alt_0_End_edge__edge2.lgspFlags = candidate_InClass_alt_0_End_edge__edge2.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InClass_alt_0_End_edge__edge2;
                                                candidate_InClass_alt_0_End_node_prev.lgspFlags = candidate_InClass_alt_0_End_node_prev.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InClass_alt_0_End_node_prev;
                                                openTasks.Push(this);
                                                return;
                                            }
                                            continue;
                                        }
                                        uint prevGlobal__candidate_InClass_alt_0_End_node_prev;
                                        prevGlobal__candidate_InClass_alt_0_End_node_prev = candidate_InClass_alt_0_End_node_prev.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        candidate_InClass_alt_0_End_node_prev.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        uint prevGlobal__candidate_InClass_alt_0_End_node_b;
                                        prevGlobal__candidate_InClass_alt_0_End_node_b = candidate_InClass_alt_0_End_node_b.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        candidate_InClass_alt_0_End_node_b.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        uint prevGlobal__candidate_InClass_alt_0_End_node_mb;
                                        prevGlobal__candidate_InClass_alt_0_End_node_mb = candidate_InClass_alt_0_End_node_mb.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        candidate_InClass_alt_0_End_node_mb.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        uint prevGlobal__candidate_InClass_alt_0_End_edge__edge0;
                                        prevGlobal__candidate_InClass_alt_0_End_edge__edge0 = candidate_InClass_alt_0_End_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        candidate_InClass_alt_0_End_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        uint prevGlobal__candidate_InClass_alt_0_End_edge__edge1;
                                        prevGlobal__candidate_InClass_alt_0_End_edge__edge1 = candidate_InClass_alt_0_End_edge__edge1.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        candidate_InClass_alt_0_End_edge__edge1.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        uint prevGlobal__candidate_InClass_alt_0_End_edge__edge2;
                                        prevGlobal__candidate_InClass_alt_0_End_edge__edge2 = candidate_InClass_alt_0_End_edge__edge2.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        candidate_InClass_alt_0_End_edge__edge2.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                                        // Match subpatterns 
                                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                                        // Check whether subpatterns were found 
                                        if(matchesList.Count>0) {
                                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                                            {
                                                Pattern_InClass.Match_InClass_alt_0_End match = new Pattern_InClass.Match_InClass_alt_0_End();
                                                match._node_prev = candidate_InClass_alt_0_End_node_prev;
                                                match._node_e = candidate_InClass_node_e;
                                                match._node_b = candidate_InClass_alt_0_End_node_b;
                                                match._node_mb = candidate_InClass_alt_0_End_node_mb;
                                                match._node_c = candidate_InClass_node_c;
                                                match._edge__edge0 = candidate_InClass_alt_0_End_edge__edge0;
                                                match._edge__edge1 = candidate_InClass_alt_0_End_edge__edge1;
                                                match._edge__edge2 = candidate_InClass_alt_0_End_edge__edge2;
                                                currentFoundPartialMatch.Push(match);
                                            }
                                            if(matchesList==foundPartialMatches) {
                                                matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                                            } else {
                                                foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                                                    foundPartialMatches.Add(match);
                                                }
                                                matchesList.Clear();
                                            }
                                            // if enough matches were found, we leave
                                            if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                                            {
                                                candidate_InClass_alt_0_End_edge__edge2.lgspFlags = candidate_InClass_alt_0_End_edge__edge2.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_edge__edge2;
                                                candidate_InClass_alt_0_End_edge__edge1.lgspFlags = candidate_InClass_alt_0_End_edge__edge1.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_edge__edge1;
                                                candidate_InClass_alt_0_End_edge__edge0.lgspFlags = candidate_InClass_alt_0_End_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_edge__edge0;
                                                candidate_InClass_alt_0_End_node_mb.lgspFlags = candidate_InClass_alt_0_End_node_mb.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_node_mb;
                                                candidate_InClass_alt_0_End_node_b.lgspFlags = candidate_InClass_alt_0_End_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_node_b;
                                                candidate_InClass_alt_0_End_node_prev.lgspFlags = candidate_InClass_alt_0_End_node_prev.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_node_prev;
                                                candidate_InClass_alt_0_End_edge__edge2.lgspFlags = candidate_InClass_alt_0_End_edge__edge2.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InClass_alt_0_End_edge__edge2;
                                                candidate_InClass_alt_0_End_node_prev.lgspFlags = candidate_InClass_alt_0_End_node_prev.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InClass_alt_0_End_node_prev;
                                                openTasks.Push(this);
                                                return;
                                            }
                                            candidate_InClass_alt_0_End_edge__edge2.lgspFlags = candidate_InClass_alt_0_End_edge__edge2.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_edge__edge2;
                                            candidate_InClass_alt_0_End_edge__edge1.lgspFlags = candidate_InClass_alt_0_End_edge__edge1.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_edge__edge1;
                                            candidate_InClass_alt_0_End_edge__edge0.lgspFlags = candidate_InClass_alt_0_End_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_edge__edge0;
                                            candidate_InClass_alt_0_End_node_mb.lgspFlags = candidate_InClass_alt_0_End_node_mb.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_node_mb;
                                            candidate_InClass_alt_0_End_node_b.lgspFlags = candidate_InClass_alt_0_End_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_node_b;
                                            candidate_InClass_alt_0_End_node_prev.lgspFlags = candidate_InClass_alt_0_End_node_prev.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_node_prev;
                                            continue;
                                        }
                                        candidate_InClass_alt_0_End_node_prev.lgspFlags = candidate_InClass_alt_0_End_node_prev.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_node_prev;
                                        candidate_InClass_alt_0_End_node_b.lgspFlags = candidate_InClass_alt_0_End_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_node_b;
                                        candidate_InClass_alt_0_End_node_mb.lgspFlags = candidate_InClass_alt_0_End_node_mb.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_node_mb;
                                        candidate_InClass_alt_0_End_edge__edge0.lgspFlags = candidate_InClass_alt_0_End_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_edge__edge0;
                                        candidate_InClass_alt_0_End_edge__edge1.lgspFlags = candidate_InClass_alt_0_End_edge__edge1.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_edge__edge1;
                                        candidate_InClass_alt_0_End_edge__edge2.lgspFlags = candidate_InClass_alt_0_End_edge__edge2.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_InClass_alt_0_End_edge__edge2;
                                    }
                                    while( (candidate_InClass_alt_0_End_edge__edge1 = candidate_InClass_alt_0_End_edge__edge1.lgspInNext) != head_candidate_InClass_alt_0_End_edge__edge1 );
                                }
                                candidate_InClass_alt_0_End_edge__edge2.lgspFlags = candidate_InClass_alt_0_End_edge__edge2.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InClass_alt_0_End_edge__edge2;
                            }
                            while( (candidate_InClass_alt_0_End_edge__edge2 = candidate_InClass_alt_0_End_edge__edge2.lgspInNext) != head_candidate_InClass_alt_0_End_edge__edge2 );
                        }
                        candidate_InClass_alt_0_End_node_prev.lgspFlags = candidate_InClass_alt_0_End_node_prev.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InClass_alt_0_End_node_prev;
                    }
                    while( (candidate_InClass_alt_0_End_edge__edge0 = candidate_InClass_alt_0_End_edge__edge0.lgspInNext) != head_candidate_InClass_alt_0_End_edge__edge0 );
                }
            } while(false);
            openTasks.Push(this);
            return;
        }
    }

    public class PatternAction_methodNameExistsSuper : GRGEN_LGSP.LGSPSubpatternAction
    {
        private PatternAction_methodNameExistsSuper(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Pattern_methodNameExistsSuper.Instance.patternGraph;
        }

        public static PatternAction_methodNameExistsSuper getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            PatternAction_methodNameExistsSuper newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new PatternAction_methodNameExistsSuper(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(PatternAction_methodNameExistsSuper oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static PatternAction_methodNameExistsSuper freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private PatternAction_methodNameExistsSuper next = null;

        public GRGEN_LGSP.LGSPNode methodNameExistsSuper_node_cls;
        public GRGEN_LGSP.LGSPNode methodNameExistsSuper_node_opForName;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // SubPreset methodNameExistsSuper_node_cls 
            GRGEN_LGSP.LGSPNode candidate_methodNameExistsSuper_node_cls = methodNameExistsSuper_node_cls;
            // SubPreset methodNameExistsSuper_node_opForName 
            GRGEN_LGSP.LGSPNode candidate_methodNameExistsSuper_node_opForName = methodNameExistsSuper_node_opForName;
            // Extend Incoming methodNameExistsSuper_edge__edge0 from methodNameExistsSuper_node_cls 
            GRGEN_LGSP.LGSPEdge head_candidate_methodNameExistsSuper_edge__edge0 = candidate_methodNameExistsSuper_node_cls.lgspInhead;
            if(head_candidate_methodNameExistsSuper_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_methodNameExistsSuper_edge__edge0 = head_candidate_methodNameExistsSuper_edge__edge0;
                do
                {
                    if(candidate_methodNameExistsSuper_edge__edge0.lgspType.TypeID!=3) {
                        continue;
                    }
                    if((candidate_methodNameExistsSuper_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                    {
                        continue;
                    }
                    // Implicit Source methodNameExistsSuper_node_op from methodNameExistsSuper_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_methodNameExistsSuper_node_op = candidate_methodNameExistsSuper_edge__edge0.lgspSource;
                    if(candidate_methodNameExistsSuper_node_op.lgspType.TypeID!=6) {
                        continue;
                    }
                    if((candidate_methodNameExistsSuper_node_op.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                    {
                        continue;
                    }
                    if((candidate_methodNameExistsSuper_node_op.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                    {
                        continue;
                    }
                    // Push alternative matching task for methodNameExistsSuper_alt_0
                    AlternativeAction_methodNameExistsSuper_alt_0 taskFor_alt_0 = AlternativeAction_methodNameExistsSuper_alt_0.getNewTask(graph, openTasks, Pattern_methodNameExistsSuper.Instance.patternGraph.alternatives[(int)Pattern_methodNameExistsSuper.methodNameExistsSuper_AltNums.@alt_0].alternativeCases);
                    taskFor_alt_0.methodNameExistsSuper_node_op = candidate_methodNameExistsSuper_node_op;
                    taskFor_alt_0.methodNameExistsSuper_node_opForName = candidate_methodNameExistsSuper_node_opForName;
                    taskFor_alt_0.methodNameExistsSuper_node_cls = candidate_methodNameExistsSuper_node_cls;
                    taskFor_alt_0.searchPatternpath = false;
                    taskFor_alt_0.matchOfNestingPattern = null;
                    taskFor_alt_0.lastMatchAtPreviousNestingLevel = null;
                    openTasks.Push(taskFor_alt_0);
                    uint prevGlobal__candidate_methodNameExistsSuper_node_op;
                    prevGlobal__candidate_methodNameExistsSuper_node_op = candidate_methodNameExistsSuper_node_op.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    candidate_methodNameExistsSuper_node_op.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    uint prevGlobal__candidate_methodNameExistsSuper_edge__edge0;
                    prevGlobal__candidate_methodNameExistsSuper_edge__edge0 = candidate_methodNameExistsSuper_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    candidate_methodNameExistsSuper_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    // Match subpatterns 
                    openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                    // Pop alternative matching task for methodNameExistsSuper_alt_0
                    openTasks.Pop();
                    AlternativeAction_methodNameExistsSuper_alt_0.releaseTask(taskFor_alt_0);
                    // Check whether subpatterns were found 
                    if(matchesList.Count>0) {
                        // subpatterns/alternatives were found, extend the partial matches by our local match object
                        foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                        {
                            Pattern_methodNameExistsSuper.Match_methodNameExistsSuper match = new Pattern_methodNameExistsSuper.Match_methodNameExistsSuper();
                            match._node_op = candidate_methodNameExistsSuper_node_op;
                            match._node_cls = candidate_methodNameExistsSuper_node_cls;
                            match._node_opForName = candidate_methodNameExistsSuper_node_opForName;
                            match._edge__edge0 = candidate_methodNameExistsSuper_edge__edge0;
                            match._alt_0 = (Pattern_methodNameExistsSuper.IMatch_methodNameExistsSuper_alt_0)currentFoundPartialMatch.Pop();
                            match._alt_0.SetMatchOfEnclosingPattern(match);
                            currentFoundPartialMatch.Push(match);
                        }
                        if(matchesList==foundPartialMatches) {
                            matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                        } else {
                            foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                                foundPartialMatches.Add(match);
                            }
                            matchesList.Clear();
                        }
                        // if enough matches were found, we leave
                        if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                        {
                            candidate_methodNameExistsSuper_edge__edge0.lgspFlags = candidate_methodNameExistsSuper_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_edge__edge0;
                            candidate_methodNameExistsSuper_node_op.lgspFlags = candidate_methodNameExistsSuper_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_node_op;
                            openTasks.Push(this);
                            return;
                        }
                        candidate_methodNameExistsSuper_edge__edge0.lgspFlags = candidate_methodNameExistsSuper_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_edge__edge0;
                        candidate_methodNameExistsSuper_node_op.lgspFlags = candidate_methodNameExistsSuper_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_node_op;
                        continue;
                    }
                    candidate_methodNameExistsSuper_node_op.lgspFlags = candidate_methodNameExistsSuper_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_node_op;
                    candidate_methodNameExistsSuper_edge__edge0.lgspFlags = candidate_methodNameExistsSuper_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_edge__edge0;
                }
                while( (candidate_methodNameExistsSuper_edge__edge0 = candidate_methodNameExistsSuper_edge__edge0.lgspInNext) != head_candidate_methodNameExistsSuper_edge__edge0 );
            }
            openTasks.Push(this);
            return;
        }
    }

    public class AlternativeAction_methodNameExistsSuper_alt_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private AlternativeAction_methodNameExistsSuper_alt_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_, GRGEN_LGSP.PatternGraph[] patternGraphs_) {
            graph = graph_; openTasks = openTasks_;
            patternGraphs = patternGraphs_;
        }

        public static AlternativeAction_methodNameExistsSuper_alt_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_, GRGEN_LGSP.PatternGraph[] patternGraphs_) {
            AlternativeAction_methodNameExistsSuper_alt_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                newTask.patternGraphs = patternGraphs_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new AlternativeAction_methodNameExistsSuper_alt_0(graph_, openTasks_, patternGraphs_);
            }
            return newTask;
        }

        public static void releaseTask(AlternativeAction_methodNameExistsSuper_alt_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static AlternativeAction_methodNameExistsSuper_alt_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private AlternativeAction_methodNameExistsSuper_alt_0 next = null;

        public GRGEN_LGSP.LGSPNode methodNameExistsSuper_node_op;
        public GRGEN_LGSP.LGSPNode methodNameExistsSuper_node_opForName;
        public GRGEN_LGSP.LGSPNode methodNameExistsSuper_node_cls;
        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            openTasks.Pop();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // Alternative case methodNameExistsSuper_alt_0_here 
            do {
                patternGraph = patternGraphs[(int)Pattern_methodNameExistsSuper.methodNameExistsSuper_alt_0_CaseNums.@here];
                // SubPreset methodNameExistsSuper_node_op 
                GRGEN_LGSP.LGSPNode candidate_methodNameExistsSuper_node_op = methodNameExistsSuper_node_op;
                // SubPreset methodNameExistsSuper_node_opForName 
                GRGEN_LGSP.LGSPNode candidate_methodNameExistsSuper_node_opForName = methodNameExistsSuper_node_opForName;
                // Condition 
                if(!((((GRGEN_MODEL.IOperation)candidate_methodNameExistsSuper_node_op).@name == ((GRGEN_MODEL.IOperation)candidate_methodNameExistsSuper_node_opForName).@name))) {
                    continue;
                }
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Pattern_methodNameExistsSuper.Match_methodNameExistsSuper_alt_0_here match = new Pattern_methodNameExistsSuper.Match_methodNameExistsSuper_alt_0_here();
                    match._node_op = candidate_methodNameExistsSuper_node_op;
                    match._node_opForName = candidate_methodNameExistsSuper_node_opForName;
                    currentFoundPartialMatch.Push(match);
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                    {
                        openTasks.Push(this);
                        return;
                    }
                    continue;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Pattern_methodNameExistsSuper.Match_methodNameExistsSuper_alt_0_here match = new Pattern_methodNameExistsSuper.Match_methodNameExistsSuper_alt_0_here();
                        match._node_op = candidate_methodNameExistsSuper_node_op;
                        match._node_opForName = candidate_methodNameExistsSuper_node_opForName;
                        currentFoundPartialMatch.Push(match);
                    }
                    if(matchesList==foundPartialMatches) {
                        matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                    } else {
                        foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                            foundPartialMatches.Add(match);
                        }
                        matchesList.Clear();
                    }
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                    {
                        openTasks.Push(this);
                        return;
                    }
                    continue;
                }
            } while(false);
            if(matchesList.Count>0) {
                if(matchesList==foundPartialMatches) {
                    matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                } else {
                    foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                        foundPartialMatches.Add(match);
                    }
                    matchesList.Clear();
                }
            }
            // Alternative case methodNameExistsSuper_alt_0_super 
            do {
                patternGraph = patternGraphs[(int)Pattern_methodNameExistsSuper.methodNameExistsSuper_alt_0_CaseNums.@super];
                // SubPreset methodNameExistsSuper_node_cls 
                GRGEN_LGSP.LGSPNode candidate_methodNameExistsSuper_node_cls = methodNameExistsSuper_node_cls;
                // SubPreset methodNameExistsSuper_node_opForName 
                GRGEN_LGSP.LGSPNode candidate_methodNameExistsSuper_node_opForName = methodNameExistsSuper_node_opForName;
                // Extend Outgoing methodNameExistsSuper_alt_0_super_edge__edge0 from methodNameExistsSuper_node_cls 
                GRGEN_LGSP.LGSPEdge head_candidate_methodNameExistsSuper_alt_0_super_edge__edge0 = candidate_methodNameExistsSuper_node_cls.lgspOuthead;
                if(head_candidate_methodNameExistsSuper_alt_0_super_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_methodNameExistsSuper_alt_0_super_edge__edge0 = head_candidate_methodNameExistsSuper_alt_0_super_edge__edge0;
                    do
                    {
                        if(candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspType.TypeID!=5) {
                            continue;
                        }
                        if((candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Implicit Target methodNameExistsSuper_alt_0_super_node_super from methodNameExistsSuper_alt_0_super_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_methodNameExistsSuper_alt_0_super_node_super = candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspTarget;
                        if(candidate_methodNameExistsSuper_alt_0_super_node_super.lgspType.TypeID!=3) {
                            continue;
                        }
                        if((candidate_methodNameExistsSuper_alt_0_super_node_super.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        if((candidate_methodNameExistsSuper_alt_0_super_node_super.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                        {
                            continue;
                        }
                        // Push subpattern matching task for _sub0
                        PatternAction_methodNameExistsSuper taskFor__sub0 = PatternAction_methodNameExistsSuper.getNewTask(graph, openTasks);
                        taskFor__sub0.methodNameExistsSuper_node_opForName = candidate_methodNameExistsSuper_node_opForName;
                        taskFor__sub0.methodNameExistsSuper_node_cls = candidate_methodNameExistsSuper_alt_0_super_node_super;
                        taskFor__sub0.searchPatternpath = false;
                        taskFor__sub0.matchOfNestingPattern = null;
                        taskFor__sub0.lastMatchAtPreviousNestingLevel = null;
                        openTasks.Push(taskFor__sub0);
                        uint prevGlobal__candidate_methodNameExistsSuper_alt_0_super_node_super;
                        prevGlobal__candidate_methodNameExistsSuper_alt_0_super_node_super = candidate_methodNameExistsSuper_alt_0_super_node_super.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_methodNameExistsSuper_alt_0_super_node_super.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        uint prevGlobal__candidate_methodNameExistsSuper_alt_0_super_edge__edge0;
                        prevGlobal__candidate_methodNameExistsSuper_alt_0_super_edge__edge0 = candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns 
                        openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                        // Pop subpattern matching task for _sub0
                        openTasks.Pop();
                        PatternAction_methodNameExistsSuper.releaseTask(taskFor__sub0);
                        // Check whether subpatterns were found 
                        if(matchesList.Count>0) {
                            // subpatterns/alternatives were found, extend the partial matches by our local match object
                            foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                            {
                                Pattern_methodNameExistsSuper.Match_methodNameExistsSuper_alt_0_super match = new Pattern_methodNameExistsSuper.Match_methodNameExistsSuper_alt_0_super();
                                match._node_cls = candidate_methodNameExistsSuper_node_cls;
                                match._node_super = candidate_methodNameExistsSuper_alt_0_super_node_super;
                                match._node_opForName = candidate_methodNameExistsSuper_node_opForName;
                                match._edge__edge0 = candidate_methodNameExistsSuper_alt_0_super_edge__edge0;
                                match.__sub0 = (@Pattern_methodNameExistsSuper.Match_methodNameExistsSuper)currentFoundPartialMatch.Pop();
                                match.__sub0._matchOfEnclosingPattern = match;
                                currentFoundPartialMatch.Push(match);
                            }
                            if(matchesList==foundPartialMatches) {
                                matchesList = new List<Stack<GRGEN_LIBGR.IMatch>>();
                            } else {
                                foreach(Stack<GRGEN_LIBGR.IMatch> match in matchesList) {
                                    foundPartialMatches.Add(match);
                                }
                                matchesList.Clear();
                            }
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && foundPartialMatches.Count >= maxMatches)
                            {
                                candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspFlags = candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_alt_0_super_edge__edge0;
                                candidate_methodNameExistsSuper_alt_0_super_node_super.lgspFlags = candidate_methodNameExistsSuper_alt_0_super_node_super.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_alt_0_super_node_super;
                                openTasks.Push(this);
                                return;
                            }
                            candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspFlags = candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_alt_0_super_edge__edge0;
                            candidate_methodNameExistsSuper_alt_0_super_node_super.lgspFlags = candidate_methodNameExistsSuper_alt_0_super_node_super.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_alt_0_super_node_super;
                            continue;
                        }
                        candidate_methodNameExistsSuper_alt_0_super_node_super.lgspFlags = candidate_methodNameExistsSuper_alt_0_super_node_super.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_alt_0_super_node_super;
                        candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspFlags = candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExistsSuper_alt_0_super_edge__edge0;
                    }
                    while( (candidate_methodNameExistsSuper_alt_0_super_edge__edge0 = candidate_methodNameExistsSuper_alt_0_super_edge__edge0.lgspOutNext) != head_candidate_methodNameExistsSuper_alt_0_super_edge__edge0 );
                }
            } while(false);
            openTasks.Push(this);
            return;
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpGxl
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpGxl_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpGxl.IMatch_dumpGxl match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpGxl_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpGxl_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpGxl_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpGxl_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpGxl_var_v);
    }
    
    public class Action_dumpGxl : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpGxl
    {
        public Action_dumpGxl() {
            _rulePattern = Rule_dumpGxl.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpGxl.Match_dumpGxl, Rule_dumpGxl.IMatch_dumpGxl>(this);
        }

        public Rule_dumpGxl _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpGxl"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpGxl.Match_dumpGxl, Rule_dumpGxl.IMatch_dumpGxl> matches;

        public static Action_dumpGxl Instance { get { return instance; } }
        private static Action_dumpGxl instance = new Action_dumpGxl();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpGxl_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpGxl_var_v = (System.Int32)dumpGxl_var_v;
            Rule_dumpGxl.Match_dumpGxl match = matches.GetNextUnfilledPosition();
            match._var_v = var_dumpGxl_var_v;
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpGxl_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpGxl_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpGxl_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpGxl.IMatch_dumpGxl match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl> matches)
        {
            foreach(Rule_dumpGxl.IMatch_dumpGxl match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpGxl_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpGxl_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpGxl_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpGxl_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpGxl.IMatch_dumpGxl match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpGxl_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpGxl_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpGxl_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpGxl_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpGxl_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpGxl_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpGxl_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpGxl.IMatch_dumpGxl)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpGxl.IMatch_dumpGxl>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodePackage
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodePackage_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodePackage.IMatch_dumpNodePackage match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodePackage_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodePackage_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodePackage_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodePackage_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodePackage_var_v);
    }
    
    public class Action_dumpNodePackage : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodePackage
    {
        public Action_dumpNodePackage() {
            _rulePattern = Rule_dumpNodePackage.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodePackage.Match_dumpNodePackage, Rule_dumpNodePackage.IMatch_dumpNodePackage>(this);
        }

        public Rule_dumpNodePackage _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodePackage"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodePackage.Match_dumpNodePackage, Rule_dumpNodePackage.IMatch_dumpNodePackage> matches;

        public static Action_dumpNodePackage Instance { get { return instance; } }
        private static Action_dumpNodePackage instance = new Action_dumpNodePackage();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodePackage_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodePackage_var_v = (System.Int32)dumpNodePackage_var_v;
            // Lookup dumpNodePackage_node_n 
            int type_id_candidate_dumpNodePackage_node_n = 1;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodePackage_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodePackage_node_n], candidate_dumpNodePackage_node_n = head_candidate_dumpNodePackage_node_n.lgspTypeNext; candidate_dumpNodePackage_node_n != head_candidate_dumpNodePackage_node_n; candidate_dumpNodePackage_node_n = candidate_dumpNodePackage_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodePackage_node_n, var_dumpNodePackage_var_v))) {
                    continue;
                }
                Rule_dumpNodePackage.Match_dumpNodePackage match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodePackage_node_n;
                match._var_v = var_dumpNodePackage_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodePackage_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodePackage_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodePackage_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodePackage_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodePackage.IMatch_dumpNodePackage match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> matches)
        {
            foreach(Rule_dumpNodePackage.IMatch_dumpNodePackage match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodePackage_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodePackage_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodePackage_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodePackage_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodePackage.IMatch_dumpNodePackage match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodePackage_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodePackage_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodePackage_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodePackage_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodePackage_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodePackage_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodePackage_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodePackage.IMatch_dumpNodePackage)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodePackage.IMatch_dumpNodePackage>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeClass
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeClass_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeClass.IMatch_dumpNodeClass match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeClass_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeClass_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeClass_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeClass_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeClass_var_v);
    }
    
    public class Action_dumpNodeClass : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeClass
    {
        public Action_dumpNodeClass() {
            _rulePattern = Rule_dumpNodeClass.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeClass.Match_dumpNodeClass, Rule_dumpNodeClass.IMatch_dumpNodeClass>(this);
        }

        public Rule_dumpNodeClass _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeClass"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeClass.Match_dumpNodeClass, Rule_dumpNodeClass.IMatch_dumpNodeClass> matches;

        public static Action_dumpNodeClass Instance { get { return instance; } }
        private static Action_dumpNodeClass instance = new Action_dumpNodeClass();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeClass_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeClass_var_v = (System.Int32)dumpNodeClass_var_v;
            // Lookup dumpNodeClass_node_n 
            int type_id_candidate_dumpNodeClass_node_n = 3;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeClass_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeClass_node_n], candidate_dumpNodeClass_node_n = head_candidate_dumpNodeClass_node_n.lgspTypeNext; candidate_dumpNodeClass_node_n != head_candidate_dumpNodeClass_node_n; candidate_dumpNodeClass_node_n = candidate_dumpNodeClass_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeClass_node_n, var_dumpNodeClass_var_v))) {
                    continue;
                }
                Rule_dumpNodeClass.Match_dumpNodeClass match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeClass_node_n;
                match._var_v = var_dumpNodeClass_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeClass_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeClass_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeClass_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeClass_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeClass.IMatch_dumpNodeClass match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> matches)
        {
            foreach(Rule_dumpNodeClass.IMatch_dumpNodeClass match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeClass_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeClass_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeClass_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeClass_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeClass.IMatch_dumpNodeClass match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeClass_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeClass_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeClass_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeClass_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeClass_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeClass_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeClass_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeClass.IMatch_dumpNodeClass)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeClass.IMatch_dumpNodeClass>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeInterface
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeInterface_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeInterface.IMatch_dumpNodeInterface match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeInterface_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeInterface_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeInterface_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeInterface_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeInterface_var_v);
    }
    
    public class Action_dumpNodeInterface : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeInterface
    {
        public Action_dumpNodeInterface() {
            _rulePattern = Rule_dumpNodeInterface.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeInterface.Match_dumpNodeInterface, Rule_dumpNodeInterface.IMatch_dumpNodeInterface>(this);
        }

        public Rule_dumpNodeInterface _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeInterface"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeInterface.Match_dumpNodeInterface, Rule_dumpNodeInterface.IMatch_dumpNodeInterface> matches;

        public static Action_dumpNodeInterface Instance { get { return instance; } }
        private static Action_dumpNodeInterface instance = new Action_dumpNodeInterface();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeInterface_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeInterface_var_v = (System.Int32)dumpNodeInterface_var_v;
            // Lookup dumpNodeInterface_node_n 
            int type_id_candidate_dumpNodeInterface_node_n = 4;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeInterface_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeInterface_node_n], candidate_dumpNodeInterface_node_n = head_candidate_dumpNodeInterface_node_n.lgspTypeNext; candidate_dumpNodeInterface_node_n != head_candidate_dumpNodeInterface_node_n; candidate_dumpNodeInterface_node_n = candidate_dumpNodeInterface_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeInterface_node_n, var_dumpNodeInterface_var_v))) {
                    continue;
                }
                Rule_dumpNodeInterface.Match_dumpNodeInterface match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeInterface_node_n;
                match._var_v = var_dumpNodeInterface_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeInterface_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeInterface_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeInterface_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeInterface_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeInterface.IMatch_dumpNodeInterface match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> matches)
        {
            foreach(Rule_dumpNodeInterface.IMatch_dumpNodeInterface match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeInterface_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeInterface_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeInterface_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeInterface_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeInterface.IMatch_dumpNodeInterface match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeInterface_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeInterface_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeInterface_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeInterface_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeInterface_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeInterface_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeInterface_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeInterface.IMatch_dumpNodeInterface)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeInterface.IMatch_dumpNodeInterface>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeVariable
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeVariable_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeVariable.IMatch_dumpNodeVariable match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeVariable_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeVariable_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeVariable_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeVariable_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeVariable_var_v);
    }
    
    public class Action_dumpNodeVariable : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeVariable
    {
        public Action_dumpNodeVariable() {
            _rulePattern = Rule_dumpNodeVariable.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeVariable.Match_dumpNodeVariable, Rule_dumpNodeVariable.IMatch_dumpNodeVariable>(this);
        }

        public Rule_dumpNodeVariable _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeVariable"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeVariable.Match_dumpNodeVariable, Rule_dumpNodeVariable.IMatch_dumpNodeVariable> matches;

        public static Action_dumpNodeVariable Instance { get { return instance; } }
        private static Action_dumpNodeVariable instance = new Action_dumpNodeVariable();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeVariable_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeVariable_var_v = (System.Int32)dumpNodeVariable_var_v;
            // Lookup dumpNodeVariable_node_n 
            int type_id_candidate_dumpNodeVariable_node_n = 5;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeVariable_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeVariable_node_n], candidate_dumpNodeVariable_node_n = head_candidate_dumpNodeVariable_node_n.lgspTypeNext; candidate_dumpNodeVariable_node_n != head_candidate_dumpNodeVariable_node_n; candidate_dumpNodeVariable_node_n = candidate_dumpNodeVariable_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeVariable_node_n, var_dumpNodeVariable_var_v))) {
                    continue;
                }
                Rule_dumpNodeVariable.Match_dumpNodeVariable match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeVariable_node_n;
                match._var_v = var_dumpNodeVariable_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeVariable_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeVariable_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeVariable_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeVariable_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeVariable.IMatch_dumpNodeVariable match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> matches)
        {
            foreach(Rule_dumpNodeVariable.IMatch_dumpNodeVariable match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeVariable_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeVariable_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeVariable_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeVariable_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeVariable.IMatch_dumpNodeVariable match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeVariable_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeVariable_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeVariable_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeVariable_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeVariable_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeVariable_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeVariable_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeVariable.IMatch_dumpNodeVariable)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeVariable.IMatch_dumpNodeVariable>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeOperation
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeOperation_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeOperation.IMatch_dumpNodeOperation match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperation_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperation_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperation_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperation_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeOperation_var_v);
    }
    
    public class Action_dumpNodeOperation : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeOperation
    {
        public Action_dumpNodeOperation() {
            _rulePattern = Rule_dumpNodeOperation.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeOperation.Match_dumpNodeOperation, Rule_dumpNodeOperation.IMatch_dumpNodeOperation>(this);
        }

        public Rule_dumpNodeOperation _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeOperation"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeOperation.Match_dumpNodeOperation, Rule_dumpNodeOperation.IMatch_dumpNodeOperation> matches;

        public static Action_dumpNodeOperation Instance { get { return instance; } }
        private static Action_dumpNodeOperation instance = new Action_dumpNodeOperation();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeOperation_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeOperation_var_v = (System.Int32)dumpNodeOperation_var_v;
            // Lookup dumpNodeOperation_node_n 
            int type_id_candidate_dumpNodeOperation_node_n = 6;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeOperation_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeOperation_node_n], candidate_dumpNodeOperation_node_n = head_candidate_dumpNodeOperation_node_n.lgspTypeNext; candidate_dumpNodeOperation_node_n != head_candidate_dumpNodeOperation_node_n; candidate_dumpNodeOperation_node_n = candidate_dumpNodeOperation_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeOperation_node_n, var_dumpNodeOperation_var_v))) {
                    continue;
                }
                Rule_dumpNodeOperation.Match_dumpNodeOperation match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeOperation_node_n;
                match._var_v = var_dumpNodeOperation_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeOperation_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeOperation_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeOperation_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeOperation_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeOperation.IMatch_dumpNodeOperation match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> matches)
        {
            foreach(Rule_dumpNodeOperation.IMatch_dumpNodeOperation match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperation_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeOperation_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperation_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeOperation_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeOperation.IMatch_dumpNodeOperation match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperation_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeOperation_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperation_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeOperation_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeOperation_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeOperation_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeOperation_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeOperation.IMatch_dumpNodeOperation)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperation.IMatch_dumpNodeOperation>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeMethodBody
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeMethodBody_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeMethodBody_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeMethodBody_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeMethodBody_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeMethodBody_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeMethodBody_var_v);
    }
    
    public class Action_dumpNodeMethodBody : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeMethodBody
    {
        public Action_dumpNodeMethodBody() {
            _rulePattern = Rule_dumpNodeMethodBody.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeMethodBody.Match_dumpNodeMethodBody, Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody>(this);
        }

        public Rule_dumpNodeMethodBody _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeMethodBody"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeMethodBody.Match_dumpNodeMethodBody, Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> matches;

        public static Action_dumpNodeMethodBody Instance { get { return instance; } }
        private static Action_dumpNodeMethodBody instance = new Action_dumpNodeMethodBody();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeMethodBody_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeMethodBody_var_v = (System.Int32)dumpNodeMethodBody_var_v;
            // Lookup dumpNodeMethodBody_node_n 
            int type_id_candidate_dumpNodeMethodBody_node_n = 7;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeMethodBody_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeMethodBody_node_n], candidate_dumpNodeMethodBody_node_n = head_candidate_dumpNodeMethodBody_node_n.lgspTypeNext; candidate_dumpNodeMethodBody_node_n != head_candidate_dumpNodeMethodBody_node_n; candidate_dumpNodeMethodBody_node_n = candidate_dumpNodeMethodBody_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeMethodBody_node_n, var_dumpNodeMethodBody_var_v))) {
                    continue;
                }
                Rule_dumpNodeMethodBody.Match_dumpNodeMethodBody match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeMethodBody_node_n;
                match._var_v = var_dumpNodeMethodBody_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeMethodBody_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeMethodBody_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeMethodBody_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeMethodBody_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> matches)
        {
            foreach(Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeMethodBody_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeMethodBody_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeMethodBody_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeMethodBody_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeMethodBody_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeMethodBody_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeMethodBody_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeMethodBody_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeMethodBody_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeMethodBody_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeMethodBody_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeMethodBody.IMatch_dumpNodeMethodBody>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeAccess
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeAccess_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeAccess.IMatch_dumpNodeAccess match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeAccess_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeAccess_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeAccess_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeAccess_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeAccess_var_v);
    }
    
    public class Action_dumpNodeAccess : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeAccess
    {
        public Action_dumpNodeAccess() {
            _rulePattern = Rule_dumpNodeAccess.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeAccess.Match_dumpNodeAccess, Rule_dumpNodeAccess.IMatch_dumpNodeAccess>(this);
        }

        public Rule_dumpNodeAccess _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeAccess"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeAccess.Match_dumpNodeAccess, Rule_dumpNodeAccess.IMatch_dumpNodeAccess> matches;

        public static Action_dumpNodeAccess Instance { get { return instance; } }
        private static Action_dumpNodeAccess instance = new Action_dumpNodeAccess();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeAccess_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeAccess_var_v = (System.Int32)dumpNodeAccess_var_v;
            // Lookup dumpNodeAccess_node_n 
            int type_id_candidate_dumpNodeAccess_node_n = 9;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeAccess_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeAccess_node_n], candidate_dumpNodeAccess_node_n = head_candidate_dumpNodeAccess_node_n.lgspTypeNext; candidate_dumpNodeAccess_node_n != head_candidate_dumpNodeAccess_node_n; candidate_dumpNodeAccess_node_n = candidate_dumpNodeAccess_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeAccess_node_n, var_dumpNodeAccess_var_v))) {
                    continue;
                }
                Rule_dumpNodeAccess.Match_dumpNodeAccess match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeAccess_node_n;
                match._var_v = var_dumpNodeAccess_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeAccess_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeAccess_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeAccess_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeAccess_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeAccess.IMatch_dumpNodeAccess match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> matches)
        {
            foreach(Rule_dumpNodeAccess.IMatch_dumpNodeAccess match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeAccess_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeAccess_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeAccess_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeAccess_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeAccess.IMatch_dumpNodeAccess match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeAccess_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeAccess_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeAccess_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeAccess_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeAccess_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeAccess_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeAccess_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeAccess.IMatch_dumpNodeAccess)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeAccess.IMatch_dumpNodeAccess>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeUpdate
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeUpdate_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeUpdate_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeUpdate_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeUpdate_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeUpdate_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeUpdate_var_v);
    }
    
    public class Action_dumpNodeUpdate : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeUpdate
    {
        public Action_dumpNodeUpdate() {
            _rulePattern = Rule_dumpNodeUpdate.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeUpdate.Match_dumpNodeUpdate, Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate>(this);
        }

        public Rule_dumpNodeUpdate _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeUpdate"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeUpdate.Match_dumpNodeUpdate, Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> matches;

        public static Action_dumpNodeUpdate Instance { get { return instance; } }
        private static Action_dumpNodeUpdate instance = new Action_dumpNodeUpdate();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeUpdate_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeUpdate_var_v = (System.Int32)dumpNodeUpdate_var_v;
            // Lookup dumpNodeUpdate_node_n 
            int type_id_candidate_dumpNodeUpdate_node_n = 10;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeUpdate_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeUpdate_node_n], candidate_dumpNodeUpdate_node_n = head_candidate_dumpNodeUpdate_node_n.lgspTypeNext; candidate_dumpNodeUpdate_node_n != head_candidate_dumpNodeUpdate_node_n; candidate_dumpNodeUpdate_node_n = candidate_dumpNodeUpdate_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeUpdate_node_n, var_dumpNodeUpdate_var_v))) {
                    continue;
                }
                Rule_dumpNodeUpdate.Match_dumpNodeUpdate match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeUpdate_node_n;
                match._var_v = var_dumpNodeUpdate_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeUpdate_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeUpdate_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeUpdate_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeUpdate_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> matches)
        {
            foreach(Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeUpdate_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeUpdate_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeUpdate_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeUpdate_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeUpdate_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeUpdate_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeUpdate_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeUpdate_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeUpdate_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeUpdate_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeUpdate_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeUpdate.IMatch_dumpNodeUpdate>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeCall
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeCall_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeCall.IMatch_dumpNodeCall match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeCall_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeCall_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeCall_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeCall_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeCall_var_v);
    }
    
    public class Action_dumpNodeCall : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeCall
    {
        public Action_dumpNodeCall() {
            _rulePattern = Rule_dumpNodeCall.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeCall.Match_dumpNodeCall, Rule_dumpNodeCall.IMatch_dumpNodeCall>(this);
        }

        public Rule_dumpNodeCall _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeCall"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeCall.Match_dumpNodeCall, Rule_dumpNodeCall.IMatch_dumpNodeCall> matches;

        public static Action_dumpNodeCall Instance { get { return instance; } }
        private static Action_dumpNodeCall instance = new Action_dumpNodeCall();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeCall_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeCall_var_v = (System.Int32)dumpNodeCall_var_v;
            // Lookup dumpNodeCall_node_n 
            int type_id_candidate_dumpNodeCall_node_n = 11;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeCall_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeCall_node_n], candidate_dumpNodeCall_node_n = head_candidate_dumpNodeCall_node_n.lgspTypeNext; candidate_dumpNodeCall_node_n != head_candidate_dumpNodeCall_node_n; candidate_dumpNodeCall_node_n = candidate_dumpNodeCall_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeCall_node_n, var_dumpNodeCall_var_v))) {
                    continue;
                }
                Rule_dumpNodeCall.Match_dumpNodeCall match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeCall_node_n;
                match._var_v = var_dumpNodeCall_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeCall_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeCall_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeCall_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeCall_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeCall.IMatch_dumpNodeCall match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> matches)
        {
            foreach(Rule_dumpNodeCall.IMatch_dumpNodeCall match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeCall_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeCall_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeCall_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeCall_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeCall.IMatch_dumpNodeCall match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeCall_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeCall_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeCall_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeCall_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeCall_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeCall_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeCall_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeCall.IMatch_dumpNodeCall)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeCall.IMatch_dumpNodeCall>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeIstantiation
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeIstantiation_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeIstantiation_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeIstantiation_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeIstantiation_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeIstantiation_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeIstantiation_var_v);
    }
    
    public class Action_dumpNodeIstantiation : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeIstantiation
    {
        public Action_dumpNodeIstantiation() {
            _rulePattern = Rule_dumpNodeIstantiation.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeIstantiation.Match_dumpNodeIstantiation, Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation>(this);
        }

        public Rule_dumpNodeIstantiation _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeIstantiation"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeIstantiation.Match_dumpNodeIstantiation, Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> matches;

        public static Action_dumpNodeIstantiation Instance { get { return instance; } }
        private static Action_dumpNodeIstantiation instance = new Action_dumpNodeIstantiation();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeIstantiation_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeIstantiation_var_v = (System.Int32)dumpNodeIstantiation_var_v;
            // Lookup dumpNodeIstantiation_node_n 
            int type_id_candidate_dumpNodeIstantiation_node_n = 12;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeIstantiation_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeIstantiation_node_n], candidate_dumpNodeIstantiation_node_n = head_candidate_dumpNodeIstantiation_node_n.lgspTypeNext; candidate_dumpNodeIstantiation_node_n != head_candidate_dumpNodeIstantiation_node_n; candidate_dumpNodeIstantiation_node_n = candidate_dumpNodeIstantiation_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeIstantiation_node_n, var_dumpNodeIstantiation_var_v))) {
                    continue;
                }
                Rule_dumpNodeIstantiation.Match_dumpNodeIstantiation match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeIstantiation_node_n;
                match._var_v = var_dumpNodeIstantiation_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeIstantiation_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeIstantiation_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeIstantiation_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeIstantiation_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> matches)
        {
            foreach(Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeIstantiation_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeIstantiation_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeIstantiation_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeIstantiation_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeIstantiation_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeIstantiation_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeIstantiation_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeIstantiation_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeIstantiation_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeIstantiation_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeIstantiation_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeIstantiation.IMatch_dumpNodeIstantiation>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeOperator
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeOperator_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeOperator.IMatch_dumpNodeOperator match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperator_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperator_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperator_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperator_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeOperator_var_v);
    }
    
    public class Action_dumpNodeOperator : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeOperator
    {
        public Action_dumpNodeOperator() {
            _rulePattern = Rule_dumpNodeOperator.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeOperator.Match_dumpNodeOperator, Rule_dumpNodeOperator.IMatch_dumpNodeOperator>(this);
        }

        public Rule_dumpNodeOperator _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeOperator"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeOperator.Match_dumpNodeOperator, Rule_dumpNodeOperator.IMatch_dumpNodeOperator> matches;

        public static Action_dumpNodeOperator Instance { get { return instance; } }
        private static Action_dumpNodeOperator instance = new Action_dumpNodeOperator();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeOperator_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeOperator_var_v = (System.Int32)dumpNodeOperator_var_v;
            // Lookup dumpNodeOperator_node_n 
            int type_id_candidate_dumpNodeOperator_node_n = 13;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeOperator_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeOperator_node_n], candidate_dumpNodeOperator_node_n = head_candidate_dumpNodeOperator_node_n.lgspTypeNext; candidate_dumpNodeOperator_node_n != head_candidate_dumpNodeOperator_node_n; candidate_dumpNodeOperator_node_n = candidate_dumpNodeOperator_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeOperator_node_n, var_dumpNodeOperator_var_v))) {
                    continue;
                }
                Rule_dumpNodeOperator.Match_dumpNodeOperator match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeOperator_node_n;
                match._var_v = var_dumpNodeOperator_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeOperator_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeOperator_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeOperator_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeOperator_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeOperator.IMatch_dumpNodeOperator match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> matches)
        {
            foreach(Rule_dumpNodeOperator.IMatch_dumpNodeOperator match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperator_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeOperator_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperator_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeOperator_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeOperator.IMatch_dumpNodeOperator match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperator_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeOperator_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeOperator_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeOperator_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeOperator_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeOperator_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeOperator_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeOperator.IMatch_dumpNodeOperator)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeOperator.IMatch_dumpNodeOperator>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeReturn
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeReturn_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeReturn.IMatch_dumpNodeReturn match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeReturn_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeReturn_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeReturn_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeReturn_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeReturn_var_v);
    }
    
    public class Action_dumpNodeReturn : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeReturn
    {
        public Action_dumpNodeReturn() {
            _rulePattern = Rule_dumpNodeReturn.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeReturn.Match_dumpNodeReturn, Rule_dumpNodeReturn.IMatch_dumpNodeReturn>(this);
        }

        public Rule_dumpNodeReturn _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeReturn"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeReturn.Match_dumpNodeReturn, Rule_dumpNodeReturn.IMatch_dumpNodeReturn> matches;

        public static Action_dumpNodeReturn Instance { get { return instance; } }
        private static Action_dumpNodeReturn instance = new Action_dumpNodeReturn();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeReturn_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeReturn_var_v = (System.Int32)dumpNodeReturn_var_v;
            // Lookup dumpNodeReturn_node_n 
            int type_id_candidate_dumpNodeReturn_node_n = 14;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeReturn_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeReturn_node_n], candidate_dumpNodeReturn_node_n = head_candidate_dumpNodeReturn_node_n.lgspTypeNext; candidate_dumpNodeReturn_node_n != head_candidate_dumpNodeReturn_node_n; candidate_dumpNodeReturn_node_n = candidate_dumpNodeReturn_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeReturn_node_n, var_dumpNodeReturn_var_v))) {
                    continue;
                }
                Rule_dumpNodeReturn.Match_dumpNodeReturn match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeReturn_node_n;
                match._var_v = var_dumpNodeReturn_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeReturn_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeReturn_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeReturn_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeReturn_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeReturn.IMatch_dumpNodeReturn match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> matches)
        {
            foreach(Rule_dumpNodeReturn.IMatch_dumpNodeReturn match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeReturn_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeReturn_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeReturn_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeReturn_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeReturn.IMatch_dumpNodeReturn match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeReturn_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeReturn_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeReturn_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeReturn_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeReturn_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeReturn_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeReturn_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeReturn.IMatch_dumpNodeReturn)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeReturn.IMatch_dumpNodeReturn>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeBlock
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeBlock_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeBlock.IMatch_dumpNodeBlock match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeBlock_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeBlock_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeBlock_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeBlock_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeBlock_var_v);
    }
    
    public class Action_dumpNodeBlock : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeBlock
    {
        public Action_dumpNodeBlock() {
            _rulePattern = Rule_dumpNodeBlock.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeBlock.Match_dumpNodeBlock, Rule_dumpNodeBlock.IMatch_dumpNodeBlock>(this);
        }

        public Rule_dumpNodeBlock _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeBlock"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeBlock.Match_dumpNodeBlock, Rule_dumpNodeBlock.IMatch_dumpNodeBlock> matches;

        public static Action_dumpNodeBlock Instance { get { return instance; } }
        private static Action_dumpNodeBlock instance = new Action_dumpNodeBlock();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeBlock_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeBlock_var_v = (System.Int32)dumpNodeBlock_var_v;
            // Lookup dumpNodeBlock_node_n 
            int type_id_candidate_dumpNodeBlock_node_n = 15;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeBlock_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeBlock_node_n], candidate_dumpNodeBlock_node_n = head_candidate_dumpNodeBlock_node_n.lgspTypeNext; candidate_dumpNodeBlock_node_n != head_candidate_dumpNodeBlock_node_n; candidate_dumpNodeBlock_node_n = candidate_dumpNodeBlock_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeBlock_node_n, var_dumpNodeBlock_var_v))) {
                    continue;
                }
                Rule_dumpNodeBlock.Match_dumpNodeBlock match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeBlock_node_n;
                match._var_v = var_dumpNodeBlock_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeBlock_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeBlock_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeBlock_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeBlock_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeBlock.IMatch_dumpNodeBlock match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> matches)
        {
            foreach(Rule_dumpNodeBlock.IMatch_dumpNodeBlock match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeBlock_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeBlock_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeBlock_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeBlock_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeBlock.IMatch_dumpNodeBlock match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeBlock_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeBlock_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeBlock_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeBlock_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeBlock_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeBlock_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeBlock_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeBlock.IMatch_dumpNodeBlock)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeBlock.IMatch_dumpNodeBlock>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeLiteral
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeLiteral_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeLiteral_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeLiteral_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeLiteral_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeLiteral_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeLiteral_var_v);
    }
    
    public class Action_dumpNodeLiteral : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeLiteral
    {
        public Action_dumpNodeLiteral() {
            _rulePattern = Rule_dumpNodeLiteral.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeLiteral.Match_dumpNodeLiteral, Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral>(this);
        }

        public Rule_dumpNodeLiteral _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeLiteral"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeLiteral.Match_dumpNodeLiteral, Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> matches;

        public static Action_dumpNodeLiteral Instance { get { return instance; } }
        private static Action_dumpNodeLiteral instance = new Action_dumpNodeLiteral();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeLiteral_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeLiteral_var_v = (System.Int32)dumpNodeLiteral_var_v;
            // Lookup dumpNodeLiteral_node_n 
            int type_id_candidate_dumpNodeLiteral_node_n = 16;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeLiteral_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeLiteral_node_n], candidate_dumpNodeLiteral_node_n = head_candidate_dumpNodeLiteral_node_n.lgspTypeNext; candidate_dumpNodeLiteral_node_n != head_candidate_dumpNodeLiteral_node_n; candidate_dumpNodeLiteral_node_n = candidate_dumpNodeLiteral_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeLiteral_node_n, var_dumpNodeLiteral_var_v))) {
                    continue;
                }
                Rule_dumpNodeLiteral.Match_dumpNodeLiteral match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeLiteral_node_n;
                match._var_v = var_dumpNodeLiteral_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeLiteral_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeLiteral_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeLiteral_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeLiteral_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> matches)
        {
            foreach(Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeLiteral_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeLiteral_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeLiteral_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeLiteral_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeLiteral_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeLiteral_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeLiteral_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeLiteral_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeLiteral_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeLiteral_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeLiteral_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeLiteral.IMatch_dumpNodeLiteral>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpNodeParameter
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeParameter_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeParameter.IMatch_dumpNodeParameter match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeParameter_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeParameter_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeParameter_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeParameter_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeParameter_var_v);
    }
    
    public class Action_dumpNodeParameter : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpNodeParameter
    {
        public Action_dumpNodeParameter() {
            _rulePattern = Rule_dumpNodeParameter.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeParameter.Match_dumpNodeParameter, Rule_dumpNodeParameter.IMatch_dumpNodeParameter>(this);
        }

        public Rule_dumpNodeParameter _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpNodeParameter"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpNodeParameter.Match_dumpNodeParameter, Rule_dumpNodeParameter.IMatch_dumpNodeParameter> matches;

        public static Action_dumpNodeParameter Instance { get { return instance; } }
        private static Action_dumpNodeParameter instance = new Action_dumpNodeParameter();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeParameter_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpNodeParameter_var_v = (System.Int32)dumpNodeParameter_var_v;
            // Lookup dumpNodeParameter_node_n 
            int type_id_candidate_dumpNodeParameter_node_n = 17;
            for(GRGEN_LGSP.LGSPNode head_candidate_dumpNodeParameter_node_n = graph.nodesByTypeHeads[type_id_candidate_dumpNodeParameter_node_n], candidate_dumpNodeParameter_node_n = head_candidate_dumpNodeParameter_node_n.lgspTypeNext; candidate_dumpNodeParameter_node_n != head_candidate_dumpNodeParameter_node_n; candidate_dumpNodeParameter_node_n = candidate_dumpNodeParameter_node_n.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpNodeParameter_node_n, var_dumpNodeParameter_var_v))) {
                    continue;
                }
                Rule_dumpNodeParameter.Match_dumpNodeParameter match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_dumpNodeParameter_node_n;
                match._var_v = var_dumpNodeParameter_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpNodeParameter_node_n);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpNodeParameter_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpNodeParameter_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeParameter_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpNodeParameter.IMatch_dumpNodeParameter match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> matches)
        {
            foreach(Rule_dumpNodeParameter.IMatch_dumpNodeParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeParameter_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpNodeParameter_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpNodeParameter.IMatch_dumpNodeParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeParameter_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpNodeParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeParameter_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeParameter_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpNodeParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpNodeParameter_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpNodeParameter.IMatch_dumpNodeParameter)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpNodeParameter.IMatch_dumpNodeParameter>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpEdgeBelongsTo
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeBelongsTo_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBelongsTo_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBelongsTo_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBelongsTo_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBelongsTo_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeBelongsTo_var_v);
    }
    
    public class Action_dumpEdgeBelongsTo : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpEdgeBelongsTo
    {
        public Action_dumpEdgeBelongsTo() {
            _rulePattern = Rule_dumpEdgeBelongsTo.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeBelongsTo.Match_dumpEdgeBelongsTo, Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo>(this);
        }

        public Rule_dumpEdgeBelongsTo _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpEdgeBelongsTo"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeBelongsTo.Match_dumpEdgeBelongsTo, Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> matches;

        public static Action_dumpEdgeBelongsTo Instance { get { return instance; } }
        private static Action_dumpEdgeBelongsTo instance = new Action_dumpEdgeBelongsTo();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeBelongsTo_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpEdgeBelongsTo_var_v = (System.Int32)dumpEdgeBelongsTo_var_v;
            // Lookup dumpEdgeBelongsTo_edge_e 
            int type_id_candidate_dumpEdgeBelongsTo_edge_e = 3;
            for(GRGEN_LGSP.LGSPEdge head_candidate_dumpEdgeBelongsTo_edge_e = graph.edgesByTypeHeads[type_id_candidate_dumpEdgeBelongsTo_edge_e], candidate_dumpEdgeBelongsTo_edge_e = head_candidate_dumpEdgeBelongsTo_edge_e.lgspTypeNext; candidate_dumpEdgeBelongsTo_edge_e != head_candidate_dumpEdgeBelongsTo_edge_e; candidate_dumpEdgeBelongsTo_edge_e = candidate_dumpEdgeBelongsTo_edge_e.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpEdgeBelongsTo_edge_e, var_dumpEdgeBelongsTo_var_v))) {
                    continue;
                }
                // Implicit Source dumpEdgeBelongsTo_node_src from dumpEdgeBelongsTo_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeBelongsTo_node_src = candidate_dumpEdgeBelongsTo_edge_e.lgspSource;
                uint prev__candidate_dumpEdgeBelongsTo_node_src;
                prev__candidate_dumpEdgeBelongsTo_node_src = candidate_dumpEdgeBelongsTo_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_dumpEdgeBelongsTo_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target dumpEdgeBelongsTo_node_tgt from dumpEdgeBelongsTo_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeBelongsTo_node_tgt = candidate_dumpEdgeBelongsTo_edge_e.lgspTarget;
                if((candidate_dumpEdgeBelongsTo_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_dumpEdgeBelongsTo_node_src.lgspFlags = candidate_dumpEdgeBelongsTo_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeBelongsTo_node_src;
                    continue;
                }
                Rule_dumpEdgeBelongsTo.Match_dumpEdgeBelongsTo match = matches.GetNextUnfilledPosition();
                match._node_src = candidate_dumpEdgeBelongsTo_node_src;
                match._node_tgt = candidate_dumpEdgeBelongsTo_node_tgt;
                match._edge_e = candidate_dumpEdgeBelongsTo_edge_e;
                match._var_v = var_dumpEdgeBelongsTo_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpEdgeBelongsTo_edge_e);
                    candidate_dumpEdgeBelongsTo_node_src.lgspFlags = candidate_dumpEdgeBelongsTo_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeBelongsTo_node_src;
                    return matches;
                }
                candidate_dumpEdgeBelongsTo_node_src.lgspFlags = candidate_dumpEdgeBelongsTo_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeBelongsTo_node_src;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeBelongsTo_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeBelongsTo_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeBelongsTo_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> matches)
        {
            foreach(Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBelongsTo_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeBelongsTo_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBelongsTo_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeBelongsTo_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBelongsTo_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeBelongsTo_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBelongsTo_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeBelongsTo_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeBelongsTo_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeBelongsTo_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeBelongsTo_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBelongsTo.IMatch_dumpEdgeBelongsTo>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpEdgeType
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeType_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeType.IMatch_dumpEdgeType match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeType_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeType_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeType_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeType_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeType_var_v);
    }
    
    public class Action_dumpEdgeType : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpEdgeType
    {
        public Action_dumpEdgeType() {
            _rulePattern = Rule_dumpEdgeType.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeType.Match_dumpEdgeType, Rule_dumpEdgeType.IMatch_dumpEdgeType>(this);
        }

        public Rule_dumpEdgeType _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpEdgeType"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeType.Match_dumpEdgeType, Rule_dumpEdgeType.IMatch_dumpEdgeType> matches;

        public static Action_dumpEdgeType Instance { get { return instance; } }
        private static Action_dumpEdgeType instance = new Action_dumpEdgeType();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeType_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpEdgeType_var_v = (System.Int32)dumpEdgeType_var_v;
            // Lookup dumpEdgeType_edge_e 
            int type_id_candidate_dumpEdgeType_edge_e = 4;
            for(GRGEN_LGSP.LGSPEdge head_candidate_dumpEdgeType_edge_e = graph.edgesByTypeHeads[type_id_candidate_dumpEdgeType_edge_e], candidate_dumpEdgeType_edge_e = head_candidate_dumpEdgeType_edge_e.lgspTypeNext; candidate_dumpEdgeType_edge_e != head_candidate_dumpEdgeType_edge_e; candidate_dumpEdgeType_edge_e = candidate_dumpEdgeType_edge_e.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpEdgeType_edge_e, var_dumpEdgeType_var_v))) {
                    continue;
                }
                // Implicit Source dumpEdgeType_node_src from dumpEdgeType_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeType_node_src = candidate_dumpEdgeType_edge_e.lgspSource;
                uint prev__candidate_dumpEdgeType_node_src;
                prev__candidate_dumpEdgeType_node_src = candidate_dumpEdgeType_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_dumpEdgeType_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target dumpEdgeType_node_tgt from dumpEdgeType_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeType_node_tgt = candidate_dumpEdgeType_edge_e.lgspTarget;
                if((candidate_dumpEdgeType_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_dumpEdgeType_node_src.lgspFlags = candidate_dumpEdgeType_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeType_node_src;
                    continue;
                }
                Rule_dumpEdgeType.Match_dumpEdgeType match = matches.GetNextUnfilledPosition();
                match._node_src = candidate_dumpEdgeType_node_src;
                match._node_tgt = candidate_dumpEdgeType_node_tgt;
                match._edge_e = candidate_dumpEdgeType_edge_e;
                match._var_v = var_dumpEdgeType_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpEdgeType_edge_e);
                    candidate_dumpEdgeType_node_src.lgspFlags = candidate_dumpEdgeType_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeType_node_src;
                    return matches;
                }
                candidate_dumpEdgeType_node_src.lgspFlags = candidate_dumpEdgeType_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeType_node_src;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeType_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeType_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeType_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeType.IMatch_dumpEdgeType match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> matches)
        {
            foreach(Rule_dumpEdgeType.IMatch_dumpEdgeType match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeType_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeType_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeType_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeType_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpEdgeType.IMatch_dumpEdgeType match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeType_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeType_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeType_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeType_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeType_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeType_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeType_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpEdgeType.IMatch_dumpEdgeType)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeType.IMatch_dumpEdgeType>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpEdgeExtends
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeExtends_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExtends_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExtends_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExtends_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExtends_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeExtends_var_v);
    }
    
    public class Action_dumpEdgeExtends : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpEdgeExtends
    {
        public Action_dumpEdgeExtends() {
            _rulePattern = Rule_dumpEdgeExtends.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeExtends.Match_dumpEdgeExtends, Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends>(this);
        }

        public Rule_dumpEdgeExtends _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpEdgeExtends"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeExtends.Match_dumpEdgeExtends, Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> matches;

        public static Action_dumpEdgeExtends Instance { get { return instance; } }
        private static Action_dumpEdgeExtends instance = new Action_dumpEdgeExtends();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeExtends_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpEdgeExtends_var_v = (System.Int32)dumpEdgeExtends_var_v;
            // Lookup dumpEdgeExtends_edge_e 
            int type_id_candidate_dumpEdgeExtends_edge_e = 5;
            for(GRGEN_LGSP.LGSPEdge head_candidate_dumpEdgeExtends_edge_e = graph.edgesByTypeHeads[type_id_candidate_dumpEdgeExtends_edge_e], candidate_dumpEdgeExtends_edge_e = head_candidate_dumpEdgeExtends_edge_e.lgspTypeNext; candidate_dumpEdgeExtends_edge_e != head_candidate_dumpEdgeExtends_edge_e; candidate_dumpEdgeExtends_edge_e = candidate_dumpEdgeExtends_edge_e.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpEdgeExtends_edge_e, var_dumpEdgeExtends_var_v))) {
                    continue;
                }
                // Implicit Source dumpEdgeExtends_node_src from dumpEdgeExtends_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeExtends_node_src = candidate_dumpEdgeExtends_edge_e.lgspSource;
                uint prev__candidate_dumpEdgeExtends_node_src;
                prev__candidate_dumpEdgeExtends_node_src = candidate_dumpEdgeExtends_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_dumpEdgeExtends_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target dumpEdgeExtends_node_tgt from dumpEdgeExtends_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeExtends_node_tgt = candidate_dumpEdgeExtends_edge_e.lgspTarget;
                if((candidate_dumpEdgeExtends_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_dumpEdgeExtends_node_src.lgspFlags = candidate_dumpEdgeExtends_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeExtends_node_src;
                    continue;
                }
                Rule_dumpEdgeExtends.Match_dumpEdgeExtends match = matches.GetNextUnfilledPosition();
                match._node_src = candidate_dumpEdgeExtends_node_src;
                match._node_tgt = candidate_dumpEdgeExtends_node_tgt;
                match._edge_e = candidate_dumpEdgeExtends_edge_e;
                match._var_v = var_dumpEdgeExtends_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpEdgeExtends_edge_e);
                    candidate_dumpEdgeExtends_node_src.lgspFlags = candidate_dumpEdgeExtends_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeExtends_node_src;
                    return matches;
                }
                candidate_dumpEdgeExtends_node_src.lgspFlags = candidate_dumpEdgeExtends_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeExtends_node_src;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeExtends_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeExtends_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeExtends_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> matches)
        {
            foreach(Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExtends_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeExtends_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExtends_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeExtends_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExtends_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeExtends_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExtends_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeExtends_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeExtends_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeExtends_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeExtends_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExtends.IMatch_dumpEdgeExtends>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpEdgeImports
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeImports_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeImports.IMatch_dumpEdgeImports match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImports_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImports_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImports_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImports_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeImports_var_v);
    }
    
    public class Action_dumpEdgeImports : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpEdgeImports
    {
        public Action_dumpEdgeImports() {
            _rulePattern = Rule_dumpEdgeImports.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeImports.Match_dumpEdgeImports, Rule_dumpEdgeImports.IMatch_dumpEdgeImports>(this);
        }

        public Rule_dumpEdgeImports _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpEdgeImports"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeImports.Match_dumpEdgeImports, Rule_dumpEdgeImports.IMatch_dumpEdgeImports> matches;

        public static Action_dumpEdgeImports Instance { get { return instance; } }
        private static Action_dumpEdgeImports instance = new Action_dumpEdgeImports();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeImports_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpEdgeImports_var_v = (System.Int32)dumpEdgeImports_var_v;
            // Lookup dumpEdgeImports_edge_e 
            int type_id_candidate_dumpEdgeImports_edge_e = 6;
            for(GRGEN_LGSP.LGSPEdge head_candidate_dumpEdgeImports_edge_e = graph.edgesByTypeHeads[type_id_candidate_dumpEdgeImports_edge_e], candidate_dumpEdgeImports_edge_e = head_candidate_dumpEdgeImports_edge_e.lgspTypeNext; candidate_dumpEdgeImports_edge_e != head_candidate_dumpEdgeImports_edge_e; candidate_dumpEdgeImports_edge_e = candidate_dumpEdgeImports_edge_e.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpEdgeImports_edge_e, var_dumpEdgeImports_var_v))) {
                    continue;
                }
                // Implicit Source dumpEdgeImports_node_src from dumpEdgeImports_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeImports_node_src = candidate_dumpEdgeImports_edge_e.lgspSource;
                uint prev__candidate_dumpEdgeImports_node_src;
                prev__candidate_dumpEdgeImports_node_src = candidate_dumpEdgeImports_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_dumpEdgeImports_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target dumpEdgeImports_node_tgt from dumpEdgeImports_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeImports_node_tgt = candidate_dumpEdgeImports_edge_e.lgspTarget;
                if((candidate_dumpEdgeImports_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_dumpEdgeImports_node_src.lgspFlags = candidate_dumpEdgeImports_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeImports_node_src;
                    continue;
                }
                Rule_dumpEdgeImports.Match_dumpEdgeImports match = matches.GetNextUnfilledPosition();
                match._node_src = candidate_dumpEdgeImports_node_src;
                match._node_tgt = candidate_dumpEdgeImports_node_tgt;
                match._edge_e = candidate_dumpEdgeImports_edge_e;
                match._var_v = var_dumpEdgeImports_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpEdgeImports_edge_e);
                    candidate_dumpEdgeImports_node_src.lgspFlags = candidate_dumpEdgeImports_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeImports_node_src;
                    return matches;
                }
                candidate_dumpEdgeImports_node_src.lgspFlags = candidate_dumpEdgeImports_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeImports_node_src;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeImports_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeImports_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeImports_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeImports.IMatch_dumpEdgeImports match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> matches)
        {
            foreach(Rule_dumpEdgeImports.IMatch_dumpEdgeImports match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImports_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeImports_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImports_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeImports_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpEdgeImports.IMatch_dumpEdgeImports match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImports_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeImports_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImports_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeImports_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeImports_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeImports_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeImports_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpEdgeImports.IMatch_dumpEdgeImports)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImports.IMatch_dumpEdgeImports>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpEdgeImplements
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeImplements_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImplements_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImplements_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImplements_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImplements_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeImplements_var_v);
    }
    
    public class Action_dumpEdgeImplements : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpEdgeImplements
    {
        public Action_dumpEdgeImplements() {
            _rulePattern = Rule_dumpEdgeImplements.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeImplements.Match_dumpEdgeImplements, Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements>(this);
        }

        public Rule_dumpEdgeImplements _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpEdgeImplements"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeImplements.Match_dumpEdgeImplements, Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> matches;

        public static Action_dumpEdgeImplements Instance { get { return instance; } }
        private static Action_dumpEdgeImplements instance = new Action_dumpEdgeImplements();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeImplements_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpEdgeImplements_var_v = (System.Int32)dumpEdgeImplements_var_v;
            // Lookup dumpEdgeImplements_edge_e 
            int type_id_candidate_dumpEdgeImplements_edge_e = 7;
            for(GRGEN_LGSP.LGSPEdge head_candidate_dumpEdgeImplements_edge_e = graph.edgesByTypeHeads[type_id_candidate_dumpEdgeImplements_edge_e], candidate_dumpEdgeImplements_edge_e = head_candidate_dumpEdgeImplements_edge_e.lgspTypeNext; candidate_dumpEdgeImplements_edge_e != head_candidate_dumpEdgeImplements_edge_e; candidate_dumpEdgeImplements_edge_e = candidate_dumpEdgeImplements_edge_e.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpEdgeImplements_edge_e, var_dumpEdgeImplements_var_v))) {
                    continue;
                }
                // Implicit Source dumpEdgeImplements_node_src from dumpEdgeImplements_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeImplements_node_src = candidate_dumpEdgeImplements_edge_e.lgspSource;
                uint prev__candidate_dumpEdgeImplements_node_src;
                prev__candidate_dumpEdgeImplements_node_src = candidate_dumpEdgeImplements_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_dumpEdgeImplements_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target dumpEdgeImplements_node_tgt from dumpEdgeImplements_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeImplements_node_tgt = candidate_dumpEdgeImplements_edge_e.lgspTarget;
                if((candidate_dumpEdgeImplements_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_dumpEdgeImplements_node_src.lgspFlags = candidate_dumpEdgeImplements_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeImplements_node_src;
                    continue;
                }
                Rule_dumpEdgeImplements.Match_dumpEdgeImplements match = matches.GetNextUnfilledPosition();
                match._node_src = candidate_dumpEdgeImplements_node_src;
                match._node_tgt = candidate_dumpEdgeImplements_node_tgt;
                match._edge_e = candidate_dumpEdgeImplements_edge_e;
                match._var_v = var_dumpEdgeImplements_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpEdgeImplements_edge_e);
                    candidate_dumpEdgeImplements_node_src.lgspFlags = candidate_dumpEdgeImplements_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeImplements_node_src;
                    return matches;
                }
                candidate_dumpEdgeImplements_node_src.lgspFlags = candidate_dumpEdgeImplements_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeImplements_node_src;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeImplements_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeImplements_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeImplements_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> matches)
        {
            foreach(Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImplements_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeImplements_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImplements_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeImplements_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImplements_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeImplements_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeImplements_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeImplements_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeImplements_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeImplements_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeImplements_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeImplements.IMatch_dumpEdgeImplements>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpEdgeParameter
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeParameter_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeParameter_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeParameter_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeParameter_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeParameter_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeParameter_var_v);
    }
    
    public class Action_dumpEdgeParameter : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpEdgeParameter
    {
        public Action_dumpEdgeParameter() {
            _rulePattern = Rule_dumpEdgeParameter.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeParameter.Match_dumpEdgeParameter, Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter>(this);
        }

        public Rule_dumpEdgeParameter _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpEdgeParameter"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeParameter.Match_dumpEdgeParameter, Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> matches;

        public static Action_dumpEdgeParameter Instance { get { return instance; } }
        private static Action_dumpEdgeParameter instance = new Action_dumpEdgeParameter();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeParameter_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpEdgeParameter_var_v = (System.Int32)dumpEdgeParameter_var_v;
            // Lookup dumpEdgeParameter_edge_e 
            int type_id_candidate_dumpEdgeParameter_edge_e = 8;
            for(GRGEN_LGSP.LGSPEdge head_candidate_dumpEdgeParameter_edge_e = graph.edgesByTypeHeads[type_id_candidate_dumpEdgeParameter_edge_e], candidate_dumpEdgeParameter_edge_e = head_candidate_dumpEdgeParameter_edge_e.lgspTypeNext; candidate_dumpEdgeParameter_edge_e != head_candidate_dumpEdgeParameter_edge_e; candidate_dumpEdgeParameter_edge_e = candidate_dumpEdgeParameter_edge_e.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpEdgeParameter_edge_e, var_dumpEdgeParameter_var_v))) {
                    continue;
                }
                // Implicit Source dumpEdgeParameter_node_src from dumpEdgeParameter_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeParameter_node_src = candidate_dumpEdgeParameter_edge_e.lgspSource;
                uint prev__candidate_dumpEdgeParameter_node_src;
                prev__candidate_dumpEdgeParameter_node_src = candidate_dumpEdgeParameter_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_dumpEdgeParameter_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target dumpEdgeParameter_node_tgt from dumpEdgeParameter_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeParameter_node_tgt = candidate_dumpEdgeParameter_edge_e.lgspTarget;
                if((candidate_dumpEdgeParameter_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_dumpEdgeParameter_node_src.lgspFlags = candidate_dumpEdgeParameter_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeParameter_node_src;
                    continue;
                }
                Rule_dumpEdgeParameter.Match_dumpEdgeParameter match = matches.GetNextUnfilledPosition();
                match._node_src = candidate_dumpEdgeParameter_node_src;
                match._node_tgt = candidate_dumpEdgeParameter_node_tgt;
                match._edge_e = candidate_dumpEdgeParameter_edge_e;
                match._var_v = var_dumpEdgeParameter_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpEdgeParameter_edge_e);
                    candidate_dumpEdgeParameter_node_src.lgspFlags = candidate_dumpEdgeParameter_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeParameter_node_src;
                    return matches;
                }
                candidate_dumpEdgeParameter_node_src.lgspFlags = candidate_dumpEdgeParameter_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeParameter_node_src;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeParameter_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeParameter_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeParameter_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> matches)
        {
            foreach(Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeParameter_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeParameter_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeParameter_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeParameter_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeParameter_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeParameter_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeParameter.IMatch_dumpEdgeParameter>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpEdgeBinding
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeBinding_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBinding_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBinding_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBinding_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBinding_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeBinding_var_v);
    }
    
    public class Action_dumpEdgeBinding : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpEdgeBinding
    {
        public Action_dumpEdgeBinding() {
            _rulePattern = Rule_dumpEdgeBinding.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeBinding.Match_dumpEdgeBinding, Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding>(this);
        }

        public Rule_dumpEdgeBinding _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpEdgeBinding"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeBinding.Match_dumpEdgeBinding, Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> matches;

        public static Action_dumpEdgeBinding Instance { get { return instance; } }
        private static Action_dumpEdgeBinding instance = new Action_dumpEdgeBinding();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeBinding_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpEdgeBinding_var_v = (System.Int32)dumpEdgeBinding_var_v;
            // Lookup dumpEdgeBinding_edge_e 
            int type_id_candidate_dumpEdgeBinding_edge_e = 10;
            for(GRGEN_LGSP.LGSPEdge head_candidate_dumpEdgeBinding_edge_e = graph.edgesByTypeHeads[type_id_candidate_dumpEdgeBinding_edge_e], candidate_dumpEdgeBinding_edge_e = head_candidate_dumpEdgeBinding_edge_e.lgspTypeNext; candidate_dumpEdgeBinding_edge_e != head_candidate_dumpEdgeBinding_edge_e; candidate_dumpEdgeBinding_edge_e = candidate_dumpEdgeBinding_edge_e.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpEdgeBinding_edge_e, var_dumpEdgeBinding_var_v))) {
                    continue;
                }
                // Implicit Source dumpEdgeBinding_node_src from dumpEdgeBinding_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeBinding_node_src = candidate_dumpEdgeBinding_edge_e.lgspSource;
                uint prev__candidate_dumpEdgeBinding_node_src;
                prev__candidate_dumpEdgeBinding_node_src = candidate_dumpEdgeBinding_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_dumpEdgeBinding_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target dumpEdgeBinding_node_tgt from dumpEdgeBinding_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeBinding_node_tgt = candidate_dumpEdgeBinding_edge_e.lgspTarget;
                if((candidate_dumpEdgeBinding_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_dumpEdgeBinding_node_src.lgspFlags = candidate_dumpEdgeBinding_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeBinding_node_src;
                    continue;
                }
                Rule_dumpEdgeBinding.Match_dumpEdgeBinding match = matches.GetNextUnfilledPosition();
                match._node_src = candidate_dumpEdgeBinding_node_src;
                match._node_tgt = candidate_dumpEdgeBinding_node_tgt;
                match._edge_e = candidate_dumpEdgeBinding_edge_e;
                match._var_v = var_dumpEdgeBinding_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpEdgeBinding_edge_e);
                    candidate_dumpEdgeBinding_node_src.lgspFlags = candidate_dumpEdgeBinding_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeBinding_node_src;
                    return matches;
                }
                candidate_dumpEdgeBinding_node_src.lgspFlags = candidate_dumpEdgeBinding_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeBinding_node_src;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeBinding_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeBinding_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeBinding_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> matches)
        {
            foreach(Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBinding_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeBinding_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBinding_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeBinding_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBinding_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeBinding_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeBinding_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeBinding_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeBinding_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeBinding_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeBinding_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeBinding.IMatch_dumpEdgeBinding>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpEdgeLink
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeLink_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeLink.IMatch_dumpEdgeLink match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeLink_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeLink_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeLink_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeLink_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeLink_var_v);
    }
    
    public class Action_dumpEdgeLink : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpEdgeLink
    {
        public Action_dumpEdgeLink() {
            _rulePattern = Rule_dumpEdgeLink.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeLink.Match_dumpEdgeLink, Rule_dumpEdgeLink.IMatch_dumpEdgeLink>(this);
        }

        public Rule_dumpEdgeLink _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpEdgeLink"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeLink.Match_dumpEdgeLink, Rule_dumpEdgeLink.IMatch_dumpEdgeLink> matches;

        public static Action_dumpEdgeLink Instance { get { return instance; } }
        private static Action_dumpEdgeLink instance = new Action_dumpEdgeLink();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeLink_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpEdgeLink_var_v = (System.Int32)dumpEdgeLink_var_v;
            // Lookup dumpEdgeLink_edge_e 
            int type_id_candidate_dumpEdgeLink_edge_e = 11;
            for(GRGEN_LGSP.LGSPEdge head_candidate_dumpEdgeLink_edge_e = graph.edgesByTypeHeads[type_id_candidate_dumpEdgeLink_edge_e], candidate_dumpEdgeLink_edge_e = head_candidate_dumpEdgeLink_edge_e.lgspTypeNext; candidate_dumpEdgeLink_edge_e != head_candidate_dumpEdgeLink_edge_e; candidate_dumpEdgeLink_edge_e = candidate_dumpEdgeLink_edge_e.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpEdgeLink_edge_e, var_dumpEdgeLink_var_v))) {
                    continue;
                }
                // Implicit Source dumpEdgeLink_node_src from dumpEdgeLink_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeLink_node_src = candidate_dumpEdgeLink_edge_e.lgspSource;
                uint prev__candidate_dumpEdgeLink_node_src;
                prev__candidate_dumpEdgeLink_node_src = candidate_dumpEdgeLink_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_dumpEdgeLink_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target dumpEdgeLink_node_tgt from dumpEdgeLink_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeLink_node_tgt = candidate_dumpEdgeLink_edge_e.lgspTarget;
                if((candidate_dumpEdgeLink_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_dumpEdgeLink_node_src.lgspFlags = candidate_dumpEdgeLink_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeLink_node_src;
                    continue;
                }
                Rule_dumpEdgeLink.Match_dumpEdgeLink match = matches.GetNextUnfilledPosition();
                match._node_src = candidate_dumpEdgeLink_node_src;
                match._node_tgt = candidate_dumpEdgeLink_node_tgt;
                match._edge_e = candidate_dumpEdgeLink_edge_e;
                match._var_v = var_dumpEdgeLink_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpEdgeLink_edge_e);
                    candidate_dumpEdgeLink_node_src.lgspFlags = candidate_dumpEdgeLink_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeLink_node_src;
                    return matches;
                }
                candidate_dumpEdgeLink_node_src.lgspFlags = candidate_dumpEdgeLink_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeLink_node_src;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeLink_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeLink_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeLink_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeLink.IMatch_dumpEdgeLink match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> matches)
        {
            foreach(Rule_dumpEdgeLink.IMatch_dumpEdgeLink match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeLink_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeLink_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeLink_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeLink_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpEdgeLink.IMatch_dumpEdgeLink match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeLink_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeLink_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeLink_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeLink_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeLink_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeLink_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeLink_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpEdgeLink.IMatch_dumpEdgeLink)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeLink.IMatch_dumpEdgeLink>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpEdgeExpression
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeExpression_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExpression_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExpression_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExpression_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExpression_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeExpression_var_v);
    }
    
    public class Action_dumpEdgeExpression : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpEdgeExpression
    {
        public Action_dumpEdgeExpression() {
            _rulePattern = Rule_dumpEdgeExpression.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeExpression.Match_dumpEdgeExpression, Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression>(this);
        }

        public Rule_dumpEdgeExpression _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpEdgeExpression"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeExpression.Match_dumpEdgeExpression, Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> matches;

        public static Action_dumpEdgeExpression Instance { get { return instance; } }
        private static Action_dumpEdgeExpression instance = new Action_dumpEdgeExpression();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeExpression_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpEdgeExpression_var_v = (System.Int32)dumpEdgeExpression_var_v;
            // Lookup dumpEdgeExpression_edge_e 
            int type_id_candidate_dumpEdgeExpression_edge_e = 12;
            for(GRGEN_LGSP.LGSPEdge head_candidate_dumpEdgeExpression_edge_e = graph.edgesByTypeHeads[type_id_candidate_dumpEdgeExpression_edge_e], candidate_dumpEdgeExpression_edge_e = head_candidate_dumpEdgeExpression_edge_e.lgspTypeNext; candidate_dumpEdgeExpression_edge_e != head_candidate_dumpEdgeExpression_edge_e; candidate_dumpEdgeExpression_edge_e = candidate_dumpEdgeExpression_edge_e.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpEdgeExpression_edge_e, var_dumpEdgeExpression_var_v))) {
                    continue;
                }
                // Implicit Source dumpEdgeExpression_node_src from dumpEdgeExpression_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeExpression_node_src = candidate_dumpEdgeExpression_edge_e.lgspSource;
                uint prev__candidate_dumpEdgeExpression_node_src;
                prev__candidate_dumpEdgeExpression_node_src = candidate_dumpEdgeExpression_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_dumpEdgeExpression_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target dumpEdgeExpression_node_tgt from dumpEdgeExpression_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeExpression_node_tgt = candidate_dumpEdgeExpression_edge_e.lgspTarget;
                if((candidate_dumpEdgeExpression_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_dumpEdgeExpression_node_src.lgspFlags = candidate_dumpEdgeExpression_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeExpression_node_src;
                    continue;
                }
                Rule_dumpEdgeExpression.Match_dumpEdgeExpression match = matches.GetNextUnfilledPosition();
                match._node_src = candidate_dumpEdgeExpression_node_src;
                match._node_tgt = candidate_dumpEdgeExpression_node_tgt;
                match._edge_e = candidate_dumpEdgeExpression_edge_e;
                match._var_v = var_dumpEdgeExpression_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpEdgeExpression_edge_e);
                    candidate_dumpEdgeExpression_node_src.lgspFlags = candidate_dumpEdgeExpression_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeExpression_node_src;
                    return matches;
                }
                candidate_dumpEdgeExpression_node_src.lgspFlags = candidate_dumpEdgeExpression_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeExpression_node_src;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeExpression_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeExpression_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeExpression_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> matches)
        {
            foreach(Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExpression_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeExpression_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExpression_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeExpression_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExpression_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeExpression_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeExpression_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeExpression_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeExpression_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeExpression_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeExpression_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeExpression.IMatch_dumpEdgeExpression>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_dumpEdgeActualParameter
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeActualParameter_var_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeActualParameter_var_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeActualParameter_var_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeActualParameter_var_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeActualParameter_var_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeActualParameter_var_v);
    }
    
    public class Action_dumpEdgeActualParameter : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_dumpEdgeActualParameter
    {
        public Action_dumpEdgeActualParameter() {
            _rulePattern = Rule_dumpEdgeActualParameter.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeActualParameter.Match_dumpEdgeActualParameter, Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter>(this);
        }

        public Rule_dumpEdgeActualParameter _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "dumpEdgeActualParameter"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_dumpEdgeActualParameter.Match_dumpEdgeActualParameter, Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> matches;

        public static Action_dumpEdgeActualParameter Instance { get { return instance; } }
        private static Action_dumpEdgeActualParameter instance = new Action_dumpEdgeActualParameter();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeActualParameter_var_v)
        {
            matches.Clear();
            int negLevel = 0;
            System.Int32 var_dumpEdgeActualParameter_var_v = (System.Int32)dumpEdgeActualParameter_var_v;
            // Lookup dumpEdgeActualParameter_edge_e 
            int type_id_candidate_dumpEdgeActualParameter_edge_e = 9;
            for(GRGEN_LGSP.LGSPEdge head_candidate_dumpEdgeActualParameter_edge_e = graph.edgesByTypeHeads[type_id_candidate_dumpEdgeActualParameter_edge_e], candidate_dumpEdgeActualParameter_edge_e = head_candidate_dumpEdgeActualParameter_edge_e.lgspTypeNext; candidate_dumpEdgeActualParameter_edge_e != head_candidate_dumpEdgeActualParameter_edge_e; candidate_dumpEdgeActualParameter_edge_e = candidate_dumpEdgeActualParameter_edge_e.lgspTypeNext)
            {
                // Condition 
                if(!(!graph.IsVisited(candidate_dumpEdgeActualParameter_edge_e, var_dumpEdgeActualParameter_var_v))) {
                    continue;
                }
                // Implicit Source dumpEdgeActualParameter_node_src from dumpEdgeActualParameter_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeActualParameter_node_src = candidate_dumpEdgeActualParameter_edge_e.lgspSource;
                uint prev__candidate_dumpEdgeActualParameter_node_src;
                prev__candidate_dumpEdgeActualParameter_node_src = candidate_dumpEdgeActualParameter_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_dumpEdgeActualParameter_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target dumpEdgeActualParameter_node_tgt from dumpEdgeActualParameter_edge_e 
                GRGEN_LGSP.LGSPNode candidate_dumpEdgeActualParameter_node_tgt = candidate_dumpEdgeActualParameter_edge_e.lgspTarget;
                if((candidate_dumpEdgeActualParameter_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_dumpEdgeActualParameter_node_src.lgspFlags = candidate_dumpEdgeActualParameter_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeActualParameter_node_src;
                    continue;
                }
                Rule_dumpEdgeActualParameter.Match_dumpEdgeActualParameter match = matches.GetNextUnfilledPosition();
                match._node_src = candidate_dumpEdgeActualParameter_node_src;
                match._node_tgt = candidate_dumpEdgeActualParameter_node_tgt;
                match._edge_e = candidate_dumpEdgeActualParameter_edge_e;
                match._var_v = var_dumpEdgeActualParameter_var_v;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_dumpEdgeActualParameter_edge_e);
                    candidate_dumpEdgeActualParameter_node_src.lgspFlags = candidate_dumpEdgeActualParameter_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeActualParameter_node_src;
                    return matches;
                }
                candidate_dumpEdgeActualParameter_node_src.lgspFlags = candidate_dumpEdgeActualParameter_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_dumpEdgeActualParameter_node_src;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, System.Int32 dumpEdgeActualParameter_var_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, System.Int32 dumpEdgeActualParameter_var_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeActualParameter_var_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> matches)
        {
            foreach(Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeActualParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeActualParameter_var_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeActualParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, dumpEdgeActualParameter_var_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeActualParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeActualParameter_var_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, System.Int32 dumpEdgeActualParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeActualParameter_var_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeActualParameter_var_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, System.Int32 dumpEdgeActualParameter_var_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, dumpEdgeActualParameter_var_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (System.Int32) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_dumpEdgeActualParameter.IMatch_dumpEdgeActualParameter>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (System.Int32) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (System.Int32) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (System.Int32) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_emitSpanningTree
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree> Match(GRGEN_LIBGR.IGraph graph, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_emitSpanningTree.IMatch_emitSpanningTree match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max);
    }
    
    public class Action_emitSpanningTree : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_emitSpanningTree
    {
        public Action_emitSpanningTree() {
            _rulePattern = Rule_emitSpanningTree.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_emitSpanningTree.Match_emitSpanningTree, Rule_emitSpanningTree.IMatch_emitSpanningTree>(this);
        }

        public Rule_emitSpanningTree _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "emitSpanningTree"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_emitSpanningTree.Match_emitSpanningTree, Rule_emitSpanningTree.IMatch_emitSpanningTree> matches;

        public static Action_emitSpanningTree Instance { get { return instance; } }
        private static Action_emitSpanningTree instance = new Action_emitSpanningTree();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches)
        {
            matches.Clear();
            int negLevel = 0;
            Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks = new Stack<GRGEN_LGSP.LGSPSubpatternAction>();
            List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches = new List<Stack<GRGEN_LIBGR.IMatch>>();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            // Push iterated matching task for emitSpanningTree_iter_0
            IteratedAction_emitSpanningTree_iter_0 taskFor_iter_0 = IteratedAction_emitSpanningTree_iter_0.getNewTask(graph, openTasks);
            taskFor_iter_0.searchPatternpath = false;
            taskFor_iter_0.matchOfNestingPattern = null;
            taskFor_iter_0.lastMatchAtPreviousNestingLevel = null;
            openTasks.Push(taskFor_iter_0);
            // Match subpatterns 
            openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
            // Pop iterated matching task for emitSpanningTree_iter_0
            openTasks.Pop();
            IteratedAction_emitSpanningTree_iter_0.releaseTask(taskFor_iter_0);
            // Check whether subpatterns were found 
            if(matchesList.Count>0) {
                // subpatterns/alternatives were found, extend the partial matches by our local match object, becoming a complete match object and save it
                foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                {
                    Rule_emitSpanningTree.Match_emitSpanningTree match = matches.GetNextUnfilledPosition();
                    match._iter_0 = new GRGEN_LGSP.LGSPMatchesList<Rule_emitSpanningTree.Match_emitSpanningTree_iter_0, Rule_emitSpanningTree.IMatch_emitSpanningTree_iter_0>(null);
                    while(currentFoundPartialMatch.Count>0 && currentFoundPartialMatch.Peek() is Rule_emitSpanningTree.IMatch_emitSpanningTree_iter_0) {
                        Rule_emitSpanningTree.Match_emitSpanningTree_iter_0 cfpm = (Rule_emitSpanningTree.Match_emitSpanningTree_iter_0)currentFoundPartialMatch.Pop();
                        if(cfpm.IsNullMatch) break;
                        cfpm.SetMatchOfEnclosingPattern(match);
                        match._iter_0.Add(cfpm);
                    }
                    matches.PositionWasFilledFixIt();
                }
                matchesList.Clear();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    return matches;
                }
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree> Match(GRGEN_LIBGR.IGraph graph, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_emitSpanningTree.IMatch_emitSpanningTree match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree> matches)
        {
            foreach(Rule_emitSpanningTree.IMatch_emitSpanningTree match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
            if(matches.Count <= 0) return false;
            foreach(Rule_emitSpanningTree.IMatch_emitSpanningTree match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_emitSpanningTree.IMatch_emitSpanningTree)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_emitSpanningTree.IMatch_emitSpanningTree>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            return ApplyMinMax(graph, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max);
        }
    }

    public class IteratedAction_emitSpanningTree_iter_0 : GRGEN_LGSP.LGSPSubpatternAction
    {
        private IteratedAction_emitSpanningTree_iter_0(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            graph = graph_; openTasks = openTasks_;
            patternGraph = Rule_emitSpanningTree.Instance.patternGraph;
            minMatchesIter = 0;
            maxMatchesIter = 0;
            numMatchesIter = 0;
        }

        int minMatchesIter;
        int maxMatchesIter;
        int numMatchesIter;

        public static IteratedAction_emitSpanningTree_iter_0 getNewTask(GRGEN_LGSP.LGSPGraph graph_, Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks_) {
            IteratedAction_emitSpanningTree_iter_0 newTask;
            if(numFreeTasks>0) {
                newTask = freeListHead;
                newTask.graph = graph_; newTask.openTasks = openTasks_;
                freeListHead = newTask.next;
                newTask.next = null;
                --numFreeTasks;
            } else {
                newTask = new IteratedAction_emitSpanningTree_iter_0(graph_, openTasks_);
            }
            return newTask;
        }

        public static void releaseTask(IteratedAction_emitSpanningTree_iter_0 oldTask) {
            if(numFreeTasks<MAX_NUM_FREE_TASKS) {
                oldTask.next = freeListHead;
                oldTask.graph = null; oldTask.openTasks = null;
                freeListHead = oldTask;
                ++numFreeTasks;
            }
        }

        private static IteratedAction_emitSpanningTree_iter_0 freeListHead = null;
        private static int numFreeTasks = 0;
        private const int MAX_NUM_FREE_TASKS = 100;

        private IteratedAction_emitSpanningTree_iter_0 next = null;

        
        public override void myMatch(List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches, int maxMatches, int negLevel)
        {
            bool patternFound = false;
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            if(matchesList.Count!=0) throw new ApplicationException(); //debug assert
            // if the maximum number of matches of the iterated is reached, we complete iterated matching by building the null match object
            if(maxMatchesIter>0 && numMatchesIter>=maxMatchesIter) goto maxMatchesIterReached;
            // dummy iteration for iterated return prevention
            do
            {
                // Lookup emitSpanningTree_iter_0_node_p 
                int type_id_candidate_emitSpanningTree_iter_0_node_p = 1;
                for(GRGEN_LGSP.LGSPNode head_candidate_emitSpanningTree_iter_0_node_p = graph.nodesByTypeHeads[type_id_candidate_emitSpanningTree_iter_0_node_p], candidate_emitSpanningTree_iter_0_node_p = head_candidate_emitSpanningTree_iter_0_node_p.lgspTypeNext; candidate_emitSpanningTree_iter_0_node_p != head_candidate_emitSpanningTree_iter_0_node_p; candidate_emitSpanningTree_iter_0_node_p = candidate_emitSpanningTree_iter_0_node_p.lgspTypeNext)
                {
                    if((candidate_emitSpanningTree_iter_0_node_p.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                    {
                        continue;
                    }
                    // NegativePattern 
                    {
                        ++negLevel;
                        // Extend Outgoing emitSpanningTree_iter_0_neg_0_edge__edge0 from emitSpanningTree_iter_0_node_p 
                        GRGEN_LGSP.LGSPEdge head_candidate_emitSpanningTree_iter_0_neg_0_edge__edge0 = candidate_emitSpanningTree_iter_0_node_p.lgspOuthead;
                        if(head_candidate_emitSpanningTree_iter_0_neg_0_edge__edge0 != null)
                        {
                            GRGEN_LGSP.LGSPEdge candidate_emitSpanningTree_iter_0_neg_0_edge__edge0 = head_candidate_emitSpanningTree_iter_0_neg_0_edge__edge0;
                            do
                            {
                                if(candidate_emitSpanningTree_iter_0_neg_0_edge__edge0.lgspType.TypeID!=3) {
                                    continue;
                                }
                                if((candidate_emitSpanningTree_iter_0_neg_0_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)==(uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel)
                                {
                                    continue;
                                }
                                // accept iterated instance match
                                ++numMatchesIter;
                                // negative pattern found
                                --numMatchesIter;
                                --negLevel;
                                goto label3;
                                --numMatchesIter;
                            }
                            while( (candidate_emitSpanningTree_iter_0_neg_0_edge__edge0 = candidate_emitSpanningTree_iter_0_neg_0_edge__edge0.lgspOutNext) != head_candidate_emitSpanningTree_iter_0_neg_0_edge__edge0 );
                        }
                        --negLevel;
                    }
                    // accept iterated instance match
                    ++numMatchesIter;
                    // Push subpattern matching task for mpc
                    PatternAction_MultipleContainedPackagesOrClasses taskFor_mpc = PatternAction_MultipleContainedPackagesOrClasses.getNewTask(graph, openTasks);
                    taskFor_mpc.MultipleContainedPackagesOrClasses_node_p = candidate_emitSpanningTree_iter_0_node_p;
                    taskFor_mpc.searchPatternpath = false;
                    taskFor_mpc.matchOfNestingPattern = null;
                    taskFor_mpc.lastMatchAtPreviousNestingLevel = null;
                    openTasks.Push(taskFor_mpc);
                    uint prevGlobal__candidate_emitSpanningTree_iter_0_node_p;
                    prevGlobal__candidate_emitSpanningTree_iter_0_node_p = candidate_emitSpanningTree_iter_0_node_p.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    candidate_emitSpanningTree_iter_0_node_p.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    // Match subpatterns 
                    openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                    // Pop subpattern matching task for mpc
                    openTasks.Pop();
                    PatternAction_MultipleContainedPackagesOrClasses.releaseTask(taskFor_mpc);
                    // Check whether subpatterns were found 
                    if(matchesList.Count>0) {
                        patternFound = true;
                        // subpatterns/alternatives were found, extend the partial matches by our local match object
                        foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                        {
                            Rule_emitSpanningTree.Match_emitSpanningTree_iter_0 match = new Rule_emitSpanningTree.Match_emitSpanningTree_iter_0();
                            match._node_p = candidate_emitSpanningTree_iter_0_node_p;
                            match._mpc = (@Pattern_MultipleContainedPackagesOrClasses.Match_MultipleContainedPackagesOrClasses)currentFoundPartialMatch.Pop();
                            match._mpc._matchOfEnclosingPattern = match;
                            currentFoundPartialMatch.Push(match);
                        }
                        // if enough matches were found, we leave
                        if(true) // as soon as there's a match, it's enough for iterated
                        {
                            candidate_emitSpanningTree_iter_0_node_p.lgspFlags = candidate_emitSpanningTree_iter_0_node_p.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_emitSpanningTree_iter_0_node_p;
                            --numMatchesIter;
                            goto maxMatchesIterReached;
                        }
                        candidate_emitSpanningTree_iter_0_node_p.lgspFlags = candidate_emitSpanningTree_iter_0_node_p.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_emitSpanningTree_iter_0_node_p;
                        --numMatchesIter;
                        goto label4;
                    }
                    candidate_emitSpanningTree_iter_0_node_p.lgspFlags = candidate_emitSpanningTree_iter_0_node_p.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_emitSpanningTree_iter_0_node_p;
                    --numMatchesIter;
label3: ;
label4: ;
                }
            } while(false);
            // Check whether the iterated pattern null match was found
maxMatchesIterReached:
            if(!patternFound && numMatchesIter>=minMatchesIter)
            {
                openTasks.Pop();
                // Check whether there are subpattern matching tasks left to execute
                if(openTasks.Count==0)
                {
                    Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch = new Stack<GRGEN_LIBGR.IMatch>();
                    foundPartialMatches.Add(currentFoundPartialMatch);
                    Rule_emitSpanningTree.Match_emitSpanningTree_iter_0 match = new Rule_emitSpanningTree.Match_emitSpanningTree_iter_0();
                    match._isNullMatch = true; // null match of iterated pattern
                    currentFoundPartialMatch.Push(match);
                    openTasks.Push(this);
                    return;
                }
                // Match subpatterns 
                openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                // Check whether subpatterns were found 
                if(matchesList.Count>0) {
                    // subpatterns/alternatives were found, extend the partial matches by our local match object
                    foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                    {
                        Rule_emitSpanningTree.Match_emitSpanningTree_iter_0 match = new Rule_emitSpanningTree.Match_emitSpanningTree_iter_0();
                        match._isNullMatch = true; // null match of iterated pattern
                        currentFoundPartialMatch.Push(match);
                    }
                }
                openTasks.Push(this);
                return;
            }
            return;
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_InsertHelperEdgesForNestedLayout
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> Match(GRGEN_LIBGR.IGraph graph, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max);
    }
    
    public class Action_InsertHelperEdgesForNestedLayout : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_InsertHelperEdgesForNestedLayout
    {
        public Action_InsertHelperEdgesForNestedLayout() {
            _rulePattern = Rule_InsertHelperEdgesForNestedLayout.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_InsertHelperEdgesForNestedLayout.Match_InsertHelperEdgesForNestedLayout, Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout>(this);
        }

        public Rule_InsertHelperEdgesForNestedLayout _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "InsertHelperEdgesForNestedLayout"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_InsertHelperEdgesForNestedLayout.Match_InsertHelperEdgesForNestedLayout, Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> matches;

        public static Action_InsertHelperEdgesForNestedLayout Instance { get { return instance; } }
        private static Action_InsertHelperEdgesForNestedLayout instance = new Action_InsertHelperEdgesForNestedLayout();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches)
        {
            matches.Clear();
            int negLevel = 0;
            Rule_InsertHelperEdgesForNestedLayout.Match_InsertHelperEdgesForNestedLayout match = matches.GetNextUnfilledPosition();
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> Match(GRGEN_LIBGR.IGraph graph, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> matches)
        {
            foreach(Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
            if(matches.Count <= 0) return false;
            foreach(Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_InsertHelperEdgesForNestedLayout.IMatch_InsertHelperEdgesForNestedLayout>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            return ApplyMinMax(graph, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_BindOperations
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> Match(GRGEN_LIBGR.IGraph graph, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_BindOperations.IMatch_BindOperations match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max);
    }
    
    public class Action_BindOperations : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_BindOperations
    {
        public Action_BindOperations() {
            _rulePattern = Rule_BindOperations.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_BindOperations.Match_BindOperations, Rule_BindOperations.IMatch_BindOperations>(this);
        }

        public Rule_BindOperations _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "BindOperations"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_BindOperations.Match_BindOperations, Rule_BindOperations.IMatch_BindOperations> matches;

        public static Action_BindOperations Instance { get { return instance; } }
        private static Action_BindOperations instance = new Action_BindOperations();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches)
        {
            matches.Clear();
            int negLevel = 0;
            // Lookup BindOperations_edge__edge1 
            int type_id_candidate_BindOperations_edge__edge1 = 3;
            for(GRGEN_LGSP.LGSPEdge head_candidate_BindOperations_edge__edge1 = graph.edgesByTypeHeads[type_id_candidate_BindOperations_edge__edge1], candidate_BindOperations_edge__edge1 = head_candidate_BindOperations_edge__edge1.lgspTypeNext; candidate_BindOperations_edge__edge1 != head_candidate_BindOperations_edge__edge1; candidate_BindOperations_edge__edge1 = candidate_BindOperations_edge__edge1.lgspTypeNext)
            {
                // Implicit Source BindOperations_node_body from BindOperations_edge__edge1 
                GRGEN_LGSP.LGSPNode candidate_BindOperations_node_body = candidate_BindOperations_edge__edge1.lgspSource;
                if(candidate_BindOperations_node_body.lgspType.TypeID!=7) {
                    continue;
                }
                // NegativePattern 
                {
                    ++negLevel;
                    // Extend Incoming BindOperations_implneg_3_edge__edge6 from BindOperations_node_body 
                    GRGEN_LGSP.LGSPEdge head_candidate_BindOperations_implneg_3_edge__edge6 = candidate_BindOperations_node_body.lgspInhead;
                    if(head_candidate_BindOperations_implneg_3_edge__edge6 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_BindOperations_implneg_3_edge__edge6 = head_candidate_BindOperations_implneg_3_edge__edge6;
                        do
                        {
                            if( (candidate_BindOperations_node_body==candidate_BindOperations_implneg_3_edge__edge6.lgspSource ? candidate_BindOperations_implneg_3_edge__edge6.lgspTarget : candidate_BindOperations_implneg_3_edge__edge6.lgspSource) != candidate_BindOperations_node_body) {
                                continue;
                            }
                            // negative pattern found
                            --negLevel;
                            goto label5;
                        }
                        while( (candidate_BindOperations_implneg_3_edge__edge6 = candidate_BindOperations_implneg_3_edge__edge6.lgspInNext) != head_candidate_BindOperations_implneg_3_edge__edge6 );
                    }
                    --negLevel;
                }
                // Implicit Target BindOperations_node_cl from BindOperations_edge__edge1 
                GRGEN_LGSP.LGSPNode candidate_BindOperations_node_cl = candidate_BindOperations_edge__edge1.lgspTarget;
                if(candidate_BindOperations_node_cl.lgspType.TypeID!=3) {
                    goto label6;
                }
                // NegativePattern 
                {
                    ++negLevel;
                    uint prev_implneg_4__candidate_BindOperations_edge__edge1;
                    prev_implneg_4__candidate_BindOperations_edge__edge1 = candidate_BindOperations_edge__edge1.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    candidate_BindOperations_edge__edge1.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    // both directions of BindOperations_implneg_4_edge__edge7
                    for(int directionRunCounterOf_BindOperations_implneg_4_edge__edge7 = 0; directionRunCounterOf_BindOperations_implneg_4_edge__edge7 < 2; ++directionRunCounterOf_BindOperations_implneg_4_edge__edge7)
                    {
                        // Extend IncomingOrOutgoing BindOperations_implneg_4_edge__edge7 from BindOperations_node_body 
                        GRGEN_LGSP.LGSPEdge head_candidate_BindOperations_implneg_4_edge__edge7 = directionRunCounterOf_BindOperations_implneg_4_edge__edge7==0 ? candidate_BindOperations_node_body.lgspInhead : candidate_BindOperations_node_body.lgspOuthead;
                        if(head_candidate_BindOperations_implneg_4_edge__edge7 != null)
                        {
                            GRGEN_LGSP.LGSPEdge candidate_BindOperations_implneg_4_edge__edge7 = head_candidate_BindOperations_implneg_4_edge__edge7;
                            do
                            {
                                if( (candidate_BindOperations_node_body==candidate_BindOperations_implneg_4_edge__edge7.lgspSource ? candidate_BindOperations_implneg_4_edge__edge7.lgspTarget : candidate_BindOperations_implneg_4_edge__edge7.lgspSource) != candidate_BindOperations_node_cl) {
                                    continue;
                                }
                                if((candidate_BindOperations_implneg_4_edge__edge7.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                                {
                                    continue;
                                }
                                // negative pattern found
                                candidate_BindOperations_edge__edge1.lgspFlags = candidate_BindOperations_edge__edge1.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_implneg_4__candidate_BindOperations_edge__edge1;
                                --negLevel;
                                goto label7;
                            }
                            while( (directionRunCounterOf_BindOperations_implneg_4_edge__edge7==0 ? candidate_BindOperations_implneg_4_edge__edge7 = candidate_BindOperations_implneg_4_edge__edge7.lgspInNext : candidate_BindOperations_implneg_4_edge__edge7 = candidate_BindOperations_implneg_4_edge__edge7.lgspOutNext) != head_candidate_BindOperations_implneg_4_edge__edge7 );
                        }
                    }
                    candidate_BindOperations_edge__edge1.lgspFlags = candidate_BindOperations_edge__edge1.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_implneg_4__candidate_BindOperations_edge__edge1;
                    --negLevel;
                }
                // NegativePattern 
                {
                    ++negLevel;
                    // Extend Incoming BindOperations_implneg_5_edge__edge8 from BindOperations_node_cl 
                    GRGEN_LGSP.LGSPEdge head_candidate_BindOperations_implneg_5_edge__edge8 = candidate_BindOperations_node_cl.lgspInhead;
                    if(head_candidate_BindOperations_implneg_5_edge__edge8 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_BindOperations_implneg_5_edge__edge8 = head_candidate_BindOperations_implneg_5_edge__edge8;
                        do
                        {
                            if( (candidate_BindOperations_node_cl==candidate_BindOperations_implneg_5_edge__edge8.lgspSource ? candidate_BindOperations_implneg_5_edge__edge8.lgspTarget : candidate_BindOperations_implneg_5_edge__edge8.lgspSource) != candidate_BindOperations_node_cl) {
                                continue;
                            }
                            // negative pattern found
                            --negLevel;
                            goto label8;
                        }
                        while( (candidate_BindOperations_implneg_5_edge__edge8 = candidate_BindOperations_implneg_5_edge__edge8.lgspInNext) != head_candidate_BindOperations_implneg_5_edge__edge8 );
                    }
                    --negLevel;
                }
                // Extend Incoming BindOperations_edge__edge0 from BindOperations_node_body 
                GRGEN_LGSP.LGSPEdge head_candidate_BindOperations_edge__edge0 = candidate_BindOperations_node_body.lgspInhead;
                if(head_candidate_BindOperations_edge__edge0 != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_BindOperations_edge__edge0 = head_candidate_BindOperations_edge__edge0;
                    do
                    {
                        if(candidate_BindOperations_edge__edge0.lgspType.TypeID!=10) {
                            continue;
                        }
                        // Implicit Source BindOperations_node_op from BindOperations_edge__edge0 
                        GRGEN_LGSP.LGSPNode candidate_BindOperations_node_op = candidate_BindOperations_edge__edge0.lgspSource;
                        if(candidate_BindOperations_node_op.lgspType.TypeID!=6) {
                            continue;
                        }
                        // NegativePattern 
                        {
                            ++negLevel;
                            // Extend Incoming BindOperations_implneg_0_edge__edge3 from BindOperations_node_op 
                            GRGEN_LGSP.LGSPEdge head_candidate_BindOperations_implneg_0_edge__edge3 = candidate_BindOperations_node_op.lgspInhead;
                            if(head_candidate_BindOperations_implneg_0_edge__edge3 != null)
                            {
                                GRGEN_LGSP.LGSPEdge candidate_BindOperations_implneg_0_edge__edge3 = head_candidate_BindOperations_implneg_0_edge__edge3;
                                do
                                {
                                    if( (candidate_BindOperations_node_op==candidate_BindOperations_implneg_0_edge__edge3.lgspSource ? candidate_BindOperations_implneg_0_edge__edge3.lgspTarget : candidate_BindOperations_implneg_0_edge__edge3.lgspSource) != candidate_BindOperations_node_op) {
                                        continue;
                                    }
                                    // negative pattern found
                                    --negLevel;
                                    goto label9;
                                }
                                while( (candidate_BindOperations_implneg_0_edge__edge3 = candidate_BindOperations_implneg_0_edge__edge3.lgspInNext) != head_candidate_BindOperations_implneg_0_edge__edge3 );
                            }
                            --negLevel;
                        }
                        // NegativePattern 
                        {
                            ++negLevel;
                            uint prev_implneg_1__candidate_BindOperations_edge__edge0;
                            prev_implneg_1__candidate_BindOperations_edge__edge0 = candidate_BindOperations_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                            candidate_BindOperations_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                            // both directions of BindOperations_implneg_1_edge__edge4
                            for(int directionRunCounterOf_BindOperations_implneg_1_edge__edge4 = 0; directionRunCounterOf_BindOperations_implneg_1_edge__edge4 < 2; ++directionRunCounterOf_BindOperations_implneg_1_edge__edge4)
                            {
                                // Extend IncomingOrOutgoing BindOperations_implneg_1_edge__edge4 from BindOperations_node_op 
                                GRGEN_LGSP.LGSPEdge head_candidate_BindOperations_implneg_1_edge__edge4 = directionRunCounterOf_BindOperations_implneg_1_edge__edge4==0 ? candidate_BindOperations_node_op.lgspInhead : candidate_BindOperations_node_op.lgspOuthead;
                                if(head_candidate_BindOperations_implneg_1_edge__edge4 != null)
                                {
                                    GRGEN_LGSP.LGSPEdge candidate_BindOperations_implneg_1_edge__edge4 = head_candidate_BindOperations_implneg_1_edge__edge4;
                                    do
                                    {
                                        if( (candidate_BindOperations_node_op==candidate_BindOperations_implneg_1_edge__edge4.lgspSource ? candidate_BindOperations_implneg_1_edge__edge4.lgspTarget : candidate_BindOperations_implneg_1_edge__edge4.lgspSource) != candidate_BindOperations_node_body) {
                                            continue;
                                        }
                                        if((candidate_BindOperations_implneg_1_edge__edge4.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                                        {
                                            continue;
                                        }
                                        // negative pattern found
                                        candidate_BindOperations_edge__edge0.lgspFlags = candidate_BindOperations_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_implneg_1__candidate_BindOperations_edge__edge0;
                                        --negLevel;
                                        goto label10;
                                    }
                                    while( (directionRunCounterOf_BindOperations_implneg_1_edge__edge4==0 ? candidate_BindOperations_implneg_1_edge__edge4 = candidate_BindOperations_implneg_1_edge__edge4.lgspInNext : candidate_BindOperations_implneg_1_edge__edge4 = candidate_BindOperations_implneg_1_edge__edge4.lgspOutNext) != head_candidate_BindOperations_implneg_1_edge__edge4 );
                                }
                            }
                            candidate_BindOperations_edge__edge0.lgspFlags = candidate_BindOperations_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_implneg_1__candidate_BindOperations_edge__edge0;
                            --negLevel;
                        }
                        // NegativePattern 
                        {
                            ++negLevel;
                            // both directions of BindOperations_implneg_2_edge__edge5
                            for(int directionRunCounterOf_BindOperations_implneg_2_edge__edge5 = 0; directionRunCounterOf_BindOperations_implneg_2_edge__edge5 < 2; ++directionRunCounterOf_BindOperations_implneg_2_edge__edge5)
                            {
                                // Extend IncomingOrOutgoing BindOperations_implneg_2_edge__edge5 from BindOperations_node_op 
                                GRGEN_LGSP.LGSPEdge head_candidate_BindOperations_implneg_2_edge__edge5 = directionRunCounterOf_BindOperations_implneg_2_edge__edge5==0 ? candidate_BindOperations_node_op.lgspInhead : candidate_BindOperations_node_op.lgspOuthead;
                                if(head_candidate_BindOperations_implneg_2_edge__edge5 != null)
                                {
                                    GRGEN_LGSP.LGSPEdge candidate_BindOperations_implneg_2_edge__edge5 = head_candidate_BindOperations_implneg_2_edge__edge5;
                                    do
                                    {
                                        if( (candidate_BindOperations_node_op==candidate_BindOperations_implneg_2_edge__edge5.lgspSource ? candidate_BindOperations_implneg_2_edge__edge5.lgspTarget : candidate_BindOperations_implneg_2_edge__edge5.lgspSource) != candidate_BindOperations_node_cl) {
                                            continue;
                                        }
                                        // negative pattern found
                                        --negLevel;
                                        goto label11;
                                    }
                                    while( (directionRunCounterOf_BindOperations_implneg_2_edge__edge5==0 ? candidate_BindOperations_implneg_2_edge__edge5 = candidate_BindOperations_implneg_2_edge__edge5.lgspInNext : candidate_BindOperations_implneg_2_edge__edge5 = candidate_BindOperations_implneg_2_edge__edge5.lgspOutNext) != head_candidate_BindOperations_implneg_2_edge__edge5 );
                                }
                            }
                            --negLevel;
                        }
                        Rule_BindOperations.Match_BindOperations match = matches.GetNextUnfilledPosition();
                        match._node_op = candidate_BindOperations_node_op;
                        match._node_body = candidate_BindOperations_node_body;
                        match._node_cl = candidate_BindOperations_node_cl;
                        match._edge__edge0 = candidate_BindOperations_edge__edge0;
                        match._edge__edge1 = candidate_BindOperations_edge__edge1;
                        matches.PositionWasFilledFixIt();
                        // if enough matches were found, we leave
                        if(maxMatches > 0 && matches.Count >= maxMatches)
                        {
                            candidate_BindOperations_node_body.MoveInHeadAfter(candidate_BindOperations_edge__edge0);
                            graph.MoveHeadAfter(candidate_BindOperations_edge__edge1);
                            return matches;
                        }
label9: ;
label10: ;
label11: ;
                    }
                    while( (candidate_BindOperations_edge__edge0 = candidate_BindOperations_edge__edge0.lgspInNext) != head_candidate_BindOperations_edge__edge0 );
                }
label5: ;
label6: ;
label7: ;
label8: ;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> Match(GRGEN_LIBGR.IGraph graph, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_BindOperations.IMatch_BindOperations match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> matches)
        {
            foreach(Rule_BindOperations.IMatch_BindOperations match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
            if(matches.Count <= 0) return false;
            foreach(Rule_BindOperations.IMatch_BindOperations match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_BindOperations.IMatch_BindOperations)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_BindOperations.IMatch_BindOperations>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            return ApplyMinMax(graph, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_InitMoveIntoBlocks
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> Match(GRGEN_LIBGR.IGraph graph, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max);
    }
    
    public class Action_InitMoveIntoBlocks : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_InitMoveIntoBlocks
    {
        public Action_InitMoveIntoBlocks() {
            _rulePattern = Rule_InitMoveIntoBlocks.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_InitMoveIntoBlocks.Match_InitMoveIntoBlocks, Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks>(this);
        }

        public Rule_InitMoveIntoBlocks _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "InitMoveIntoBlocks"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_InitMoveIntoBlocks.Match_InitMoveIntoBlocks, Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> matches;

        public static Action_InitMoveIntoBlocks Instance { get { return instance; } }
        private static Action_InitMoveIntoBlocks instance = new Action_InitMoveIntoBlocks();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches)
        {
            matches.Clear();
            int negLevel = 0;
            // Lookup InitMoveIntoBlocks_edge__edge0 
            int type_id_candidate_InitMoveIntoBlocks_edge__edge0 = 12;
            for(GRGEN_LGSP.LGSPEdge head_candidate_InitMoveIntoBlocks_edge__edge0 = graph.edgesByTypeHeads[type_id_candidate_InitMoveIntoBlocks_edge__edge0], candidate_InitMoveIntoBlocks_edge__edge0 = head_candidate_InitMoveIntoBlocks_edge__edge0.lgspTypeNext; candidate_InitMoveIntoBlocks_edge__edge0 != head_candidate_InitMoveIntoBlocks_edge__edge0; candidate_InitMoveIntoBlocks_edge__edge0 = candidate_InitMoveIntoBlocks_edge__edge0.lgspTypeNext)
            {
                // Implicit Source InitMoveIntoBlocks_node_b from InitMoveIntoBlocks_edge__edge0 
                GRGEN_LGSP.LGSPNode candidate_InitMoveIntoBlocks_node_b = candidate_InitMoveIntoBlocks_edge__edge0.lgspSource;
                if(candidate_InitMoveIntoBlocks_node_b.lgspType.TypeID!=15) {
                    continue;
                }
                uint prev__candidate_InitMoveIntoBlocks_node_b;
                prev__candidate_InitMoveIntoBlocks_node_b = candidate_InitMoveIntoBlocks_node_b.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_InitMoveIntoBlocks_node_b.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target InitMoveIntoBlocks_node_exp from InitMoveIntoBlocks_edge__edge0 
                GRGEN_LGSP.LGSPNode candidate_InitMoveIntoBlocks_node_exp = candidate_InitMoveIntoBlocks_edge__edge0.lgspTarget;
                if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_InitMoveIntoBlocks_node_exp.lgspType.TypeID]) {
                    candidate_InitMoveIntoBlocks_node_b.lgspFlags = candidate_InitMoveIntoBlocks_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InitMoveIntoBlocks_node_b;
                    continue;
                }
                if((candidate_InitMoveIntoBlocks_node_exp.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_InitMoveIntoBlocks_node_b.lgspFlags = candidate_InitMoveIntoBlocks_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InitMoveIntoBlocks_node_b;
                    continue;
                }
                // NegativePattern 
                {
                    ++negLevel;
                    uint prev_neg_0__candidate_InitMoveIntoBlocks_node_exp;
                    prev_neg_0__candidate_InitMoveIntoBlocks_node_exp = candidate_InitMoveIntoBlocks_node_exp.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    candidate_InitMoveIntoBlocks_node_exp.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    if((candidate_InitMoveIntoBlocks_node_b.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                    {
                        candidate_InitMoveIntoBlocks_node_exp.lgspFlags = candidate_InitMoveIntoBlocks_node_exp.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_neg_0__candidate_InitMoveIntoBlocks_node_exp;
                        --negLevel;
                        goto label12;
                    }
                    // Extend Outgoing InitMoveIntoBlocks_neg_0_edge__edge0 from InitMoveIntoBlocks_node_exp 
                    GRGEN_LGSP.LGSPEdge head_candidate_InitMoveIntoBlocks_neg_0_edge__edge0 = candidate_InitMoveIntoBlocks_node_exp.lgspOuthead;
                    if(head_candidate_InitMoveIntoBlocks_neg_0_edge__edge0 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_InitMoveIntoBlocks_neg_0_edge__edge0 = head_candidate_InitMoveIntoBlocks_neg_0_edge__edge0;
                        do
                        {
                            if(candidate_InitMoveIntoBlocks_neg_0_edge__edge0.lgspType.TypeID!=13) {
                                continue;
                            }
                            if(candidate_InitMoveIntoBlocks_neg_0_edge__edge0.lgspTarget != candidate_InitMoveIntoBlocks_node_b) {
                                continue;
                            }
                            // negative pattern found
                            candidate_InitMoveIntoBlocks_node_exp.lgspFlags = candidate_InitMoveIntoBlocks_node_exp.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_neg_0__candidate_InitMoveIntoBlocks_node_exp;
                            --negLevel;
                            candidate_InitMoveIntoBlocks_node_b.lgspFlags = candidate_InitMoveIntoBlocks_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InitMoveIntoBlocks_node_b;
                            goto label13;
                        }
                        while( (candidate_InitMoveIntoBlocks_neg_0_edge__edge0 = candidate_InitMoveIntoBlocks_neg_0_edge__edge0.lgspOutNext) != head_candidate_InitMoveIntoBlocks_neg_0_edge__edge0 );
                    }
                    candidate_InitMoveIntoBlocks_node_exp.lgspFlags = candidate_InitMoveIntoBlocks_node_exp.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_neg_0__candidate_InitMoveIntoBlocks_node_exp;
                    --negLevel;
                }
label12: ;
                Rule_InitMoveIntoBlocks.Match_InitMoveIntoBlocks match = matches.GetNextUnfilledPosition();
                match._node_b = candidate_InitMoveIntoBlocks_node_b;
                match._node_exp = candidate_InitMoveIntoBlocks_node_exp;
                match._edge__edge0 = candidate_InitMoveIntoBlocks_edge__edge0;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_InitMoveIntoBlocks_edge__edge0);
                    candidate_InitMoveIntoBlocks_node_b.lgspFlags = candidate_InitMoveIntoBlocks_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InitMoveIntoBlocks_node_b;
                    return matches;
                }
                candidate_InitMoveIntoBlocks_node_b.lgspFlags = candidate_InitMoveIntoBlocks_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_InitMoveIntoBlocks_node_b;
label13: ;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> Match(GRGEN_LIBGR.IGraph graph, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> matches)
        {
            foreach(Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
            if(matches.Count <= 0) return false;
            foreach(Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_InitMoveIntoBlocks.IMatch_InitMoveIntoBlocks>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            return ApplyMinMax(graph, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_MoveIntoBlocks
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> Match(GRGEN_LIBGR.IGraph graph, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max);
    }
    
    public class Action_MoveIntoBlocks : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_MoveIntoBlocks
    {
        public Action_MoveIntoBlocks() {
            _rulePattern = Rule_MoveIntoBlocks.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_MoveIntoBlocks.Match_MoveIntoBlocks, Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks>(this);
        }

        public Rule_MoveIntoBlocks _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "MoveIntoBlocks"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_MoveIntoBlocks.Match_MoveIntoBlocks, Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> matches;

        public static Action_MoveIntoBlocks Instance { get { return instance; } }
        private static Action_MoveIntoBlocks instance = new Action_MoveIntoBlocks();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches)
        {
            matches.Clear();
            int negLevel = 0;
            // Lookup MoveIntoBlocks_edge__edge0 
            int type_id_candidate_MoveIntoBlocks_edge__edge0 = 13;
            for(GRGEN_LGSP.LGSPEdge head_candidate_MoveIntoBlocks_edge__edge0 = graph.edgesByTypeHeads[type_id_candidate_MoveIntoBlocks_edge__edge0], candidate_MoveIntoBlocks_edge__edge0 = head_candidate_MoveIntoBlocks_edge__edge0.lgspTypeNext; candidate_MoveIntoBlocks_edge__edge0 != head_candidate_MoveIntoBlocks_edge__edge0; candidate_MoveIntoBlocks_edge__edge0 = candidate_MoveIntoBlocks_edge__edge0.lgspTypeNext)
            {
                uint prev__candidate_MoveIntoBlocks_edge__edge0;
                prev__candidate_MoveIntoBlocks_edge__edge0 = candidate_MoveIntoBlocks_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_MoveIntoBlocks_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Source MoveIntoBlocks_node__node0 from MoveIntoBlocks_edge__edge0 
                GRGEN_LGSP.LGSPNode candidate_MoveIntoBlocks_node__node0 = candidate_MoveIntoBlocks_edge__edge0.lgspSource;
                if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_MoveIntoBlocks_node__node0.lgspType.TypeID]) {
                    candidate_MoveIntoBlocks_edge__edge0.lgspFlags = candidate_MoveIntoBlocks_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_MoveIntoBlocks_edge__edge0;
                    continue;
                }
                uint prev__candidate_MoveIntoBlocks_node__node0;
                prev__candidate_MoveIntoBlocks_node__node0 = candidate_MoveIntoBlocks_node__node0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_MoveIntoBlocks_node__node0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Implicit Target MoveIntoBlocks_node_b from MoveIntoBlocks_edge__edge0 
                GRGEN_LGSP.LGSPNode candidate_MoveIntoBlocks_node_b = candidate_MoveIntoBlocks_edge__edge0.lgspTarget;
                if(candidate_MoveIntoBlocks_node_b.lgspType.TypeID!=15) {
                    candidate_MoveIntoBlocks_node__node0.lgspFlags = candidate_MoveIntoBlocks_node__node0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_MoveIntoBlocks_node__node0;
                    candidate_MoveIntoBlocks_edge__edge0.lgspFlags = candidate_MoveIntoBlocks_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_MoveIntoBlocks_edge__edge0;
                    continue;
                }
                if((candidate_MoveIntoBlocks_node_b.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                {
                    candidate_MoveIntoBlocks_node__node0.lgspFlags = candidate_MoveIntoBlocks_node__node0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_MoveIntoBlocks_node__node0;
                    candidate_MoveIntoBlocks_edge__edge0.lgspFlags = candidate_MoveIntoBlocks_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_MoveIntoBlocks_edge__edge0;
                    continue;
                }
                uint prev__candidate_MoveIntoBlocks_node_b;
                prev__candidate_MoveIntoBlocks_node_b = candidate_MoveIntoBlocks_node_b.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                candidate_MoveIntoBlocks_node_b.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                // Extend Outgoing MoveIntoBlocks_edge_e from MoveIntoBlocks_node__node0 
                GRGEN_LGSP.LGSPEdge head_candidate_MoveIntoBlocks_edge_e = candidate_MoveIntoBlocks_node__node0.lgspOuthead;
                if(head_candidate_MoveIntoBlocks_edge_e != null)
                {
                    GRGEN_LGSP.LGSPEdge candidate_MoveIntoBlocks_edge_e = head_candidate_MoveIntoBlocks_edge_e;
                    do
                    {
                        if(!GRGEN_MODEL.EdgeType_Edge.isMyType[candidate_MoveIntoBlocks_edge_e.lgspType.TypeID]) {
                            continue;
                        }
                        if((candidate_MoveIntoBlocks_edge_e.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        // Condition 
                        if(!(((candidate_MoveIntoBlocks_edge_e.lgspType == GRGEN_MODEL.EdgeType_expression.typeVar) || (candidate_MoveIntoBlocks_edge_e.lgspType == GRGEN_MODEL.EdgeType_actualParameter.typeVar)))) {
                            continue;
                        }
                        // Implicit Target MoveIntoBlocks_node_exp from MoveIntoBlocks_edge_e 
                        GRGEN_LGSP.LGSPNode candidate_MoveIntoBlocks_node_exp = candidate_MoveIntoBlocks_edge_e.lgspTarget;
                        if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_MoveIntoBlocks_node_exp.lgspType.TypeID]) {
                            continue;
                        }
                        if((candidate_MoveIntoBlocks_node_exp.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                        {
                            continue;
                        }
                        // NegativePattern 
                        {
                            ++negLevel;
                            uint prev_neg_0__candidate_MoveIntoBlocks_node_exp;
                            prev_neg_0__candidate_MoveIntoBlocks_node_exp = candidate_MoveIntoBlocks_node_exp.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                            candidate_MoveIntoBlocks_node_exp.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                            if((candidate_MoveIntoBlocks_node_b.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                            {
                                candidate_MoveIntoBlocks_node_exp.lgspFlags = candidate_MoveIntoBlocks_node_exp.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_neg_0__candidate_MoveIntoBlocks_node_exp;
                                --negLevel;
                                goto label14;
                            }
                            // Extend Outgoing MoveIntoBlocks_neg_0_edge__edge0 from MoveIntoBlocks_node_exp 
                            GRGEN_LGSP.LGSPEdge head_candidate_MoveIntoBlocks_neg_0_edge__edge0 = candidate_MoveIntoBlocks_node_exp.lgspOuthead;
                            if(head_candidate_MoveIntoBlocks_neg_0_edge__edge0 != null)
                            {
                                GRGEN_LGSP.LGSPEdge candidate_MoveIntoBlocks_neg_0_edge__edge0 = head_candidate_MoveIntoBlocks_neg_0_edge__edge0;
                                do
                                {
                                    if(candidate_MoveIntoBlocks_neg_0_edge__edge0.lgspType.TypeID!=13) {
                                        continue;
                                    }
                                    if(candidate_MoveIntoBlocks_neg_0_edge__edge0.lgspTarget != candidate_MoveIntoBlocks_node_b) {
                                        continue;
                                    }
                                    // negative pattern found
                                    candidate_MoveIntoBlocks_node_exp.lgspFlags = candidate_MoveIntoBlocks_node_exp.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_neg_0__candidate_MoveIntoBlocks_node_exp;
                                    --negLevel;
                                    goto label15;
                                }
                                while( (candidate_MoveIntoBlocks_neg_0_edge__edge0 = candidate_MoveIntoBlocks_neg_0_edge__edge0.lgspOutNext) != head_candidate_MoveIntoBlocks_neg_0_edge__edge0 );
                            }
                            candidate_MoveIntoBlocks_node_exp.lgspFlags = candidate_MoveIntoBlocks_node_exp.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_neg_0__candidate_MoveIntoBlocks_node_exp;
                            --negLevel;
                        }
label14: ;
                        Rule_MoveIntoBlocks.Match_MoveIntoBlocks match = matches.GetNextUnfilledPosition();
                        match._node__node0 = candidate_MoveIntoBlocks_node__node0;
                        match._node_b = candidate_MoveIntoBlocks_node_b;
                        match._node_exp = candidate_MoveIntoBlocks_node_exp;
                        match._edge__edge0 = candidate_MoveIntoBlocks_edge__edge0;
                        match._edge_e = candidate_MoveIntoBlocks_edge_e;
                        matches.PositionWasFilledFixIt();
                        // if enough matches were found, we leave
                        if(maxMatches > 0 && matches.Count >= maxMatches)
                        {
                            candidate_MoveIntoBlocks_node__node0.MoveOutHeadAfter(candidate_MoveIntoBlocks_edge_e);
                            graph.MoveHeadAfter(candidate_MoveIntoBlocks_edge__edge0);
                            candidate_MoveIntoBlocks_node_b.lgspFlags = candidate_MoveIntoBlocks_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_MoveIntoBlocks_node_b;
                            candidate_MoveIntoBlocks_node__node0.lgspFlags = candidate_MoveIntoBlocks_node__node0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_MoveIntoBlocks_node__node0;
                            candidate_MoveIntoBlocks_edge__edge0.lgspFlags = candidate_MoveIntoBlocks_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_MoveIntoBlocks_edge__edge0;
                            return matches;
                        }
label15: ;
                    }
                    while( (candidate_MoveIntoBlocks_edge_e = candidate_MoveIntoBlocks_edge_e.lgspOutNext) != head_candidate_MoveIntoBlocks_edge_e );
                }
                candidate_MoveIntoBlocks_node_b.lgspFlags = candidate_MoveIntoBlocks_node_b.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_MoveIntoBlocks_node_b;
                candidate_MoveIntoBlocks_node__node0.lgspFlags = candidate_MoveIntoBlocks_node__node0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_MoveIntoBlocks_node__node0;
                candidate_MoveIntoBlocks_edge__edge0.lgspFlags = candidate_MoveIntoBlocks_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_MoveIntoBlocks_edge__edge0;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> Match(GRGEN_LIBGR.IGraph graph, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> matches)
        {
            foreach(Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
            if(matches.Count <= 0) return false;
            foreach(Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_MoveIntoBlocks.IMatch_MoveIntoBlocks>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            return ApplyMinMax(graph, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_getClassAndVariable
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_getClassAndVariable.IMatch_getClassAndVariable match, out GRGEN_MODEL.IClass output_0, out GRGEN_MODEL.IVariable output_1);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable> matches, out GRGEN_MODEL.IClass output_0, out GRGEN_MODEL.IVariable output_1);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v, ref GRGEN_MODEL.IClass output_0, ref GRGEN_MODEL.IVariable output_1);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v, ref GRGEN_MODEL.IClass output_0, ref GRGEN_MODEL.IVariable output_1);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v);
    }
    
    public class Action_getClassAndVariable : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_getClassAndVariable
    {
        public Action_getClassAndVariable() {
            _rulePattern = Rule_getClassAndVariable.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[2];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_getClassAndVariable.Match_getClassAndVariable, Rule_getClassAndVariable.IMatch_getClassAndVariable>(this);
        }

        public Rule_getClassAndVariable _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "getClassAndVariable"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_getClassAndVariable.Match_getClassAndVariable, Rule_getClassAndVariable.IMatch_getClassAndVariable> matches;

        public static Action_getClassAndVariable Instance { get { return instance; } }
        private static Action_getClassAndVariable instance = new Action_getClassAndVariable();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset getClassAndVariable_node_c 
            GRGEN_LGSP.LGSPNode candidate_getClassAndVariable_node_c = (GRGEN_LGSP.LGSPNode)getClassAndVariable_node_c;
            if(candidate_getClassAndVariable_node_c.lgspType.TypeID!=3) {
                return matches;
            }
            // Preset getClassAndVariable_node_v 
            GRGEN_LGSP.LGSPNode candidate_getClassAndVariable_node_v = (GRGEN_LGSP.LGSPNode)getClassAndVariable_node_v;
            if(candidate_getClassAndVariable_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            Rule_getClassAndVariable.Match_getClassAndVariable match = matches.GetNextUnfilledPosition();
            match._node_c = candidate_getClassAndVariable_node_c;
            match._node_v = candidate_getClassAndVariable_node_v;
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, getClassAndVariable_node_c, getClassAndVariable_node_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_getClassAndVariable.IMatch_getClassAndVariable match, out GRGEN_MODEL.IClass output_0, out GRGEN_MODEL.IVariable output_1)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0, out output_1);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable> matches, out GRGEN_MODEL.IClass output_0, out GRGEN_MODEL.IVariable output_1)
        {
            output_0 = null;
            output_1 = null;
            foreach(Rule_getClassAndVariable.IMatch_getClassAndVariable match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0, out output_1);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v, ref GRGEN_MODEL.IClass output_0, ref GRGEN_MODEL.IVariable output_1)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getClassAndVariable_node_c, getClassAndVariable_node_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v, ref GRGEN_MODEL.IClass output_0, ref GRGEN_MODEL.IVariable output_1)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, getClassAndVariable_node_c, getClassAndVariable_node_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_getClassAndVariable.IMatch_getClassAndVariable match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0, out output_1);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable> matches;
            GRGEN_MODEL.IClass output_0; GRGEN_MODEL.IVariable output_1; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getClassAndVariable_node_c, getClassAndVariable_node_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getClassAndVariable_node_c, getClassAndVariable_node_v);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IClass output_0; GRGEN_MODEL.IVariable output_1; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getClassAndVariable_node_c, getClassAndVariable_node_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass getClassAndVariable_node_c, GRGEN_MODEL.IVariable getClassAndVariable_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable> matches;
            GRGEN_MODEL.IClass output_0; GRGEN_MODEL.IVariable output_1; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getClassAndVariable_node_c, getClassAndVariable_node_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IClass output_0; GRGEN_MODEL.IVariable output_1; 
            Modify(graph, (Rule_getClassAndVariable.IMatch_getClassAndVariable)match, out output_0, out output_1);
            ReturnArray[0] = output_0;
            ReturnArray[1] = output_1;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.IClass output_0; GRGEN_MODEL.IVariable output_1; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_getClassAndVariable.IMatch_getClassAndVariable>)matches, out output_0, out output_1);
            ReturnArray[0] = output_0;
            ReturnArray[1] = output_1;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IClass output_0 = null; GRGEN_MODEL.IVariable output_1 = null; 
            if(Apply(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], ref output_0, ref output_1)) {
                ReturnArray[0] = output_0;
                ReturnArray[1] = output_1;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IClass output_0 = null; GRGEN_MODEL.IVariable output_1 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], ref output_0, ref output_1)) {
                ReturnArray[0] = output_0;
                ReturnArray[1] = output_1;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_variableInClass
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_variableInClass.IMatch_variableInClass match, out System.Boolean output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass> matches, out System.Boolean output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v, ref System.Boolean output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v, ref System.Boolean output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v);
    }
    
    public class Action_variableInClass : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_variableInClass
    {
        public Action_variableInClass() {
            _rulePattern = Rule_variableInClass.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[1];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_variableInClass.Match_variableInClass, Rule_variableInClass.IMatch_variableInClass>(this);
        }

        public Rule_variableInClass _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "variableInClass"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_variableInClass.Match_variableInClass, Rule_variableInClass.IMatch_variableInClass> matches;

        public static Action_variableInClass Instance { get { return instance; } }
        private static Action_variableInClass instance = new Action_variableInClass();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset variableInClass_node_v 
            GRGEN_LGSP.LGSPNode candidate_variableInClass_node_v = (GRGEN_LGSP.LGSPNode)variableInClass_node_v;
            if(candidate_variableInClass_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            // Preset variableInClass_node_c 
            GRGEN_LGSP.LGSPNode candidate_variableInClass_node_c = (GRGEN_LGSP.LGSPNode)variableInClass_node_c;
            if(candidate_variableInClass_node_c.lgspType.TypeID!=3) {
                return matches;
            }
            uint prev__candidate_variableInClass_node_c;
            prev__candidate_variableInClass_node_c = candidate_variableInClass_node_c.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_variableInClass_node_c.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Extend Outgoing variableInClass_edge__edge0 from variableInClass_node_v 
            GRGEN_LGSP.LGSPEdge head_candidate_variableInClass_edge__edge0 = candidate_variableInClass_node_v.lgspOuthead;
            if(head_candidate_variableInClass_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_variableInClass_edge__edge0 = head_candidate_variableInClass_edge__edge0;
                do
                {
                    if(candidate_variableInClass_edge__edge0.lgspType.TypeID!=3) {
                        continue;
                    }
                    if(candidate_variableInClass_edge__edge0.lgspTarget != candidate_variableInClass_node_c) {
                        continue;
                    }
                    // Extend Outgoing variableInClass_edge__edge1 from variableInClass_node_v 
                    GRGEN_LGSP.LGSPEdge head_candidate_variableInClass_edge__edge1 = candidate_variableInClass_node_v.lgspOuthead;
                    if(head_candidate_variableInClass_edge__edge1 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_variableInClass_edge__edge1 = head_candidate_variableInClass_edge__edge1;
                        do
                        {
                            if(candidate_variableInClass_edge__edge1.lgspType.TypeID!=4) {
                                continue;
                            }
                            // Implicit Target variableInClass_node__node0 from variableInClass_edge__edge1 
                            GRGEN_LGSP.LGSPNode candidate_variableInClass_node__node0 = candidate_variableInClass_edge__edge1.lgspTarget;
                            if(candidate_variableInClass_node__node0.lgspType.TypeID!=3) {
                                continue;
                            }
                            if((candidate_variableInClass_node__node0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                            {
                                continue;
                            }
                            Rule_variableInClass.Match_variableInClass match = matches.GetNextUnfilledPosition();
                            match._node_v = candidate_variableInClass_node_v;
                            match._node_c = candidate_variableInClass_node_c;
                            match._node__node0 = candidate_variableInClass_node__node0;
                            match._edge__edge0 = candidate_variableInClass_edge__edge0;
                            match._edge__edge1 = candidate_variableInClass_edge__edge1;
                            matches.PositionWasFilledFixIt();
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && matches.Count >= maxMatches)
                            {
                                candidate_variableInClass_node_v.MoveOutHeadAfter(candidate_variableInClass_edge__edge1);
                                candidate_variableInClass_node_v.MoveOutHeadAfter(candidate_variableInClass_edge__edge0);
                                candidate_variableInClass_node_c.lgspFlags = candidate_variableInClass_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_variableInClass_node_c;
                                return matches;
                            }
                        }
                        while( (candidate_variableInClass_edge__edge1 = candidate_variableInClass_edge__edge1.lgspOutNext) != head_candidate_variableInClass_edge__edge1 );
                    }
                }
                while( (candidate_variableInClass_edge__edge0 = candidate_variableInClass_edge__edge0.lgspOutNext) != head_candidate_variableInClass_edge__edge0 );
            }
            candidate_variableInClass_node_c.lgspFlags = candidate_variableInClass_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_variableInClass_node_c;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, variableInClass_node_c, variableInClass_node_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_variableInClass.IMatch_variableInClass match, out System.Boolean output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass> matches, out System.Boolean output_0)
        {
            output_0 = false;
            foreach(Rule_variableInClass.IMatch_variableInClass match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v, ref System.Boolean output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, variableInClass_node_c, variableInClass_node_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v, ref System.Boolean output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, variableInClass_node_c, variableInClass_node_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_variableInClass.IMatch_variableInClass match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass> matches;
            System.Boolean output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, variableInClass_node_c, variableInClass_node_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, variableInClass_node_c, variableInClass_node_v);
            if(matches.Count <= 0) return false;
            System.Boolean output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, variableInClass_node_c, variableInClass_node_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass variableInClass_node_c, GRGEN_MODEL.IVariable variableInClass_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass> matches;
            System.Boolean output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, variableInClass_node_c, variableInClass_node_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            System.Boolean output_0; 
            Modify(graph, (Rule_variableInClass.IMatch_variableInClass)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            System.Boolean output_0; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_variableInClass.IMatch_variableInClass>)matches, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            System.Boolean output_0 = false; 
            if(Apply(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            System.Boolean output_0 = false; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_methodExists
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_methodExists.IMatch_methodExists match, out GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists> matches, out GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name, ref GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name, ref GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name);
    }
    
    public class Action_methodExists : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_methodExists
    {
        public Action_methodExists() {
            _rulePattern = Rule_methodExists.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[1];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_methodExists.Match_methodExists, Rule_methodExists.IMatch_methodExists>(this);
        }

        public Rule_methodExists _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "methodExists"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_methodExists.Match_methodExists, Rule_methodExists.IMatch_methodExists> matches;

        public static Action_methodExists Instance { get { return instance; } }
        private static Action_methodExists instance = new Action_methodExists();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name)
        {
            matches.Clear();
            int negLevel = 0;
            System.String var_methodExists_var_name = (System.String)methodExists_var_name;
            // Preset methodExists_node_c 
            GRGEN_LGSP.LGSPNode candidate_methodExists_node_c = (GRGEN_LGSP.LGSPNode)methodExists_node_c;
            if(candidate_methodExists_node_c.lgspType.TypeID!=3) {
                return matches;
            }
            // Extend Incoming methodExists_edge__edge0 from methodExists_node_c 
            GRGEN_LGSP.LGSPEdge head_candidate_methodExists_edge__edge0 = candidate_methodExists_node_c.lgspInhead;
            if(head_candidate_methodExists_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_methodExists_edge__edge0 = head_candidate_methodExists_edge__edge0;
                do
                {
                    if(candidate_methodExists_edge__edge0.lgspType.TypeID!=3) {
                        continue;
                    }
                    // Implicit Source methodExists_node_mb from methodExists_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_methodExists_node_mb = candidate_methodExists_edge__edge0.lgspSource;
                    if(candidate_methodExists_node_mb.lgspType.TypeID!=7) {
                        continue;
                    }
                    // Extend Incoming methodExists_edge__edge1 from methodExists_node_mb 
                    GRGEN_LGSP.LGSPEdge head_candidate_methodExists_edge__edge1 = candidate_methodExists_node_mb.lgspInhead;
                    if(head_candidate_methodExists_edge__edge1 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_methodExists_edge__edge1 = head_candidate_methodExists_edge__edge1;
                        do
                        {
                            if(candidate_methodExists_edge__edge1.lgspType.TypeID!=10) {
                                continue;
                            }
                            // Implicit Source methodExists_node_op from methodExists_edge__edge1 
                            GRGEN_LGSP.LGSPNode candidate_methodExists_node_op = candidate_methodExists_edge__edge1.lgspSource;
                            if(candidate_methodExists_node_op.lgspType.TypeID!=6) {
                                continue;
                            }
                            // Condition 
                            if(!((((GRGEN_MODEL.IOperation)candidate_methodExists_node_op).@name == var_methodExists_var_name))) {
                                continue;
                            }
                            Rule_methodExists.Match_methodExists match = matches.GetNextUnfilledPosition();
                            match._node_mb = candidate_methodExists_node_mb;
                            match._node_c = candidate_methodExists_node_c;
                            match._node_op = candidate_methodExists_node_op;
                            match._edge__edge0 = candidate_methodExists_edge__edge0;
                            match._edge__edge1 = candidate_methodExists_edge__edge1;
                            match._var_name = var_methodExists_var_name;
                            matches.PositionWasFilledFixIt();
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && matches.Count >= maxMatches)
                            {
                                candidate_methodExists_node_mb.MoveInHeadAfter(candidate_methodExists_edge__edge1);
                                candidate_methodExists_node_c.MoveInHeadAfter(candidate_methodExists_edge__edge0);
                                return matches;
                            }
                        }
                        while( (candidate_methodExists_edge__edge1 = candidate_methodExists_edge__edge1.lgspInNext) != head_candidate_methodExists_edge__edge1 );
                    }
                }
                while( (candidate_methodExists_edge__edge0 = candidate_methodExists_edge__edge0.lgspInNext) != head_candidate_methodExists_edge__edge0 );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, methodExists_node_c, methodExists_var_name);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_methodExists.IMatch_methodExists match, out GRGEN_MODEL.IOperation output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists> matches, out GRGEN_MODEL.IOperation output_0)
        {
            output_0 = null;
            foreach(Rule_methodExists.IMatch_methodExists match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name, ref GRGEN_MODEL.IOperation output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, methodExists_node_c, methodExists_var_name);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name, ref GRGEN_MODEL.IOperation output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, methodExists_node_c, methodExists_var_name);
            if(matches.Count <= 0) return false;
            foreach(Rule_methodExists.IMatch_methodExists match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists> matches;
            GRGEN_MODEL.IOperation output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, methodExists_node_c, methodExists_var_name);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, methodExists_node_c, methodExists_var_name);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IOperation output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, methodExists_node_c, methodExists_var_name);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass methodExists_node_c, System.String methodExists_var_name)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists> matches;
            GRGEN_MODEL.IOperation output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, methodExists_node_c, methodExists_var_name);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IClass) parameters[0], (System.String) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IOperation output_0; 
            Modify(graph, (Rule_methodExists.IMatch_methodExists)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.IOperation output_0; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_methodExists.IMatch_methodExists>)matches, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IOperation output_0 = null; 
            if(Apply(graph, (GRGEN_MODEL.IClass) parameters[0], (System.String) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IOperation output_0 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IClass) parameters[0], (System.String) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IClass) parameters[0], (System.String) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IClass) parameters[0], (System.String) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IClass) parameters[0], (System.String) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_sameStaticness
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_sameStaticness.IMatch_sameStaticness match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op);
    }
    
    public class Action_sameStaticness : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_sameStaticness
    {
        public Action_sameStaticness() {
            _rulePattern = Rule_sameStaticness.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_sameStaticness.Match_sameStaticness, Rule_sameStaticness.IMatch_sameStaticness>(this);
        }

        public Rule_sameStaticness _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "sameStaticness"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_sameStaticness.Match_sameStaticness, Rule_sameStaticness.IMatch_sameStaticness> matches;

        public static Action_sameStaticness Instance { get { return instance; } }
        private static Action_sameStaticness instance = new Action_sameStaticness();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset sameStaticness_node_v 
            GRGEN_LGSP.LGSPNode candidate_sameStaticness_node_v = (GRGEN_LGSP.LGSPNode)sameStaticness_node_v;
            if(candidate_sameStaticness_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            // Preset sameStaticness_node_op 
            GRGEN_LGSP.LGSPNode candidate_sameStaticness_node_op = (GRGEN_LGSP.LGSPNode)sameStaticness_node_op;
            if(candidate_sameStaticness_node_op.lgspType.TypeID!=6) {
                return matches;
            }
            // Condition 
            if(!((((GRGEN_MODEL.IVariable)candidate_sameStaticness_node_v).@isStatic == ((GRGEN_MODEL.IOperation)candidate_sameStaticness_node_op).@isStatic))) {
                return matches;
            }
            Rule_sameStaticness.Match_sameStaticness match = matches.GetNextUnfilledPosition();
            match._node_v = candidate_sameStaticness_node_v;
            match._node_op = candidate_sameStaticness_node_op;
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, sameStaticness_node_v, sameStaticness_node_op);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_sameStaticness.IMatch_sameStaticness match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness> matches)
        {
            foreach(Rule_sameStaticness.IMatch_sameStaticness match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, sameStaticness_node_v, sameStaticness_node_op);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, sameStaticness_node_v, sameStaticness_node_op);
            if(matches.Count <= 0) return false;
            foreach(Rule_sameStaticness.IMatch_sameStaticness match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, sameStaticness_node_v, sameStaticness_node_op);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, sameStaticness_node_v, sameStaticness_node_op);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, sameStaticness_node_v, sameStaticness_node_op);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IVariable sameStaticness_node_v, GRGEN_MODEL.IOperation sameStaticness_node_op)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, sameStaticness_node_v, sameStaticness_node_op);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IVariable) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_sameStaticness.IMatch_sameStaticness)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_sameStaticness.IMatch_sameStaticness>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IVariable) parameters[0], (GRGEN_MODEL.IOperation) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IVariable) parameters[0], (GRGEN_MODEL.IOperation) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IVariable) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IVariable) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IVariable) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_insertMethodGetter
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_insertMethodGetter.IMatch_insertMethodGetter match, out GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter> matches, out GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic, ref GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic, ref GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic);
    }
    
    public class Action_insertMethodGetter : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_insertMethodGetter
    {
        public Action_insertMethodGetter() {
            _rulePattern = Rule_insertMethodGetter.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[1];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_insertMethodGetter.Match_insertMethodGetter, Rule_insertMethodGetter.IMatch_insertMethodGetter>(this);
        }

        public Rule_insertMethodGetter _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "insertMethodGetter"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_insertMethodGetter.Match_insertMethodGetter, Rule_insertMethodGetter.IMatch_insertMethodGetter> matches;

        public static Action_insertMethodGetter Instance { get { return instance; } }
        private static Action_insertMethodGetter instance = new Action_insertMethodGetter();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic)
        {
            matches.Clear();
            int negLevel = 0;
            System.String var_insertMethodGetter_var_name = (System.String)insertMethodGetter_var_name;
            System.Boolean var_insertMethodGetter_var_isStatic = (System.Boolean)insertMethodGetter_var_isStatic;
            // Preset insertMethodGetter_node_c 
            GRGEN_LGSP.LGSPNode candidate_insertMethodGetter_node_c = (GRGEN_LGSP.LGSPNode)insertMethodGetter_node_c;
            if(candidate_insertMethodGetter_node_c.lgspType.TypeID!=3) {
                return matches;
            }
            // Preset insertMethodGetter_node_v 
            GRGEN_LGSP.LGSPNode candidate_insertMethodGetter_node_v = (GRGEN_LGSP.LGSPNode)insertMethodGetter_node_v;
            if(candidate_insertMethodGetter_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            Rule_insertMethodGetter.Match_insertMethodGetter match = matches.GetNextUnfilledPosition();
            match._node_c = candidate_insertMethodGetter_node_c;
            match._node_v = candidate_insertMethodGetter_node_v;
            match._var_name = var_insertMethodGetter_var_name;
            match._var_isStatic = var_insertMethodGetter_var_isStatic;
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, insertMethodGetter_node_c, insertMethodGetter_node_v, insertMethodGetter_var_name, insertMethodGetter_var_isStatic);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_insertMethodGetter.IMatch_insertMethodGetter match, out GRGEN_MODEL.IOperation output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter> matches, out GRGEN_MODEL.IOperation output_0)
        {
            output_0 = null;
            foreach(Rule_insertMethodGetter.IMatch_insertMethodGetter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic, ref GRGEN_MODEL.IOperation output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, insertMethodGetter_node_c, insertMethodGetter_node_v, insertMethodGetter_var_name, insertMethodGetter_var_isStatic);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic, ref GRGEN_MODEL.IOperation output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, insertMethodGetter_node_c, insertMethodGetter_node_v, insertMethodGetter_var_name, insertMethodGetter_var_isStatic);
            if(matches.Count <= 0) return false;
            foreach(Rule_insertMethodGetter.IMatch_insertMethodGetter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter> matches;
            GRGEN_MODEL.IOperation output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, insertMethodGetter_node_c, insertMethodGetter_node_v, insertMethodGetter_var_name, insertMethodGetter_var_isStatic);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, insertMethodGetter_node_c, insertMethodGetter_node_v, insertMethodGetter_var_name, insertMethodGetter_var_isStatic);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IOperation output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, insertMethodGetter_node_c, insertMethodGetter_node_v, insertMethodGetter_var_name, insertMethodGetter_var_isStatic);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass insertMethodGetter_node_c, GRGEN_MODEL.IVariable insertMethodGetter_node_v, System.String insertMethodGetter_var_name, System.Boolean insertMethodGetter_var_isStatic)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter> matches;
            GRGEN_MODEL.IOperation output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, insertMethodGetter_node_c, insertMethodGetter_node_v, insertMethodGetter_var_name, insertMethodGetter_var_isStatic);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IOperation output_0; 
            Modify(graph, (Rule_insertMethodGetter.IMatch_insertMethodGetter)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.IOperation output_0; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_insertMethodGetter.IMatch_insertMethodGetter>)matches, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IOperation output_0 = null; 
            if(Apply(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IOperation output_0 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_insertMethodSetter
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_insertMethodSetter.IMatch_insertMethodSetter match, out GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter> matches, out GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic, ref GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic, ref GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic);
    }
    
    public class Action_insertMethodSetter : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_insertMethodSetter
    {
        public Action_insertMethodSetter() {
            _rulePattern = Rule_insertMethodSetter.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[1];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_insertMethodSetter.Match_insertMethodSetter, Rule_insertMethodSetter.IMatch_insertMethodSetter>(this);
        }

        public Rule_insertMethodSetter _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "insertMethodSetter"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_insertMethodSetter.Match_insertMethodSetter, Rule_insertMethodSetter.IMatch_insertMethodSetter> matches;

        public static Action_insertMethodSetter Instance { get { return instance; } }
        private static Action_insertMethodSetter instance = new Action_insertMethodSetter();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic)
        {
            matches.Clear();
            int negLevel = 0;
            System.String var_insertMethodSetter_var_name = (System.String)insertMethodSetter_var_name;
            System.Boolean var_insertMethodSetter_var_isStatic = (System.Boolean)insertMethodSetter_var_isStatic;
            // Preset insertMethodSetter_node_v 
            GRGEN_LGSP.LGSPNode candidate_insertMethodSetter_node_v = (GRGEN_LGSP.LGSPNode)insertMethodSetter_node_v;
            if(candidate_insertMethodSetter_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            // Preset insertMethodSetter_node_c 
            GRGEN_LGSP.LGSPNode candidate_insertMethodSetter_node_c = (GRGEN_LGSP.LGSPNode)insertMethodSetter_node_c;
            if(candidate_insertMethodSetter_node_c.lgspType.TypeID!=3) {
                return matches;
            }
            uint prev__candidate_insertMethodSetter_node_c;
            prev__candidate_insertMethodSetter_node_c = candidate_insertMethodSetter_node_c.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_insertMethodSetter_node_c.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Extend Outgoing insertMethodSetter_edge__edge0 from insertMethodSetter_node_v 
            GRGEN_LGSP.LGSPEdge head_candidate_insertMethodSetter_edge__edge0 = candidate_insertMethodSetter_node_v.lgspOuthead;
            if(head_candidate_insertMethodSetter_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_insertMethodSetter_edge__edge0 = head_candidate_insertMethodSetter_edge__edge0;
                do
                {
                    if(candidate_insertMethodSetter_edge__edge0.lgspType.TypeID!=4) {
                        continue;
                    }
                    // Implicit Target insertMethodSetter_node_type from insertMethodSetter_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_insertMethodSetter_node_type = candidate_insertMethodSetter_edge__edge0.lgspTarget;
                    if(candidate_insertMethodSetter_node_type.lgspType.TypeID!=3) {
                        continue;
                    }
                    if((candidate_insertMethodSetter_node_type.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                    {
                        continue;
                    }
                    Rule_insertMethodSetter.Match_insertMethodSetter match = matches.GetNextUnfilledPosition();
                    match._node_v = candidate_insertMethodSetter_node_v;
                    match._node_type = candidate_insertMethodSetter_node_type;
                    match._node_c = candidate_insertMethodSetter_node_c;
                    match._edge__edge0 = candidate_insertMethodSetter_edge__edge0;
                    match._var_name = var_insertMethodSetter_var_name;
                    match._var_isStatic = var_insertMethodSetter_var_isStatic;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        candidate_insertMethodSetter_node_v.MoveOutHeadAfter(candidate_insertMethodSetter_edge__edge0);
                        candidate_insertMethodSetter_node_c.lgspFlags = candidate_insertMethodSetter_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_insertMethodSetter_node_c;
                        return matches;
                    }
                }
                while( (candidate_insertMethodSetter_edge__edge0 = candidate_insertMethodSetter_edge__edge0.lgspOutNext) != head_candidate_insertMethodSetter_edge__edge0 );
            }
            candidate_insertMethodSetter_node_c.lgspFlags = candidate_insertMethodSetter_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_insertMethodSetter_node_c;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, insertMethodSetter_node_c, insertMethodSetter_node_v, insertMethodSetter_var_name, insertMethodSetter_var_isStatic);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_insertMethodSetter.IMatch_insertMethodSetter match, out GRGEN_MODEL.IOperation output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter> matches, out GRGEN_MODEL.IOperation output_0)
        {
            output_0 = null;
            foreach(Rule_insertMethodSetter.IMatch_insertMethodSetter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic, ref GRGEN_MODEL.IOperation output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, insertMethodSetter_node_c, insertMethodSetter_node_v, insertMethodSetter_var_name, insertMethodSetter_var_isStatic);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic, ref GRGEN_MODEL.IOperation output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, insertMethodSetter_node_c, insertMethodSetter_node_v, insertMethodSetter_var_name, insertMethodSetter_var_isStatic);
            if(matches.Count <= 0) return false;
            foreach(Rule_insertMethodSetter.IMatch_insertMethodSetter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter> matches;
            GRGEN_MODEL.IOperation output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, insertMethodSetter_node_c, insertMethodSetter_node_v, insertMethodSetter_var_name, insertMethodSetter_var_isStatic);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, insertMethodSetter_node_c, insertMethodSetter_node_v, insertMethodSetter_var_name, insertMethodSetter_var_isStatic);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IOperation output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, insertMethodSetter_node_c, insertMethodSetter_node_v, insertMethodSetter_var_name, insertMethodSetter_var_isStatic);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass insertMethodSetter_node_c, GRGEN_MODEL.IVariable insertMethodSetter_node_v, System.String insertMethodSetter_var_name, System.Boolean insertMethodSetter_var_isStatic)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter> matches;
            GRGEN_MODEL.IOperation output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, insertMethodSetter_node_c, insertMethodSetter_node_v, insertMethodSetter_var_name, insertMethodSetter_var_isStatic);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IOperation output_0; 
            Modify(graph, (Rule_insertMethodSetter.IMatch_insertMethodSetter)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.IOperation output_0; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_insertMethodSetter.IMatch_insertMethodSetter>)matches, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IOperation output_0 = null; 
            if(Apply(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IOperation output_0 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (System.String) parameters[2], (System.Boolean) parameters[3]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_changeVisibility
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IVariable changeVisibility_node_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_changeVisibility.IMatch_changeVisibility match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable changeVisibility_node_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable changeVisibility_node_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable changeVisibility_node_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable changeVisibility_node_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IVariable changeVisibility_node_v);
    }
    
    public class Action_changeVisibility : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_changeVisibility
    {
        public Action_changeVisibility() {
            _rulePattern = Rule_changeVisibility.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_changeVisibility.Match_changeVisibility, Rule_changeVisibility.IMatch_changeVisibility>(this);
        }

        public Rule_changeVisibility _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "changeVisibility"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_changeVisibility.Match_changeVisibility, Rule_changeVisibility.IMatch_changeVisibility> matches;

        public static Action_changeVisibility Instance { get { return instance; } }
        private static Action_changeVisibility instance = new Action_changeVisibility();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IVariable changeVisibility_node_v)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset changeVisibility_node_v 
            GRGEN_LGSP.LGSPNode candidate_changeVisibility_node_v = (GRGEN_LGSP.LGSPNode)changeVisibility_node_v;
            if(candidate_changeVisibility_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            Rule_changeVisibility.Match_changeVisibility match = matches.GetNextUnfilledPosition();
            match._node_v = candidate_changeVisibility_node_v;
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IVariable changeVisibility_node_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IVariable changeVisibility_node_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, changeVisibility_node_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_changeVisibility.IMatch_changeVisibility match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility> matches)
        {
            foreach(Rule_changeVisibility.IMatch_changeVisibility match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable changeVisibility_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, changeVisibility_node_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable changeVisibility_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, changeVisibility_node_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_changeVisibility.IMatch_changeVisibility match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable changeVisibility_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, changeVisibility_node_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IVariable changeVisibility_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, changeVisibility_node_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, changeVisibility_node_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IVariable changeVisibility_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, changeVisibility_node_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IVariable) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_changeVisibility.IMatch_changeVisibility)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_changeVisibility.IMatch_changeVisibility>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IVariable) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IVariable) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IVariable) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IVariable) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IVariable) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_adaptAccess
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_adaptAccess.IMatch_adaptAccess match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter);
    }
    
    public class Action_adaptAccess : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_adaptAccess
    {
        public Action_adaptAccess() {
            _rulePattern = Rule_adaptAccess.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_adaptAccess.Match_adaptAccess, Rule_adaptAccess.IMatch_adaptAccess>(this);
        }

        public Rule_adaptAccess _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "adaptAccess"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_adaptAccess.Match_adaptAccess, Rule_adaptAccess.IMatch_adaptAccess> matches;

        public static Action_adaptAccess Instance { get { return instance; } }
        private static Action_adaptAccess instance = new Action_adaptAccess();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset adaptAccess_node_v 
            GRGEN_LGSP.LGSPNode candidate_adaptAccess_node_v = (GRGEN_LGSP.LGSPNode)adaptAccess_node_v;
            if(candidate_adaptAccess_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            // Preset adaptAccess_node_c 
            GRGEN_LGSP.LGSPNode candidate_adaptAccess_node_c = (GRGEN_LGSP.LGSPNode)adaptAccess_node_c;
            if(candidate_adaptAccess_node_c.lgspType.TypeID!=3) {
                return matches;
            }
            // Preset adaptAccess_node_getter 
            GRGEN_LGSP.LGSPNode candidate_adaptAccess_node_getter = (GRGEN_LGSP.LGSPNode)adaptAccess_node_getter;
            if(candidate_adaptAccess_node_getter.lgspType.TypeID!=6) {
                return matches;
            }
            // Extend Incoming adaptAccess_edge_l from adaptAccess_node_v 
            GRGEN_LGSP.LGSPEdge head_candidate_adaptAccess_edge_l = candidate_adaptAccess_node_v.lgspInhead;
            if(head_candidate_adaptAccess_edge_l != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_adaptAccess_edge_l = head_candidate_adaptAccess_edge_l;
                do
                {
                    if(candidate_adaptAccess_edge_l.lgspType.TypeID!=11) {
                        continue;
                    }
                    // Implicit Source adaptAccess_node_a from adaptAccess_edge_l 
                    GRGEN_LGSP.LGSPNode candidate_adaptAccess_node_a = candidate_adaptAccess_edge_l.lgspSource;
                    if(candidate_adaptAccess_node_a.lgspType.TypeID!=9) {
                        continue;
                    }
                    // NegativePattern 
                    {
                        ++negLevel;
                        Stack<GRGEN_LGSP.LGSPSubpatternAction> neg_0_openTasks = new Stack<GRGEN_LGSP.LGSPSubpatternAction>();
                        List<Stack<GRGEN_LIBGR.IMatch>> neg_0_foundPartialMatches = new List<Stack<GRGEN_LIBGR.IMatch>>();
                        List<Stack<GRGEN_LIBGR.IMatch>> neg_0_matchesList = neg_0_foundPartialMatches;
                        // Push subpattern matching task for _sub0
                        PatternAction_InClass taskFor_neg_0__sub0 = PatternAction_InClass.getNewTask(graph, neg_0_openTasks);
                        taskFor_neg_0__sub0.InClass_node_e = candidate_adaptAccess_node_a;
                        taskFor_neg_0__sub0.InClass_node_c = candidate_adaptAccess_node_c;
                        taskFor_neg_0__sub0.searchPatternpath = false;
                        taskFor_neg_0__sub0.matchOfNestingPattern = null;
                        taskFor_neg_0__sub0.lastMatchAtPreviousNestingLevel = null;
                        neg_0_openTasks.Push(taskFor_neg_0__sub0);
                        uint prevGlobal_neg_0__candidate_adaptAccess_node_c;
                        prevGlobal_neg_0__candidate_adaptAccess_node_c = candidate_adaptAccess_node_c.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_adaptAccess_node_c.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns of neg_0_
                        neg_0_openTasks.Peek().myMatch(neg_0_matchesList, 1, negLevel);
                        // Pop subpattern matching task for _sub0
                        neg_0_openTasks.Pop();
                        PatternAction_InClass.releaseTask(taskFor_neg_0__sub0);
                        // Check whether subpatterns were found 
                        if(neg_0_matchesList.Count>0) {
                            // negative pattern with contained subpatterns found
                            neg_0_matchesList.Clear();
                            candidate_adaptAccess_node_c.lgspFlags = candidate_adaptAccess_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal_neg_0__candidate_adaptAccess_node_c;
                            --negLevel;
                            goto label16;
                        }
                        candidate_adaptAccess_node_c.lgspFlags = candidate_adaptAccess_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal_neg_0__candidate_adaptAccess_node_c;
                        --negLevel;
                    }
                    Rule_adaptAccess.Match_adaptAccess match = matches.GetNextUnfilledPosition();
                    match._node_a = candidate_adaptAccess_node_a;
                    match._node_v = candidate_adaptAccess_node_v;
                    match._node_c = candidate_adaptAccess_node_c;
                    match._node_getter = candidate_adaptAccess_node_getter;
                    match._edge_l = candidate_adaptAccess_edge_l;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        candidate_adaptAccess_node_v.MoveInHeadAfter(candidate_adaptAccess_edge_l);
                        return matches;
                    }
label16: ;
                }
                while( (candidate_adaptAccess_edge_l = candidate_adaptAccess_edge_l.lgspInNext) != head_candidate_adaptAccess_edge_l );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, adaptAccess_node_c, adaptAccess_node_v, adaptAccess_node_getter);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_adaptAccess.IMatch_adaptAccess match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess> matches)
        {
            foreach(Rule_adaptAccess.IMatch_adaptAccess match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptAccess_node_c, adaptAccess_node_v, adaptAccess_node_getter);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, adaptAccess_node_c, adaptAccess_node_v, adaptAccess_node_getter);
            if(matches.Count <= 0) return false;
            foreach(Rule_adaptAccess.IMatch_adaptAccess match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptAccess_node_c, adaptAccess_node_v, adaptAccess_node_getter);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptAccess_node_c, adaptAccess_node_v, adaptAccess_node_getter);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptAccess_node_c, adaptAccess_node_v, adaptAccess_node_getter);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass adaptAccess_node_c, GRGEN_MODEL.IVariable adaptAccess_node_v, GRGEN_MODEL.IOperation adaptAccess_node_getter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptAccess_node_c, adaptAccess_node_v, adaptAccess_node_getter);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_adaptAccess.IMatch_adaptAccess)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_adaptAccess.IMatch_adaptAccess>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_adaptUpdate
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_adaptUpdate.IMatch_adaptUpdate match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter);
    }
    
    public class Action_adaptUpdate : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_adaptUpdate
    {
        public Action_adaptUpdate() {
            _rulePattern = Rule_adaptUpdate.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_adaptUpdate.Match_adaptUpdate, Rule_adaptUpdate.IMatch_adaptUpdate>(this);
        }

        public Rule_adaptUpdate _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "adaptUpdate"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_adaptUpdate.Match_adaptUpdate, Rule_adaptUpdate.IMatch_adaptUpdate> matches;

        public static Action_adaptUpdate Instance { get { return instance; } }
        private static Action_adaptUpdate instance = new Action_adaptUpdate();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset adaptUpdate_node_v 
            GRGEN_LGSP.LGSPNode candidate_adaptUpdate_node_v = (GRGEN_LGSP.LGSPNode)adaptUpdate_node_v;
            if(candidate_adaptUpdate_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            // Preset adaptUpdate_node_c 
            GRGEN_LGSP.LGSPNode candidate_adaptUpdate_node_c = (GRGEN_LGSP.LGSPNode)adaptUpdate_node_c;
            if(candidate_adaptUpdate_node_c.lgspType.TypeID!=3) {
                return matches;
            }
            // Preset adaptUpdate_node_setter 
            GRGEN_LGSP.LGSPNode candidate_adaptUpdate_node_setter = (GRGEN_LGSP.LGSPNode)adaptUpdate_node_setter;
            if(candidate_adaptUpdate_node_setter.lgspType.TypeID!=6) {
                return matches;
            }
            // Extend Incoming adaptUpdate_edge_l from adaptUpdate_node_v 
            GRGEN_LGSP.LGSPEdge head_candidate_adaptUpdate_edge_l = candidate_adaptUpdate_node_v.lgspInhead;
            if(head_candidate_adaptUpdate_edge_l != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_adaptUpdate_edge_l = head_candidate_adaptUpdate_edge_l;
                do
                {
                    if(candidate_adaptUpdate_edge_l.lgspType.TypeID!=11) {
                        continue;
                    }
                    // Implicit Source adaptUpdate_node_u from adaptUpdate_edge_l 
                    GRGEN_LGSP.LGSPNode candidate_adaptUpdate_node_u = candidate_adaptUpdate_edge_l.lgspSource;
                    if(candidate_adaptUpdate_node_u.lgspType.TypeID!=10) {
                        continue;
                    }
                    uint prev__candidate_adaptUpdate_node_u;
                    prev__candidate_adaptUpdate_node_u = candidate_adaptUpdate_node_u.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    candidate_adaptUpdate_node_u.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    // NegativePattern 
                    {
                        ++negLevel;
                        Stack<GRGEN_LGSP.LGSPSubpatternAction> neg_0_openTasks = new Stack<GRGEN_LGSP.LGSPSubpatternAction>();
                        List<Stack<GRGEN_LIBGR.IMatch>> neg_0_foundPartialMatches = new List<Stack<GRGEN_LIBGR.IMatch>>();
                        List<Stack<GRGEN_LIBGR.IMatch>> neg_0_matchesList = neg_0_foundPartialMatches;
                        // Push subpattern matching task for _sub0
                        PatternAction_InClass taskFor_neg_0__sub0 = PatternAction_InClass.getNewTask(graph, neg_0_openTasks);
                        taskFor_neg_0__sub0.InClass_node_e = candidate_adaptUpdate_node_u;
                        taskFor_neg_0__sub0.InClass_node_c = candidate_adaptUpdate_node_c;
                        taskFor_neg_0__sub0.searchPatternpath = false;
                        taskFor_neg_0__sub0.matchOfNestingPattern = null;
                        taskFor_neg_0__sub0.lastMatchAtPreviousNestingLevel = null;
                        neg_0_openTasks.Push(taskFor_neg_0__sub0);
                        uint prevGlobal_neg_0__candidate_adaptUpdate_node_c;
                        prevGlobal_neg_0__candidate_adaptUpdate_node_c = candidate_adaptUpdate_node_c.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        candidate_adaptUpdate_node_c.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                        // Match subpatterns of neg_0_
                        neg_0_openTasks.Peek().myMatch(neg_0_matchesList, 1, negLevel);
                        // Pop subpattern matching task for _sub0
                        neg_0_openTasks.Pop();
                        PatternAction_InClass.releaseTask(taskFor_neg_0__sub0);
                        // Check whether subpatterns were found 
                        if(neg_0_matchesList.Count>0) {
                            // negative pattern with contained subpatterns found
                            neg_0_matchesList.Clear();
                            candidate_adaptUpdate_node_c.lgspFlags = candidate_adaptUpdate_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal_neg_0__candidate_adaptUpdate_node_c;
                            --negLevel;
                            candidate_adaptUpdate_node_u.lgspFlags = candidate_adaptUpdate_node_u.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_adaptUpdate_node_u;
                            goto label17;
                        }
                        candidate_adaptUpdate_node_c.lgspFlags = candidate_adaptUpdate_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal_neg_0__candidate_adaptUpdate_node_c;
                        --negLevel;
                    }
                    // Extend Outgoing adaptUpdate_edge_e from adaptUpdate_node_u 
                    GRGEN_LGSP.LGSPEdge head_candidate_adaptUpdate_edge_e = candidate_adaptUpdate_node_u.lgspOuthead;
                    if(head_candidate_adaptUpdate_edge_e != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_adaptUpdate_edge_e = head_candidate_adaptUpdate_edge_e;
                        do
                        {
                            if(candidate_adaptUpdate_edge_e.lgspType.TypeID!=12) {
                                continue;
                            }
                            // Implicit Target adaptUpdate_node_exp from adaptUpdate_edge_e 
                            GRGEN_LGSP.LGSPNode candidate_adaptUpdate_node_exp = candidate_adaptUpdate_edge_e.lgspTarget;
                            if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_adaptUpdate_node_exp.lgspType.TypeID]) {
                                continue;
                            }
                            if((candidate_adaptUpdate_node_exp.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                            {
                                continue;
                            }
                            Rule_adaptUpdate.Match_adaptUpdate match = matches.GetNextUnfilledPosition();
                            match._node_u = candidate_adaptUpdate_node_u;
                            match._node_v = candidate_adaptUpdate_node_v;
                            match._node_exp = candidate_adaptUpdate_node_exp;
                            match._node_c = candidate_adaptUpdate_node_c;
                            match._node_setter = candidate_adaptUpdate_node_setter;
                            match._edge_l = candidate_adaptUpdate_edge_l;
                            match._edge_e = candidate_adaptUpdate_edge_e;
                            matches.PositionWasFilledFixIt();
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && matches.Count >= maxMatches)
                            {
                                candidate_adaptUpdate_node_u.MoveOutHeadAfter(candidate_adaptUpdate_edge_e);
                                candidate_adaptUpdate_node_v.MoveInHeadAfter(candidate_adaptUpdate_edge_l);
                                candidate_adaptUpdate_node_u.lgspFlags = candidate_adaptUpdate_node_u.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_adaptUpdate_node_u;
                                return matches;
                            }
                        }
                        while( (candidate_adaptUpdate_edge_e = candidate_adaptUpdate_edge_e.lgspOutNext) != head_candidate_adaptUpdate_edge_e );
                    }
                    candidate_adaptUpdate_node_u.lgspFlags = candidate_adaptUpdate_node_u.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_adaptUpdate_node_u;
label17: ;
                }
                while( (candidate_adaptUpdate_edge_l = candidate_adaptUpdate_edge_l.lgspInNext) != head_candidate_adaptUpdate_edge_l );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, adaptUpdate_node_c, adaptUpdate_node_v, adaptUpdate_node_setter);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_adaptUpdate.IMatch_adaptUpdate match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate> matches)
        {
            foreach(Rule_adaptUpdate.IMatch_adaptUpdate match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptUpdate_node_c, adaptUpdate_node_v, adaptUpdate_node_setter);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, adaptUpdate_node_c, adaptUpdate_node_v, adaptUpdate_node_setter);
            if(matches.Count <= 0) return false;
            foreach(Rule_adaptUpdate.IMatch_adaptUpdate match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptUpdate_node_c, adaptUpdate_node_v, adaptUpdate_node_setter);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptUpdate_node_c, adaptUpdate_node_v, adaptUpdate_node_setter);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptUpdate_node_c, adaptUpdate_node_v, adaptUpdate_node_setter);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass adaptUpdate_node_c, GRGEN_MODEL.IVariable adaptUpdate_node_v, GRGEN_MODEL.IOperation adaptUpdate_node_setter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptUpdate_node_c, adaptUpdate_node_v, adaptUpdate_node_setter);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_adaptUpdate.IMatch_adaptUpdate)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdate.IMatch_adaptUpdate>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_adaptAccessUseAccessorsAlways
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter);
    }
    
    public class Action_adaptAccessUseAccessorsAlways : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_adaptAccessUseAccessorsAlways
    {
        public Action_adaptAccessUseAccessorsAlways() {
            _rulePattern = Rule_adaptAccessUseAccessorsAlways.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_adaptAccessUseAccessorsAlways.Match_adaptAccessUseAccessorsAlways, Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways>(this);
        }

        public Rule_adaptAccessUseAccessorsAlways _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "adaptAccessUseAccessorsAlways"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_adaptAccessUseAccessorsAlways.Match_adaptAccessUseAccessorsAlways, Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> matches;

        public static Action_adaptAccessUseAccessorsAlways Instance { get { return instance; } }
        private static Action_adaptAccessUseAccessorsAlways instance = new Action_adaptAccessUseAccessorsAlways();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset adaptAccessUseAccessorsAlways_node_v 
            GRGEN_LGSP.LGSPNode candidate_adaptAccessUseAccessorsAlways_node_v = (GRGEN_LGSP.LGSPNode)adaptAccessUseAccessorsAlways_node_v;
            if(candidate_adaptAccessUseAccessorsAlways_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            // Preset adaptAccessUseAccessorsAlways_node_c 
            GRGEN_LGSP.LGSPNode candidate_adaptAccessUseAccessorsAlways_node_c = (GRGEN_LGSP.LGSPNode)adaptAccessUseAccessorsAlways_node_c;
            if(candidate_adaptAccessUseAccessorsAlways_node_c.lgspType.TypeID!=3) {
                return matches;
            }
            // Preset adaptAccessUseAccessorsAlways_node_getter 
            GRGEN_LGSP.LGSPNode candidate_adaptAccessUseAccessorsAlways_node_getter = (GRGEN_LGSP.LGSPNode)adaptAccessUseAccessorsAlways_node_getter;
            if(candidate_adaptAccessUseAccessorsAlways_node_getter.lgspType.TypeID!=6) {
                return matches;
            }
            // Extend Incoming adaptAccessUseAccessorsAlways_edge_l from adaptAccessUseAccessorsAlways_node_v 
            GRGEN_LGSP.LGSPEdge head_candidate_adaptAccessUseAccessorsAlways_edge_l = candidate_adaptAccessUseAccessorsAlways_node_v.lgspInhead;
            if(head_candidate_adaptAccessUseAccessorsAlways_edge_l != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_adaptAccessUseAccessorsAlways_edge_l = head_candidate_adaptAccessUseAccessorsAlways_edge_l;
                do
                {
                    if(candidate_adaptAccessUseAccessorsAlways_edge_l.lgspType.TypeID!=11) {
                        continue;
                    }
                    // Implicit Source adaptAccessUseAccessorsAlways_node_a from adaptAccessUseAccessorsAlways_edge_l 
                    GRGEN_LGSP.LGSPNode candidate_adaptAccessUseAccessorsAlways_node_a = candidate_adaptAccessUseAccessorsAlways_edge_l.lgspSource;
                    if(candidate_adaptAccessUseAccessorsAlways_node_a.lgspType.TypeID!=9) {
                        continue;
                    }
                    Rule_adaptAccessUseAccessorsAlways.Match_adaptAccessUseAccessorsAlways match = matches.GetNextUnfilledPosition();
                    match._node_a = candidate_adaptAccessUseAccessorsAlways_node_a;
                    match._node_v = candidate_adaptAccessUseAccessorsAlways_node_v;
                    match._node_c = candidate_adaptAccessUseAccessorsAlways_node_c;
                    match._node_getter = candidate_adaptAccessUseAccessorsAlways_node_getter;
                    match._edge_l = candidate_adaptAccessUseAccessorsAlways_edge_l;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        candidate_adaptAccessUseAccessorsAlways_node_v.MoveInHeadAfter(candidate_adaptAccessUseAccessorsAlways_edge_l);
                        return matches;
                    }
                }
                while( (candidate_adaptAccessUseAccessorsAlways_edge_l = candidate_adaptAccessUseAccessorsAlways_edge_l.lgspInNext) != head_candidate_adaptAccessUseAccessorsAlways_edge_l );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, adaptAccessUseAccessorsAlways_node_c, adaptAccessUseAccessorsAlways_node_v, adaptAccessUseAccessorsAlways_node_getter);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> matches)
        {
            foreach(Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptAccessUseAccessorsAlways_node_c, adaptAccessUseAccessorsAlways_node_v, adaptAccessUseAccessorsAlways_node_getter);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, adaptAccessUseAccessorsAlways_node_c, adaptAccessUseAccessorsAlways_node_v, adaptAccessUseAccessorsAlways_node_getter);
            if(matches.Count <= 0) return false;
            foreach(Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptAccessUseAccessorsAlways_node_c, adaptAccessUseAccessorsAlways_node_v, adaptAccessUseAccessorsAlways_node_getter);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptAccessUseAccessorsAlways_node_c, adaptAccessUseAccessorsAlways_node_v, adaptAccessUseAccessorsAlways_node_getter);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptAccessUseAccessorsAlways_node_c, adaptAccessUseAccessorsAlways_node_v, adaptAccessUseAccessorsAlways_node_getter);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass adaptAccessUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptAccessUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptAccessUseAccessorsAlways_node_getter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptAccessUseAccessorsAlways_node_c, adaptAccessUseAccessorsAlways_node_v, adaptAccessUseAccessorsAlways_node_getter);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_adaptAccessUseAccessorsAlways.IMatch_adaptAccessUseAccessorsAlways>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_adaptUpdateUseAccessorsAlways
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter);
    }
    
    public class Action_adaptUpdateUseAccessorsAlways : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_adaptUpdateUseAccessorsAlways
    {
        public Action_adaptUpdateUseAccessorsAlways() {
            _rulePattern = Rule_adaptUpdateUseAccessorsAlways.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_adaptUpdateUseAccessorsAlways.Match_adaptUpdateUseAccessorsAlways, Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways>(this);
        }

        public Rule_adaptUpdateUseAccessorsAlways _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "adaptUpdateUseAccessorsAlways"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_adaptUpdateUseAccessorsAlways.Match_adaptUpdateUseAccessorsAlways, Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> matches;

        public static Action_adaptUpdateUseAccessorsAlways Instance { get { return instance; } }
        private static Action_adaptUpdateUseAccessorsAlways instance = new Action_adaptUpdateUseAccessorsAlways();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset adaptUpdateUseAccessorsAlways_node_v 
            GRGEN_LGSP.LGSPNode candidate_adaptUpdateUseAccessorsAlways_node_v = (GRGEN_LGSP.LGSPNode)adaptUpdateUseAccessorsAlways_node_v;
            if(candidate_adaptUpdateUseAccessorsAlways_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            // Preset adaptUpdateUseAccessorsAlways_node_c 
            GRGEN_LGSP.LGSPNode candidate_adaptUpdateUseAccessorsAlways_node_c = (GRGEN_LGSP.LGSPNode)adaptUpdateUseAccessorsAlways_node_c;
            if(candidate_adaptUpdateUseAccessorsAlways_node_c.lgspType.TypeID!=3) {
                return matches;
            }
            // Preset adaptUpdateUseAccessorsAlways_node_setter 
            GRGEN_LGSP.LGSPNode candidate_adaptUpdateUseAccessorsAlways_node_setter = (GRGEN_LGSP.LGSPNode)adaptUpdateUseAccessorsAlways_node_setter;
            if(candidate_adaptUpdateUseAccessorsAlways_node_setter.lgspType.TypeID!=6) {
                return matches;
            }
            // Extend Incoming adaptUpdateUseAccessorsAlways_edge_l from adaptUpdateUseAccessorsAlways_node_v 
            GRGEN_LGSP.LGSPEdge head_candidate_adaptUpdateUseAccessorsAlways_edge_l = candidate_adaptUpdateUseAccessorsAlways_node_v.lgspInhead;
            if(head_candidate_adaptUpdateUseAccessorsAlways_edge_l != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_adaptUpdateUseAccessorsAlways_edge_l = head_candidate_adaptUpdateUseAccessorsAlways_edge_l;
                do
                {
                    if(candidate_adaptUpdateUseAccessorsAlways_edge_l.lgspType.TypeID!=11) {
                        continue;
                    }
                    // Implicit Source adaptUpdateUseAccessorsAlways_node_u from adaptUpdateUseAccessorsAlways_edge_l 
                    GRGEN_LGSP.LGSPNode candidate_adaptUpdateUseAccessorsAlways_node_u = candidate_adaptUpdateUseAccessorsAlways_edge_l.lgspSource;
                    if(candidate_adaptUpdateUseAccessorsAlways_node_u.lgspType.TypeID!=10) {
                        continue;
                    }
                    uint prev__candidate_adaptUpdateUseAccessorsAlways_node_u;
                    prev__candidate_adaptUpdateUseAccessorsAlways_node_u = candidate_adaptUpdateUseAccessorsAlways_node_u.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    candidate_adaptUpdateUseAccessorsAlways_node_u.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    // Extend Outgoing adaptUpdateUseAccessorsAlways_edge_e from adaptUpdateUseAccessorsAlways_node_u 
                    GRGEN_LGSP.LGSPEdge head_candidate_adaptUpdateUseAccessorsAlways_edge_e = candidate_adaptUpdateUseAccessorsAlways_node_u.lgspOuthead;
                    if(head_candidate_adaptUpdateUseAccessorsAlways_edge_e != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_adaptUpdateUseAccessorsAlways_edge_e = head_candidate_adaptUpdateUseAccessorsAlways_edge_e;
                        do
                        {
                            if(candidate_adaptUpdateUseAccessorsAlways_edge_e.lgspType.TypeID!=12) {
                                continue;
                            }
                            // Implicit Target adaptUpdateUseAccessorsAlways_node_exp from adaptUpdateUseAccessorsAlways_edge_e 
                            GRGEN_LGSP.LGSPNode candidate_adaptUpdateUseAccessorsAlways_node_exp = candidate_adaptUpdateUseAccessorsAlways_edge_e.lgspTarget;
                            if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_adaptUpdateUseAccessorsAlways_node_exp.lgspType.TypeID]) {
                                continue;
                            }
                            if((candidate_adaptUpdateUseAccessorsAlways_node_exp.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                            {
                                continue;
                            }
                            Rule_adaptUpdateUseAccessorsAlways.Match_adaptUpdateUseAccessorsAlways match = matches.GetNextUnfilledPosition();
                            match._node_u = candidate_adaptUpdateUseAccessorsAlways_node_u;
                            match._node_v = candidate_adaptUpdateUseAccessorsAlways_node_v;
                            match._node_exp = candidate_adaptUpdateUseAccessorsAlways_node_exp;
                            match._node_c = candidate_adaptUpdateUseAccessorsAlways_node_c;
                            match._node_setter = candidate_adaptUpdateUseAccessorsAlways_node_setter;
                            match._edge_l = candidate_adaptUpdateUseAccessorsAlways_edge_l;
                            match._edge_e = candidate_adaptUpdateUseAccessorsAlways_edge_e;
                            matches.PositionWasFilledFixIt();
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && matches.Count >= maxMatches)
                            {
                                candidate_adaptUpdateUseAccessorsAlways_node_u.MoveOutHeadAfter(candidate_adaptUpdateUseAccessorsAlways_edge_e);
                                candidate_adaptUpdateUseAccessorsAlways_node_v.MoveInHeadAfter(candidate_adaptUpdateUseAccessorsAlways_edge_l);
                                candidate_adaptUpdateUseAccessorsAlways_node_u.lgspFlags = candidate_adaptUpdateUseAccessorsAlways_node_u.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_adaptUpdateUseAccessorsAlways_node_u;
                                return matches;
                            }
                        }
                        while( (candidate_adaptUpdateUseAccessorsAlways_edge_e = candidate_adaptUpdateUseAccessorsAlways_edge_e.lgspOutNext) != head_candidate_adaptUpdateUseAccessorsAlways_edge_e );
                    }
                    candidate_adaptUpdateUseAccessorsAlways_node_u.lgspFlags = candidate_adaptUpdateUseAccessorsAlways_node_u.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_adaptUpdateUseAccessorsAlways_node_u;
                }
                while( (candidate_adaptUpdateUseAccessorsAlways_edge_l = candidate_adaptUpdateUseAccessorsAlways_edge_l.lgspInNext) != head_candidate_adaptUpdateUseAccessorsAlways_edge_l );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, adaptUpdateUseAccessorsAlways_node_c, adaptUpdateUseAccessorsAlways_node_v, adaptUpdateUseAccessorsAlways_node_setter);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> matches)
        {
            foreach(Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptUpdateUseAccessorsAlways_node_c, adaptUpdateUseAccessorsAlways_node_v, adaptUpdateUseAccessorsAlways_node_setter);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, adaptUpdateUseAccessorsAlways_node_c, adaptUpdateUseAccessorsAlways_node_v, adaptUpdateUseAccessorsAlways_node_setter);
            if(matches.Count <= 0) return false;
            foreach(Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptUpdateUseAccessorsAlways_node_c, adaptUpdateUseAccessorsAlways_node_v, adaptUpdateUseAccessorsAlways_node_setter);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptUpdateUseAccessorsAlways_node_c, adaptUpdateUseAccessorsAlways_node_v, adaptUpdateUseAccessorsAlways_node_setter);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptUpdateUseAccessorsAlways_node_c, adaptUpdateUseAccessorsAlways_node_v, adaptUpdateUseAccessorsAlways_node_setter);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass adaptUpdateUseAccessorsAlways_node_c, GRGEN_MODEL.IVariable adaptUpdateUseAccessorsAlways_node_v, GRGEN_MODEL.IOperation adaptUpdateUseAccessorsAlways_node_setter)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, adaptUpdateUseAccessorsAlways_node_c, adaptUpdateUseAccessorsAlways_node_v, adaptUpdateUseAccessorsAlways_node_setter);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_adaptUpdateUseAccessorsAlways.IMatch_adaptUpdateUseAccessorsAlways>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_getSourceAndTargetAndMethodBody
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody match, out GRGEN_MODEL.IClass output_0, out GRGEN_MODEL.IClass output_1, out GRGEN_MODEL.IMethodBody output_2);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> matches, out GRGEN_MODEL.IClass output_0, out GRGEN_MODEL.IClass output_1, out GRGEN_MODEL.IMethodBody output_2);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb, ref GRGEN_MODEL.IClass output_0, ref GRGEN_MODEL.IClass output_1, ref GRGEN_MODEL.IMethodBody output_2);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb, ref GRGEN_MODEL.IClass output_0, ref GRGEN_MODEL.IClass output_1, ref GRGEN_MODEL.IMethodBody output_2);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb);
    }
    
    public class Action_getSourceAndTargetAndMethodBody : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_getSourceAndTargetAndMethodBody
    {
        public Action_getSourceAndTargetAndMethodBody() {
            _rulePattern = Rule_getSourceAndTargetAndMethodBody.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[3];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_getSourceAndTargetAndMethodBody.Match_getSourceAndTargetAndMethodBody, Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody>(this);
        }

        public Rule_getSourceAndTargetAndMethodBody _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "getSourceAndTargetAndMethodBody"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_getSourceAndTargetAndMethodBody.Match_getSourceAndTargetAndMethodBody, Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> matches;

        public static Action_getSourceAndTargetAndMethodBody Instance { get { return instance; } }
        private static Action_getSourceAndTargetAndMethodBody instance = new Action_getSourceAndTargetAndMethodBody();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset getSourceAndTargetAndMethodBody_node_src 
            GRGEN_LGSP.LGSPNode candidate_getSourceAndTargetAndMethodBody_node_src = (GRGEN_LGSP.LGSPNode)getSourceAndTargetAndMethodBody_node_src;
            if(candidate_getSourceAndTargetAndMethodBody_node_src.lgspType.TypeID!=3) {
                return matches;
            }
            uint prev__candidate_getSourceAndTargetAndMethodBody_node_src;
            prev__candidate_getSourceAndTargetAndMethodBody_node_src = candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Preset getSourceAndTargetAndMethodBody_node_tgt 
            GRGEN_LGSP.LGSPNode candidate_getSourceAndTargetAndMethodBody_node_tgt = (GRGEN_LGSP.LGSPNode)getSourceAndTargetAndMethodBody_node_tgt;
            if(candidate_getSourceAndTargetAndMethodBody_node_tgt.lgspType.TypeID!=3) {
                candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags = candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_getSourceAndTargetAndMethodBody_node_src;
                return matches;
            }
            if((candidate_getSourceAndTargetAndMethodBody_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
            {
                candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags = candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_getSourceAndTargetAndMethodBody_node_src;
                return matches;
            }
            // Preset getSourceAndTargetAndMethodBody_node_mb 
            GRGEN_LGSP.LGSPNode candidate_getSourceAndTargetAndMethodBody_node_mb = (GRGEN_LGSP.LGSPNode)getSourceAndTargetAndMethodBody_node_mb;
            if(candidate_getSourceAndTargetAndMethodBody_node_mb.lgspType.TypeID!=7) {
                candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags = candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_getSourceAndTargetAndMethodBody_node_src;
                return matches;
            }
            Rule_getSourceAndTargetAndMethodBody.Match_getSourceAndTargetAndMethodBody match = matches.GetNextUnfilledPosition();
            match._node_src = candidate_getSourceAndTargetAndMethodBody_node_src;
            match._node_tgt = candidate_getSourceAndTargetAndMethodBody_node_tgt;
            match._node_mb = candidate_getSourceAndTargetAndMethodBody_node_mb;
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags = candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_getSourceAndTargetAndMethodBody_node_src;
                return matches;
            }
            candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags = candidate_getSourceAndTargetAndMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_getSourceAndTargetAndMethodBody_node_src;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, getSourceAndTargetAndMethodBody_node_src, getSourceAndTargetAndMethodBody_node_tgt, getSourceAndTargetAndMethodBody_node_mb);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody match, out GRGEN_MODEL.IClass output_0, out GRGEN_MODEL.IClass output_1, out GRGEN_MODEL.IMethodBody output_2)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0, out output_1, out output_2);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> matches, out GRGEN_MODEL.IClass output_0, out GRGEN_MODEL.IClass output_1, out GRGEN_MODEL.IMethodBody output_2)
        {
            output_0 = null;
            output_1 = null;
            output_2 = null;
            foreach(Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0, out output_1, out output_2);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb, ref GRGEN_MODEL.IClass output_0, ref GRGEN_MODEL.IClass output_1, ref GRGEN_MODEL.IMethodBody output_2)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getSourceAndTargetAndMethodBody_node_src, getSourceAndTargetAndMethodBody_node_tgt, getSourceAndTargetAndMethodBody_node_mb);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1, out output_2);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb, ref GRGEN_MODEL.IClass output_0, ref GRGEN_MODEL.IClass output_1, ref GRGEN_MODEL.IMethodBody output_2)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, getSourceAndTargetAndMethodBody_node_src, getSourceAndTargetAndMethodBody_node_tgt, getSourceAndTargetAndMethodBody_node_mb);
            if(matches.Count <= 0) return false;
            foreach(Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0, out output_1, out output_2);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> matches;
            GRGEN_MODEL.IClass output_0; GRGEN_MODEL.IClass output_1; GRGEN_MODEL.IMethodBody output_2; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getSourceAndTargetAndMethodBody_node_src, getSourceAndTargetAndMethodBody_node_tgt, getSourceAndTargetAndMethodBody_node_mb);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1, out output_2);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getSourceAndTargetAndMethodBody_node_src, getSourceAndTargetAndMethodBody_node_tgt, getSourceAndTargetAndMethodBody_node_mb);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IClass output_0; GRGEN_MODEL.IClass output_1; GRGEN_MODEL.IMethodBody output_2; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1, out output_2);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getSourceAndTargetAndMethodBody_node_src, getSourceAndTargetAndMethodBody_node_tgt, getSourceAndTargetAndMethodBody_node_mb);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_src, GRGEN_MODEL.IClass getSourceAndTargetAndMethodBody_node_tgt, GRGEN_MODEL.IMethodBody getSourceAndTargetAndMethodBody_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody> matches;
            GRGEN_MODEL.IClass output_0; GRGEN_MODEL.IClass output_1; GRGEN_MODEL.IMethodBody output_2; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getSourceAndTargetAndMethodBody_node_src, getSourceAndTargetAndMethodBody_node_tgt, getSourceAndTargetAndMethodBody_node_mb);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1, out output_2);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IMethodBody) parameters[2]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IClass output_0; GRGEN_MODEL.IClass output_1; GRGEN_MODEL.IMethodBody output_2; 
            Modify(graph, (Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody)match, out output_0, out output_1, out output_2);
            ReturnArray[0] = output_0;
            ReturnArray[1] = output_1;
            ReturnArray[2] = output_2;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.IClass output_0; GRGEN_MODEL.IClass output_1; GRGEN_MODEL.IMethodBody output_2; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_getSourceAndTargetAndMethodBody.IMatch_getSourceAndTargetAndMethodBody>)matches, out output_0, out output_1, out output_2);
            ReturnArray[0] = output_0;
            ReturnArray[1] = output_1;
            ReturnArray[2] = output_2;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IClass output_0 = null; GRGEN_MODEL.IClass output_1 = null; GRGEN_MODEL.IMethodBody output_2 = null; 
            if(Apply(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IMethodBody) parameters[2], ref output_0, ref output_1, ref output_2)) {
                ReturnArray[0] = output_0;
                ReturnArray[1] = output_1;
                ReturnArray[2] = output_2;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IClass output_0 = null; GRGEN_MODEL.IClass output_1 = null; GRGEN_MODEL.IMethodBody output_2 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IMethodBody) parameters[2], ref output_0, ref output_1, ref output_2)) {
                ReturnArray[0] = output_0;
                ReturnArray[1] = output_1;
                ReturnArray[2] = output_2;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IMethodBody) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IMethodBody) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IMethodBody) parameters[2]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_getOperation
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody getOperation_node_mb);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_getOperation.IMatch_getOperation match, out GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation> matches, out GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody getOperation_node_mb, ref GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody getOperation_node_mb, ref GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody getOperation_node_mb);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody getOperation_node_mb);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody getOperation_node_mb);
    }
    
    public class Action_getOperation : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_getOperation
    {
        public Action_getOperation() {
            _rulePattern = Rule_getOperation.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[1];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_getOperation.Match_getOperation, Rule_getOperation.IMatch_getOperation>(this);
        }

        public Rule_getOperation _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "getOperation"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_getOperation.Match_getOperation, Rule_getOperation.IMatch_getOperation> matches;

        public static Action_getOperation Instance { get { return instance; } }
        private static Action_getOperation instance = new Action_getOperation();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody getOperation_node_mb)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset getOperation_node_mb 
            GRGEN_LGSP.LGSPNode candidate_getOperation_node_mb = (GRGEN_LGSP.LGSPNode)getOperation_node_mb;
            if(candidate_getOperation_node_mb.lgspType.TypeID!=7) {
                return matches;
            }
            // Extend Incoming getOperation_edge__edge0 from getOperation_node_mb 
            GRGEN_LGSP.LGSPEdge head_candidate_getOperation_edge__edge0 = candidate_getOperation_node_mb.lgspInhead;
            if(head_candidate_getOperation_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_getOperation_edge__edge0 = head_candidate_getOperation_edge__edge0;
                do
                {
                    if(candidate_getOperation_edge__edge0.lgspType.TypeID!=10) {
                        continue;
                    }
                    // Implicit Source getOperation_node_op from getOperation_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_getOperation_node_op = candidate_getOperation_edge__edge0.lgspSource;
                    if(candidate_getOperation_node_op.lgspType.TypeID!=6) {
                        continue;
                    }
                    Rule_getOperation.Match_getOperation match = matches.GetNextUnfilledPosition();
                    match._node_op = candidate_getOperation_node_op;
                    match._node_mb = candidate_getOperation_node_mb;
                    match._edge__edge0 = candidate_getOperation_edge__edge0;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        candidate_getOperation_node_mb.MoveInHeadAfter(candidate_getOperation_edge__edge0);
                        return matches;
                    }
                }
                while( (candidate_getOperation_edge__edge0 = candidate_getOperation_edge__edge0.lgspInNext) != head_candidate_getOperation_edge__edge0 );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody getOperation_node_mb);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody getOperation_node_mb)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, getOperation_node_mb);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_getOperation.IMatch_getOperation match, out GRGEN_MODEL.IOperation output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation> matches, out GRGEN_MODEL.IOperation output_0)
        {
            output_0 = null;
            foreach(Rule_getOperation.IMatch_getOperation match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody getOperation_node_mb, ref GRGEN_MODEL.IOperation output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getOperation_node_mb);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody getOperation_node_mb, ref GRGEN_MODEL.IOperation output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, getOperation_node_mb);
            if(matches.Count <= 0) return false;
            foreach(Rule_getOperation.IMatch_getOperation match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody getOperation_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation> matches;
            GRGEN_MODEL.IOperation output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getOperation_node_mb);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody getOperation_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getOperation_node_mb);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IOperation output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getOperation_node_mb);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody getOperation_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation> matches;
            GRGEN_MODEL.IOperation output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getOperation_node_mb);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IOperation output_0; 
            Modify(graph, (Rule_getOperation.IMatch_getOperation)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.IOperation output_0; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_getOperation.IMatch_getOperation>)matches, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IOperation output_0 = null; 
            if(Apply(graph, (GRGEN_MODEL.IMethodBody) parameters[0], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IOperation output_0 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IMethodBody) parameters[0], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_someInstanceVariableOfTargetType
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType match, out GRGEN_MODEL.IVariable output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> matches, out GRGEN_MODEL.IVariable output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt, ref GRGEN_MODEL.IVariable output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt, ref GRGEN_MODEL.IVariable output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt);
    }
    
    public class Action_someInstanceVariableOfTargetType : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_someInstanceVariableOfTargetType
    {
        public Action_someInstanceVariableOfTargetType() {
            _rulePattern = Rule_someInstanceVariableOfTargetType.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[1];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_someInstanceVariableOfTargetType.Match_someInstanceVariableOfTargetType, Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType>(this);
        }

        public Rule_someInstanceVariableOfTargetType _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "someInstanceVariableOfTargetType"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_someInstanceVariableOfTargetType.Match_someInstanceVariableOfTargetType, Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> matches;

        public static Action_someInstanceVariableOfTargetType Instance { get { return instance; } }
        private static Action_someInstanceVariableOfTargetType instance = new Action_someInstanceVariableOfTargetType();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset someInstanceVariableOfTargetType_node_mb 
            GRGEN_LGSP.LGSPNode candidate_someInstanceVariableOfTargetType_node_mb = (GRGEN_LGSP.LGSPNode)someInstanceVariableOfTargetType_node_mb;
            if(candidate_someInstanceVariableOfTargetType_node_mb.lgspType.TypeID!=7) {
                return matches;
            }
            // Preset someInstanceVariableOfTargetType_node_tgt 
            GRGEN_LGSP.LGSPNode candidate_someInstanceVariableOfTargetType_node_tgt = (GRGEN_LGSP.LGSPNode)someInstanceVariableOfTargetType_node_tgt;
            if(candidate_someInstanceVariableOfTargetType_node_tgt.lgspType.TypeID!=3) {
                return matches;
            }
            uint prev__candidate_someInstanceVariableOfTargetType_node_tgt;
            prev__candidate_someInstanceVariableOfTargetType_node_tgt = candidate_someInstanceVariableOfTargetType_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_someInstanceVariableOfTargetType_node_tgt.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Extend Outgoing someInstanceVariableOfTargetType_edge__edge0 from someInstanceVariableOfTargetType_node_mb 
            GRGEN_LGSP.LGSPEdge head_candidate_someInstanceVariableOfTargetType_edge__edge0 = candidate_someInstanceVariableOfTargetType_node_mb.lgspOuthead;
            if(head_candidate_someInstanceVariableOfTargetType_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_someInstanceVariableOfTargetType_edge__edge0 = head_candidate_someInstanceVariableOfTargetType_edge__edge0;
                do
                {
                    if(candidate_someInstanceVariableOfTargetType_edge__edge0.lgspType.TypeID!=3) {
                        continue;
                    }
                    uint prev__candidate_someInstanceVariableOfTargetType_edge__edge0;
                    prev__candidate_someInstanceVariableOfTargetType_edge__edge0 = candidate_someInstanceVariableOfTargetType_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    candidate_someInstanceVariableOfTargetType_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    // Implicit Target someInstanceVariableOfTargetType_node_src from someInstanceVariableOfTargetType_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_someInstanceVariableOfTargetType_node_src = candidate_someInstanceVariableOfTargetType_edge__edge0.lgspTarget;
                    if(candidate_someInstanceVariableOfTargetType_node_src.lgspType.TypeID!=3) {
                        candidate_someInstanceVariableOfTargetType_edge__edge0.lgspFlags = candidate_someInstanceVariableOfTargetType_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_someInstanceVariableOfTargetType_edge__edge0;
                        continue;
                    }
                    if((candidate_someInstanceVariableOfTargetType_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                    {
                        candidate_someInstanceVariableOfTargetType_edge__edge0.lgspFlags = candidate_someInstanceVariableOfTargetType_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_someInstanceVariableOfTargetType_edge__edge0;
                        continue;
                    }
                    // Extend Incoming someInstanceVariableOfTargetType_edge__edge1 from someInstanceVariableOfTargetType_node_src 
                    GRGEN_LGSP.LGSPEdge head_candidate_someInstanceVariableOfTargetType_edge__edge1 = candidate_someInstanceVariableOfTargetType_node_src.lgspInhead;
                    if(head_candidate_someInstanceVariableOfTargetType_edge__edge1 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_someInstanceVariableOfTargetType_edge__edge1 = head_candidate_someInstanceVariableOfTargetType_edge__edge1;
                        do
                        {
                            if(candidate_someInstanceVariableOfTargetType_edge__edge1.lgspType.TypeID!=3) {
                                continue;
                            }
                            if((candidate_someInstanceVariableOfTargetType_edge__edge1.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                            {
                                continue;
                            }
                            // Implicit Source someInstanceVariableOfTargetType_node_v from someInstanceVariableOfTargetType_edge__edge1 
                            GRGEN_LGSP.LGSPNode candidate_someInstanceVariableOfTargetType_node_v = candidate_someInstanceVariableOfTargetType_edge__edge1.lgspSource;
                            if(candidate_someInstanceVariableOfTargetType_node_v.lgspType.TypeID!=5) {
                                continue;
                            }
                            // Extend Outgoing someInstanceVariableOfTargetType_edge__edge2 from someInstanceVariableOfTargetType_node_v 
                            GRGEN_LGSP.LGSPEdge head_candidate_someInstanceVariableOfTargetType_edge__edge2 = candidate_someInstanceVariableOfTargetType_node_v.lgspOuthead;
                            if(head_candidate_someInstanceVariableOfTargetType_edge__edge2 != null)
                            {
                                GRGEN_LGSP.LGSPEdge candidate_someInstanceVariableOfTargetType_edge__edge2 = head_candidate_someInstanceVariableOfTargetType_edge__edge2;
                                do
                                {
                                    if(candidate_someInstanceVariableOfTargetType_edge__edge2.lgspType.TypeID!=4) {
                                        continue;
                                    }
                                    if(candidate_someInstanceVariableOfTargetType_edge__edge2.lgspTarget != candidate_someInstanceVariableOfTargetType_node_tgt) {
                                        continue;
                                    }
                                    Rule_someInstanceVariableOfTargetType.Match_someInstanceVariableOfTargetType match = matches.GetNextUnfilledPosition();
                                    match._node_mb = candidate_someInstanceVariableOfTargetType_node_mb;
                                    match._node_src = candidate_someInstanceVariableOfTargetType_node_src;
                                    match._node_v = candidate_someInstanceVariableOfTargetType_node_v;
                                    match._node_tgt = candidate_someInstanceVariableOfTargetType_node_tgt;
                                    match._edge__edge0 = candidate_someInstanceVariableOfTargetType_edge__edge0;
                                    match._edge__edge1 = candidate_someInstanceVariableOfTargetType_edge__edge1;
                                    match._edge__edge2 = candidate_someInstanceVariableOfTargetType_edge__edge2;
                                    matches.PositionWasFilledFixIt();
                                    // if enough matches were found, we leave
                                    if(maxMatches > 0 && matches.Count >= maxMatches)
                                    {
                                        candidate_someInstanceVariableOfTargetType_node_v.MoveOutHeadAfter(candidate_someInstanceVariableOfTargetType_edge__edge2);
                                        candidate_someInstanceVariableOfTargetType_node_src.MoveInHeadAfter(candidate_someInstanceVariableOfTargetType_edge__edge1);
                                        candidate_someInstanceVariableOfTargetType_node_mb.MoveOutHeadAfter(candidate_someInstanceVariableOfTargetType_edge__edge0);
                                        candidate_someInstanceVariableOfTargetType_edge__edge0.lgspFlags = candidate_someInstanceVariableOfTargetType_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_someInstanceVariableOfTargetType_edge__edge0;
                                        candidate_someInstanceVariableOfTargetType_node_tgt.lgspFlags = candidate_someInstanceVariableOfTargetType_node_tgt.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_someInstanceVariableOfTargetType_node_tgt;
                                        return matches;
                                    }
                                }
                                while( (candidate_someInstanceVariableOfTargetType_edge__edge2 = candidate_someInstanceVariableOfTargetType_edge__edge2.lgspOutNext) != head_candidate_someInstanceVariableOfTargetType_edge__edge2 );
                            }
                        }
                        while( (candidate_someInstanceVariableOfTargetType_edge__edge1 = candidate_someInstanceVariableOfTargetType_edge__edge1.lgspInNext) != head_candidate_someInstanceVariableOfTargetType_edge__edge1 );
                    }
                    candidate_someInstanceVariableOfTargetType_edge__edge0.lgspFlags = candidate_someInstanceVariableOfTargetType_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_someInstanceVariableOfTargetType_edge__edge0;
                }
                while( (candidate_someInstanceVariableOfTargetType_edge__edge0 = candidate_someInstanceVariableOfTargetType_edge__edge0.lgspOutNext) != head_candidate_someInstanceVariableOfTargetType_edge__edge0 );
            }
            candidate_someInstanceVariableOfTargetType_node_tgt.lgspFlags = candidate_someInstanceVariableOfTargetType_node_tgt.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_someInstanceVariableOfTargetType_node_tgt;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, someInstanceVariableOfTargetType_node_mb, someInstanceVariableOfTargetType_node_tgt);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType match, out GRGEN_MODEL.IVariable output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> matches, out GRGEN_MODEL.IVariable output_0)
        {
            output_0 = null;
            foreach(Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt, ref GRGEN_MODEL.IVariable output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, someInstanceVariableOfTargetType_node_mb, someInstanceVariableOfTargetType_node_tgt);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt, ref GRGEN_MODEL.IVariable output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, someInstanceVariableOfTargetType_node_mb, someInstanceVariableOfTargetType_node_tgt);
            if(matches.Count <= 0) return false;
            foreach(Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> matches;
            GRGEN_MODEL.IVariable output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, someInstanceVariableOfTargetType_node_mb, someInstanceVariableOfTargetType_node_tgt);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, someInstanceVariableOfTargetType_node_mb, someInstanceVariableOfTargetType_node_tgt);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IVariable output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, someInstanceVariableOfTargetType_node_mb, someInstanceVariableOfTargetType_node_tgt);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody someInstanceVariableOfTargetType_node_mb, GRGEN_MODEL.IClass someInstanceVariableOfTargetType_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType> matches;
            GRGEN_MODEL.IVariable output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, someInstanceVariableOfTargetType_node_mb, someInstanceVariableOfTargetType_node_tgt);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IVariable output_0; 
            Modify(graph, (Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.IVariable output_0; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_someInstanceVariableOfTargetType.IMatch_someInstanceVariableOfTargetType>)matches, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IVariable output_0 = null; 
            if(Apply(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IVariable output_0 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_someParameterOfTargetType
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType match, out GRGEN_MODEL.IParameter output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> matches, out GRGEN_MODEL.IParameter output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt, ref GRGEN_MODEL.IParameter output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt, ref GRGEN_MODEL.IParameter output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt);
    }
    
    public class Action_someParameterOfTargetType : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_someParameterOfTargetType
    {
        public Action_someParameterOfTargetType() {
            _rulePattern = Rule_someParameterOfTargetType.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[1];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_someParameterOfTargetType.Match_someParameterOfTargetType, Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType>(this);
        }

        public Rule_someParameterOfTargetType _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "someParameterOfTargetType"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_someParameterOfTargetType.Match_someParameterOfTargetType, Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> matches;

        public static Action_someParameterOfTargetType Instance { get { return instance; } }
        private static Action_someParameterOfTargetType instance = new Action_someParameterOfTargetType();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset someParameterOfTargetType_node_mb 
            GRGEN_LGSP.LGSPNode candidate_someParameterOfTargetType_node_mb = (GRGEN_LGSP.LGSPNode)someParameterOfTargetType_node_mb;
            if(candidate_someParameterOfTargetType_node_mb.lgspType.TypeID!=7) {
                return matches;
            }
            // Preset someParameterOfTargetType_node_tgt 
            GRGEN_LGSP.LGSPNode candidate_someParameterOfTargetType_node_tgt = (GRGEN_LGSP.LGSPNode)someParameterOfTargetType_node_tgt;
            if(candidate_someParameterOfTargetType_node_tgt.lgspType.TypeID!=3) {
                return matches;
            }
            // Extend Incoming someParameterOfTargetType_edge__edge0 from someParameterOfTargetType_node_mb 
            GRGEN_LGSP.LGSPEdge head_candidate_someParameterOfTargetType_edge__edge0 = candidate_someParameterOfTargetType_node_mb.lgspInhead;
            if(head_candidate_someParameterOfTargetType_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_someParameterOfTargetType_edge__edge0 = head_candidate_someParameterOfTargetType_edge__edge0;
                do
                {
                    if(candidate_someParameterOfTargetType_edge__edge0.lgspType.TypeID!=10) {
                        continue;
                    }
                    // Implicit Source someParameterOfTargetType_node_op from someParameterOfTargetType_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_someParameterOfTargetType_node_op = candidate_someParameterOfTargetType_edge__edge0.lgspSource;
                    if(candidate_someParameterOfTargetType_node_op.lgspType.TypeID!=6) {
                        continue;
                    }
                    // Extend Outgoing someParameterOfTargetType_edge__edge1 from someParameterOfTargetType_node_op 
                    GRGEN_LGSP.LGSPEdge head_candidate_someParameterOfTargetType_edge__edge1 = candidate_someParameterOfTargetType_node_op.lgspOuthead;
                    if(head_candidate_someParameterOfTargetType_edge__edge1 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_someParameterOfTargetType_edge__edge1 = head_candidate_someParameterOfTargetType_edge__edge1;
                        do
                        {
                            if(candidate_someParameterOfTargetType_edge__edge1.lgspType.TypeID!=8) {
                                continue;
                            }
                            // Implicit Target someParameterOfTargetType_node_p from someParameterOfTargetType_edge__edge1 
                            GRGEN_LGSP.LGSPNode candidate_someParameterOfTargetType_node_p = candidate_someParameterOfTargetType_edge__edge1.lgspTarget;
                            if(candidate_someParameterOfTargetType_node_p.lgspType.TypeID!=17) {
                                continue;
                            }
                            // Extend Outgoing someParameterOfTargetType_edge__edge2 from someParameterOfTargetType_node_p 
                            GRGEN_LGSP.LGSPEdge head_candidate_someParameterOfTargetType_edge__edge2 = candidate_someParameterOfTargetType_node_p.lgspOuthead;
                            if(head_candidate_someParameterOfTargetType_edge__edge2 != null)
                            {
                                GRGEN_LGSP.LGSPEdge candidate_someParameterOfTargetType_edge__edge2 = head_candidate_someParameterOfTargetType_edge__edge2;
                                do
                                {
                                    if(candidate_someParameterOfTargetType_edge__edge2.lgspType.TypeID!=4) {
                                        continue;
                                    }
                                    if(candidate_someParameterOfTargetType_edge__edge2.lgspTarget != candidate_someParameterOfTargetType_node_tgt) {
                                        continue;
                                    }
                                    Rule_someParameterOfTargetType.Match_someParameterOfTargetType match = matches.GetNextUnfilledPosition();
                                    match._node_op = candidate_someParameterOfTargetType_node_op;
                                    match._node_mb = candidate_someParameterOfTargetType_node_mb;
                                    match._node_p = candidate_someParameterOfTargetType_node_p;
                                    match._node_tgt = candidate_someParameterOfTargetType_node_tgt;
                                    match._edge__edge0 = candidate_someParameterOfTargetType_edge__edge0;
                                    match._edge__edge1 = candidate_someParameterOfTargetType_edge__edge1;
                                    match._edge__edge2 = candidate_someParameterOfTargetType_edge__edge2;
                                    matches.PositionWasFilledFixIt();
                                    // if enough matches were found, we leave
                                    if(maxMatches > 0 && matches.Count >= maxMatches)
                                    {
                                        candidate_someParameterOfTargetType_node_p.MoveOutHeadAfter(candidate_someParameterOfTargetType_edge__edge2);
                                        candidate_someParameterOfTargetType_node_op.MoveOutHeadAfter(candidate_someParameterOfTargetType_edge__edge1);
                                        candidate_someParameterOfTargetType_node_mb.MoveInHeadAfter(candidate_someParameterOfTargetType_edge__edge0);
                                        return matches;
                                    }
                                }
                                while( (candidate_someParameterOfTargetType_edge__edge2 = candidate_someParameterOfTargetType_edge__edge2.lgspOutNext) != head_candidate_someParameterOfTargetType_edge__edge2 );
                            }
                        }
                        while( (candidate_someParameterOfTargetType_edge__edge1 = candidate_someParameterOfTargetType_edge__edge1.lgspOutNext) != head_candidate_someParameterOfTargetType_edge__edge1 );
                    }
                }
                while( (candidate_someParameterOfTargetType_edge__edge0 = candidate_someParameterOfTargetType_edge__edge0.lgspInNext) != head_candidate_someParameterOfTargetType_edge__edge0 );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, someParameterOfTargetType_node_mb, someParameterOfTargetType_node_tgt);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType match, out GRGEN_MODEL.IParameter output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> matches, out GRGEN_MODEL.IParameter output_0)
        {
            output_0 = null;
            foreach(Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt, ref GRGEN_MODEL.IParameter output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, someParameterOfTargetType_node_mb, someParameterOfTargetType_node_tgt);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt, ref GRGEN_MODEL.IParameter output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, someParameterOfTargetType_node_mb, someParameterOfTargetType_node_tgt);
            if(matches.Count <= 0) return false;
            foreach(Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> matches;
            GRGEN_MODEL.IParameter output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, someParameterOfTargetType_node_mb, someParameterOfTargetType_node_tgt);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, someParameterOfTargetType_node_mb, someParameterOfTargetType_node_tgt);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IParameter output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, someParameterOfTargetType_node_mb, someParameterOfTargetType_node_tgt);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody someParameterOfTargetType_node_mb, GRGEN_MODEL.IClass someParameterOfTargetType_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType> matches;
            GRGEN_MODEL.IParameter output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, someParameterOfTargetType_node_mb, someParameterOfTargetType_node_tgt);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IParameter output_0; 
            Modify(graph, (Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.IParameter output_0; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_someParameterOfTargetType.IMatch_someParameterOfTargetType>)matches, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IParameter output_0 = null; 
            if(Apply(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IParameter output_0 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_markExpressionOfBody
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_markExpressionOfBody.IMatch_markExpressionOfBody match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb);
    }
    
    public class Action_markExpressionOfBody : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_markExpressionOfBody
    {
        public Action_markExpressionOfBody() {
            _rulePattern = Rule_markExpressionOfBody.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_markExpressionOfBody.Match_markExpressionOfBody, Rule_markExpressionOfBody.IMatch_markExpressionOfBody>(this);
        }

        public Rule_markExpressionOfBody _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "markExpressionOfBody"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_markExpressionOfBody.Match_markExpressionOfBody, Rule_markExpressionOfBody.IMatch_markExpressionOfBody> matches;

        public static Action_markExpressionOfBody Instance { get { return instance; } }
        private static Action_markExpressionOfBody instance = new Action_markExpressionOfBody();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset markExpressionOfBody_node_mb 
            GRGEN_LGSP.LGSPNode candidate_markExpressionOfBody_node_mb = (GRGEN_LGSP.LGSPNode)markExpressionOfBody_node_mb;
            if(candidate_markExpressionOfBody_node_mb.lgspType.TypeID!=7) {
                return matches;
            }
            // Extend Incoming markExpressionOfBody_edge__edge0 from markExpressionOfBody_node_mb 
            GRGEN_LGSP.LGSPEdge head_candidate_markExpressionOfBody_edge__edge0 = candidate_markExpressionOfBody_node_mb.lgspInhead;
            if(head_candidate_markExpressionOfBody_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_markExpressionOfBody_edge__edge0 = head_candidate_markExpressionOfBody_edge__edge0;
                do
                {
                    if(candidate_markExpressionOfBody_edge__edge0.lgspType.TypeID!=3) {
                        continue;
                    }
                    // Implicit Source markExpressionOfBody_node__node0 from markExpressionOfBody_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_markExpressionOfBody_node__node0 = candidate_markExpressionOfBody_edge__edge0.lgspSource;
                    if(candidate_markExpressionOfBody_node__node0.lgspType.TypeID!=15) {
                        continue;
                    }
                    uint prev__candidate_markExpressionOfBody_node__node0;
                    prev__candidate_markExpressionOfBody_node__node0 = candidate_markExpressionOfBody_node__node0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    candidate_markExpressionOfBody_node__node0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    // Extend Outgoing markExpressionOfBody_edge__edge1 from markExpressionOfBody_node__node0 
                    GRGEN_LGSP.LGSPEdge head_candidate_markExpressionOfBody_edge__edge1 = candidate_markExpressionOfBody_node__node0.lgspOuthead;
                    if(head_candidate_markExpressionOfBody_edge__edge1 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_markExpressionOfBody_edge__edge1 = head_candidate_markExpressionOfBody_edge__edge1;
                        do
                        {
                            if(candidate_markExpressionOfBody_edge__edge1.lgspType.TypeID!=12) {
                                continue;
                            }
                            // Implicit Target markExpressionOfBody_node_exp from markExpressionOfBody_edge__edge1 
                            GRGEN_LGSP.LGSPNode candidate_markExpressionOfBody_node_exp = candidate_markExpressionOfBody_edge__edge1.lgspTarget;
                            if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_markExpressionOfBody_node_exp.lgspType.TypeID]) {
                                continue;
                            }
                            if((candidate_markExpressionOfBody_node_exp.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                            {
                                continue;
                            }
                            // Condition 
                            if(!(!graph.IsVisited(candidate_markExpressionOfBody_node_exp, 0))) {
                                continue;
                            }
                            Rule_markExpressionOfBody.Match_markExpressionOfBody match = matches.GetNextUnfilledPosition();
                            match._node__node0 = candidate_markExpressionOfBody_node__node0;
                            match._node_mb = candidate_markExpressionOfBody_node_mb;
                            match._node_exp = candidate_markExpressionOfBody_node_exp;
                            match._edge__edge0 = candidate_markExpressionOfBody_edge__edge0;
                            match._edge__edge1 = candidate_markExpressionOfBody_edge__edge1;
                            matches.PositionWasFilledFixIt();
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && matches.Count >= maxMatches)
                            {
                                candidate_markExpressionOfBody_node__node0.MoveOutHeadAfter(candidate_markExpressionOfBody_edge__edge1);
                                candidate_markExpressionOfBody_node_mb.MoveInHeadAfter(candidate_markExpressionOfBody_edge__edge0);
                                candidate_markExpressionOfBody_node__node0.lgspFlags = candidate_markExpressionOfBody_node__node0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_markExpressionOfBody_node__node0;
                                return matches;
                            }
                        }
                        while( (candidate_markExpressionOfBody_edge__edge1 = candidate_markExpressionOfBody_edge__edge1.lgspOutNext) != head_candidate_markExpressionOfBody_edge__edge1 );
                    }
                    candidate_markExpressionOfBody_node__node0.lgspFlags = candidate_markExpressionOfBody_node__node0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_markExpressionOfBody_node__node0;
                }
                while( (candidate_markExpressionOfBody_edge__edge0 = candidate_markExpressionOfBody_edge__edge0.lgspInNext) != head_candidate_markExpressionOfBody_edge__edge0 );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, markExpressionOfBody_node_mb);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_markExpressionOfBody.IMatch_markExpressionOfBody match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody> matches)
        {
            foreach(Rule_markExpressionOfBody.IMatch_markExpressionOfBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionOfBody_node_mb);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, markExpressionOfBody_node_mb);
            if(matches.Count <= 0) return false;
            foreach(Rule_markExpressionOfBody.IMatch_markExpressionOfBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionOfBody_node_mb);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionOfBody_node_mb);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionOfBody_node_mb);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody markExpressionOfBody_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionOfBody_node_mb);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_markExpressionOfBody.IMatch_markExpressionOfBody)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_markExpressionOfBody.IMatch_markExpressionOfBody>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IMethodBody) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IMethodBody) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_markExpressionFollowingExpression
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root);
    }
    
    public class Action_markExpressionFollowingExpression : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_markExpressionFollowingExpression
    {
        public Action_markExpressionFollowingExpression() {
            _rulePattern = Rule_markExpressionFollowingExpression.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_markExpressionFollowingExpression.Match_markExpressionFollowingExpression, Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression>(this);
        }

        public Rule_markExpressionFollowingExpression _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "markExpressionFollowingExpression"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_markExpressionFollowingExpression.Match_markExpressionFollowingExpression, Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> matches;

        public static Action_markExpressionFollowingExpression Instance { get { return instance; } }
        private static Action_markExpressionFollowingExpression instance = new Action_markExpressionFollowingExpression();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset markExpressionFollowingExpression_node_root 
            GRGEN_LGSP.LGSPNode candidate_markExpressionFollowingExpression_node_root = (GRGEN_LGSP.LGSPNode)markExpressionFollowingExpression_node_root;
            if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_markExpressionFollowingExpression_node_root.lgspType.TypeID]) {
                return matches;
            }
            uint prev__candidate_markExpressionFollowingExpression_node_root;
            prev__candidate_markExpressionFollowingExpression_node_root = candidate_markExpressionFollowingExpression_node_root.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_markExpressionFollowingExpression_node_root.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Extend Outgoing markExpressionFollowingExpression_edge__edge0 from markExpressionFollowingExpression_node_root 
            GRGEN_LGSP.LGSPEdge head_candidate_markExpressionFollowingExpression_edge__edge0 = candidate_markExpressionFollowingExpression_node_root.lgspOuthead;
            if(head_candidate_markExpressionFollowingExpression_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_markExpressionFollowingExpression_edge__edge0 = head_candidate_markExpressionFollowingExpression_edge__edge0;
                do
                {
                    if(candidate_markExpressionFollowingExpression_edge__edge0.lgspType.TypeID!=12) {
                        continue;
                    }
                    // Implicit Target markExpressionFollowingExpression_node_exp from markExpressionFollowingExpression_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_markExpressionFollowingExpression_node_exp = candidate_markExpressionFollowingExpression_edge__edge0.lgspTarget;
                    if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_markExpressionFollowingExpression_node_exp.lgspType.TypeID]) {
                        continue;
                    }
                    if((candidate_markExpressionFollowingExpression_node_exp.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                    {
                        continue;
                    }
                    // Condition 
                    if(!(!graph.IsVisited(candidate_markExpressionFollowingExpression_node_exp, 0))) {
                        continue;
                    }
                    Rule_markExpressionFollowingExpression.Match_markExpressionFollowingExpression match = matches.GetNextUnfilledPosition();
                    match._node_root = candidate_markExpressionFollowingExpression_node_root;
                    match._node_exp = candidate_markExpressionFollowingExpression_node_exp;
                    match._edge__edge0 = candidate_markExpressionFollowingExpression_edge__edge0;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        candidate_markExpressionFollowingExpression_node_root.MoveOutHeadAfter(candidate_markExpressionFollowingExpression_edge__edge0);
                        candidate_markExpressionFollowingExpression_node_root.lgspFlags = candidate_markExpressionFollowingExpression_node_root.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_markExpressionFollowingExpression_node_root;
                        return matches;
                    }
                }
                while( (candidate_markExpressionFollowingExpression_edge__edge0 = candidate_markExpressionFollowingExpression_edge__edge0.lgspOutNext) != head_candidate_markExpressionFollowingExpression_edge__edge0 );
            }
            candidate_markExpressionFollowingExpression_node_root.lgspFlags = candidate_markExpressionFollowingExpression_node_root.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_markExpressionFollowingExpression_node_root;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, markExpressionFollowingExpression_node_root);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> matches)
        {
            foreach(Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionFollowingExpression_node_root);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, markExpressionFollowingExpression_node_root);
            if(matches.Count <= 0) return false;
            foreach(Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionFollowingExpression_node_root);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionFollowingExpression_node_root);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionFollowingExpression_node_root);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IExpression markExpressionFollowingExpression_node_root)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionFollowingExpression_node_root);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IExpression) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingExpression.IMatch_markExpressionFollowingExpression>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IExpression) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IExpression) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IExpression) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IExpression) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IExpression) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_markExpressionFollowingActualParameter
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root);
    }
    
    public class Action_markExpressionFollowingActualParameter : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_markExpressionFollowingActualParameter
    {
        public Action_markExpressionFollowingActualParameter() {
            _rulePattern = Rule_markExpressionFollowingActualParameter.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_markExpressionFollowingActualParameter.Match_markExpressionFollowingActualParameter, Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter>(this);
        }

        public Rule_markExpressionFollowingActualParameter _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "markExpressionFollowingActualParameter"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_markExpressionFollowingActualParameter.Match_markExpressionFollowingActualParameter, Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> matches;

        public static Action_markExpressionFollowingActualParameter Instance { get { return instance; } }
        private static Action_markExpressionFollowingActualParameter instance = new Action_markExpressionFollowingActualParameter();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset markExpressionFollowingActualParameter_node_root 
            GRGEN_LGSP.LGSPNode candidate_markExpressionFollowingActualParameter_node_root = (GRGEN_LGSP.LGSPNode)markExpressionFollowingActualParameter_node_root;
            if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_markExpressionFollowingActualParameter_node_root.lgspType.TypeID]) {
                return matches;
            }
            uint prev__candidate_markExpressionFollowingActualParameter_node_root;
            prev__candidate_markExpressionFollowingActualParameter_node_root = candidate_markExpressionFollowingActualParameter_node_root.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_markExpressionFollowingActualParameter_node_root.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Extend Outgoing markExpressionFollowingActualParameter_edge__edge0 from markExpressionFollowingActualParameter_node_root 
            GRGEN_LGSP.LGSPEdge head_candidate_markExpressionFollowingActualParameter_edge__edge0 = candidate_markExpressionFollowingActualParameter_node_root.lgspOuthead;
            if(head_candidate_markExpressionFollowingActualParameter_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_markExpressionFollowingActualParameter_edge__edge0 = head_candidate_markExpressionFollowingActualParameter_edge__edge0;
                do
                {
                    if(candidate_markExpressionFollowingActualParameter_edge__edge0.lgspType.TypeID!=9) {
                        continue;
                    }
                    // Implicit Target markExpressionFollowingActualParameter_node_exp from markExpressionFollowingActualParameter_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_markExpressionFollowingActualParameter_node_exp = candidate_markExpressionFollowingActualParameter_edge__edge0.lgspTarget;
                    if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_markExpressionFollowingActualParameter_node_exp.lgspType.TypeID]) {
                        continue;
                    }
                    if((candidate_markExpressionFollowingActualParameter_node_exp.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                    {
                        continue;
                    }
                    // Condition 
                    if(!(!graph.IsVisited(candidate_markExpressionFollowingActualParameter_node_exp, 0))) {
                        continue;
                    }
                    Rule_markExpressionFollowingActualParameter.Match_markExpressionFollowingActualParameter match = matches.GetNextUnfilledPosition();
                    match._node_root = candidate_markExpressionFollowingActualParameter_node_root;
                    match._node_exp = candidate_markExpressionFollowingActualParameter_node_exp;
                    match._edge__edge0 = candidate_markExpressionFollowingActualParameter_edge__edge0;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        candidate_markExpressionFollowingActualParameter_node_root.MoveOutHeadAfter(candidate_markExpressionFollowingActualParameter_edge__edge0);
                        candidate_markExpressionFollowingActualParameter_node_root.lgspFlags = candidate_markExpressionFollowingActualParameter_node_root.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_markExpressionFollowingActualParameter_node_root;
                        return matches;
                    }
                }
                while( (candidate_markExpressionFollowingActualParameter_edge__edge0 = candidate_markExpressionFollowingActualParameter_edge__edge0.lgspOutNext) != head_candidate_markExpressionFollowingActualParameter_edge__edge0 );
            }
            candidate_markExpressionFollowingActualParameter_node_root.lgspFlags = candidate_markExpressionFollowingActualParameter_node_root.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_markExpressionFollowingActualParameter_node_root;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, markExpressionFollowingActualParameter_node_root);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> matches)
        {
            foreach(Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionFollowingActualParameter_node_root);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, markExpressionFollowingActualParameter_node_root);
            if(matches.Count <= 0) return false;
            foreach(Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionFollowingActualParameter_node_root);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionFollowingActualParameter_node_root);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionFollowingActualParameter_node_root);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IExpression markExpressionFollowingActualParameter_node_root)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, markExpressionFollowingActualParameter_node_root);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IExpression) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_markExpressionFollowingActualParameter.IMatch_markExpressionFollowingActualParameter>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IExpression) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IExpression) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IExpression) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IExpression) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IExpression) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_unmarkExpression
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression> Match(GRGEN_LIBGR.IGraph graph, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_unmarkExpression.IMatch_unmarkExpression match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max);
    }
    
    public class Action_unmarkExpression : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_unmarkExpression
    {
        public Action_unmarkExpression() {
            _rulePattern = Rule_unmarkExpression.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_unmarkExpression.Match_unmarkExpression, Rule_unmarkExpression.IMatch_unmarkExpression>(this);
        }

        public Rule_unmarkExpression _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "unmarkExpression"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_unmarkExpression.Match_unmarkExpression, Rule_unmarkExpression.IMatch_unmarkExpression> matches;

        public static Action_unmarkExpression Instance { get { return instance; } }
        private static Action_unmarkExpression instance = new Action_unmarkExpression();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches)
        {
            matches.Clear();
            int negLevel = 0;
            // Lookup unmarkExpression_node_exp 
            foreach(GRGEN_LIBGR.NodeType type_candidate_unmarkExpression_node_exp in GRGEN_MODEL.NodeType_Expression.typeVar.SubOrSameTypes)
            {
                int type_id_candidate_unmarkExpression_node_exp = type_candidate_unmarkExpression_node_exp.TypeID;
                for(GRGEN_LGSP.LGSPNode head_candidate_unmarkExpression_node_exp = graph.nodesByTypeHeads[type_id_candidate_unmarkExpression_node_exp], candidate_unmarkExpression_node_exp = head_candidate_unmarkExpression_node_exp.lgspTypeNext; candidate_unmarkExpression_node_exp != head_candidate_unmarkExpression_node_exp; candidate_unmarkExpression_node_exp = candidate_unmarkExpression_node_exp.lgspTypeNext)
                {
                    // Condition 
                    if(!(graph.IsVisited(candidate_unmarkExpression_node_exp, 0))) {
                        continue;
                    }
                    Rule_unmarkExpression.Match_unmarkExpression match = matches.GetNextUnfilledPosition();
                    match._node_exp = candidate_unmarkExpression_node_exp;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        graph.MoveHeadAfter(candidate_unmarkExpression_node_exp);
                        return matches;
                    }
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression> Match(GRGEN_LIBGR.IGraph graph, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_unmarkExpression.IMatch_unmarkExpression match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression> matches)
        {
            foreach(Rule_unmarkExpression.IMatch_unmarkExpression match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
            if(matches.Count <= 0) return false;
            foreach(Rule_unmarkExpression.IMatch_unmarkExpression match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_unmarkExpression.IMatch_unmarkExpression)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_unmarkExpression.IMatch_unmarkExpression>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            return ApplyMinMax(graph, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_callToSuperExists
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists> Match(GRGEN_LIBGR.IGraph graph, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_callToSuperExists.IMatch_callToSuperExists match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max);
    }
    
    public class Action_callToSuperExists : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_callToSuperExists
    {
        public Action_callToSuperExists() {
            _rulePattern = Rule_callToSuperExists.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_callToSuperExists.Match_callToSuperExists, Rule_callToSuperExists.IMatch_callToSuperExists>(this);
        }

        public Rule_callToSuperExists _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "callToSuperExists"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_callToSuperExists.Match_callToSuperExists, Rule_callToSuperExists.IMatch_callToSuperExists> matches;

        public static Action_callToSuperExists Instance { get { return instance; } }
        private static Action_callToSuperExists instance = new Action_callToSuperExists();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches)
        {
            matches.Clear();
            int negLevel = 0;
            // Lookup callToSuperExists_node_call 
            int type_id_candidate_callToSuperExists_node_call = 11;
            for(GRGEN_LGSP.LGSPNode head_candidate_callToSuperExists_node_call = graph.nodesByTypeHeads[type_id_candidate_callToSuperExists_node_call], candidate_callToSuperExists_node_call = head_candidate_callToSuperExists_node_call.lgspTypeNext; candidate_callToSuperExists_node_call != head_candidate_callToSuperExists_node_call; candidate_callToSuperExists_node_call = candidate_callToSuperExists_node_call.lgspTypeNext)
            {
                // Condition 
                if(!((((GRGEN_MODEL.ICall)candidate_callToSuperExists_node_call).@super && graph.IsVisited(candidate_callToSuperExists_node_call, 0)))) {
                    continue;
                }
                Rule_callToSuperExists.Match_callToSuperExists match = matches.GetNextUnfilledPosition();
                match._node_call = candidate_callToSuperExists_node_call;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_callToSuperExists_node_call);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists> Match(GRGEN_LIBGR.IGraph graph, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_callToSuperExists.IMatch_callToSuperExists match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists> matches)
        {
            foreach(Rule_callToSuperExists.IMatch_callToSuperExists match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
            if(matches.Count <= 0) return false;
            foreach(Rule_callToSuperExists.IMatch_callToSuperExists match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_callToSuperExists.IMatch_callToSuperExists)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_callToSuperExists.IMatch_callToSuperExists>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            return ApplyMinMax(graph, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_isStatic
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody isStatic_node_mb);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_isStatic.IMatch_isStatic match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody isStatic_node_mb);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody isStatic_node_mb);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody isStatic_node_mb);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody isStatic_node_mb);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody isStatic_node_mb);
    }
    
    public class Action_isStatic : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_isStatic
    {
        public Action_isStatic() {
            _rulePattern = Rule_isStatic.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_isStatic.Match_isStatic, Rule_isStatic.IMatch_isStatic>(this);
        }

        public Rule_isStatic _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "isStatic"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_isStatic.Match_isStatic, Rule_isStatic.IMatch_isStatic> matches;

        public static Action_isStatic Instance { get { return instance; } }
        private static Action_isStatic instance = new Action_isStatic();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody isStatic_node_mb)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset isStatic_node_mb 
            GRGEN_LGSP.LGSPNode candidate_isStatic_node_mb = (GRGEN_LGSP.LGSPNode)isStatic_node_mb;
            if(candidate_isStatic_node_mb.lgspType.TypeID!=7) {
                return matches;
            }
            // Extend Incoming isStatic_edge__edge0 from isStatic_node_mb 
            GRGEN_LGSP.LGSPEdge head_candidate_isStatic_edge__edge0 = candidate_isStatic_node_mb.lgspInhead;
            if(head_candidate_isStatic_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_isStatic_edge__edge0 = head_candidate_isStatic_edge__edge0;
                do
                {
                    if(candidate_isStatic_edge__edge0.lgspType.TypeID!=10) {
                        continue;
                    }
                    // Implicit Source isStatic_node_op from isStatic_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_isStatic_node_op = candidate_isStatic_edge__edge0.lgspSource;
                    if(candidate_isStatic_node_op.lgspType.TypeID!=6) {
                        continue;
                    }
                    // Condition 
                    if(!(((GRGEN_MODEL.IOperation)candidate_isStatic_node_op).@isStatic)) {
                        continue;
                    }
                    Rule_isStatic.Match_isStatic match = matches.GetNextUnfilledPosition();
                    match._node_op = candidate_isStatic_node_op;
                    match._node_mb = candidate_isStatic_node_mb;
                    match._edge__edge0 = candidate_isStatic_edge__edge0;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        candidate_isStatic_node_mb.MoveInHeadAfter(candidate_isStatic_edge__edge0);
                        return matches;
                    }
                }
                while( (candidate_isStatic_edge__edge0 = candidate_isStatic_edge__edge0.lgspInNext) != head_candidate_isStatic_edge__edge0 );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody isStatic_node_mb);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody isStatic_node_mb)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, isStatic_node_mb);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_isStatic.IMatch_isStatic match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic> matches)
        {
            foreach(Rule_isStatic.IMatch_isStatic match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody isStatic_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, isStatic_node_mb);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody isStatic_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, isStatic_node_mb);
            if(matches.Count <= 0) return false;
            foreach(Rule_isStatic.IMatch_isStatic match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody isStatic_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, isStatic_node_mb);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody isStatic_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, isStatic_node_mb);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, isStatic_node_mb);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody isStatic_node_mb)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, isStatic_node_mb);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_isStatic.IMatch_isStatic)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_isStatic.IMatch_isStatic>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IMethodBody) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IMethodBody) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IMethodBody) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_methodNameExists
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_methodNameExists.IMatch_methodNameExists match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt);
    }
    
    public class Action_methodNameExists : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_methodNameExists
    {
        public Action_methodNameExists() {
            _rulePattern = Rule_methodNameExists.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_methodNameExists.Match_methodNameExists, Rule_methodNameExists.IMatch_methodNameExists>(this);
        }

        public Rule_methodNameExists _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "methodNameExists"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_methodNameExists.Match_methodNameExists, Rule_methodNameExists.IMatch_methodNameExists> matches;

        public static Action_methodNameExists Instance { get { return instance; } }
        private static Action_methodNameExists instance = new Action_methodNameExists();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt)
        {
            matches.Clear();
            int negLevel = 0;
            Stack<GRGEN_LGSP.LGSPSubpatternAction> openTasks = new Stack<GRGEN_LGSP.LGSPSubpatternAction>();
            List<Stack<GRGEN_LIBGR.IMatch>> foundPartialMatches = new List<Stack<GRGEN_LIBGR.IMatch>>();
            List<Stack<GRGEN_LIBGR.IMatch>> matchesList = foundPartialMatches;
            // Preset methodNameExists_node_mb 
            GRGEN_LGSP.LGSPNode candidate_methodNameExists_node_mb = (GRGEN_LGSP.LGSPNode)methodNameExists_node_mb;
            if(candidate_methodNameExists_node_mb.lgspType.TypeID!=7) {
                return matches;
            }
            // Preset methodNameExists_node_tgt 
            GRGEN_LGSP.LGSPNode candidate_methodNameExists_node_tgt = (GRGEN_LGSP.LGSPNode)methodNameExists_node_tgt;
            if(candidate_methodNameExists_node_tgt.lgspType.TypeID!=3) {
                return matches;
            }
            // Extend Incoming methodNameExists_edge__edge0 from methodNameExists_node_mb 
            GRGEN_LGSP.LGSPEdge head_candidate_methodNameExists_edge__edge0 = candidate_methodNameExists_node_mb.lgspInhead;
            if(head_candidate_methodNameExists_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_methodNameExists_edge__edge0 = head_candidate_methodNameExists_edge__edge0;
                do
                {
                    if(!GRGEN_MODEL.EdgeType_Edge.isMyType[candidate_methodNameExists_edge__edge0.lgspType.TypeID]) {
                        continue;
                    }
                    // Implicit Source methodNameExists_node_op from methodNameExists_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_methodNameExists_node_op = candidate_methodNameExists_edge__edge0.lgspSource;
                    if(candidate_methodNameExists_node_op.lgspType.TypeID!=6) {
                        continue;
                    }
                    // Push subpattern matching task for _sub0
                    PatternAction_methodNameExistsSuper taskFor__sub0 = PatternAction_methodNameExistsSuper.getNewTask(graph, openTasks);
                    taskFor__sub0.methodNameExistsSuper_node_opForName = candidate_methodNameExists_node_op;
                    taskFor__sub0.methodNameExistsSuper_node_cls = candidate_methodNameExists_node_tgt;
                    taskFor__sub0.searchPatternpath = false;
                    taskFor__sub0.matchOfNestingPattern = null;
                    taskFor__sub0.lastMatchAtPreviousNestingLevel = null;
                    openTasks.Push(taskFor__sub0);
                    uint prevGlobal__candidate_methodNameExists_node_op;
                    prevGlobal__candidate_methodNameExists_node_op = candidate_methodNameExists_node_op.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    candidate_methodNameExists_node_op.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    uint prevGlobal__candidate_methodNameExists_node_mb;
                    prevGlobal__candidate_methodNameExists_node_mb = candidate_methodNameExists_node_mb.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    candidate_methodNameExists_node_mb.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    uint prevGlobal__candidate_methodNameExists_node_tgt;
                    prevGlobal__candidate_methodNameExists_node_tgt = candidate_methodNameExists_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    candidate_methodNameExists_node_tgt.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    uint prevGlobal__candidate_methodNameExists_edge__edge0;
                    prevGlobal__candidate_methodNameExists_edge__edge0 = candidate_methodNameExists_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    candidate_methodNameExists_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel;
                    // Match subpatterns 
                    openTasks.Peek().myMatch(matchesList, maxMatches - foundPartialMatches.Count, negLevel);
                    // Pop subpattern matching task for _sub0
                    openTasks.Pop();
                    PatternAction_methodNameExistsSuper.releaseTask(taskFor__sub0);
                    // Check whether subpatterns were found 
                    if(matchesList.Count>0) {
                        // subpatterns/alternatives were found, extend the partial matches by our local match object, becoming a complete match object and save it
                        foreach(Stack<GRGEN_LIBGR.IMatch> currentFoundPartialMatch in matchesList)
                        {
                            Rule_methodNameExists.Match_methodNameExists match = matches.GetNextUnfilledPosition();
                            match._node_op = candidate_methodNameExists_node_op;
                            match._node_mb = candidate_methodNameExists_node_mb;
                            match._node_tgt = candidate_methodNameExists_node_tgt;
                            match._edge__edge0 = candidate_methodNameExists_edge__edge0;
                            match.__sub0 = (@Pattern_methodNameExistsSuper.Match_methodNameExistsSuper)currentFoundPartialMatch.Pop();
                            match.__sub0._matchOfEnclosingPattern = match;
                            matches.PositionWasFilledFixIt();
                        }
                        matchesList.Clear();
                        // if enough matches were found, we leave
                        if(maxMatches > 0 && matches.Count >= maxMatches)
                        {
                            candidate_methodNameExists_edge__edge0.lgspFlags = candidate_methodNameExists_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_edge__edge0;
                            candidate_methodNameExists_node_tgt.lgspFlags = candidate_methodNameExists_node_tgt.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_node_tgt;
                            candidate_methodNameExists_node_mb.lgspFlags = candidate_methodNameExists_node_mb.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_node_mb;
                            candidate_methodNameExists_node_op.lgspFlags = candidate_methodNameExists_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_node_op;
                            return matches;
                        }
                        candidate_methodNameExists_edge__edge0.lgspFlags = candidate_methodNameExists_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_edge__edge0;
                        candidate_methodNameExists_node_tgt.lgspFlags = candidate_methodNameExists_node_tgt.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_node_tgt;
                        candidate_methodNameExists_node_mb.lgspFlags = candidate_methodNameExists_node_mb.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_node_mb;
                        candidate_methodNameExists_node_op.lgspFlags = candidate_methodNameExists_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_node_op;
                        continue;
                    }
                    candidate_methodNameExists_node_op.lgspFlags = candidate_methodNameExists_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_node_op;
                    candidate_methodNameExists_node_mb.lgspFlags = candidate_methodNameExists_node_mb.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_node_mb;
                    candidate_methodNameExists_node_tgt.lgspFlags = candidate_methodNameExists_node_tgt.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_node_tgt;
                    candidate_methodNameExists_edge__edge0.lgspFlags = candidate_methodNameExists_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED_BY_ENCLOSING_PATTERN << negLevel) | prevGlobal__candidate_methodNameExists_edge__edge0;
                }
                while( (candidate_methodNameExists_edge__edge0 = candidate_methodNameExists_edge__edge0.lgspInNext) != head_candidate_methodNameExists_edge__edge0 );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, methodNameExists_node_mb, methodNameExists_node_tgt);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_methodNameExists.IMatch_methodNameExists match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists> matches)
        {
            foreach(Rule_methodNameExists.IMatch_methodNameExists match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, methodNameExists_node_mb, methodNameExists_node_tgt);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, methodNameExists_node_mb, methodNameExists_node_tgt);
            if(matches.Count <= 0) return false;
            foreach(Rule_methodNameExists.IMatch_methodNameExists match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, methodNameExists_node_mb, methodNameExists_node_tgt);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, methodNameExists_node_mb, methodNameExists_node_tgt);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, methodNameExists_node_mb, methodNameExists_node_tgt);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody methodNameExists_node_mb, GRGEN_MODEL.IClass methodNameExists_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, methodNameExists_node_mb, methodNameExists_node_tgt);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_methodNameExists.IMatch_methodNameExists)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_methodNameExists.IMatch_methodNameExists>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_thisIsAccessed
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed> Match(GRGEN_LIBGR.IGraph graph, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_thisIsAccessed.IMatch_thisIsAccessed match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max);
    }
    
    public class Action_thisIsAccessed : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_thisIsAccessed
    {
        public Action_thisIsAccessed() {
            _rulePattern = Rule_thisIsAccessed.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_thisIsAccessed.Match_thisIsAccessed, Rule_thisIsAccessed.IMatch_thisIsAccessed>(this);
        }

        public Rule_thisIsAccessed _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "thisIsAccessed"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_thisIsAccessed.Match_thisIsAccessed, Rule_thisIsAccessed.IMatch_thisIsAccessed> matches;

        public static Action_thisIsAccessed Instance { get { return instance; } }
        private static Action_thisIsAccessed instance = new Action_thisIsAccessed();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches)
        {
            matches.Clear();
            int negLevel = 0;
            // Lookup thisIsAccessed_node_access 
            int type_id_candidate_thisIsAccessed_node_access = 9;
            for(GRGEN_LGSP.LGSPNode head_candidate_thisIsAccessed_node_access = graph.nodesByTypeHeads[type_id_candidate_thisIsAccessed_node_access], candidate_thisIsAccessed_node_access = head_candidate_thisIsAccessed_node_access.lgspTypeNext; candidate_thisIsAccessed_node_access != head_candidate_thisIsAccessed_node_access; candidate_thisIsAccessed_node_access = candidate_thisIsAccessed_node_access.lgspTypeNext)
            {
                // Condition 
                if(!(graph.IsVisited(candidate_thisIsAccessed_node_access, 0))) {
                    continue;
                }
                // NegativePattern 
                {
                    ++negLevel;
                    // Extend Outgoing thisIsAccessed_neg_0_edge__edge0 from thisIsAccessed_node_access 
                    GRGEN_LGSP.LGSPEdge head_candidate_thisIsAccessed_neg_0_edge__edge0 = candidate_thisIsAccessed_node_access.lgspOuthead;
                    if(head_candidate_thisIsAccessed_neg_0_edge__edge0 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_thisIsAccessed_neg_0_edge__edge0 = head_candidate_thisIsAccessed_neg_0_edge__edge0;
                        do
                        {
                            if(candidate_thisIsAccessed_neg_0_edge__edge0.lgspType.TypeID!=11) {
                                continue;
                            }
                            // negative pattern found
                            --negLevel;
                            goto label18;
                        }
                        while( (candidate_thisIsAccessed_neg_0_edge__edge0 = candidate_thisIsAccessed_neg_0_edge__edge0.lgspOutNext) != head_candidate_thisIsAccessed_neg_0_edge__edge0 );
                    }
                    --negLevel;
                }
                Rule_thisIsAccessed.Match_thisIsAccessed match = matches.GetNextUnfilledPosition();
                match._node_access = candidate_thisIsAccessed_node_access;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_thisIsAccessed_node_access);
                    return matches;
                }
label18: ;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed> Match(GRGEN_LIBGR.IGraph graph, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_thisIsAccessed.IMatch_thisIsAccessed match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed> matches)
        {
            foreach(Rule_thisIsAccessed.IMatch_thisIsAccessed match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches);
            if(matches.Count <= 0) return false;
            foreach(Rule_thisIsAccessed.IMatch_thisIsAccessed match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_thisIsAccessed.IMatch_thisIsAccessed)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_thisIsAccessed.IMatch_thisIsAccessed>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph)) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            return ApplyMinMax(graph, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_addSourceParameter
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_addSourceParameter.IMatch_addSourceParameter match, out GRGEN_MODEL.IParameter output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter> matches, out GRGEN_MODEL.IParameter output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src, ref GRGEN_MODEL.IParameter output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src, ref GRGEN_MODEL.IParameter output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src);
    }
    
    public class Action_addSourceParameter : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_addSourceParameter
    {
        public Action_addSourceParameter() {
            _rulePattern = Rule_addSourceParameter.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[1];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_addSourceParameter.Match_addSourceParameter, Rule_addSourceParameter.IMatch_addSourceParameter>(this);
        }

        public Rule_addSourceParameter _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "addSourceParameter"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_addSourceParameter.Match_addSourceParameter, Rule_addSourceParameter.IMatch_addSourceParameter> matches;

        public static Action_addSourceParameter Instance { get { return instance; } }
        private static Action_addSourceParameter instance = new Action_addSourceParameter();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset addSourceParameter_node_op 
            GRGEN_LGSP.LGSPNode candidate_addSourceParameter_node_op = (GRGEN_LGSP.LGSPNode)addSourceParameter_node_op;
            if(candidate_addSourceParameter_node_op.lgspType.TypeID!=6) {
                return matches;
            }
            // Preset addSourceParameter_node_src 
            GRGEN_LGSP.LGSPNode candidate_addSourceParameter_node_src = (GRGEN_LGSP.LGSPNode)addSourceParameter_node_src;
            if(candidate_addSourceParameter_node_src.lgspType.TypeID!=3) {
                return matches;
            }
            Rule_addSourceParameter.Match_addSourceParameter match = matches.GetNextUnfilledPosition();
            match._node_op = candidate_addSourceParameter_node_op;
            match._node_src = candidate_addSourceParameter_node_src;
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, addSourceParameter_node_op, addSourceParameter_node_src);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_addSourceParameter.IMatch_addSourceParameter match, out GRGEN_MODEL.IParameter output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter> matches, out GRGEN_MODEL.IParameter output_0)
        {
            output_0 = null;
            foreach(Rule_addSourceParameter.IMatch_addSourceParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src, ref GRGEN_MODEL.IParameter output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addSourceParameter_node_op, addSourceParameter_node_src);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src, ref GRGEN_MODEL.IParameter output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, addSourceParameter_node_op, addSourceParameter_node_src);
            if(matches.Count <= 0) return false;
            foreach(Rule_addSourceParameter.IMatch_addSourceParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter> matches;
            GRGEN_MODEL.IParameter output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addSourceParameter_node_op, addSourceParameter_node_src);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addSourceParameter_node_op, addSourceParameter_node_src);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IParameter output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addSourceParameter_node_op, addSourceParameter_node_src);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation addSourceParameter_node_op, GRGEN_MODEL.IClass addSourceParameter_node_src)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter> matches;
            GRGEN_MODEL.IParameter output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addSourceParameter_node_op, addSourceParameter_node_src);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IParameter output_0; 
            Modify(graph, (Rule_addSourceParameter.IMatch_addSourceParameter)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.IParameter output_0; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_addSourceParameter.IMatch_addSourceParameter>)matches, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IParameter output_0 = null; 
            if(Apply(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IParameter output_0 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_useSourceParameter
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_useSourceParameter.IMatch_useSourceParameter match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam);
    }
    
    public class Action_useSourceParameter : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_useSourceParameter
    {
        public Action_useSourceParameter() {
            _rulePattern = Rule_useSourceParameter.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_useSourceParameter.Match_useSourceParameter, Rule_useSourceParameter.IMatch_useSourceParameter>(this);
        }

        public Rule_useSourceParameter _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "useSourceParameter"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_useSourceParameter.Match_useSourceParameter, Rule_useSourceParameter.IMatch_useSourceParameter> matches;

        public static Action_useSourceParameter Instance { get { return instance; } }
        private static Action_useSourceParameter instance = new Action_useSourceParameter();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset useSourceParameter_node_srcparam 
            GRGEN_LGSP.LGSPNode candidate_useSourceParameter_node_srcparam = (GRGEN_LGSP.LGSPNode)useSourceParameter_node_srcparam;
            if(candidate_useSourceParameter_node_srcparam.lgspType.TypeID!=17) {
                return matches;
            }
            // Lookup useSourceParameter_node_access 
            int type_id_candidate_useSourceParameter_node_access = 9;
            for(GRGEN_LGSP.LGSPNode head_candidate_useSourceParameter_node_access = graph.nodesByTypeHeads[type_id_candidate_useSourceParameter_node_access], candidate_useSourceParameter_node_access = head_candidate_useSourceParameter_node_access.lgspTypeNext; candidate_useSourceParameter_node_access != head_candidate_useSourceParameter_node_access; candidate_useSourceParameter_node_access = candidate_useSourceParameter_node_access.lgspTypeNext)
            {
                // Condition 
                if(!(graph.IsVisited(candidate_useSourceParameter_node_access, 0))) {
                    continue;
                }
                // NegativePattern 
                {
                    ++negLevel;
                    // Extend Outgoing useSourceParameter_neg_0_edge__edge0 from useSourceParameter_node_access 
                    GRGEN_LGSP.LGSPEdge head_candidate_useSourceParameter_neg_0_edge__edge0 = candidate_useSourceParameter_node_access.lgspOuthead;
                    if(head_candidate_useSourceParameter_neg_0_edge__edge0 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_useSourceParameter_neg_0_edge__edge0 = head_candidate_useSourceParameter_neg_0_edge__edge0;
                        do
                        {
                            if(candidate_useSourceParameter_neg_0_edge__edge0.lgspType.TypeID!=11) {
                                continue;
                            }
                            // negative pattern found
                            --negLevel;
                            goto label19;
                        }
                        while( (candidate_useSourceParameter_neg_0_edge__edge0 = candidate_useSourceParameter_neg_0_edge__edge0.lgspOutNext) != head_candidate_useSourceParameter_neg_0_edge__edge0 );
                    }
                    --negLevel;
                }
                Rule_useSourceParameter.Match_useSourceParameter match = matches.GetNextUnfilledPosition();
                match._node_srcparam = candidate_useSourceParameter_node_srcparam;
                match._node_access = candidate_useSourceParameter_node_access;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_useSourceParameter_node_access);
                    return matches;
                }
label19: ;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, useSourceParameter_node_srcparam);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_useSourceParameter.IMatch_useSourceParameter match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter> matches)
        {
            foreach(Rule_useSourceParameter.IMatch_useSourceParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, useSourceParameter_node_srcparam);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, useSourceParameter_node_srcparam);
            if(matches.Count <= 0) return false;
            foreach(Rule_useSourceParameter.IMatch_useSourceParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, useSourceParameter_node_srcparam);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, useSourceParameter_node_srcparam);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, useSourceParameter_node_srcparam);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IParameter useSourceParameter_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, useSourceParameter_node_srcparam);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IParameter) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_useSourceParameter.IMatch_useSourceParameter)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_useSourceParameter.IMatch_useSourceParameter>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IParameter) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IParameter) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IParameter) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IParameter) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IParameter) parameters[0]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_copyOperation
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_copyOperation.IMatch_copyOperation match, out GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation> matches, out GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt, ref GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt, ref GRGEN_MODEL.IOperation output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt);
    }
    
    public class Action_copyOperation : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_copyOperation
    {
        public Action_copyOperation() {
            _rulePattern = Rule_copyOperation.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[1];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_copyOperation.Match_copyOperation, Rule_copyOperation.IMatch_copyOperation>(this);
        }

        public Rule_copyOperation _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "copyOperation"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_copyOperation.Match_copyOperation, Rule_copyOperation.IMatch_copyOperation> matches;

        public static Action_copyOperation Instance { get { return instance; } }
        private static Action_copyOperation instance = new Action_copyOperation();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset copyOperation_node_op 
            GRGEN_LGSP.LGSPNode candidate_copyOperation_node_op = (GRGEN_LGSP.LGSPNode)copyOperation_node_op;
            if(candidate_copyOperation_node_op.lgspType.TypeID!=6) {
                return matches;
            }
            // Preset copyOperation_node_tgt 
            GRGEN_LGSP.LGSPNode candidate_copyOperation_node_tgt = (GRGEN_LGSP.LGSPNode)copyOperation_node_tgt;
            if(candidate_copyOperation_node_tgt.lgspType.TypeID!=3) {
                return matches;
            }
            Rule_copyOperation.Match_copyOperation match = matches.GetNextUnfilledPosition();
            match._node_op = candidate_copyOperation_node_op;
            match._node_tgt = candidate_copyOperation_node_tgt;
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, copyOperation_node_op, copyOperation_node_tgt);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_copyOperation.IMatch_copyOperation match, out GRGEN_MODEL.IOperation output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation> matches, out GRGEN_MODEL.IOperation output_0)
        {
            output_0 = null;
            foreach(Rule_copyOperation.IMatch_copyOperation match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt, ref GRGEN_MODEL.IOperation output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, copyOperation_node_op, copyOperation_node_tgt);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt, ref GRGEN_MODEL.IOperation output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, copyOperation_node_op, copyOperation_node_tgt);
            if(matches.Count <= 0) return false;
            foreach(Rule_copyOperation.IMatch_copyOperation match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation> matches;
            GRGEN_MODEL.IOperation output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, copyOperation_node_op, copyOperation_node_tgt);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, copyOperation_node_op, copyOperation_node_tgt);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IOperation output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, copyOperation_node_op, copyOperation_node_tgt);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation copyOperation_node_op, GRGEN_MODEL.IClass copyOperation_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation> matches;
            GRGEN_MODEL.IOperation output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, copyOperation_node_op, copyOperation_node_tgt);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IOperation output_0; 
            Modify(graph, (Rule_copyOperation.IMatch_copyOperation)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.IOperation output_0; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_copyOperation.IMatch_copyOperation>)matches, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IOperation output_0 = null; 
            if(Apply(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.IOperation output_0 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IClass) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_copyOperationParameter
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_copyOperationParameter.IMatch_copyOperationParameter match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop);
    }
    
    public class Action_copyOperationParameter : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_copyOperationParameter
    {
        public Action_copyOperationParameter() {
            _rulePattern = Rule_copyOperationParameter.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_copyOperationParameter.Match_copyOperationParameter, Rule_copyOperationParameter.IMatch_copyOperationParameter>(this);
        }

        public Rule_copyOperationParameter _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "copyOperationParameter"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_copyOperationParameter.Match_copyOperationParameter, Rule_copyOperationParameter.IMatch_copyOperationParameter> matches;

        public static Action_copyOperationParameter Instance { get { return instance; } }
        private static Action_copyOperationParameter instance = new Action_copyOperationParameter();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset copyOperationParameter_node_op 
            GRGEN_LGSP.LGSPNode candidate_copyOperationParameter_node_op = (GRGEN_LGSP.LGSPNode)copyOperationParameter_node_op;
            if(candidate_copyOperationParameter_node_op.lgspType.TypeID!=6) {
                return matches;
            }
            uint prev__candidate_copyOperationParameter_node_op;
            prev__candidate_copyOperationParameter_node_op = candidate_copyOperationParameter_node_op.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_copyOperationParameter_node_op.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Preset copyOperationParameter_node_newop 
            GRGEN_LGSP.LGSPNode candidate_copyOperationParameter_node_newop = (GRGEN_LGSP.LGSPNode)copyOperationParameter_node_newop;
            if(candidate_copyOperationParameter_node_newop.lgspType.TypeID!=6) {
                candidate_copyOperationParameter_node_op.lgspFlags = candidate_copyOperationParameter_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_copyOperationParameter_node_op;
                return matches;
            }
            if((candidate_copyOperationParameter_node_newop.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
            {
                candidate_copyOperationParameter_node_op.lgspFlags = candidate_copyOperationParameter_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_copyOperationParameter_node_op;
                return matches;
            }
            // Extend Outgoing copyOperationParameter_edge__edge0 from copyOperationParameter_node_op 
            GRGEN_LGSP.LGSPEdge head_candidate_copyOperationParameter_edge__edge0 = candidate_copyOperationParameter_node_op.lgspOuthead;
            if(head_candidate_copyOperationParameter_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_copyOperationParameter_edge__edge0 = head_candidate_copyOperationParameter_edge__edge0;
                do
                {
                    if(candidate_copyOperationParameter_edge__edge0.lgspType.TypeID!=8) {
                        continue;
                    }
                    // Implicit Target copyOperationParameter_node_p from copyOperationParameter_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_copyOperationParameter_node_p = candidate_copyOperationParameter_edge__edge0.lgspTarget;
                    if(candidate_copyOperationParameter_node_p.lgspType.TypeID!=17) {
                        continue;
                    }
                    Rule_copyOperationParameter.Match_copyOperationParameter match = matches.GetNextUnfilledPosition();
                    match._node_op = candidate_copyOperationParameter_node_op;
                    match._node_p = candidate_copyOperationParameter_node_p;
                    match._node_newop = candidate_copyOperationParameter_node_newop;
                    match._edge__edge0 = candidate_copyOperationParameter_edge__edge0;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        candidate_copyOperationParameter_node_op.MoveOutHeadAfter(candidate_copyOperationParameter_edge__edge0);
                        candidate_copyOperationParameter_node_op.lgspFlags = candidate_copyOperationParameter_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_copyOperationParameter_node_op;
                        return matches;
                    }
                }
                while( (candidate_copyOperationParameter_edge__edge0 = candidate_copyOperationParameter_edge__edge0.lgspOutNext) != head_candidate_copyOperationParameter_edge__edge0 );
            }
            candidate_copyOperationParameter_node_op.lgspFlags = candidate_copyOperationParameter_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_copyOperationParameter_node_op;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, copyOperationParameter_node_op, copyOperationParameter_node_newop);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_copyOperationParameter.IMatch_copyOperationParameter match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter> matches)
        {
            foreach(Rule_copyOperationParameter.IMatch_copyOperationParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, copyOperationParameter_node_op, copyOperationParameter_node_newop);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, copyOperationParameter_node_op, copyOperationParameter_node_newop);
            if(matches.Count <= 0) return false;
            foreach(Rule_copyOperationParameter.IMatch_copyOperationParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, copyOperationParameter_node_op, copyOperationParameter_node_newop);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, copyOperationParameter_node_op, copyOperationParameter_node_newop);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, copyOperationParameter_node_op, copyOperationParameter_node_newop);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation copyOperationParameter_node_op, GRGEN_MODEL.IOperation copyOperationParameter_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, copyOperationParameter_node_op, copyOperationParameter_node_newop);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_copyOperationParameter.IMatch_copyOperationParameter)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_copyOperationParameter.IMatch_copyOperationParameter>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IOperation) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IOperation) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_relinkMethodBody
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_relinkMethodBody.IMatch_relinkMethodBody match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop);
    }
    
    public class Action_relinkMethodBody : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_relinkMethodBody
    {
        public Action_relinkMethodBody() {
            _rulePattern = Rule_relinkMethodBody.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_relinkMethodBody.Match_relinkMethodBody, Rule_relinkMethodBody.IMatch_relinkMethodBody>(this);
        }

        public Rule_relinkMethodBody _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "relinkMethodBody"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_relinkMethodBody.Match_relinkMethodBody, Rule_relinkMethodBody.IMatch_relinkMethodBody> matches;

        public static Action_relinkMethodBody Instance { get { return instance; } }
        private static Action_relinkMethodBody instance = new Action_relinkMethodBody();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset relinkMethodBody_node_mb 
            GRGEN_LGSP.LGSPNode candidate_relinkMethodBody_node_mb = (GRGEN_LGSP.LGSPNode)relinkMethodBody_node_mb;
            if(candidate_relinkMethodBody_node_mb.lgspType.TypeID!=7) {
                return matches;
            }
            // Preset relinkMethodBody_node_src 
            GRGEN_LGSP.LGSPNode candidate_relinkMethodBody_node_src = (GRGEN_LGSP.LGSPNode)relinkMethodBody_node_src;
            if(candidate_relinkMethodBody_node_src.lgspType.TypeID!=3) {
                return matches;
            }
            uint prev__candidate_relinkMethodBody_node_src;
            prev__candidate_relinkMethodBody_node_src = candidate_relinkMethodBody_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_relinkMethodBody_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Preset relinkMethodBody_node_op 
            GRGEN_LGSP.LGSPNode candidate_relinkMethodBody_node_op = (GRGEN_LGSP.LGSPNode)relinkMethodBody_node_op;
            if(candidate_relinkMethodBody_node_op.lgspType.TypeID!=6) {
                candidate_relinkMethodBody_node_src.lgspFlags = candidate_relinkMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_src;
                return matches;
            }
            uint prev__candidate_relinkMethodBody_node_op;
            prev__candidate_relinkMethodBody_node_op = candidate_relinkMethodBody_node_op.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_relinkMethodBody_node_op.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Preset relinkMethodBody_node_tgt 
            GRGEN_LGSP.LGSPNode candidate_relinkMethodBody_node_tgt = (GRGEN_LGSP.LGSPNode)relinkMethodBody_node_tgt;
            if(candidate_relinkMethodBody_node_tgt.lgspType.TypeID!=3) {
                candidate_relinkMethodBody_node_op.lgspFlags = candidate_relinkMethodBody_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_op;
                candidate_relinkMethodBody_node_src.lgspFlags = candidate_relinkMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_src;
                return matches;
            }
            if((candidate_relinkMethodBody_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
            {
                candidate_relinkMethodBody_node_op.lgspFlags = candidate_relinkMethodBody_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_op;
                candidate_relinkMethodBody_node_src.lgspFlags = candidate_relinkMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_src;
                return matches;
            }
            // Preset relinkMethodBody_node_newop 
            GRGEN_LGSP.LGSPNode candidate_relinkMethodBody_node_newop = (GRGEN_LGSP.LGSPNode)relinkMethodBody_node_newop;
            if(candidate_relinkMethodBody_node_newop.lgspType.TypeID!=6) {
                candidate_relinkMethodBody_node_op.lgspFlags = candidate_relinkMethodBody_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_op;
                candidate_relinkMethodBody_node_src.lgspFlags = candidate_relinkMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_src;
                return matches;
            }
            if((candidate_relinkMethodBody_node_newop.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
            {
                candidate_relinkMethodBody_node_op.lgspFlags = candidate_relinkMethodBody_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_op;
                candidate_relinkMethodBody_node_src.lgspFlags = candidate_relinkMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_src;
                return matches;
            }
            // Extend Outgoing relinkMethodBody_edge_b1 from relinkMethodBody_node_mb 
            GRGEN_LGSP.LGSPEdge head_candidate_relinkMethodBody_edge_b1 = candidate_relinkMethodBody_node_mb.lgspOuthead;
            if(head_candidate_relinkMethodBody_edge_b1 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_relinkMethodBody_edge_b1 = head_candidate_relinkMethodBody_edge_b1;
                do
                {
                    if(candidate_relinkMethodBody_edge_b1.lgspType.TypeID!=3) {
                        continue;
                    }
                    if(candidate_relinkMethodBody_edge_b1.lgspTarget != candidate_relinkMethodBody_node_src) {
                        continue;
                    }
                    // Extend Outgoing relinkMethodBody_edge_b from relinkMethodBody_node_op 
                    GRGEN_LGSP.LGSPEdge head_candidate_relinkMethodBody_edge_b = candidate_relinkMethodBody_node_op.lgspOuthead;
                    if(head_candidate_relinkMethodBody_edge_b != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_relinkMethodBody_edge_b = head_candidate_relinkMethodBody_edge_b;
                        do
                        {
                            if(candidate_relinkMethodBody_edge_b.lgspType.TypeID!=10) {
                                continue;
                            }
                            if(candidate_relinkMethodBody_edge_b.lgspTarget != candidate_relinkMethodBody_node_mb) {
                                continue;
                            }
                            Rule_relinkMethodBody.Match_relinkMethodBody match = matches.GetNextUnfilledPosition();
                            match._node_mb = candidate_relinkMethodBody_node_mb;
                            match._node_src = candidate_relinkMethodBody_node_src;
                            match._node_op = candidate_relinkMethodBody_node_op;
                            match._node_tgt = candidate_relinkMethodBody_node_tgt;
                            match._node_newop = candidate_relinkMethodBody_node_newop;
                            match._edge_b1 = candidate_relinkMethodBody_edge_b1;
                            match._edge_b = candidate_relinkMethodBody_edge_b;
                            matches.PositionWasFilledFixIt();
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && matches.Count >= maxMatches)
                            {
                                candidate_relinkMethodBody_node_op.MoveOutHeadAfter(candidate_relinkMethodBody_edge_b);
                                candidate_relinkMethodBody_node_mb.MoveOutHeadAfter(candidate_relinkMethodBody_edge_b1);
                                candidate_relinkMethodBody_node_op.lgspFlags = candidate_relinkMethodBody_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_op;
                                candidate_relinkMethodBody_node_src.lgspFlags = candidate_relinkMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_src;
                                return matches;
                            }
                        }
                        while( (candidate_relinkMethodBody_edge_b = candidate_relinkMethodBody_edge_b.lgspOutNext) != head_candidate_relinkMethodBody_edge_b );
                    }
                }
                while( (candidate_relinkMethodBody_edge_b1 = candidate_relinkMethodBody_edge_b1.lgspOutNext) != head_candidate_relinkMethodBody_edge_b1 );
            }
            candidate_relinkMethodBody_node_op.lgspFlags = candidate_relinkMethodBody_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_op;
            candidate_relinkMethodBody_node_src.lgspFlags = candidate_relinkMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkMethodBody_node_src;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, relinkMethodBody_node_mb, relinkMethodBody_node_src, relinkMethodBody_node_tgt, relinkMethodBody_node_op, relinkMethodBody_node_newop);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_relinkMethodBody.IMatch_relinkMethodBody match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody> matches)
        {
            foreach(Rule_relinkMethodBody.IMatch_relinkMethodBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkMethodBody_node_mb, relinkMethodBody_node_src, relinkMethodBody_node_tgt, relinkMethodBody_node_op, relinkMethodBody_node_newop);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, relinkMethodBody_node_mb, relinkMethodBody_node_src, relinkMethodBody_node_tgt, relinkMethodBody_node_op, relinkMethodBody_node_newop);
            if(matches.Count <= 0) return false;
            foreach(Rule_relinkMethodBody.IMatch_relinkMethodBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkMethodBody_node_mb, relinkMethodBody_node_src, relinkMethodBody_node_tgt, relinkMethodBody_node_op, relinkMethodBody_node_newop);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkMethodBody_node_mb, relinkMethodBody_node_src, relinkMethodBody_node_tgt, relinkMethodBody_node_op, relinkMethodBody_node_newop);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkMethodBody_node_mb, relinkMethodBody_node_src, relinkMethodBody_node_tgt, relinkMethodBody_node_op, relinkMethodBody_node_newop);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody relinkMethodBody_node_mb, GRGEN_MODEL.IClass relinkMethodBody_node_src, GRGEN_MODEL.IClass relinkMethodBody_node_tgt, GRGEN_MODEL.IOperation relinkMethodBody_node_op, GRGEN_MODEL.IOperation relinkMethodBody_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkMethodBody_node_mb, relinkMethodBody_node_src, relinkMethodBody_node_tgt, relinkMethodBody_node_op, relinkMethodBody_node_newop);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IOperation) parameters[3], (GRGEN_MODEL.IOperation) parameters[4]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_relinkMethodBody.IMatch_relinkMethodBody)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_relinkMethodBody.IMatch_relinkMethodBody>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IOperation) parameters[3], (GRGEN_MODEL.IOperation) parameters[4])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IOperation) parameters[3], (GRGEN_MODEL.IOperation) parameters[4])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IOperation) parameters[3], (GRGEN_MODEL.IOperation) parameters[4]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IOperation) parameters[3], (GRGEN_MODEL.IOperation) parameters[4]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IClass) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IOperation) parameters[3], (GRGEN_MODEL.IOperation) parameters[4]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_relinkParameter
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_relinkParameter.IMatch_relinkParameter match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop);
    }
    
    public class Action_relinkParameter : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_relinkParameter
    {
        public Action_relinkParameter() {
            _rulePattern = Rule_relinkParameter.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_relinkParameter.Match_relinkParameter, Rule_relinkParameter.IMatch_relinkParameter>(this);
        }

        public Rule_relinkParameter _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "relinkParameter"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_relinkParameter.Match_relinkParameter, Rule_relinkParameter.IMatch_relinkParameter> matches;

        public static Action_relinkParameter Instance { get { return instance; } }
        private static Action_relinkParameter instance = new Action_relinkParameter();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset relinkParameter_node_op 
            GRGEN_LGSP.LGSPNode candidate_relinkParameter_node_op = (GRGEN_LGSP.LGSPNode)relinkParameter_node_op;
            if(candidate_relinkParameter_node_op.lgspType.TypeID!=6) {
                return matches;
            }
            uint prev__candidate_relinkParameter_node_op;
            prev__candidate_relinkParameter_node_op = candidate_relinkParameter_node_op.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_relinkParameter_node_op.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Preset relinkParameter_node_newop 
            GRGEN_LGSP.LGSPNode candidate_relinkParameter_node_newop = (GRGEN_LGSP.LGSPNode)relinkParameter_node_newop;
            if(candidate_relinkParameter_node_newop.lgspType.TypeID!=6) {
                candidate_relinkParameter_node_op.lgspFlags = candidate_relinkParameter_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkParameter_node_op;
                return matches;
            }
            if((candidate_relinkParameter_node_newop.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
            {
                candidate_relinkParameter_node_op.lgspFlags = candidate_relinkParameter_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkParameter_node_op;
                return matches;
            }
            // Preset relinkParameter_node_mb 
            GRGEN_LGSP.LGSPNode candidate_relinkParameter_node_mb = (GRGEN_LGSP.LGSPNode)relinkParameter_node_mb;
            if(candidate_relinkParameter_node_mb.lgspType.TypeID!=7) {
                candidate_relinkParameter_node_op.lgspFlags = candidate_relinkParameter_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkParameter_node_op;
                return matches;
            }
            // Extend Outgoing relinkParameter_edge__edge0 from relinkParameter_node_op 
            GRGEN_LGSP.LGSPEdge head_candidate_relinkParameter_edge__edge0 = candidate_relinkParameter_node_op.lgspOuthead;
            if(head_candidate_relinkParameter_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_relinkParameter_edge__edge0 = head_candidate_relinkParameter_edge__edge0;
                do
                {
                    if(candidate_relinkParameter_edge__edge0.lgspType.TypeID!=8) {
                        continue;
                    }
                    uint prev__candidate_relinkParameter_edge__edge0;
                    prev__candidate_relinkParameter_edge__edge0 = candidate_relinkParameter_edge__edge0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    candidate_relinkParameter_edge__edge0.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    // Implicit Target relinkParameter_node_p from relinkParameter_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_relinkParameter_node_p = candidate_relinkParameter_edge__edge0.lgspTarget;
                    if(candidate_relinkParameter_node_p.lgspType.TypeID!=17) {
                        candidate_relinkParameter_edge__edge0.lgspFlags = candidate_relinkParameter_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkParameter_edge__edge0;
                        continue;
                    }
                    uint prev__candidate_relinkParameter_node_p;
                    prev__candidate_relinkParameter_node_p = candidate_relinkParameter_node_p.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    candidate_relinkParameter_node_p.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    // Extend Outgoing relinkParameter_edge__edge1 from relinkParameter_node_newop 
                    GRGEN_LGSP.LGSPEdge head_candidate_relinkParameter_edge__edge1 = candidate_relinkParameter_node_newop.lgspOuthead;
                    if(head_candidate_relinkParameter_edge__edge1 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_relinkParameter_edge__edge1 = head_candidate_relinkParameter_edge__edge1;
                        do
                        {
                            if(candidate_relinkParameter_edge__edge1.lgspType.TypeID!=8) {
                                continue;
                            }
                            if((candidate_relinkParameter_edge__edge1.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                            {
                                continue;
                            }
                            // Implicit Target relinkParameter_node_newp from relinkParameter_edge__edge1 
                            GRGEN_LGSP.LGSPNode candidate_relinkParameter_node_newp = candidate_relinkParameter_edge__edge1.lgspTarget;
                            if(candidate_relinkParameter_node_newp.lgspType.TypeID!=17) {
                                continue;
                            }
                            if((candidate_relinkParameter_node_newp.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                            {
                                continue;
                            }
                            // Extend Incoming relinkParameter_edge_l from relinkParameter_node_p 
                            GRGEN_LGSP.LGSPEdge head_candidate_relinkParameter_edge_l = candidate_relinkParameter_node_p.lgspInhead;
                            if(head_candidate_relinkParameter_edge_l != null)
                            {
                                GRGEN_LGSP.LGSPEdge candidate_relinkParameter_edge_l = head_candidate_relinkParameter_edge_l;
                                do
                                {
                                    if(candidate_relinkParameter_edge_l.lgspType.TypeID!=11) {
                                        continue;
                                    }
                                    // Implicit Source relinkParameter_node_exp from relinkParameter_edge_l 
                                    GRGEN_LGSP.LGSPNode candidate_relinkParameter_node_exp = candidate_relinkParameter_edge_l.lgspSource;
                                    if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_relinkParameter_node_exp.lgspType.TypeID]) {
                                        continue;
                                    }
                                    Rule_relinkParameter.Match_relinkParameter match = matches.GetNextUnfilledPosition();
                                    match._node_exp = candidate_relinkParameter_node_exp;
                                    match._node_p = candidate_relinkParameter_node_p;
                                    match._node_op = candidate_relinkParameter_node_op;
                                    match._node_newop = candidate_relinkParameter_node_newop;
                                    match._node_newp = candidate_relinkParameter_node_newp;
                                    match._node_mb = candidate_relinkParameter_node_mb;
                                    match._edge_l = candidate_relinkParameter_edge_l;
                                    match._edge__edge0 = candidate_relinkParameter_edge__edge0;
                                    match._edge__edge1 = candidate_relinkParameter_edge__edge1;
                                    matches.PositionWasFilledFixIt();
                                    // if enough matches were found, we leave
                                    if(maxMatches > 0 && matches.Count >= maxMatches)
                                    {
                                        candidate_relinkParameter_node_p.MoveInHeadAfter(candidate_relinkParameter_edge_l);
                                        candidate_relinkParameter_node_newop.MoveOutHeadAfter(candidate_relinkParameter_edge__edge1);
                                        candidate_relinkParameter_node_op.MoveOutHeadAfter(candidate_relinkParameter_edge__edge0);
                                        candidate_relinkParameter_node_p.lgspFlags = candidate_relinkParameter_node_p.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkParameter_node_p;
                                        candidate_relinkParameter_edge__edge0.lgspFlags = candidate_relinkParameter_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkParameter_edge__edge0;
                                        candidate_relinkParameter_node_op.lgspFlags = candidate_relinkParameter_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkParameter_node_op;
                                        return matches;
                                    }
                                }
                                while( (candidate_relinkParameter_edge_l = candidate_relinkParameter_edge_l.lgspInNext) != head_candidate_relinkParameter_edge_l );
                            }
                        }
                        while( (candidate_relinkParameter_edge__edge1 = candidate_relinkParameter_edge__edge1.lgspOutNext) != head_candidate_relinkParameter_edge__edge1 );
                    }
                    candidate_relinkParameter_node_p.lgspFlags = candidate_relinkParameter_node_p.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkParameter_node_p;
                    candidate_relinkParameter_edge__edge0.lgspFlags = candidate_relinkParameter_edge__edge0.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkParameter_edge__edge0;
                }
                while( (candidate_relinkParameter_edge__edge0 = candidate_relinkParameter_edge__edge0.lgspOutNext) != head_candidate_relinkParameter_edge__edge0 );
            }
            candidate_relinkParameter_node_op.lgspFlags = candidate_relinkParameter_node_op.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkParameter_node_op;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, relinkParameter_node_mb, relinkParameter_node_op, relinkParameter_node_newop);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_relinkParameter.IMatch_relinkParameter match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter> matches)
        {
            foreach(Rule_relinkParameter.IMatch_relinkParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkParameter_node_mb, relinkParameter_node_op, relinkParameter_node_newop);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, relinkParameter_node_mb, relinkParameter_node_op, relinkParameter_node_newop);
            if(matches.Count <= 0) return false;
            foreach(Rule_relinkParameter.IMatch_relinkParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkParameter_node_mb, relinkParameter_node_op, relinkParameter_node_newop);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkParameter_node_mb, relinkParameter_node_op, relinkParameter_node_newop);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkParameter_node_mb, relinkParameter_node_op, relinkParameter_node_newop);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IMethodBody relinkParameter_node_mb, GRGEN_MODEL.IOperation relinkParameter_node_op, GRGEN_MODEL.IOperation relinkParameter_node_newop)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkParameter_node_mb, relinkParameter_node_op, relinkParameter_node_newop);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_relinkParameter.IMatch_relinkParameter)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_relinkParameter.IMatch_relinkParameter>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IMethodBody) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_relinkOperationAndMethodBody
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt);
    }
    
    public class Action_relinkOperationAndMethodBody : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_relinkOperationAndMethodBody
    {
        public Action_relinkOperationAndMethodBody() {
            _rulePattern = Rule_relinkOperationAndMethodBody.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_relinkOperationAndMethodBody.Match_relinkOperationAndMethodBody, Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody>(this);
        }

        public Rule_relinkOperationAndMethodBody _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "relinkOperationAndMethodBody"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_relinkOperationAndMethodBody.Match_relinkOperationAndMethodBody, Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> matches;

        public static Action_relinkOperationAndMethodBody Instance { get { return instance; } }
        private static Action_relinkOperationAndMethodBody instance = new Action_relinkOperationAndMethodBody();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset relinkOperationAndMethodBody_node_mb 
            GRGEN_LGSP.LGSPNode candidate_relinkOperationAndMethodBody_node_mb = (GRGEN_LGSP.LGSPNode)relinkOperationAndMethodBody_node_mb;
            if(candidate_relinkOperationAndMethodBody_node_mb.lgspType.TypeID!=7) {
                return matches;
            }
            // Preset relinkOperationAndMethodBody_node_src 
            GRGEN_LGSP.LGSPNode candidate_relinkOperationAndMethodBody_node_src = (GRGEN_LGSP.LGSPNode)relinkOperationAndMethodBody_node_src;
            if(candidate_relinkOperationAndMethodBody_node_src.lgspType.TypeID!=3) {
                return matches;
            }
            uint prev__candidate_relinkOperationAndMethodBody_node_src;
            prev__candidate_relinkOperationAndMethodBody_node_src = candidate_relinkOperationAndMethodBody_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_relinkOperationAndMethodBody_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Preset relinkOperationAndMethodBody_node_op 
            GRGEN_LGSP.LGSPNode candidate_relinkOperationAndMethodBody_node_op = (GRGEN_LGSP.LGSPNode)relinkOperationAndMethodBody_node_op;
            if(candidate_relinkOperationAndMethodBody_node_op.lgspType.TypeID!=6) {
                candidate_relinkOperationAndMethodBody_node_src.lgspFlags = candidate_relinkOperationAndMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkOperationAndMethodBody_node_src;
                return matches;
            }
            // Preset relinkOperationAndMethodBody_node_tgt 
            GRGEN_LGSP.LGSPNode candidate_relinkOperationAndMethodBody_node_tgt = (GRGEN_LGSP.LGSPNode)relinkOperationAndMethodBody_node_tgt;
            if(candidate_relinkOperationAndMethodBody_node_tgt.lgspType.TypeID!=3) {
                candidate_relinkOperationAndMethodBody_node_src.lgspFlags = candidate_relinkOperationAndMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkOperationAndMethodBody_node_src;
                return matches;
            }
            if((candidate_relinkOperationAndMethodBody_node_tgt.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
            {
                candidate_relinkOperationAndMethodBody_node_src.lgspFlags = candidate_relinkOperationAndMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkOperationAndMethodBody_node_src;
                return matches;
            }
            // Extend Outgoing relinkOperationAndMethodBody_edge_bc from relinkOperationAndMethodBody_node_mb 
            GRGEN_LGSP.LGSPEdge head_candidate_relinkOperationAndMethodBody_edge_bc = candidate_relinkOperationAndMethodBody_node_mb.lgspOuthead;
            if(head_candidate_relinkOperationAndMethodBody_edge_bc != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_relinkOperationAndMethodBody_edge_bc = head_candidate_relinkOperationAndMethodBody_edge_bc;
                do
                {
                    if(candidate_relinkOperationAndMethodBody_edge_bc.lgspType.TypeID!=3) {
                        continue;
                    }
                    if(candidate_relinkOperationAndMethodBody_edge_bc.lgspTarget != candidate_relinkOperationAndMethodBody_node_src) {
                        continue;
                    }
                    // Extend Outgoing relinkOperationAndMethodBody_edge_b from relinkOperationAndMethodBody_node_op 
                    GRGEN_LGSP.LGSPEdge head_candidate_relinkOperationAndMethodBody_edge_b = candidate_relinkOperationAndMethodBody_node_op.lgspOuthead;
                    if(head_candidate_relinkOperationAndMethodBody_edge_b != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_relinkOperationAndMethodBody_edge_b = head_candidate_relinkOperationAndMethodBody_edge_b;
                        do
                        {
                            if(candidate_relinkOperationAndMethodBody_edge_b.lgspType.TypeID!=10) {
                                continue;
                            }
                            if(candidate_relinkOperationAndMethodBody_edge_b.lgspTarget != candidate_relinkOperationAndMethodBody_node_mb) {
                                continue;
                            }
                            Rule_relinkOperationAndMethodBody.Match_relinkOperationAndMethodBody match = matches.GetNextUnfilledPosition();
                            match._node_mb = candidate_relinkOperationAndMethodBody_node_mb;
                            match._node_src = candidate_relinkOperationAndMethodBody_node_src;
                            match._node_op = candidate_relinkOperationAndMethodBody_node_op;
                            match._node_tgt = candidate_relinkOperationAndMethodBody_node_tgt;
                            match._edge_bc = candidate_relinkOperationAndMethodBody_edge_bc;
                            match._edge_b = candidate_relinkOperationAndMethodBody_edge_b;
                            matches.PositionWasFilledFixIt();
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && matches.Count >= maxMatches)
                            {
                                candidate_relinkOperationAndMethodBody_node_op.MoveOutHeadAfter(candidate_relinkOperationAndMethodBody_edge_b);
                                candidate_relinkOperationAndMethodBody_node_mb.MoveOutHeadAfter(candidate_relinkOperationAndMethodBody_edge_bc);
                                candidate_relinkOperationAndMethodBody_node_src.lgspFlags = candidate_relinkOperationAndMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkOperationAndMethodBody_node_src;
                                return matches;
                            }
                        }
                        while( (candidate_relinkOperationAndMethodBody_edge_b = candidate_relinkOperationAndMethodBody_edge_b.lgspOutNext) != head_candidate_relinkOperationAndMethodBody_edge_b );
                    }
                }
                while( (candidate_relinkOperationAndMethodBody_edge_bc = candidate_relinkOperationAndMethodBody_edge_bc.lgspOutNext) != head_candidate_relinkOperationAndMethodBody_edge_bc );
            }
            candidate_relinkOperationAndMethodBody_node_src.lgspFlags = candidate_relinkOperationAndMethodBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_relinkOperationAndMethodBody_node_src;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, relinkOperationAndMethodBody_node_op, relinkOperationAndMethodBody_node_mb, relinkOperationAndMethodBody_node_src, relinkOperationAndMethodBody_node_tgt);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> matches)
        {
            foreach(Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkOperationAndMethodBody_node_op, relinkOperationAndMethodBody_node_mb, relinkOperationAndMethodBody_node_src, relinkOperationAndMethodBody_node_tgt);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, relinkOperationAndMethodBody_node_op, relinkOperationAndMethodBody_node_mb, relinkOperationAndMethodBody_node_src, relinkOperationAndMethodBody_node_tgt);
            if(matches.Count <= 0) return false;
            foreach(Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkOperationAndMethodBody_node_op, relinkOperationAndMethodBody_node_mb, relinkOperationAndMethodBody_node_src, relinkOperationAndMethodBody_node_tgt);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkOperationAndMethodBody_node_op, relinkOperationAndMethodBody_node_mb, relinkOperationAndMethodBody_node_src, relinkOperationAndMethodBody_node_tgt);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkOperationAndMethodBody_node_op, relinkOperationAndMethodBody_node_mb, relinkOperationAndMethodBody_node_src, relinkOperationAndMethodBody_node_tgt);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation relinkOperationAndMethodBody_node_op, GRGEN_MODEL.IMethodBody relinkOperationAndMethodBody_node_mb, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_src, GRGEN_MODEL.IClass relinkOperationAndMethodBody_node_tgt)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, relinkOperationAndMethodBody_node_op, relinkOperationAndMethodBody_node_mb, relinkOperationAndMethodBody_node_src, relinkOperationAndMethodBody_node_tgt);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IMethodBody) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IClass) parameters[3]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_relinkOperationAndMethodBody.IMatch_relinkOperationAndMethodBody>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IMethodBody) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IClass) parameters[3])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IMethodBody) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IClass) parameters[3])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IMethodBody) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IClass) parameters[3]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IMethodBody) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IClass) parameters[3]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IMethodBody) parameters[1], (GRGEN_MODEL.IClass) parameters[2], (GRGEN_MODEL.IClass) parameters[3]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_addDelegateBody
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_addDelegateBody.IMatch_addDelegateBody match, out GRGEN_MODEL.ICall output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody> matches, out GRGEN_MODEL.ICall output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp, ref GRGEN_MODEL.ICall output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp, ref GRGEN_MODEL.ICall output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp);
    }
    
    public class Action_addDelegateBody : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_addDelegateBody
    {
        public Action_addDelegateBody() {
            _rulePattern = Rule_addDelegateBody.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[1];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_addDelegateBody.Match_addDelegateBody, Rule_addDelegateBody.IMatch_addDelegateBody>(this);
        }

        public Rule_addDelegateBody _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "addDelegateBody"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_addDelegateBody.Match_addDelegateBody, Rule_addDelegateBody.IMatch_addDelegateBody> matches;

        public static Action_addDelegateBody Instance { get { return instance; } }
        private static Action_addDelegateBody instance = new Action_addDelegateBody();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset addDelegateBody_node_src 
            GRGEN_LGSP.LGSPNode candidate_addDelegateBody_node_src = (GRGEN_LGSP.LGSPNode)addDelegateBody_node_src;
            if(candidate_addDelegateBody_node_src.lgspType.TypeID!=3) {
                return matches;
            }
            uint prev__candidate_addDelegateBody_node_src;
            prev__candidate_addDelegateBody_node_src = candidate_addDelegateBody_node_src.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_addDelegateBody_node_src.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Preset addDelegateBody_node_own 
            GRGEN_LGSP.LGSPNode candidate_addDelegateBody_node_own = (GRGEN_LGSP.LGSPNode)addDelegateBody_node_own;
            if(candidate_addDelegateBody_node_own.lgspType.TypeID!=6) {
                candidate_addDelegateBody_node_src.lgspFlags = candidate_addDelegateBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_src;
                return matches;
            }
            uint prev__candidate_addDelegateBody_node_own;
            prev__candidate_addDelegateBody_node_own = candidate_addDelegateBody_node_own.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_addDelegateBody_node_own.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Preset addDelegateBody_node_orig 
            GRGEN_LGSP.LGSPNode candidate_addDelegateBody_node_orig = (GRGEN_LGSP.LGSPNode)addDelegateBody_node_orig;
            if(candidate_addDelegateBody_node_orig.lgspType.TypeID!=6) {
                candidate_addDelegateBody_node_own.lgspFlags = candidate_addDelegateBody_node_own.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_own;
                candidate_addDelegateBody_node_src.lgspFlags = candidate_addDelegateBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_src;
                return matches;
            }
            if((candidate_addDelegateBody_node_orig.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
            {
                candidate_addDelegateBody_node_own.lgspFlags = candidate_addDelegateBody_node_own.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_own;
                candidate_addDelegateBody_node_src.lgspFlags = candidate_addDelegateBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_src;
                return matches;
            }
            uint prev__candidate_addDelegateBody_node_orig;
            prev__candidate_addDelegateBody_node_orig = candidate_addDelegateBody_node_orig.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_addDelegateBody_node_orig.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Preset addDelegateBody_node_vp 
            GRGEN_LGSP.LGSPNode candidate_addDelegateBody_node_vp = (GRGEN_LGSP.LGSPNode)addDelegateBody_node_vp;
            if((candidate_addDelegateBody_node_vp.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
            {
                candidate_addDelegateBody_node_orig.lgspFlags = candidate_addDelegateBody_node_orig.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_orig;
                candidate_addDelegateBody_node_own.lgspFlags = candidate_addDelegateBody_node_own.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_own;
                candidate_addDelegateBody_node_src.lgspFlags = candidate_addDelegateBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_src;
                return matches;
            }
            Rule_addDelegateBody.Match_addDelegateBody match = matches.GetNextUnfilledPosition();
            match._node_src = candidate_addDelegateBody_node_src;
            match._node_own = candidate_addDelegateBody_node_own;
            match._node_orig = candidate_addDelegateBody_node_orig;
            match._node_vp = candidate_addDelegateBody_node_vp;
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                candidate_addDelegateBody_node_orig.lgspFlags = candidate_addDelegateBody_node_orig.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_orig;
                candidate_addDelegateBody_node_own.lgspFlags = candidate_addDelegateBody_node_own.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_own;
                candidate_addDelegateBody_node_src.lgspFlags = candidate_addDelegateBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_src;
                return matches;
            }
            candidate_addDelegateBody_node_orig.lgspFlags = candidate_addDelegateBody_node_orig.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_orig;
            candidate_addDelegateBody_node_own.lgspFlags = candidate_addDelegateBody_node_own.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_own;
            candidate_addDelegateBody_node_src.lgspFlags = candidate_addDelegateBody_node_src.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_addDelegateBody_node_src;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, addDelegateBody_node_src, addDelegateBody_node_own, addDelegateBody_node_orig, addDelegateBody_node_vp);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_addDelegateBody.IMatch_addDelegateBody match, out GRGEN_MODEL.ICall output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody> matches, out GRGEN_MODEL.ICall output_0)
        {
            output_0 = null;
            foreach(Rule_addDelegateBody.IMatch_addDelegateBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp, ref GRGEN_MODEL.ICall output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addDelegateBody_node_src, addDelegateBody_node_own, addDelegateBody_node_orig, addDelegateBody_node_vp);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp, ref GRGEN_MODEL.ICall output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, addDelegateBody_node_src, addDelegateBody_node_own, addDelegateBody_node_orig, addDelegateBody_node_vp);
            if(matches.Count <= 0) return false;
            foreach(Rule_addDelegateBody.IMatch_addDelegateBody match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody> matches;
            GRGEN_MODEL.ICall output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addDelegateBody_node_src, addDelegateBody_node_own, addDelegateBody_node_orig, addDelegateBody_node_vp);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addDelegateBody_node_src, addDelegateBody_node_own, addDelegateBody_node_orig, addDelegateBody_node_vp);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.ICall output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addDelegateBody_node_src, addDelegateBody_node_own, addDelegateBody_node_orig, addDelegateBody_node_vp);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IClass addDelegateBody_node_src, GRGEN_MODEL.IOperation addDelegateBody_node_own, GRGEN_MODEL.IOperation addDelegateBody_node_orig, GRGEN_LIBGR.INode addDelegateBody_node_vp)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody> matches;
            GRGEN_MODEL.ICall output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addDelegateBody_node_src, addDelegateBody_node_own, addDelegateBody_node_orig, addDelegateBody_node_vp);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2], (GRGEN_LIBGR.INode) parameters[3]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.ICall output_0; 
            Modify(graph, (Rule_addDelegateBody.IMatch_addDelegateBody)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.ICall output_0; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_addDelegateBody.IMatch_addDelegateBody>)matches, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.ICall output_0 = null; 
            if(Apply(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2], (GRGEN_LIBGR.INode) parameters[3], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.ICall output_0 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2], (GRGEN_LIBGR.INode) parameters[3], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2], (GRGEN_LIBGR.INode) parameters[3]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2], (GRGEN_LIBGR.INode) parameters[3]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IClass) parameters[0], (GRGEN_MODEL.IOperation) parameters[1], (GRGEN_MODEL.IOperation) parameters[2], (GRGEN_LIBGR.INode) parameters[3]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_linkDelegateBodyToOperation
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op);
    }
    
    public class Action_linkDelegateBodyToOperation : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_linkDelegateBodyToOperation
    {
        public Action_linkDelegateBodyToOperation() {
            _rulePattern = Rule_linkDelegateBodyToOperation.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_linkDelegateBodyToOperation.Match_linkDelegateBodyToOperation, Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation>(this);
        }

        public Rule_linkDelegateBodyToOperation _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "linkDelegateBodyToOperation"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_linkDelegateBodyToOperation.Match_linkDelegateBodyToOperation, Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> matches;

        public static Action_linkDelegateBodyToOperation Instance { get { return instance; } }
        private static Action_linkDelegateBodyToOperation instance = new Action_linkDelegateBodyToOperation();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset linkDelegateBodyToOperation_node_op 
            GRGEN_LGSP.LGSPNode candidate_linkDelegateBodyToOperation_node_op = (GRGEN_LGSP.LGSPNode)linkDelegateBodyToOperation_node_op;
            if(candidate_linkDelegateBodyToOperation_node_op.lgspType.TypeID!=6) {
                return matches;
            }
            // Preset linkDelegateBodyToOperation_node_call 
            GRGEN_LGSP.LGSPNode candidate_linkDelegateBodyToOperation_node_call = (GRGEN_LGSP.LGSPNode)linkDelegateBodyToOperation_node_call;
            if(candidate_linkDelegateBodyToOperation_node_call.lgspType.TypeID!=11) {
                return matches;
            }
            // Extend Outgoing linkDelegateBodyToOperation_edge__edge0 from linkDelegateBodyToOperation_node_op 
            GRGEN_LGSP.LGSPEdge head_candidate_linkDelegateBodyToOperation_edge__edge0 = candidate_linkDelegateBodyToOperation_node_op.lgspOuthead;
            if(head_candidate_linkDelegateBodyToOperation_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_linkDelegateBodyToOperation_edge__edge0 = head_candidate_linkDelegateBodyToOperation_edge__edge0;
                do
                {
                    if(candidate_linkDelegateBodyToOperation_edge__edge0.lgspType.TypeID!=8) {
                        continue;
                    }
                    // Implicit Target linkDelegateBodyToOperation_node_param from linkDelegateBodyToOperation_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_linkDelegateBodyToOperation_node_param = candidate_linkDelegateBodyToOperation_edge__edge0.lgspTarget;
                    if(candidate_linkDelegateBodyToOperation_node_param.lgspType.TypeID!=17) {
                        continue;
                    }
                    Rule_linkDelegateBodyToOperation.Match_linkDelegateBodyToOperation match = matches.GetNextUnfilledPosition();
                    match._node_op = candidate_linkDelegateBodyToOperation_node_op;
                    match._node_param = candidate_linkDelegateBodyToOperation_node_param;
                    match._node_call = candidate_linkDelegateBodyToOperation_node_call;
                    match._edge__edge0 = candidate_linkDelegateBodyToOperation_edge__edge0;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        candidate_linkDelegateBodyToOperation_node_op.MoveOutHeadAfter(candidate_linkDelegateBodyToOperation_edge__edge0);
                        return matches;
                    }
                }
                while( (candidate_linkDelegateBodyToOperation_edge__edge0 = candidate_linkDelegateBodyToOperation_edge__edge0.lgspOutNext) != head_candidate_linkDelegateBodyToOperation_edge__edge0 );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, linkDelegateBodyToOperation_node_call, linkDelegateBodyToOperation_node_op);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> matches)
        {
            foreach(Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, linkDelegateBodyToOperation_node_call, linkDelegateBodyToOperation_node_op);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, linkDelegateBodyToOperation_node_call, linkDelegateBodyToOperation_node_op);
            if(matches.Count <= 0) return false;
            foreach(Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, linkDelegateBodyToOperation_node_call, linkDelegateBodyToOperation_node_op);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, linkDelegateBodyToOperation_node_call, linkDelegateBodyToOperation_node_op);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, linkDelegateBodyToOperation_node_call, linkDelegateBodyToOperation_node_op);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.ICall linkDelegateBodyToOperation_node_call, GRGEN_MODEL.IOperation linkDelegateBodyToOperation_node_op)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, linkDelegateBodyToOperation_node_call, linkDelegateBodyToOperation_node_op);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_linkDelegateBodyToOperation.IMatch_linkDelegateBodyToOperation>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IOperation) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IOperation) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IOperation) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_replaceAccess_Variable
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v);
    }
    
    public class Action_replaceAccess_Variable : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_replaceAccess_Variable
    {
        public Action_replaceAccess_Variable() {
            _rulePattern = Rule_replaceAccess_Variable.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_replaceAccess_Variable.Match_replaceAccess_Variable, Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable>(this);
        }

        public Rule_replaceAccess_Variable _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "replaceAccess_Variable"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_replaceAccess_Variable.Match_replaceAccess_Variable, Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> matches;

        public static Action_replaceAccess_Variable Instance { get { return instance; } }
        private static Action_replaceAccess_Variable instance = new Action_replaceAccess_Variable();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset replaceAccess_Variable_node_movedOperation 
            GRGEN_LGSP.LGSPNode candidate_replaceAccess_Variable_node_movedOperation = (GRGEN_LGSP.LGSPNode)replaceAccess_Variable_node_movedOperation;
            if(candidate_replaceAccess_Variable_node_movedOperation.lgspType.TypeID!=6) {
                return matches;
            }
            // Preset replaceAccess_Variable_node_v 
            GRGEN_LGSP.LGSPNode candidate_replaceAccess_Variable_node_v = (GRGEN_LGSP.LGSPNode)replaceAccess_Variable_node_v;
            if(candidate_replaceAccess_Variable_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            // Extend Incoming replaceAccess_Variable_edge_l from replaceAccess_Variable_node_movedOperation 
            GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Variable_edge_l = candidate_replaceAccess_Variable_node_movedOperation.lgspInhead;
            if(head_candidate_replaceAccess_Variable_edge_l != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Variable_edge_l = head_candidate_replaceAccess_Variable_edge_l;
                do
                {
                    if(candidate_replaceAccess_Variable_edge_l.lgspType.TypeID!=11) {
                        continue;
                    }
                    // Implicit Source replaceAccess_Variable_node_call from replaceAccess_Variable_edge_l 
                    GRGEN_LGSP.LGSPNode candidate_replaceAccess_Variable_node_call = candidate_replaceAccess_Variable_edge_l.lgspSource;
                    if(candidate_replaceAccess_Variable_node_call.lgspType.TypeID!=11) {
                        continue;
                    }
                    // Extend Incoming replaceAccess_Variable_edge_e from replaceAccess_Variable_node_call 
                    GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Variable_edge_e = candidate_replaceAccess_Variable_node_call.lgspInhead;
                    if(head_candidate_replaceAccess_Variable_edge_e != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Variable_edge_e = head_candidate_replaceAccess_Variable_edge_e;
                        do
                        {
                            if(candidate_replaceAccess_Variable_edge_e.lgspType.TypeID!=12) {
                                continue;
                            }
                            // Implicit Source replaceAccess_Variable_node_a from replaceAccess_Variable_edge_e 
                            GRGEN_LGSP.LGSPNode candidate_replaceAccess_Variable_node_a = candidate_replaceAccess_Variable_edge_e.lgspSource;
                            if(candidate_replaceAccess_Variable_node_a.lgspType.TypeID!=9) {
                                continue;
                            }
                            // Extend Outgoing replaceAccess_Variable_edge__edge0 from replaceAccess_Variable_node_call 
                            GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Variable_edge__edge0 = candidate_replaceAccess_Variable_node_call.lgspOuthead;
                            if(head_candidate_replaceAccess_Variable_edge__edge0 != null)
                            {
                                GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Variable_edge__edge0 = head_candidate_replaceAccess_Variable_edge__edge0;
                                do
                                {
                                    if(candidate_replaceAccess_Variable_edge__edge0.lgspType.TypeID!=13) {
                                        continue;
                                    }
                                    // Implicit Target replaceAccess_Variable_node_b from replaceAccess_Variable_edge__edge0 
                                    GRGEN_LGSP.LGSPNode candidate_replaceAccess_Variable_node_b = candidate_replaceAccess_Variable_edge__edge0.lgspTarget;
                                    if(candidate_replaceAccess_Variable_node_b.lgspType.TypeID!=15) {
                                        continue;
                                    }
                                    Rule_replaceAccess_Variable.Match_replaceAccess_Variable match = matches.GetNextUnfilledPosition();
                                    match._node_a = candidate_replaceAccess_Variable_node_a;
                                    match._node_call = candidate_replaceAccess_Variable_node_call;
                                    match._node_movedOperation = candidate_replaceAccess_Variable_node_movedOperation;
                                    match._node_b = candidate_replaceAccess_Variable_node_b;
                                    match._node_v = candidate_replaceAccess_Variable_node_v;
                                    match._edge_e = candidate_replaceAccess_Variable_edge_e;
                                    match._edge_l = candidate_replaceAccess_Variable_edge_l;
                                    match._edge__edge0 = candidate_replaceAccess_Variable_edge__edge0;
                                    matches.PositionWasFilledFixIt();
                                    // if enough matches were found, we leave
                                    if(maxMatches > 0 && matches.Count >= maxMatches)
                                    {
                                        candidate_replaceAccess_Variable_node_call.MoveOutHeadAfter(candidate_replaceAccess_Variable_edge__edge0);
                                        candidate_replaceAccess_Variable_node_call.MoveInHeadAfter(candidate_replaceAccess_Variable_edge_e);
                                        candidate_replaceAccess_Variable_node_movedOperation.MoveInHeadAfter(candidate_replaceAccess_Variable_edge_l);
                                        return matches;
                                    }
                                }
                                while( (candidate_replaceAccess_Variable_edge__edge0 = candidate_replaceAccess_Variable_edge__edge0.lgspOutNext) != head_candidate_replaceAccess_Variable_edge__edge0 );
                            }
                        }
                        while( (candidate_replaceAccess_Variable_edge_e = candidate_replaceAccess_Variable_edge_e.lgspInNext) != head_candidate_replaceAccess_Variable_edge_e );
                    }
                }
                while( (candidate_replaceAccess_Variable_edge_l = candidate_replaceAccess_Variable_edge_l.lgspInNext) != head_candidate_replaceAccess_Variable_edge_l );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, replaceAccess_Variable_node_movedOperation, replaceAccess_Variable_node_v);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> matches)
        {
            foreach(Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Variable_node_movedOperation, replaceAccess_Variable_node_v);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, replaceAccess_Variable_node_movedOperation, replaceAccess_Variable_node_v);
            if(matches.Count <= 0) return false;
            foreach(Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Variable_node_movedOperation, replaceAccess_Variable_node_v);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Variable_node_movedOperation, replaceAccess_Variable_node_v);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Variable_node_movedOperation, replaceAccess_Variable_node_v);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation replaceAccess_Variable_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_node_v)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Variable_node_movedOperation, replaceAccess_Variable_node_v);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable.IMatch_replaceAccess_Variable>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_replaceAccess_Variable_WithSource
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam);
    }
    
    public class Action_replaceAccess_Variable_WithSource : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_replaceAccess_Variable_WithSource
    {
        public Action_replaceAccess_Variable_WithSource() {
            _rulePattern = Rule_replaceAccess_Variable_WithSource.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_replaceAccess_Variable_WithSource.Match_replaceAccess_Variable_WithSource, Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource>(this);
        }

        public Rule_replaceAccess_Variable_WithSource _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "replaceAccess_Variable_WithSource"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_replaceAccess_Variable_WithSource.Match_replaceAccess_Variable_WithSource, Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> matches;

        public static Action_replaceAccess_Variable_WithSource Instance { get { return instance; } }
        private static Action_replaceAccess_Variable_WithSource instance = new Action_replaceAccess_Variable_WithSource();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset replaceAccess_Variable_WithSource_node_movedOperation 
            GRGEN_LGSP.LGSPNode candidate_replaceAccess_Variable_WithSource_node_movedOperation = (GRGEN_LGSP.LGSPNode)replaceAccess_Variable_WithSource_node_movedOperation;
            if(candidate_replaceAccess_Variable_WithSource_node_movedOperation.lgspType.TypeID!=6) {
                return matches;
            }
            // Preset replaceAccess_Variable_WithSource_node_v 
            GRGEN_LGSP.LGSPNode candidate_replaceAccess_Variable_WithSource_node_v = (GRGEN_LGSP.LGSPNode)replaceAccess_Variable_WithSource_node_v;
            if(candidate_replaceAccess_Variable_WithSource_node_v.lgspType.TypeID!=5) {
                return matches;
            }
            // Preset replaceAccess_Variable_WithSource_node_srcparam 
            GRGEN_LGSP.LGSPNode candidate_replaceAccess_Variable_WithSource_node_srcparam = (GRGEN_LGSP.LGSPNode)replaceAccess_Variable_WithSource_node_srcparam;
            if(candidate_replaceAccess_Variable_WithSource_node_srcparam.lgspType.TypeID!=17) {
                return matches;
            }
            // Extend Incoming replaceAccess_Variable_WithSource_edge_l from replaceAccess_Variable_WithSource_node_movedOperation 
            GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Variable_WithSource_edge_l = candidate_replaceAccess_Variable_WithSource_node_movedOperation.lgspInhead;
            if(head_candidate_replaceAccess_Variable_WithSource_edge_l != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Variable_WithSource_edge_l = head_candidate_replaceAccess_Variable_WithSource_edge_l;
                do
                {
                    if(candidate_replaceAccess_Variable_WithSource_edge_l.lgspType.TypeID!=11) {
                        continue;
                    }
                    // Implicit Source replaceAccess_Variable_WithSource_node_call from replaceAccess_Variable_WithSource_edge_l 
                    GRGEN_LGSP.LGSPNode candidate_replaceAccess_Variable_WithSource_node_call = candidate_replaceAccess_Variable_WithSource_edge_l.lgspSource;
                    if(candidate_replaceAccess_Variable_WithSource_node_call.lgspType.TypeID!=11) {
                        continue;
                    }
                    // Extend Incoming replaceAccess_Variable_WithSource_edge_e from replaceAccess_Variable_WithSource_node_call 
                    GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Variable_WithSource_edge_e = candidate_replaceAccess_Variable_WithSource_node_call.lgspInhead;
                    if(head_candidate_replaceAccess_Variable_WithSource_edge_e != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Variable_WithSource_edge_e = head_candidate_replaceAccess_Variable_WithSource_edge_e;
                        do
                        {
                            if(candidate_replaceAccess_Variable_WithSource_edge_e.lgspType.TypeID!=12) {
                                continue;
                            }
                            // Implicit Source replaceAccess_Variable_WithSource_node_a from replaceAccess_Variable_WithSource_edge_e 
                            GRGEN_LGSP.LGSPNode candidate_replaceAccess_Variable_WithSource_node_a = candidate_replaceAccess_Variable_WithSource_edge_e.lgspSource;
                            if(candidate_replaceAccess_Variable_WithSource_node_a.lgspType.TypeID!=9) {
                                continue;
                            }
                            // Extend Outgoing replaceAccess_Variable_WithSource_edge__edge0 from replaceAccess_Variable_WithSource_node_call 
                            GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Variable_WithSource_edge__edge0 = candidate_replaceAccess_Variable_WithSource_node_call.lgspOuthead;
                            if(head_candidate_replaceAccess_Variable_WithSource_edge__edge0 != null)
                            {
                                GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Variable_WithSource_edge__edge0 = head_candidate_replaceAccess_Variable_WithSource_edge__edge0;
                                do
                                {
                                    if(candidate_replaceAccess_Variable_WithSource_edge__edge0.lgspType.TypeID!=13) {
                                        continue;
                                    }
                                    // Implicit Target replaceAccess_Variable_WithSource_node_b from replaceAccess_Variable_WithSource_edge__edge0 
                                    GRGEN_LGSP.LGSPNode candidate_replaceAccess_Variable_WithSource_node_b = candidate_replaceAccess_Variable_WithSource_edge__edge0.lgspTarget;
                                    if(candidate_replaceAccess_Variable_WithSource_node_b.lgspType.TypeID!=15) {
                                        continue;
                                    }
                                    Rule_replaceAccess_Variable_WithSource.Match_replaceAccess_Variable_WithSource match = matches.GetNextUnfilledPosition();
                                    match._node_a = candidate_replaceAccess_Variable_WithSource_node_a;
                                    match._node_call = candidate_replaceAccess_Variable_WithSource_node_call;
                                    match._node_movedOperation = candidate_replaceAccess_Variable_WithSource_node_movedOperation;
                                    match._node_b = candidate_replaceAccess_Variable_WithSource_node_b;
                                    match._node_v = candidate_replaceAccess_Variable_WithSource_node_v;
                                    match._node_srcparam = candidate_replaceAccess_Variable_WithSource_node_srcparam;
                                    match._edge_e = candidate_replaceAccess_Variable_WithSource_edge_e;
                                    match._edge_l = candidate_replaceAccess_Variable_WithSource_edge_l;
                                    match._edge__edge0 = candidate_replaceAccess_Variable_WithSource_edge__edge0;
                                    matches.PositionWasFilledFixIt();
                                    // if enough matches were found, we leave
                                    if(maxMatches > 0 && matches.Count >= maxMatches)
                                    {
                                        candidate_replaceAccess_Variable_WithSource_node_call.MoveOutHeadAfter(candidate_replaceAccess_Variable_WithSource_edge__edge0);
                                        candidate_replaceAccess_Variable_WithSource_node_call.MoveInHeadAfter(candidate_replaceAccess_Variable_WithSource_edge_e);
                                        candidate_replaceAccess_Variable_WithSource_node_movedOperation.MoveInHeadAfter(candidate_replaceAccess_Variable_WithSource_edge_l);
                                        return matches;
                                    }
                                }
                                while( (candidate_replaceAccess_Variable_WithSource_edge__edge0 = candidate_replaceAccess_Variable_WithSource_edge__edge0.lgspOutNext) != head_candidate_replaceAccess_Variable_WithSource_edge__edge0 );
                            }
                        }
                        while( (candidate_replaceAccess_Variable_WithSource_edge_e = candidate_replaceAccess_Variable_WithSource_edge_e.lgspInNext) != head_candidate_replaceAccess_Variable_WithSource_edge_e );
                    }
                }
                while( (candidate_replaceAccess_Variable_WithSource_edge_l = candidate_replaceAccess_Variable_WithSource_edge_l.lgspInNext) != head_candidate_replaceAccess_Variable_WithSource_edge_l );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, replaceAccess_Variable_WithSource_node_movedOperation, replaceAccess_Variable_WithSource_node_v, replaceAccess_Variable_WithSource_node_srcparam);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> matches)
        {
            foreach(Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Variable_WithSource_node_movedOperation, replaceAccess_Variable_WithSource_node_v, replaceAccess_Variable_WithSource_node_srcparam);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, replaceAccess_Variable_WithSource_node_movedOperation, replaceAccess_Variable_WithSource_node_v, replaceAccess_Variable_WithSource_node_srcparam);
            if(matches.Count <= 0) return false;
            foreach(Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Variable_WithSource_node_movedOperation, replaceAccess_Variable_WithSource_node_v, replaceAccess_Variable_WithSource_node_srcparam);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Variable_WithSource_node_movedOperation, replaceAccess_Variable_WithSource_node_v, replaceAccess_Variable_WithSource_node_srcparam);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Variable_WithSource_node_movedOperation, replaceAccess_Variable_WithSource_node_v, replaceAccess_Variable_WithSource_node_srcparam);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation replaceAccess_Variable_WithSource_node_movedOperation, GRGEN_MODEL.IVariable replaceAccess_Variable_WithSource_node_v, GRGEN_MODEL.IParameter replaceAccess_Variable_WithSource_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Variable_WithSource_node_movedOperation, replaceAccess_Variable_WithSource_node_v, replaceAccess_Variable_WithSource_node_srcparam);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IParameter) parameters[2]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Variable_WithSource.IMatch_replaceAccess_Variable_WithSource>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IParameter) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IParameter) parameters[2])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IParameter) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IParameter) parameters[2]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IVariable) parameters[1], (GRGEN_MODEL.IParameter) parameters[2]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_addSourceToCall
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_addSourceToCall.IMatch_addSourceToCall match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam);
    }
    
    public class Action_addSourceToCall : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_addSourceToCall
    {
        public Action_addSourceToCall() {
            _rulePattern = Rule_addSourceToCall.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_addSourceToCall.Match_addSourceToCall, Rule_addSourceToCall.IMatch_addSourceToCall>(this);
        }

        public Rule_addSourceToCall _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "addSourceToCall"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_addSourceToCall.Match_addSourceToCall, Rule_addSourceToCall.IMatch_addSourceToCall> matches;

        public static Action_addSourceToCall Instance { get { return instance; } }
        private static Action_addSourceToCall instance = new Action_addSourceToCall();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset addSourceToCall_node_call 
            GRGEN_LGSP.LGSPNode candidate_addSourceToCall_node_call = (GRGEN_LGSP.LGSPNode)addSourceToCall_node_call;
            if(candidate_addSourceToCall_node_call.lgspType.TypeID!=11) {
                return matches;
            }
            // Preset addSourceToCall_node_srcparam 
            GRGEN_LGSP.LGSPNode candidate_addSourceToCall_node_srcparam = (GRGEN_LGSP.LGSPNode)addSourceToCall_node_srcparam;
            if(candidate_addSourceToCall_node_srcparam.lgspType.TypeID!=17) {
                return matches;
            }
            Rule_addSourceToCall.Match_addSourceToCall match = matches.GetNextUnfilledPosition();
            match._node_call = candidate_addSourceToCall_node_call;
            match._node_srcparam = candidate_addSourceToCall_node_srcparam;
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, addSourceToCall_node_call, addSourceToCall_node_srcparam);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_addSourceToCall.IMatch_addSourceToCall match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall> matches)
        {
            foreach(Rule_addSourceToCall.IMatch_addSourceToCall match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addSourceToCall_node_call, addSourceToCall_node_srcparam);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, addSourceToCall_node_call, addSourceToCall_node_srcparam);
            if(matches.Count <= 0) return false;
            foreach(Rule_addSourceToCall.IMatch_addSourceToCall match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addSourceToCall_node_call, addSourceToCall_node_srcparam);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addSourceToCall_node_call, addSourceToCall_node_srcparam);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addSourceToCall_node_call, addSourceToCall_node_srcparam);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.ICall addSourceToCall_node_call, GRGEN_MODEL.IParameter addSourceToCall_node_srcparam)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, addSourceToCall_node_call, addSourceToCall_node_srcparam);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IParameter) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_addSourceToCall.IMatch_addSourceToCall)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_addSourceToCall.IMatch_addSourceToCall>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IParameter) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IParameter) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IParameter) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IParameter) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IParameter) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_getUnprocessedCallWithActualParameter
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter match, out GRGEN_MODEL.ICall output_0, out GRGEN_MODEL.IExpression output_1);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> matches, out GRGEN_MODEL.ICall output_0, out GRGEN_MODEL.IExpression output_1);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p, ref GRGEN_MODEL.ICall output_0, ref GRGEN_MODEL.IExpression output_1);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p, ref GRGEN_MODEL.ICall output_0, ref GRGEN_MODEL.IExpression output_1);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p);
    }
    
    public class Action_getUnprocessedCallWithActualParameter : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_getUnprocessedCallWithActualParameter
    {
        public Action_getUnprocessedCallWithActualParameter() {
            _rulePattern = Rule_getUnprocessedCallWithActualParameter.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[2];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_getUnprocessedCallWithActualParameter.Match_getUnprocessedCallWithActualParameter, Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter>(this);
        }

        public Rule_getUnprocessedCallWithActualParameter _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "getUnprocessedCallWithActualParameter"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_getUnprocessedCallWithActualParameter.Match_getUnprocessedCallWithActualParameter, Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> matches;

        public static Action_getUnprocessedCallWithActualParameter Instance { get { return instance; } }
        private static Action_getUnprocessedCallWithActualParameter instance = new Action_getUnprocessedCallWithActualParameter();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset getUnprocessedCallWithActualParameter_node_movedOperation 
            GRGEN_LGSP.LGSPNode candidate_getUnprocessedCallWithActualParameter_node_movedOperation = (GRGEN_LGSP.LGSPNode)getUnprocessedCallWithActualParameter_node_movedOperation;
            if(candidate_getUnprocessedCallWithActualParameter_node_movedOperation.lgspType.TypeID!=6) {
                return matches;
            }
            // Preset getUnprocessedCallWithActualParameter_node_p 
            GRGEN_LGSP.LGSPNode candidate_getUnprocessedCallWithActualParameter_node_p = (GRGEN_LGSP.LGSPNode)getUnprocessedCallWithActualParameter_node_p;
            if(candidate_getUnprocessedCallWithActualParameter_node_p.lgspType.TypeID!=17) {
                return matches;
            }
            // Extend Incoming getUnprocessedCallWithActualParameter_edge__edge0 from getUnprocessedCallWithActualParameter_node_movedOperation 
            GRGEN_LGSP.LGSPEdge head_candidate_getUnprocessedCallWithActualParameter_edge__edge0 = candidate_getUnprocessedCallWithActualParameter_node_movedOperation.lgspInhead;
            if(head_candidate_getUnprocessedCallWithActualParameter_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_getUnprocessedCallWithActualParameter_edge__edge0 = head_candidate_getUnprocessedCallWithActualParameter_edge__edge0;
                do
                {
                    if(candidate_getUnprocessedCallWithActualParameter_edge__edge0.lgspType.TypeID!=11) {
                        continue;
                    }
                    // Implicit Source getUnprocessedCallWithActualParameter_node_c from getUnprocessedCallWithActualParameter_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_getUnprocessedCallWithActualParameter_node_c = candidate_getUnprocessedCallWithActualParameter_edge__edge0.lgspSource;
                    if(candidate_getUnprocessedCallWithActualParameter_node_c.lgspType.TypeID!=11) {
                        continue;
                    }
                    uint prev__candidate_getUnprocessedCallWithActualParameter_node_c;
                    prev__candidate_getUnprocessedCallWithActualParameter_node_c = candidate_getUnprocessedCallWithActualParameter_node_c.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    candidate_getUnprocessedCallWithActualParameter_node_c.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    // Extend Outgoing getUnprocessedCallWithActualParameter_edge__edge1 from getUnprocessedCallWithActualParameter_node_movedOperation 
                    GRGEN_LGSP.LGSPEdge head_candidate_getUnprocessedCallWithActualParameter_edge__edge1 = candidate_getUnprocessedCallWithActualParameter_node_movedOperation.lgspOuthead;
                    if(head_candidate_getUnprocessedCallWithActualParameter_edge__edge1 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_getUnprocessedCallWithActualParameter_edge__edge1 = head_candidate_getUnprocessedCallWithActualParameter_edge__edge1;
                        do
                        {
                            if(candidate_getUnprocessedCallWithActualParameter_edge__edge1.lgspType.TypeID!=8) {
                                continue;
                            }
                            if(candidate_getUnprocessedCallWithActualParameter_edge__edge1.lgspTarget != candidate_getUnprocessedCallWithActualParameter_node_p) {
                                continue;
                            }
                            // Extend Incoming getUnprocessedCallWithActualParameter_edge_e from getUnprocessedCallWithActualParameter_node_c 
                            GRGEN_LGSP.LGSPEdge head_candidate_getUnprocessedCallWithActualParameter_edge_e = candidate_getUnprocessedCallWithActualParameter_node_c.lgspInhead;
                            if(head_candidate_getUnprocessedCallWithActualParameter_edge_e != null)
                            {
                                GRGEN_LGSP.LGSPEdge candidate_getUnprocessedCallWithActualParameter_edge_e = head_candidate_getUnprocessedCallWithActualParameter_edge_e;
                                do
                                {
                                    if(candidate_getUnprocessedCallWithActualParameter_edge_e.lgspType.TypeID!=12) {
                                        continue;
                                    }
                                    // Implicit Source getUnprocessedCallWithActualParameter_node_a from getUnprocessedCallWithActualParameter_edge_e 
                                    GRGEN_LGSP.LGSPNode candidate_getUnprocessedCallWithActualParameter_node_a = candidate_getUnprocessedCallWithActualParameter_edge_e.lgspSource;
                                    if(candidate_getUnprocessedCallWithActualParameter_node_a.lgspType.TypeID!=9) {
                                        continue;
                                    }
                                    uint prev__candidate_getUnprocessedCallWithActualParameter_node_a;
                                    prev__candidate_getUnprocessedCallWithActualParameter_node_a = candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                                    candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                                    // Extend Outgoing getUnprocessedCallWithActualParameter_edge__edge2 from getUnprocessedCallWithActualParameter_node_c 
                                    GRGEN_LGSP.LGSPEdge head_candidate_getUnprocessedCallWithActualParameter_edge__edge2 = candidate_getUnprocessedCallWithActualParameter_node_c.lgspOuthead;
                                    if(head_candidate_getUnprocessedCallWithActualParameter_edge__edge2 != null)
                                    {
                                        GRGEN_LGSP.LGSPEdge candidate_getUnprocessedCallWithActualParameter_edge__edge2 = head_candidate_getUnprocessedCallWithActualParameter_edge__edge2;
                                        do
                                        {
                                            if(candidate_getUnprocessedCallWithActualParameter_edge__edge2.lgspType.TypeID!=9) {
                                                continue;
                                            }
                                            // Implicit Target getUnprocessedCallWithActualParameter_node_pe from getUnprocessedCallWithActualParameter_edge__edge2 
                                            GRGEN_LGSP.LGSPNode candidate_getUnprocessedCallWithActualParameter_node_pe = candidate_getUnprocessedCallWithActualParameter_edge__edge2.lgspTarget;
                                            if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_getUnprocessedCallWithActualParameter_node_pe.lgspType.TypeID]) {
                                                continue;
                                            }
                                            if((candidate_getUnprocessedCallWithActualParameter_node_pe.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                                            {
                                                continue;
                                            }
                                            // NegativePattern 
                                            {
                                                ++negLevel;
                                                uint prev_neg_0__candidate_getUnprocessedCallWithActualParameter_node_a;
                                                prev_neg_0__candidate_getUnprocessedCallWithActualParameter_node_a = candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                                                candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                                                if((candidate_getUnprocessedCallWithActualParameter_node_pe.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                                                {
                                                    candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags = candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_neg_0__candidate_getUnprocessedCallWithActualParameter_node_a;
                                                    --negLevel;
                                                    goto label20;
                                                }
                                                // Extend Outgoing getUnprocessedCallWithActualParameter_neg_0_edge__edge0 from getUnprocessedCallWithActualParameter_node_a 
                                                GRGEN_LGSP.LGSPEdge head_candidate_getUnprocessedCallWithActualParameter_neg_0_edge__edge0 = candidate_getUnprocessedCallWithActualParameter_node_a.lgspOuthead;
                                                if(head_candidate_getUnprocessedCallWithActualParameter_neg_0_edge__edge0 != null)
                                                {
                                                    GRGEN_LGSP.LGSPEdge candidate_getUnprocessedCallWithActualParameter_neg_0_edge__edge0 = head_candidate_getUnprocessedCallWithActualParameter_neg_0_edge__edge0;
                                                    do
                                                    {
                                                        if(candidate_getUnprocessedCallWithActualParameter_neg_0_edge__edge0.lgspType.TypeID!=11) {
                                                            continue;
                                                        }
                                                        if(candidate_getUnprocessedCallWithActualParameter_neg_0_edge__edge0.lgspTarget != candidate_getUnprocessedCallWithActualParameter_node_pe) {
                                                            continue;
                                                        }
                                                        // negative pattern found
                                                        candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags = candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_neg_0__candidate_getUnprocessedCallWithActualParameter_node_a;
                                                        --negLevel;
                                                        goto label21;
                                                    }
                                                    while( (candidate_getUnprocessedCallWithActualParameter_neg_0_edge__edge0 = candidate_getUnprocessedCallWithActualParameter_neg_0_edge__edge0.lgspOutNext) != head_candidate_getUnprocessedCallWithActualParameter_neg_0_edge__edge0 );
                                                }
                                                candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags = candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_neg_0__candidate_getUnprocessedCallWithActualParameter_node_a;
                                                --negLevel;
                                            }
label20: ;
                                            Rule_getUnprocessedCallWithActualParameter.Match_getUnprocessedCallWithActualParameter match = matches.GetNextUnfilledPosition();
                                            match._node_a = candidate_getUnprocessedCallWithActualParameter_node_a;
                                            match._node_c = candidate_getUnprocessedCallWithActualParameter_node_c;
                                            match._node_movedOperation = candidate_getUnprocessedCallWithActualParameter_node_movedOperation;
                                            match._node_p = candidate_getUnprocessedCallWithActualParameter_node_p;
                                            match._node_pe = candidate_getUnprocessedCallWithActualParameter_node_pe;
                                            match._edge_e = candidate_getUnprocessedCallWithActualParameter_edge_e;
                                            match._edge__edge0 = candidate_getUnprocessedCallWithActualParameter_edge__edge0;
                                            match._edge__edge1 = candidate_getUnprocessedCallWithActualParameter_edge__edge1;
                                            match._edge__edge2 = candidate_getUnprocessedCallWithActualParameter_edge__edge2;
                                            matches.PositionWasFilledFixIt();
                                            // if enough matches were found, we leave
                                            if(maxMatches > 0 && matches.Count >= maxMatches)
                                            {
                                                candidate_getUnprocessedCallWithActualParameter_node_c.MoveOutHeadAfter(candidate_getUnprocessedCallWithActualParameter_edge__edge2);
                                                candidate_getUnprocessedCallWithActualParameter_node_c.MoveInHeadAfter(candidate_getUnprocessedCallWithActualParameter_edge_e);
                                                candidate_getUnprocessedCallWithActualParameter_node_movedOperation.MoveOutHeadAfter(candidate_getUnprocessedCallWithActualParameter_edge__edge1);
                                                candidate_getUnprocessedCallWithActualParameter_node_movedOperation.MoveInHeadAfter(candidate_getUnprocessedCallWithActualParameter_edge__edge0);
                                                candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags = candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_getUnprocessedCallWithActualParameter_node_a;
                                                candidate_getUnprocessedCallWithActualParameter_node_c.lgspFlags = candidate_getUnprocessedCallWithActualParameter_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_getUnprocessedCallWithActualParameter_node_c;
                                                return matches;
                                            }
label21: ;
                                        }
                                        while( (candidate_getUnprocessedCallWithActualParameter_edge__edge2 = candidate_getUnprocessedCallWithActualParameter_edge__edge2.lgspOutNext) != head_candidate_getUnprocessedCallWithActualParameter_edge__edge2 );
                                    }
                                    candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags = candidate_getUnprocessedCallWithActualParameter_node_a.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_getUnprocessedCallWithActualParameter_node_a;
                                }
                                while( (candidate_getUnprocessedCallWithActualParameter_edge_e = candidate_getUnprocessedCallWithActualParameter_edge_e.lgspInNext) != head_candidate_getUnprocessedCallWithActualParameter_edge_e );
                            }
                        }
                        while( (candidate_getUnprocessedCallWithActualParameter_edge__edge1 = candidate_getUnprocessedCallWithActualParameter_edge__edge1.lgspOutNext) != head_candidate_getUnprocessedCallWithActualParameter_edge__edge1 );
                    }
                    candidate_getUnprocessedCallWithActualParameter_node_c.lgspFlags = candidate_getUnprocessedCallWithActualParameter_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_getUnprocessedCallWithActualParameter_node_c;
                }
                while( (candidate_getUnprocessedCallWithActualParameter_edge__edge0 = candidate_getUnprocessedCallWithActualParameter_edge__edge0.lgspInNext) != head_candidate_getUnprocessedCallWithActualParameter_edge__edge0 );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, getUnprocessedCallWithActualParameter_node_movedOperation, getUnprocessedCallWithActualParameter_node_p);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter match, out GRGEN_MODEL.ICall output_0, out GRGEN_MODEL.IExpression output_1)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0, out output_1);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> matches, out GRGEN_MODEL.ICall output_0, out GRGEN_MODEL.IExpression output_1)
        {
            output_0 = null;
            output_1 = null;
            foreach(Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0, out output_1);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p, ref GRGEN_MODEL.ICall output_0, ref GRGEN_MODEL.IExpression output_1)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getUnprocessedCallWithActualParameter_node_movedOperation, getUnprocessedCallWithActualParameter_node_p);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p, ref GRGEN_MODEL.ICall output_0, ref GRGEN_MODEL.IExpression output_1)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, getUnprocessedCallWithActualParameter_node_movedOperation, getUnprocessedCallWithActualParameter_node_p);
            if(matches.Count <= 0) return false;
            foreach(Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match, out output_0, out output_1);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> matches;
            GRGEN_MODEL.ICall output_0; GRGEN_MODEL.IExpression output_1; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getUnprocessedCallWithActualParameter_node_movedOperation, getUnprocessedCallWithActualParameter_node_p);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getUnprocessedCallWithActualParameter_node_movedOperation, getUnprocessedCallWithActualParameter_node_p);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.ICall output_0; GRGEN_MODEL.IExpression output_1; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getUnprocessedCallWithActualParameter_node_movedOperation, getUnprocessedCallWithActualParameter_node_p);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.IOperation getUnprocessedCallWithActualParameter_node_movedOperation, GRGEN_MODEL.IParameter getUnprocessedCallWithActualParameter_node_p)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter> matches;
            GRGEN_MODEL.ICall output_0; GRGEN_MODEL.IExpression output_1; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, getUnprocessedCallWithActualParameter_node_movedOperation, getUnprocessedCallWithActualParameter_node_p);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First, out output_0, out output_1);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IParameter) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.ICall output_0; GRGEN_MODEL.IExpression output_1; 
            Modify(graph, (Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter)match, out output_0, out output_1);
            ReturnArray[0] = output_0;
            ReturnArray[1] = output_1;
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            GRGEN_MODEL.ICall output_0; GRGEN_MODEL.IExpression output_1; 
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_getUnprocessedCallWithActualParameter.IMatch_getUnprocessedCallWithActualParameter>)matches, out output_0, out output_1);
            ReturnArray[0] = output_0;
            ReturnArray[1] = output_1;
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.ICall output_0 = null; GRGEN_MODEL.IExpression output_1 = null; 
            if(Apply(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IParameter) parameters[1], ref output_0, ref output_1)) {
                ReturnArray[0] = output_0;
                ReturnArray[1] = output_1;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            GRGEN_MODEL.ICall output_0 = null; GRGEN_MODEL.IExpression output_1 = null; 
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IParameter) parameters[1], ref output_0, ref output_1)) {
                ReturnArray[0] = output_0;
                ReturnArray[1] = output_1;
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IParameter) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IParameter) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.IOperation) parameters[0], (GRGEN_MODEL.IParameter) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_replaceAccess_Parameter_AccessWithoutLink
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe);
    }
    
    public class Action_replaceAccess_Parameter_AccessWithoutLink : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_replaceAccess_Parameter_AccessWithoutLink
    {
        public Action_replaceAccess_Parameter_AccessWithoutLink() {
            _rulePattern = Rule_replaceAccess_Parameter_AccessWithoutLink.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_replaceAccess_Parameter_AccessWithoutLink.Match_replaceAccess_Parameter_AccessWithoutLink, Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink>(this);
        }

        public Rule_replaceAccess_Parameter_AccessWithoutLink _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "replaceAccess_Parameter_AccessWithoutLink"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_replaceAccess_Parameter_AccessWithoutLink.Match_replaceAccess_Parameter_AccessWithoutLink, Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> matches;

        public static Action_replaceAccess_Parameter_AccessWithoutLink Instance { get { return instance; } }
        private static Action_replaceAccess_Parameter_AccessWithoutLink instance = new Action_replaceAccess_Parameter_AccessWithoutLink();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset replaceAccess_Parameter_AccessWithoutLink_node_c 
            GRGEN_LGSP.LGSPNode candidate_replaceAccess_Parameter_AccessWithoutLink_node_c = (GRGEN_LGSP.LGSPNode)replaceAccess_Parameter_AccessWithoutLink_node_c;
            if(candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspType.TypeID!=11) {
                return matches;
            }
            uint prev__candidate_replaceAccess_Parameter_AccessWithoutLink_node_c;
            prev__candidate_replaceAccess_Parameter_AccessWithoutLink_node_c = candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Preset replaceAccess_Parameter_AccessWithoutLink_node_pe 
            GRGEN_LGSP.LGSPNode candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe = (GRGEN_LGSP.LGSPNode)replaceAccess_Parameter_AccessWithoutLink_node_pe;
            if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe.lgspType.TypeID]) {
                candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspFlags = candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithoutLink_node_c;
                return matches;
            }
            if((candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
            {
                candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspFlags = candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithoutLink_node_c;
                return matches;
            }
            uint prev__candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe;
            prev__candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe = candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Extend Incoming replaceAccess_Parameter_AccessWithoutLink_edge_e from replaceAccess_Parameter_AccessWithoutLink_node_c 
            GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Parameter_AccessWithoutLink_edge_e = candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspInhead;
            if(head_candidate_replaceAccess_Parameter_AccessWithoutLink_edge_e != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Parameter_AccessWithoutLink_edge_e = head_candidate_replaceAccess_Parameter_AccessWithoutLink_edge_e;
                do
                {
                    if(candidate_replaceAccess_Parameter_AccessWithoutLink_edge_e.lgspType.TypeID!=12) {
                        continue;
                    }
                    // Implicit Source replaceAccess_Parameter_AccessWithoutLink_node_a from replaceAccess_Parameter_AccessWithoutLink_edge_e 
                    GRGEN_LGSP.LGSPNode candidate_replaceAccess_Parameter_AccessWithoutLink_node_a = candidate_replaceAccess_Parameter_AccessWithoutLink_edge_e.lgspSource;
                    if(candidate_replaceAccess_Parameter_AccessWithoutLink_node_a.lgspType.TypeID!=9) {
                        continue;
                    }
                    if((candidate_replaceAccess_Parameter_AccessWithoutLink_node_a.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                    {
                        continue;
                    }
                    // NegativePattern 
                    {
                        ++negLevel;
                        uint prev_neg_0__candidate_replaceAccess_Parameter_AccessWithoutLink_node_a;
                        prev_neg_0__candidate_replaceAccess_Parameter_AccessWithoutLink_node_a = candidate_replaceAccess_Parameter_AccessWithoutLink_node_a.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                        candidate_replaceAccess_Parameter_AccessWithoutLink_node_a.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                        // Extend Outgoing replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0 from replaceAccess_Parameter_AccessWithoutLink_node_a 
                        GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0 = candidate_replaceAccess_Parameter_AccessWithoutLink_node_a.lgspOuthead;
                        if(head_candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0 != null)
                        {
                            GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0 = head_candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0;
                            do
                            {
                                if(candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0.lgspType.TypeID!=11) {
                                    continue;
                                }
                                // Implicit Target replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0 from replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0 
                                GRGEN_LGSP.LGSPNode candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0 = candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0.lgspTarget;
                                if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0.lgspType.TypeID]) {
                                    continue;
                                }
                                if((candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_node__node0.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                                {
                                    continue;
                                }
                                // negative pattern found
                                candidate_replaceAccess_Parameter_AccessWithoutLink_node_a.lgspFlags = candidate_replaceAccess_Parameter_AccessWithoutLink_node_a.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_neg_0__candidate_replaceAccess_Parameter_AccessWithoutLink_node_a;
                                --negLevel;
                                goto label22;
                            }
                            while( (candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0 = candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0.lgspOutNext) != head_candidate_replaceAccess_Parameter_AccessWithoutLink_neg_0_edge__edge0 );
                        }
                        candidate_replaceAccess_Parameter_AccessWithoutLink_node_a.lgspFlags = candidate_replaceAccess_Parameter_AccessWithoutLink_node_a.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev_neg_0__candidate_replaceAccess_Parameter_AccessWithoutLink_node_a;
                        --negLevel;
                    }
                    // Extend Outgoing replaceAccess_Parameter_AccessWithoutLink_edge__edge0 from replaceAccess_Parameter_AccessWithoutLink_node_c 
                    GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Parameter_AccessWithoutLink_edge__edge0 = candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspOuthead;
                    if(head_candidate_replaceAccess_Parameter_AccessWithoutLink_edge__edge0 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Parameter_AccessWithoutLink_edge__edge0 = head_candidate_replaceAccess_Parameter_AccessWithoutLink_edge__edge0;
                        do
                        {
                            if(candidate_replaceAccess_Parameter_AccessWithoutLink_edge__edge0.lgspType.TypeID!=9) {
                                continue;
                            }
                            if(candidate_replaceAccess_Parameter_AccessWithoutLink_edge__edge0.lgspTarget != candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe) {
                                continue;
                            }
                            Rule_replaceAccess_Parameter_AccessWithoutLink.Match_replaceAccess_Parameter_AccessWithoutLink match = matches.GetNextUnfilledPosition();
                            match._node_a = candidate_replaceAccess_Parameter_AccessWithoutLink_node_a;
                            match._node_c = candidate_replaceAccess_Parameter_AccessWithoutLink_node_c;
                            match._node_pe = candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe;
                            match._edge_e = candidate_replaceAccess_Parameter_AccessWithoutLink_edge_e;
                            match._edge__edge0 = candidate_replaceAccess_Parameter_AccessWithoutLink_edge__edge0;
                            matches.PositionWasFilledFixIt();
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && matches.Count >= maxMatches)
                            {
                                candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.MoveOutHeadAfter(candidate_replaceAccess_Parameter_AccessWithoutLink_edge__edge0);
                                candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.MoveInHeadAfter(candidate_replaceAccess_Parameter_AccessWithoutLink_edge_e);
                                candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe.lgspFlags = candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe;
                                candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspFlags = candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithoutLink_node_c;
                                return matches;
                            }
                        }
                        while( (candidate_replaceAccess_Parameter_AccessWithoutLink_edge__edge0 = candidate_replaceAccess_Parameter_AccessWithoutLink_edge__edge0.lgspOutNext) != head_candidate_replaceAccess_Parameter_AccessWithoutLink_edge__edge0 );
                    }
label22: ;
                }
                while( (candidate_replaceAccess_Parameter_AccessWithoutLink_edge_e = candidate_replaceAccess_Parameter_AccessWithoutLink_edge_e.lgspInNext) != head_candidate_replaceAccess_Parameter_AccessWithoutLink_edge_e );
            }
            candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe.lgspFlags = candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithoutLink_node_pe;
            candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspFlags = candidate_replaceAccess_Parameter_AccessWithoutLink_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithoutLink_node_c;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, replaceAccess_Parameter_AccessWithoutLink_node_c, replaceAccess_Parameter_AccessWithoutLink_node_pe);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> matches)
        {
            foreach(Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Parameter_AccessWithoutLink_node_c, replaceAccess_Parameter_AccessWithoutLink_node_pe);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, replaceAccess_Parameter_AccessWithoutLink_node_c, replaceAccess_Parameter_AccessWithoutLink_node_pe);
            if(matches.Count <= 0) return false;
            foreach(Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Parameter_AccessWithoutLink_node_c, replaceAccess_Parameter_AccessWithoutLink_node_pe);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Parameter_AccessWithoutLink_node_c, replaceAccess_Parameter_AccessWithoutLink_node_pe);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Parameter_AccessWithoutLink_node_c, replaceAccess_Parameter_AccessWithoutLink_node_pe);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithoutLink_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithoutLink_node_pe)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Parameter_AccessWithoutLink_node_c, replaceAccess_Parameter_AccessWithoutLink_node_pe);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithoutLink.IMatch_replaceAccess_Parameter_AccessWithoutLink>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1]);
        }
    }

    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_replaceAccess_Parameter_AccessWithLinkToExpression
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IGraph graph, Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns true if applied at least once. </summary>
        bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
    }
    
    public class Action_replaceAccess_Parameter_AccessWithLinkToExpression : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_replaceAccess_Parameter_AccessWithLinkToExpression
    {
        public Action_replaceAccess_Parameter_AccessWithLinkToExpression() {
            _rulePattern = Rule_replaceAccess_Parameter_AccessWithLinkToExpression.Instance;
            patternGraph = _rulePattern.patternGraph;
            DynamicMatch = myMatch;
            ReturnArray = new object[0];
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.Match_replaceAccess_Parameter_AccessWithLinkToExpression, Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression>(this);
        }

        public Rule_replaceAccess_Parameter_AccessWithLinkToExpression _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "replaceAccess_Parameter_AccessWithLinkToExpression"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.Match_replaceAccess_Parameter_AccessWithLinkToExpression, Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> matches;

        public static Action_replaceAccess_Parameter_AccessWithLinkToExpression Instance { get { return instance; } }
        private static Action_replaceAccess_Parameter_AccessWithLinkToExpression instance = new Action_replaceAccess_Parameter_AccessWithLinkToExpression();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> myMatch(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe)
        {
            matches.Clear();
            int negLevel = 0;
            // Preset replaceAccess_Parameter_AccessWithLinkToExpression_node_c 
            GRGEN_LGSP.LGSPNode candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c = (GRGEN_LGSP.LGSPNode)replaceAccess_Parameter_AccessWithLinkToExpression_node_c;
            if(candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspType.TypeID!=11) {
                return matches;
            }
            uint prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c;
            prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Preset replaceAccess_Parameter_AccessWithLinkToExpression_node_pe 
            GRGEN_LGSP.LGSPNode candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe = (GRGEN_LGSP.LGSPNode)replaceAccess_Parameter_AccessWithLinkToExpression_node_pe;
            if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe.lgspType.TypeID]) {
                candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspFlags = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c;
                return matches;
            }
            if((candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
            {
                candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspFlags = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c;
                return matches;
            }
            uint prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe;
            prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
            // Extend Incoming replaceAccess_Parameter_AccessWithLinkToExpression_edge_e from replaceAccess_Parameter_AccessWithLinkToExpression_node_c 
            GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_e = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspInhead;
            if(head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_e != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_e = head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_e;
                do
                {
                    if(candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_e.lgspType.TypeID!=12) {
                        continue;
                    }
                    // Implicit Source replaceAccess_Parameter_AccessWithLinkToExpression_node_a from replaceAccess_Parameter_AccessWithLinkToExpression_edge_e 
                    GRGEN_LGSP.LGSPNode candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_e.lgspSource;
                    if(candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a.lgspType.TypeID!=9) {
                        continue;
                    }
                    if((candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                    {
                        continue;
                    }
                    uint prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a;
                    prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a.lgspFlags |= (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel;
                    // Extend Outgoing replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0 from replaceAccess_Parameter_AccessWithLinkToExpression_node_c 
                    GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0 = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspOuthead;
                    if(head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0 = head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0;
                        do
                        {
                            if(candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0.lgspType.TypeID!=9) {
                                continue;
                            }
                            if(candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0.lgspTarget != candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe) {
                                continue;
                            }
                            // Extend Outgoing replaceAccess_Parameter_AccessWithLinkToExpression_edge_old from replaceAccess_Parameter_AccessWithLinkToExpression_node_a 
                            GRGEN_LGSP.LGSPEdge head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_old = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a.lgspOuthead;
                            if(head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_old != null)
                            {
                                GRGEN_LGSP.LGSPEdge candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_old = head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_old;
                                do
                                {
                                    if(candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_old.lgspType.TypeID!=11) {
                                        continue;
                                    }
                                    // Implicit Target replaceAccess_Parameter_AccessWithLinkToExpression_node_le from replaceAccess_Parameter_AccessWithLinkToExpression_edge_old 
                                    GRGEN_LGSP.LGSPNode candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_le = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_old.lgspTarget;
                                    if(!GRGEN_MODEL.NodeType_Expression.isMyType[candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_le.lgspType.TypeID]) {
                                        continue;
                                    }
                                    if((candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_le.lgspFlags & (uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) != 0)
                                    {
                                        continue;
                                    }
                                    Rule_replaceAccess_Parameter_AccessWithLinkToExpression.Match_replaceAccess_Parameter_AccessWithLinkToExpression match = matches.GetNextUnfilledPosition();
                                    match._node_a = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a;
                                    match._node_c = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c;
                                    match._node_pe = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe;
                                    match._node_le = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_le;
                                    match._edge_e = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_e;
                                    match._edge__edge0 = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0;
                                    match._edge_old = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_old;
                                    matches.PositionWasFilledFixIt();
                                    // if enough matches were found, we leave
                                    if(maxMatches > 0 && matches.Count >= maxMatches)
                                    {
                                        candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a.MoveOutHeadAfter(candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_old);
                                        candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.MoveOutHeadAfter(candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0);
                                        candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.MoveInHeadAfter(candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_e);
                                        candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a.lgspFlags = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a;
                                        candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe.lgspFlags = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe;
                                        candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspFlags = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c;
                                        return matches;
                                    }
                                }
                                while( (candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_old = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_old.lgspOutNext) != head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_old );
                            }
                        }
                        while( (candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0 = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0.lgspOutNext) != head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge__edge0 );
                    }
                    candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a.lgspFlags = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_a;
                }
                while( (candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_e = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_e.lgspInNext) != head_candidate_replaceAccess_Parameter_AccessWithLinkToExpression_edge_e );
            }
            candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe.lgspFlags = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_pe;
            candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspFlags = candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c.lgspFlags & ~((uint) GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << negLevel) | prev__candidate_replaceAccess_Parameter_AccessWithLinkToExpression_node_c;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> MatchInvoker(GRGEN_LGSP.LGSPGraph graph, int maxMatches, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> Match(GRGEN_LIBGR.IGraph graph, int maxMatches, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, replaceAccess_Parameter_AccessWithLinkToExpression_node_c, replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
        }
        public void Modify(GRGEN_LIBGR.IGraph graph, Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> matches)
        {
            foreach(Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
        }
        public bool Apply(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Parameter_AccessWithLinkToExpression_node_c, replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            return true;
        }
        public bool ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, maxMatches, replaceAccess_Parameter_AccessWithLinkToExpression_node_c, replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
            if(matches.Count <= 0) return false;
            foreach(Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression match in matches) _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, match);
            return true;
        }
        public bool ApplyStar(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Parameter_AccessWithLinkToExpression_node_c, replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IGraph graph, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Parameter_AccessWithLinkToExpression_node_c, replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Parameter_AccessWithLinkToExpression_node_c, replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, GRGEN_MODEL.ICall replaceAccess_Parameter_AccessWithLinkToExpression_node_c, GRGEN_MODEL.IExpression replaceAccess_Parameter_AccessWithLinkToExpression_node_pe)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPGraph)graph, 1, replaceAccess_Parameter_AccessWithLinkToExpression_node_c, replaceAccess_Parameter_AccessWithLinkToExpression_node_pe);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPGraph)graph, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IGraph graph, int maxMatches, object[] parameters)
        {
            return Match(graph, maxMatches, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1]);
        }
        public object[] Modify(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(graph, (Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression)match);
            return ReturnArray;
        }
        public object[] ModifyAll(GRGEN_LIBGR.IGraph graph, GRGEN_LIBGR.IMatches matches)
        {
            
            ModifyAll(graph, (GRGEN_LIBGR.IMatchesExact<Rule_replaceAccess_Parameter_AccessWithLinkToExpression.IMatch_replaceAccess_Parameter_AccessWithLinkToExpression>)matches);
            return ReturnArray;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(Apply(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            
            if(ApplyAll(maxMatches, graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1])) {
                return ReturnArray;
            }
            else return null;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyStar(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IGraph graph, params object[] parameters)
        {
            return ApplyPlus(graph, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IGraph graph, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(graph, min, max, (GRGEN_MODEL.ICall) parameters[0], (GRGEN_MODEL.IExpression) parameters[1]);
        }
    }


    // class which instantiates and stores all the compiled actions of the module,
    // dynamic regeneration and compilation causes the old action to be overwritten by the new one
    // matching/rule patterns are analyzed at creation time here, once, so that later regeneration runs have all the information available
    public class JavaProgramGraphsActions : GRGEN_LGSP.LGSPActions
    {
        public JavaProgramGraphsActions(GRGEN_LGSP.LGSPGraph lgspgraph, string modelAsmName, string actionsAsmName)
            : base(lgspgraph, modelAsmName, actionsAsmName)
        {
            InitActions();
        }

        public JavaProgramGraphsActions(GRGEN_LGSP.LGSPGraph lgspgraph)
            : base(lgspgraph)
        {
            InitActions();
        }

        private void InitActions()
        {
            GRGEN_LGSP.PatternGraphAnalyzer analyzer = new GRGEN_LGSP.PatternGraphAnalyzer();
            analyzer.AnalyzeNestingOfAndRemember(Pattern_MultipleContainedPackagesOrClasses.Instance);
            analyzer.AnalyzeNestingOfAndRemember(Pattern_MultipleVariables.Instance);
            analyzer.AnalyzeNestingOfAndRemember(Pattern_MultipleMethodBodies.Instance);
            analyzer.AnalyzeNestingOfAndRemember(Pattern_MethodBodyAndImplementation.Instance);
            analyzer.AnalyzeNestingOfAndRemember(Pattern_MultipleParameters.Instance);
            analyzer.AnalyzeNestingOfAndRemember(Pattern_MultipleExpressions.Instance);
            analyzer.AnalyzeNestingOfAndRemember(Pattern_ExpressionChain.Instance);
            analyzer.AnalyzeNestingOfAndRemember(Pattern_MultipleActualParameters.Instance);
            analyzer.AnalyzeNestingOfAndRemember(Pattern_MultipleExtendingClasses.Instance);
            analyzer.AnalyzeNestingOfAndRemember(Pattern_InClass.Instance);
            analyzer.AnalyzeNestingOfAndRemember(Pattern_methodNameExistsSuper.Instance);
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpGxl.Instance);
            actions.Add("dumpGxl", (GRGEN_LGSP.LGSPAction) Action_dumpGxl.Instance);
            @dumpGxl = Action_dumpGxl.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodePackage.Instance);
            actions.Add("dumpNodePackage", (GRGEN_LGSP.LGSPAction) Action_dumpNodePackage.Instance);
            @dumpNodePackage = Action_dumpNodePackage.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeClass.Instance);
            actions.Add("dumpNodeClass", (GRGEN_LGSP.LGSPAction) Action_dumpNodeClass.Instance);
            @dumpNodeClass = Action_dumpNodeClass.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeInterface.Instance);
            actions.Add("dumpNodeInterface", (GRGEN_LGSP.LGSPAction) Action_dumpNodeInterface.Instance);
            @dumpNodeInterface = Action_dumpNodeInterface.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeVariable.Instance);
            actions.Add("dumpNodeVariable", (GRGEN_LGSP.LGSPAction) Action_dumpNodeVariable.Instance);
            @dumpNodeVariable = Action_dumpNodeVariable.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeOperation.Instance);
            actions.Add("dumpNodeOperation", (GRGEN_LGSP.LGSPAction) Action_dumpNodeOperation.Instance);
            @dumpNodeOperation = Action_dumpNodeOperation.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeMethodBody.Instance);
            actions.Add("dumpNodeMethodBody", (GRGEN_LGSP.LGSPAction) Action_dumpNodeMethodBody.Instance);
            @dumpNodeMethodBody = Action_dumpNodeMethodBody.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeAccess.Instance);
            actions.Add("dumpNodeAccess", (GRGEN_LGSP.LGSPAction) Action_dumpNodeAccess.Instance);
            @dumpNodeAccess = Action_dumpNodeAccess.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeUpdate.Instance);
            actions.Add("dumpNodeUpdate", (GRGEN_LGSP.LGSPAction) Action_dumpNodeUpdate.Instance);
            @dumpNodeUpdate = Action_dumpNodeUpdate.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeCall.Instance);
            actions.Add("dumpNodeCall", (GRGEN_LGSP.LGSPAction) Action_dumpNodeCall.Instance);
            @dumpNodeCall = Action_dumpNodeCall.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeIstantiation.Instance);
            actions.Add("dumpNodeIstantiation", (GRGEN_LGSP.LGSPAction) Action_dumpNodeIstantiation.Instance);
            @dumpNodeIstantiation = Action_dumpNodeIstantiation.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeOperator.Instance);
            actions.Add("dumpNodeOperator", (GRGEN_LGSP.LGSPAction) Action_dumpNodeOperator.Instance);
            @dumpNodeOperator = Action_dumpNodeOperator.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeReturn.Instance);
            actions.Add("dumpNodeReturn", (GRGEN_LGSP.LGSPAction) Action_dumpNodeReturn.Instance);
            @dumpNodeReturn = Action_dumpNodeReturn.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeBlock.Instance);
            actions.Add("dumpNodeBlock", (GRGEN_LGSP.LGSPAction) Action_dumpNodeBlock.Instance);
            @dumpNodeBlock = Action_dumpNodeBlock.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeLiteral.Instance);
            actions.Add("dumpNodeLiteral", (GRGEN_LGSP.LGSPAction) Action_dumpNodeLiteral.Instance);
            @dumpNodeLiteral = Action_dumpNodeLiteral.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpNodeParameter.Instance);
            actions.Add("dumpNodeParameter", (GRGEN_LGSP.LGSPAction) Action_dumpNodeParameter.Instance);
            @dumpNodeParameter = Action_dumpNodeParameter.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpEdgeBelongsTo.Instance);
            actions.Add("dumpEdgeBelongsTo", (GRGEN_LGSP.LGSPAction) Action_dumpEdgeBelongsTo.Instance);
            @dumpEdgeBelongsTo = Action_dumpEdgeBelongsTo.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpEdgeType.Instance);
            actions.Add("dumpEdgeType", (GRGEN_LGSP.LGSPAction) Action_dumpEdgeType.Instance);
            @dumpEdgeType = Action_dumpEdgeType.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpEdgeExtends.Instance);
            actions.Add("dumpEdgeExtends", (GRGEN_LGSP.LGSPAction) Action_dumpEdgeExtends.Instance);
            @dumpEdgeExtends = Action_dumpEdgeExtends.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpEdgeImports.Instance);
            actions.Add("dumpEdgeImports", (GRGEN_LGSP.LGSPAction) Action_dumpEdgeImports.Instance);
            @dumpEdgeImports = Action_dumpEdgeImports.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpEdgeImplements.Instance);
            actions.Add("dumpEdgeImplements", (GRGEN_LGSP.LGSPAction) Action_dumpEdgeImplements.Instance);
            @dumpEdgeImplements = Action_dumpEdgeImplements.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpEdgeParameter.Instance);
            actions.Add("dumpEdgeParameter", (GRGEN_LGSP.LGSPAction) Action_dumpEdgeParameter.Instance);
            @dumpEdgeParameter = Action_dumpEdgeParameter.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpEdgeBinding.Instance);
            actions.Add("dumpEdgeBinding", (GRGEN_LGSP.LGSPAction) Action_dumpEdgeBinding.Instance);
            @dumpEdgeBinding = Action_dumpEdgeBinding.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpEdgeLink.Instance);
            actions.Add("dumpEdgeLink", (GRGEN_LGSP.LGSPAction) Action_dumpEdgeLink.Instance);
            @dumpEdgeLink = Action_dumpEdgeLink.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpEdgeExpression.Instance);
            actions.Add("dumpEdgeExpression", (GRGEN_LGSP.LGSPAction) Action_dumpEdgeExpression.Instance);
            @dumpEdgeExpression = Action_dumpEdgeExpression.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_dumpEdgeActualParameter.Instance);
            actions.Add("dumpEdgeActualParameter", (GRGEN_LGSP.LGSPAction) Action_dumpEdgeActualParameter.Instance);
            @dumpEdgeActualParameter = Action_dumpEdgeActualParameter.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_emitSpanningTree.Instance);
            actions.Add("emitSpanningTree", (GRGEN_LGSP.LGSPAction) Action_emitSpanningTree.Instance);
            @emitSpanningTree = Action_emitSpanningTree.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_InsertHelperEdgesForNestedLayout.Instance);
            actions.Add("InsertHelperEdgesForNestedLayout", (GRGEN_LGSP.LGSPAction) Action_InsertHelperEdgesForNestedLayout.Instance);
            @InsertHelperEdgesForNestedLayout = Action_InsertHelperEdgesForNestedLayout.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_BindOperations.Instance);
            actions.Add("BindOperations", (GRGEN_LGSP.LGSPAction) Action_BindOperations.Instance);
            @BindOperations = Action_BindOperations.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_InitMoveIntoBlocks.Instance);
            actions.Add("InitMoveIntoBlocks", (GRGEN_LGSP.LGSPAction) Action_InitMoveIntoBlocks.Instance);
            @InitMoveIntoBlocks = Action_InitMoveIntoBlocks.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_MoveIntoBlocks.Instance);
            actions.Add("MoveIntoBlocks", (GRGEN_LGSP.LGSPAction) Action_MoveIntoBlocks.Instance);
            @MoveIntoBlocks = Action_MoveIntoBlocks.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_getClassAndVariable.Instance);
            actions.Add("getClassAndVariable", (GRGEN_LGSP.LGSPAction) Action_getClassAndVariable.Instance);
            @getClassAndVariable = Action_getClassAndVariable.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_variableInClass.Instance);
            actions.Add("variableInClass", (GRGEN_LGSP.LGSPAction) Action_variableInClass.Instance);
            @variableInClass = Action_variableInClass.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_methodExists.Instance);
            actions.Add("methodExists", (GRGEN_LGSP.LGSPAction) Action_methodExists.Instance);
            @methodExists = Action_methodExists.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_sameStaticness.Instance);
            actions.Add("sameStaticness", (GRGEN_LGSP.LGSPAction) Action_sameStaticness.Instance);
            @sameStaticness = Action_sameStaticness.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_insertMethodGetter.Instance);
            actions.Add("insertMethodGetter", (GRGEN_LGSP.LGSPAction) Action_insertMethodGetter.Instance);
            @insertMethodGetter = Action_insertMethodGetter.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_insertMethodSetter.Instance);
            actions.Add("insertMethodSetter", (GRGEN_LGSP.LGSPAction) Action_insertMethodSetter.Instance);
            @insertMethodSetter = Action_insertMethodSetter.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_changeVisibility.Instance);
            actions.Add("changeVisibility", (GRGEN_LGSP.LGSPAction) Action_changeVisibility.Instance);
            @changeVisibility = Action_changeVisibility.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_adaptAccess.Instance);
            actions.Add("adaptAccess", (GRGEN_LGSP.LGSPAction) Action_adaptAccess.Instance);
            @adaptAccess = Action_adaptAccess.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_adaptUpdate.Instance);
            actions.Add("adaptUpdate", (GRGEN_LGSP.LGSPAction) Action_adaptUpdate.Instance);
            @adaptUpdate = Action_adaptUpdate.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_adaptAccessUseAccessorsAlways.Instance);
            actions.Add("adaptAccessUseAccessorsAlways", (GRGEN_LGSP.LGSPAction) Action_adaptAccessUseAccessorsAlways.Instance);
            @adaptAccessUseAccessorsAlways = Action_adaptAccessUseAccessorsAlways.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_adaptUpdateUseAccessorsAlways.Instance);
            actions.Add("adaptUpdateUseAccessorsAlways", (GRGEN_LGSP.LGSPAction) Action_adaptUpdateUseAccessorsAlways.Instance);
            @adaptUpdateUseAccessorsAlways = Action_adaptUpdateUseAccessorsAlways.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_getSourceAndTargetAndMethodBody.Instance);
            actions.Add("getSourceAndTargetAndMethodBody", (GRGEN_LGSP.LGSPAction) Action_getSourceAndTargetAndMethodBody.Instance);
            @getSourceAndTargetAndMethodBody = Action_getSourceAndTargetAndMethodBody.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_getOperation.Instance);
            actions.Add("getOperation", (GRGEN_LGSP.LGSPAction) Action_getOperation.Instance);
            @getOperation = Action_getOperation.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_someInstanceVariableOfTargetType.Instance);
            actions.Add("someInstanceVariableOfTargetType", (GRGEN_LGSP.LGSPAction) Action_someInstanceVariableOfTargetType.Instance);
            @someInstanceVariableOfTargetType = Action_someInstanceVariableOfTargetType.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_someParameterOfTargetType.Instance);
            actions.Add("someParameterOfTargetType", (GRGEN_LGSP.LGSPAction) Action_someParameterOfTargetType.Instance);
            @someParameterOfTargetType = Action_someParameterOfTargetType.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_markExpressionOfBody.Instance);
            actions.Add("markExpressionOfBody", (GRGEN_LGSP.LGSPAction) Action_markExpressionOfBody.Instance);
            @markExpressionOfBody = Action_markExpressionOfBody.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_markExpressionFollowingExpression.Instance);
            actions.Add("markExpressionFollowingExpression", (GRGEN_LGSP.LGSPAction) Action_markExpressionFollowingExpression.Instance);
            @markExpressionFollowingExpression = Action_markExpressionFollowingExpression.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_markExpressionFollowingActualParameter.Instance);
            actions.Add("markExpressionFollowingActualParameter", (GRGEN_LGSP.LGSPAction) Action_markExpressionFollowingActualParameter.Instance);
            @markExpressionFollowingActualParameter = Action_markExpressionFollowingActualParameter.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_unmarkExpression.Instance);
            actions.Add("unmarkExpression", (GRGEN_LGSP.LGSPAction) Action_unmarkExpression.Instance);
            @unmarkExpression = Action_unmarkExpression.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_callToSuperExists.Instance);
            actions.Add("callToSuperExists", (GRGEN_LGSP.LGSPAction) Action_callToSuperExists.Instance);
            @callToSuperExists = Action_callToSuperExists.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_isStatic.Instance);
            actions.Add("isStatic", (GRGEN_LGSP.LGSPAction) Action_isStatic.Instance);
            @isStatic = Action_isStatic.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_methodNameExists.Instance);
            actions.Add("methodNameExists", (GRGEN_LGSP.LGSPAction) Action_methodNameExists.Instance);
            @methodNameExists = Action_methodNameExists.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_thisIsAccessed.Instance);
            actions.Add("thisIsAccessed", (GRGEN_LGSP.LGSPAction) Action_thisIsAccessed.Instance);
            @thisIsAccessed = Action_thisIsAccessed.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_addSourceParameter.Instance);
            actions.Add("addSourceParameter", (GRGEN_LGSP.LGSPAction) Action_addSourceParameter.Instance);
            @addSourceParameter = Action_addSourceParameter.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_useSourceParameter.Instance);
            actions.Add("useSourceParameter", (GRGEN_LGSP.LGSPAction) Action_useSourceParameter.Instance);
            @useSourceParameter = Action_useSourceParameter.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_copyOperation.Instance);
            actions.Add("copyOperation", (GRGEN_LGSP.LGSPAction) Action_copyOperation.Instance);
            @copyOperation = Action_copyOperation.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_copyOperationParameter.Instance);
            actions.Add("copyOperationParameter", (GRGEN_LGSP.LGSPAction) Action_copyOperationParameter.Instance);
            @copyOperationParameter = Action_copyOperationParameter.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_relinkMethodBody.Instance);
            actions.Add("relinkMethodBody", (GRGEN_LGSP.LGSPAction) Action_relinkMethodBody.Instance);
            @relinkMethodBody = Action_relinkMethodBody.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_relinkParameter.Instance);
            actions.Add("relinkParameter", (GRGEN_LGSP.LGSPAction) Action_relinkParameter.Instance);
            @relinkParameter = Action_relinkParameter.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_relinkOperationAndMethodBody.Instance);
            actions.Add("relinkOperationAndMethodBody", (GRGEN_LGSP.LGSPAction) Action_relinkOperationAndMethodBody.Instance);
            @relinkOperationAndMethodBody = Action_relinkOperationAndMethodBody.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_addDelegateBody.Instance);
            actions.Add("addDelegateBody", (GRGEN_LGSP.LGSPAction) Action_addDelegateBody.Instance);
            @addDelegateBody = Action_addDelegateBody.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_linkDelegateBodyToOperation.Instance);
            actions.Add("linkDelegateBodyToOperation", (GRGEN_LGSP.LGSPAction) Action_linkDelegateBodyToOperation.Instance);
            @linkDelegateBodyToOperation = Action_linkDelegateBodyToOperation.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_replaceAccess_Variable.Instance);
            actions.Add("replaceAccess_Variable", (GRGEN_LGSP.LGSPAction) Action_replaceAccess_Variable.Instance);
            @replaceAccess_Variable = Action_replaceAccess_Variable.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_replaceAccess_Variable_WithSource.Instance);
            actions.Add("replaceAccess_Variable_WithSource", (GRGEN_LGSP.LGSPAction) Action_replaceAccess_Variable_WithSource.Instance);
            @replaceAccess_Variable_WithSource = Action_replaceAccess_Variable_WithSource.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_addSourceToCall.Instance);
            actions.Add("addSourceToCall", (GRGEN_LGSP.LGSPAction) Action_addSourceToCall.Instance);
            @addSourceToCall = Action_addSourceToCall.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_getUnprocessedCallWithActualParameter.Instance);
            actions.Add("getUnprocessedCallWithActualParameter", (GRGEN_LGSP.LGSPAction) Action_getUnprocessedCallWithActualParameter.Instance);
            @getUnprocessedCallWithActualParameter = Action_getUnprocessedCallWithActualParameter.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_replaceAccess_Parameter_AccessWithoutLink.Instance);
            actions.Add("replaceAccess_Parameter_AccessWithoutLink", (GRGEN_LGSP.LGSPAction) Action_replaceAccess_Parameter_AccessWithoutLink.Instance);
            @replaceAccess_Parameter_AccessWithoutLink = Action_replaceAccess_Parameter_AccessWithoutLink.Instance;
            analyzer.AnalyzeNestingOfAndRemember(Rule_replaceAccess_Parameter_AccessWithLinkToExpression.Instance);
            actions.Add("replaceAccess_Parameter_AccessWithLinkToExpression", (GRGEN_LGSP.LGSPAction) Action_replaceAccess_Parameter_AccessWithLinkToExpression.Instance);
            @replaceAccess_Parameter_AccessWithLinkToExpression = Action_replaceAccess_Parameter_AccessWithLinkToExpression.Instance;
            analyzer.ComputeInterPatternRelations();
            analyzer.AnalyzeWithInterPatternRelationsKnown(Pattern_MultipleContainedPackagesOrClasses.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Pattern_MultipleVariables.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Pattern_MultipleMethodBodies.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Pattern_MethodBodyAndImplementation.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Pattern_MultipleParameters.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Pattern_MultipleExpressions.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Pattern_ExpressionChain.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Pattern_MultipleActualParameters.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Pattern_MultipleExtendingClasses.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Pattern_InClass.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Pattern_methodNameExistsSuper.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpGxl.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodePackage.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeClass.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeInterface.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeVariable.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeOperation.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeMethodBody.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeAccess.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeUpdate.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeCall.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeIstantiation.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeOperator.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeReturn.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeBlock.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeLiteral.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpNodeParameter.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpEdgeBelongsTo.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpEdgeType.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpEdgeExtends.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpEdgeImports.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpEdgeImplements.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpEdgeParameter.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpEdgeBinding.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpEdgeLink.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpEdgeExpression.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_dumpEdgeActualParameter.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_emitSpanningTree.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_InsertHelperEdgesForNestedLayout.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_BindOperations.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_InitMoveIntoBlocks.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_MoveIntoBlocks.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_getClassAndVariable.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_variableInClass.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_methodExists.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_sameStaticness.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_insertMethodGetter.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_insertMethodSetter.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_changeVisibility.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_adaptAccess.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_adaptUpdate.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_adaptAccessUseAccessorsAlways.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_adaptUpdateUseAccessorsAlways.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_getSourceAndTargetAndMethodBody.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_getOperation.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_someInstanceVariableOfTargetType.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_someParameterOfTargetType.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_markExpressionOfBody.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_markExpressionFollowingExpression.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_markExpressionFollowingActualParameter.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_unmarkExpression.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_callToSuperExists.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_isStatic.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_methodNameExists.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_thisIsAccessed.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_addSourceParameter.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_useSourceParameter.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_copyOperation.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_copyOperationParameter.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_relinkMethodBody.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_relinkParameter.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_relinkOperationAndMethodBody.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_addDelegateBody.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_linkDelegateBodyToOperation.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_replaceAccess_Variable.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_replaceAccess_Variable_WithSource.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_addSourceToCall.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_getUnprocessedCallWithActualParameter.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_replaceAccess_Parameter_AccessWithoutLink.Instance);
            analyzer.AnalyzeWithInterPatternRelationsKnown(Rule_replaceAccess_Parameter_AccessWithLinkToExpression.Instance);
        }
        
        public IAction_dumpGxl @dumpGxl;
        public IAction_dumpNodePackage @dumpNodePackage;
        public IAction_dumpNodeClass @dumpNodeClass;
        public IAction_dumpNodeInterface @dumpNodeInterface;
        public IAction_dumpNodeVariable @dumpNodeVariable;
        public IAction_dumpNodeOperation @dumpNodeOperation;
        public IAction_dumpNodeMethodBody @dumpNodeMethodBody;
        public IAction_dumpNodeAccess @dumpNodeAccess;
        public IAction_dumpNodeUpdate @dumpNodeUpdate;
        public IAction_dumpNodeCall @dumpNodeCall;
        public IAction_dumpNodeIstantiation @dumpNodeIstantiation;
        public IAction_dumpNodeOperator @dumpNodeOperator;
        public IAction_dumpNodeReturn @dumpNodeReturn;
        public IAction_dumpNodeBlock @dumpNodeBlock;
        public IAction_dumpNodeLiteral @dumpNodeLiteral;
        public IAction_dumpNodeParameter @dumpNodeParameter;
        public IAction_dumpEdgeBelongsTo @dumpEdgeBelongsTo;
        public IAction_dumpEdgeType @dumpEdgeType;
        public IAction_dumpEdgeExtends @dumpEdgeExtends;
        public IAction_dumpEdgeImports @dumpEdgeImports;
        public IAction_dumpEdgeImplements @dumpEdgeImplements;
        public IAction_dumpEdgeParameter @dumpEdgeParameter;
        public IAction_dumpEdgeBinding @dumpEdgeBinding;
        public IAction_dumpEdgeLink @dumpEdgeLink;
        public IAction_dumpEdgeExpression @dumpEdgeExpression;
        public IAction_dumpEdgeActualParameter @dumpEdgeActualParameter;
        public IAction_emitSpanningTree @emitSpanningTree;
        public IAction_InsertHelperEdgesForNestedLayout @InsertHelperEdgesForNestedLayout;
        public IAction_BindOperations @BindOperations;
        public IAction_InitMoveIntoBlocks @InitMoveIntoBlocks;
        public IAction_MoveIntoBlocks @MoveIntoBlocks;
        public IAction_getClassAndVariable @getClassAndVariable;
        public IAction_variableInClass @variableInClass;
        public IAction_methodExists @methodExists;
        public IAction_sameStaticness @sameStaticness;
        public IAction_insertMethodGetter @insertMethodGetter;
        public IAction_insertMethodSetter @insertMethodSetter;
        public IAction_changeVisibility @changeVisibility;
        public IAction_adaptAccess @adaptAccess;
        public IAction_adaptUpdate @adaptUpdate;
        public IAction_adaptAccessUseAccessorsAlways @adaptAccessUseAccessorsAlways;
        public IAction_adaptUpdateUseAccessorsAlways @adaptUpdateUseAccessorsAlways;
        public IAction_getSourceAndTargetAndMethodBody @getSourceAndTargetAndMethodBody;
        public IAction_getOperation @getOperation;
        public IAction_someInstanceVariableOfTargetType @someInstanceVariableOfTargetType;
        public IAction_someParameterOfTargetType @someParameterOfTargetType;
        public IAction_markExpressionOfBody @markExpressionOfBody;
        public IAction_markExpressionFollowingExpression @markExpressionFollowingExpression;
        public IAction_markExpressionFollowingActualParameter @markExpressionFollowingActualParameter;
        public IAction_unmarkExpression @unmarkExpression;
        public IAction_callToSuperExists @callToSuperExists;
        public IAction_isStatic @isStatic;
        public IAction_methodNameExists @methodNameExists;
        public IAction_thisIsAccessed @thisIsAccessed;
        public IAction_addSourceParameter @addSourceParameter;
        public IAction_useSourceParameter @useSourceParameter;
        public IAction_copyOperation @copyOperation;
        public IAction_copyOperationParameter @copyOperationParameter;
        public IAction_relinkMethodBody @relinkMethodBody;
        public IAction_relinkParameter @relinkParameter;
        public IAction_relinkOperationAndMethodBody @relinkOperationAndMethodBody;
        public IAction_addDelegateBody @addDelegateBody;
        public IAction_linkDelegateBodyToOperation @linkDelegateBodyToOperation;
        public IAction_replaceAccess_Variable @replaceAccess_Variable;
        public IAction_replaceAccess_Variable_WithSource @replaceAccess_Variable_WithSource;
        public IAction_addSourceToCall @addSourceToCall;
        public IAction_getUnprocessedCallWithActualParameter @getUnprocessedCallWithActualParameter;
        public IAction_replaceAccess_Parameter_AccessWithoutLink @replaceAccess_Parameter_AccessWithoutLink;
        public IAction_replaceAccess_Parameter_AccessWithLinkToExpression @replaceAccess_Parameter_AccessWithLinkToExpression;
        
        
        public override string Name { get { return "JavaProgramGraphsActions"; } }
        public override string ModelMD5Hash { get { return "8fd694f4f8cc691f8759cb852bb0c81c"; } }
    }
}