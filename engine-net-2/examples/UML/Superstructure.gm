abstract edge class association;
abstract edge class attribute;

//ObjectNodeOrderingKind is an enumeration indicating queuing order within a node.
enum ObjectNodeOrderingKind {

	//Indicates that object node tokens are unordered.
	unordered,
	//Indicates that object node tokens are ordered.
	ordered,
	//Indicates that object node tokens are queued in a last in, first out manner.
	LIFO,
	//Indicates that object node tokens are queued in a first in, first out manner.
	FIFO

}

node class ObjectNodeOrderingKind_Value {

	value : ObjectNodeOrderingKind;

}

//The datatype ParameterEffectKind is an enumeration that indicates the effect of a behavior on values passed in or out of its parameters.
enum ParameterEffectKind {

	//Indicates that the behavior creates values.
	create,
	//Indicates that the behavior reads values.
	read,
	//Indicates that the behavior updates values.
	update,
	//Indicates that the behavior deletes values.
	delete_

}

node class ParameterEffectKind_Value {

	value : ParameterEffectKind;

}

//ExpansionKind is an enumeration type used to specify how multiple executions of an expansion region interact.
enum ExpansionKind {

	//The executions are independent. They may be executed concurrently.
	parallel,
	//The executions are dependent and must be executed one at a time, in order of the collection elements.
	iterative,
	//A stream of collection elements flows into a single execution, in order of the collection elements.
	stream

}

node class ExpansionKind_Value {

	value : ExpansionKind;

}

//AggregationKind is an enumeration type that specifies the literals for defining the kind of aggregation of a property.
enum AggregationKind {

	//Indicates that the property has no aggregation.
	none,
	//Indicates that the property has a shared aggregation.
	shared,
	//Indicates that the property is aggregated compositely, i.e., the composite object has responsibility for the existence and storage of the composed objects (parts).
	composite

}

node class AggregationKind_Value {

	value : AggregationKind;

}

//Parameter direction kind is an enumeration type that defines literals used to specify direction of parameters.
enum ParameterDirectionKind {

	//Indicates that parameter values are passed into the behavioral element by the caller.
	in,
	//Indicates that parameter values are passed into a behavioral element by the caller and then back out to the caller from the behavioral element.
	inout,
	//
	out,
	//Indicates that parameter values are passed as return values from a behavioral element back to the caller.
	return_

}

node class ParameterDirectionKind_Value {

	value : ParameterDirectionKind;

}

//VisibilityKind is an enumeration type that defines literals to determine the visibility of elements in a model.
enum VisibilityKind {

	//
	public,
	//
	private,
	//
	protected,
	//
	package

}

node class VisibilityKind_Value {

	value : VisibilityKind;

}

//CallConcurrencyKind is an enumeration type.
enum CallConcurrencyKind {

	//No concurrency management mechanism is associated with the operation and, therefore, concurrency conflicts may occur. Instances that invoke a behavioral feature need to coordinate so that only one invocation to a target on any behavioral feature occurs at once.
	sequential,
	//Multiple invocations of a behavioral feature may occur simultaneously to one instance, but only one is allowed to commence. The others are blocked until the performance of the first behavioral feature is complete. It is the responsibility of the system designer to ensure that deadlocks do not occur due to simultaneous blocks.
	guarded,
	//Multiple invocations of a behavioral feature may occur simultaneously to one instance and all of them may proceed concurrently.
	concurrent

}

node class CallConcurrencyKind_Value {

	value : CallConcurrencyKind;

}

//ConnectorKind is an enumeration type.
enum ConnectorKind {

	//Indicates that the connector is an assembly connector.
	assembly,
	//Indicates that the connector is a delegation connector.
	delegation

}

node class ConnectorKind_Value {

	value : ConnectorKind;

}

//This is an enumerated type that identifies the type of message.
enum MessageKind {

	//sendEvent and receiveEvent are present
	complete,
	//sendEvent present and receiveEvent absent
	lost,
	//sendEvent absent and receiveEvent present
	found,
	//sendEvent and receiveEvent absent (should not appear)
	unknown

}

node class MessageKind_Value {

	value : MessageKind;

}

//This is an enumerated type that identifies the type of communication action that was used to generate the message.
enum MessageSort {

	//The message was generated by a synchronous call to an operation.
	synchCall,
	//The message was generated by an asynchronous call to an operation; i.e., a CallAction with isSynchronous = false.
	asynchCall,
	//The message was generated by an asynchronous send action.
	asynchSignal,
	//The message designating the creation of another lifeline object.
	createMessage,
	//The message designating the termination of another lifeline.
	deleteMessage,
	//The message is a reply message to an operation call.
	reply

}

node class MessageSort_Value {

	value : MessageSort;

}

//InteractionOperatorKind is an enumeration designating the different kinds of operators of combined fragments. The interaction operand defines the type of operator of a combined fragment.
enum InteractionOperatorKind {

	//The interactionOperator seq designates that the CombinedFragment represents a weak sequencing between the behaviors of the operands.
	seq,
	//The interactionOperator alt designates that the CombinedFragment represents a choice of behavior. At most one of the operands will be chosen. The chosen operand must have an explicit or implicit guard expression that evaluates to true at this point in the interaction. An implicit true guard is implied if the operand has no guard.
	alt,
	//The interactionOperator opt designates that the CombinedFragment represents a choice of behavior where either the (sole) operand happens or nothing happens. An option is semantically equivalent to an alternative CombinedFragment where there is one operand with non-empty content and the second operand is empty.
	opt,
	//The interactionOperator break designates that the CombinedFragment represents a breaking scenario in the sense that the operand is a scenario that is performed instead of the remainder of the enclosing InteractionFragment. A break operator with a guard is chosen when the guard is true and the rest of the enclosing Interaction Fragment is ignored. When the guard of the break operand is false, the break operand is ignored and the rest of the enclosing InteractionFragment is chosen. The choice between a break operand without a guard and the rest of the enclosing InteractionFragment is done non-deterministically.
	break,
	//The interactionOperator par designates that the CombinedFragment represents a parallel merge between the behaviors of the operands. The OccurrenceSpecifications of the different operands can be interleaved in any way as long as the ordering imposed by each operand as such is preserved.
	par,
	//The interactionOperator strict designates that the CombinedFragment represents a strict sequencing between the behaviors of the operands. The semantics of strict sequencing defines a strict ordering of the operands on the first level within the CombinedFragment with interactionOperator strict. Therefore OccurrenceSpecifications within contained CombinedFragment will not directly be compared with other OccurrenceSpecifications of the enclosing CombinedFragment.
	strict,
	//The interactionOperator loop designates that the CombinedFragment represents a loop. The loop operand will be repeated a number of times.
	loop,
	//The interactionOperator critical designates that the CombinedFragment represents a critical region. A critical region means that the traces of the region cannot be interleaved by other OccurrenceSpecifications (on those Lifelines covered by the region). This means that the region is treated atomically by the enclosing fragment when determining the set of valid traces. Even though enclosing CombinedFragments may imply that some OccurrenceSpecifications may interleave into the region, such as e.g. with par-operator, this is prevented by defining a region.
	critical,
	//The interactionOperator neg designates that the CombinedFragment represents traces that are defined to be invalid.
	neg,
	//The interactionOperator assert designates that the CombinedFragment represents an assertion. The sequences of the operand of the assertion are the only valid continuations. All other continuations result in an invalid trace.
	assert,
	//The interacionOperator ignore designates that there are some message types that are not shown within this combined fragment. These message types can be considered insignificant and are implicitly ignored if they appear in a corresponding execution. Alternatively, one can understand ignore to mean that the message types that are ignored can appear anywhere in the traces.
	ignore,
	//The interactionOperator consider designates which messages should be considered within this combined fragment. This is equivalent to defining every other message to be ignored.
	consider

}

node class InteractionOperatorKind_Value {

	value : InteractionOperatorKind;

}

//PseudostateKind is an enumeration type.
enum PseudostateKind {

	//An initial pseudostate represents a default vertex that is the source for a single transition to the default state of a composite state. There can be at most one initial vertex in a region. The outgoing transition from the initial vertex may have a behavior, but not a trigger or guard.
	initial,
	//DeepHistory represents the most recent active configuration of the composite state that directly contains this pseudostate; e.g. the state configuration that was active when the composite state was last exited. A composite state can have at most one deep history vertex. At most one transition may originate from the history connector to the default deep history state. This transition is taken in case the composite state had never been active before. Entry actions of states entered on the path to the state represented by a deep history are performed.
	deepHistory,
	//ShallowHistory represents the most recent active substate of its containing state (but not the substates of that substate). A composite state can have at most one shallow history vertex. A transition coming into the shallow history vertex is equivalent to a transition coming into the most recent active substate of a state. At most one transition may originate from the history connector to the default shallow history state. This transition is taken in case the composite state had never been active before. Entry actions of states entered on the path to the state represented by a shallow history are performed.
	shallowHistory,
	//Join vertices serve to merge several transitions emanating from source vertices in different orthogonal regions. The transitions entering a join vertex cannot have guards or triggers.
	join,
	//Fork vertices serve to split an incoming transition into two or more transitions terminating on orthogonal target vertices (i.e. vertices in different regions of a composite state). The segments outgoing from a fork vertex must not have guards or triggers.
	fork,
	//Junction vertices are semantic-free vertices that are used to chain together multiple transitions. They are used to construct compound transition paths between states. For example, a junction can be used to converge multiple incoming transitions into a single outgoing transition representing a shared transition path (this is known as an merge). Conversely, they can be used to split an incoming transition into multiple outgoing transition segments with different guard conditions. This realizes a static conditional branch. (In the latter case, outgoing transitions whose guard conditions evaluate to false are disabled. A predefined guard denoted 'else' may be defined for at most one outgoing transition. This transition is enabled if all the guards labeling the other transitions are false.) Static conditional branches are distinct from dynamic conditional branches that are realized by choice vertices (described below).
	junction,
	//Choice vertices which, when reached, result in the dynamic evaluation of the guards of the triggers of its outgoing transitions. This realizes a dynamic conditional branch. It allows splitting of transitions into multiple outgoing paths such that the decision on which path to take may be a function of the results of prior actions performed in the same run-tocompletion step. If more than one of the guards evaluates to true, an arbitrary one is selected. If none of the guards evaluates to true, then the model is considered ill-formed. (To avoid this, it is recommended to define one outgoing transition with the predefined else guard for every choice vertex.) Choice vertices should be distinguished from static branch points that are based on junction points (described above).
	choice,
	//An entry point pseudostate is an entry point of a state machine or composite state. In each region of the state machine or composite state it has a single transition to a vertex within the same region.
	entryPoint,
	//An exit point pseudostate is an exit point of a state machine or composite state. Entering an exit point within any region of the composite state or state machine referenced by a submachine state implies the exit of this composite state or submachine state and the triggering of the transition that has this exit point as source in the state machine enclosing the submachine or composite state.
	exitPoint,
	//Entering a terminate pseudostate implies that the execution of this state machine by means of its context object is terminated. The state machine does not exit any states nor does it perform any exit actions other than those associated with the transition leading to the terminate pseudostate. Entering a terminate pseudostate is equivalent to invoking a DestroyObjectAction.
	terminate

}

node class PseudostateKind_Value {

	value : PseudostateKind;

}

//TransitionKind is an enumeration type.
enum TransitionKind {

	//Implies that the transition, if triggered, occurs without exiting or entering the source state. Thus, it does not cause a state change. This means that the entry or exit condition of the source state will not be invoked. An internal transition can be taken even if the state machine is in one or more regions nested within this state.
	internal,
	//Implies that the transition, if triggered, will not exit the composite (source) state, but it will apply to any state within the composite state, and these will be exited and entered.
	local,
	//Implies that the transition, if triggered, will exit the composite (source) state.
	external

}

node class TransitionKind_Value {

	value : TransitionKind;

}

//A read extent action is an action that retrieves the current instances of a classifier.
node class ReadExtentAction extends Actions_BasicActions_Action;
edge class Actions_CompleteActions_ReadExtentAction_result extends association
	 connect ReadExtentAction[*] --> Actions_BasicActions_OutputPin[1:1];
edge class Actions_CompleteActions_ReadExtentAction_classifier extends association
	 connect ReadExtentAction[*] --> Classes_Kernel_Classifier[1:1];

//A reclassify object action is an action that changes which classifiers classify an object.
node class ReclassifyObjectAction extends Actions_BasicActions_Action;
edge class Actions_CompleteActions_ReclassifyObjectAction_oldClassifier extends association
	 connect ReclassifyObjectAction[*] --> Classes_Kernel_Classifier[0:*];
edge class Actions_CompleteActions_ReclassifyObjectAction_newClassifier extends association
	 connect ReclassifyObjectAction[*] --> Classes_Kernel_Classifier[0:*];
edge class Actions_CompleteActions_ReclassifyObjectAction_object extends association
	 connect ReclassifyObjectAction[*] --> Actions_BasicActions_InputPin[1:1];

//A read is classified object action is an action that determines whether a runtime object is classified by a given classifier.
node class ReadIsClassifiedObjectAction extends Actions_BasicActions_Action;
edge class Actions_CompleteActions_ReadIsClassifiedObjectAction_classifier extends association
	 connect ReadIsClassifiedObjectAction[*] --> Classes_Kernel_Classifier[1:1];
edge class Actions_CompleteActions_ReadIsClassifiedObjectAction_result extends association
	 connect ReadIsClassifiedObjectAction[*] --> Actions_BasicActions_OutputPin[1:1];
edge class Actions_CompleteActions_ReadIsClassifiedObjectAction_object extends association
	 connect ReadIsClassifiedObjectAction[*] --> Actions_BasicActions_InputPin[1:1];

//A start classifier behavior action is an action that starts the classifier behavior of the input.
node class StartClassifierBehaviorAction extends Actions_BasicActions_Action;
edge class Actions_CompleteActions_StartClassifierBehaviorAction_object extends association
	 connect StartClassifierBehaviorAction[*] --> Actions_BasicActions_InputPin[1:1];

//A qualifier value is not an action. It is an element that identifies links. It gives a single qualifier within a link end data specification.
node class QualifierValue extends Classes_Kernel_Element;
edge class Actions_CompleteActions_QualifierValue_qualifier extends association
	 connect QualifierValue[*] --> Classes_AssociationClasses_Property[1:1];
edge class Actions_CompleteActions_QualifierValue_value extends association
	 connect QualifierValue[*] --> Actions_BasicActions_InputPin[1:1];

//
node class LinkEndData;
edge class Actions_CompleteActions_LinkEndData_qualifier extends association
	 connect LinkEndData[*] --> Actions_CompleteActions_QualifierValue[0:*];

//A read link object end action is an action that retrieves an end object from a link object.
node class ReadLinkObjectEndAction extends Actions_BasicActions_Action;
edge class Actions_CompleteActions_ReadLinkObjectEndAction_object extends association
	 connect ReadLinkObjectEndAction[*] --> Actions_BasicActions_InputPin[1:1];
edge class Actions_CompleteActions_ReadLinkObjectEndAction_end extends association
	 connect ReadLinkObjectEndAction[*] --> Classes_Kernel_Property[1:1];
edge class Actions_CompleteActions_ReadLinkObjectEndAction_result extends association
	 connect ReadLinkObjectEndAction[*] --> Actions_BasicActions_OutputPin[1:1];

//A read link object end qualifier action is an action that retrieves a qualifier end value from a link object.
node class ReadLinkObjectEndQualifierAction extends Actions_BasicActions_Action;
edge class Actions_CompleteActions_ReadLinkObjectEndQualifierAction_object extends association
	 connect ReadLinkObjectEndQualifierAction[*] --> Actions_BasicActions_InputPin[1:1];
edge class Actions_CompleteActions_ReadLinkObjectEndQualifierAction_result extends association
	 connect ReadLinkObjectEndQualifierAction[*] --> Actions_BasicActions_OutputPin[1:1];
edge class Actions_CompleteActions_ReadLinkObjectEndQualifierAction_qualifier extends association
	 connect ReadLinkObjectEndQualifierAction[*] --> Classes_AssociationClasses_Property[1:1];

//A create link object action creates a link object.
node class CreateLinkObjectAction extends Actions_IntermediateActions_CreateLinkAction;
edge class Actions_CompleteActions_CreateLinkObjectAction_result extends association
	 connect CreateLinkObjectAction[*] --> Actions_BasicActions_OutputPin[1:1];

//A accept event action is an action that waits for the occurrence of an event meeting specified conditions.
node class AcceptEventAction extends Actions_BasicActions_Action;
edge class Actions_CompleteActions_AcceptEventAction_result extends association
	 connect AcceptEventAction[*] --> Actions_BasicActions_OutputPin[0:*];
edge class Actions_CompleteActions_AcceptEventAction_trigger extends association
	 connect AcceptEventAction[*] --> CommonBehaviors_Communications_Trigger[1:*];

//An accept call action is an accept event action representing the receipt of a synchronous call request. In addition to the normal operation parameters, the action produces an output that is needed later to supply the information to the reply action necessary to return control to the caller. This action is for synchronous calls. If it is used to handle an asynchronous call, execution of the subsequent reply action will complete immediately with no effects.
node class AcceptCallAction extends Actions_CompleteActions_AcceptEventAction;
edge class Actions_CompleteActions_AcceptCallAction_returnInformation extends association
	 connect AcceptCallAction[*] --> Actions_BasicActions_OutputPin[1:1];

//A reply action is an action that accepts a set of return values and a value containing return information produced by a previous accept call action. The reply action returns the values to the caller of the previous call, completing execution of the call.
node class ReplyAction extends Actions_BasicActions_Action;
edge class Actions_CompleteActions_ReplyAction_replyToCall extends association
	 connect ReplyAction[*] --> CommonBehaviors_Communications_Trigger[1:1];
edge class Actions_CompleteActions_ReplyAction_returnInformation extends association
	 connect ReplyAction[*] --> Actions_BasicActions_InputPin[1:1];
edge class Actions_CompleteActions_ReplyAction_replyValue extends association
	 connect ReplyAction[*] --> Actions_BasicActions_InputPin[0:*];

//An unmarshall action is an action that breaks an object of a known type into outputs each of which is equal to a value from a structural feature of the object.
node class UnmarshallAction extends Actions_BasicActions_Action;
edge class Actions_CompleteActions_UnmarshallAction_result extends association
	 connect UnmarshallAction[*] --> Actions_BasicActions_OutputPin[1:*];
edge class Actions_CompleteActions_UnmarshallAction_unmarshallType extends association
	 connect UnmarshallAction[*] --> Classes_Kernel_Classifier[1:1];
edge class Actions_CompleteActions_UnmarshallAction_object extends association
	 connect UnmarshallAction[*] --> Actions_BasicActions_InputPin[1:1];

//A reduce action is an action that reduces a collection to a single value by combining the elements of the collection.
node class ReduceAction extends Actions_BasicActions_Action;
edge class Actions_CompleteActions_ReduceAction_reducer extends association
	 connect ReduceAction[*] --> CommonBehaviors_BasicBehaviors_Behavior[1:1];
edge class Actions_CompleteActions_ReduceAction_result extends association
	 connect ReduceAction[*] --> Actions_BasicActions_OutputPin[1:1];
edge class Actions_CompleteActions_ReduceAction_collection extends association
	 connect ReduceAction[*] --> Actions_BasicActions_InputPin[1:1];

//A create object action is an action that creates an object that conforms to a statically specified classifier and puts it on an output pin at runtime.
node class CreateObjectAction extends Actions_BasicActions_Action;
edge class Actions_IntermediateActions_CreateObjectAction_classifier extends association
	 connect CreateObjectAction[*] --> Classes_Kernel_Classifier[1:1];
edge class Actions_IntermediateActions_CreateObjectAction_result extends association
	 connect CreateObjectAction[*] --> Actions_BasicActions_OutputPin[1:1];

//A destroy object action is an action that destroys objects.
node class DestroyObjectAction extends Actions_BasicActions_Action;
edge class Actions_IntermediateActions_DestroyObjectAction_target extends association
	 connect DestroyObjectAction[*] --> Actions_BasicActions_InputPin[1:1];

//A test identity action is an action that tests if two values are identical objects.
node class TestIdentityAction extends Actions_BasicActions_Action;
edge class Actions_IntermediateActions_TestIdentityAction_first extends association
	 connect TestIdentityAction[*] --> Actions_BasicActions_InputPin[1:1];
edge class Actions_IntermediateActions_TestIdentityAction_second extends association
	 connect TestIdentityAction[*] --> Actions_BasicActions_InputPin[1:1];
edge class Actions_IntermediateActions_TestIdentityAction_result extends association
	 connect TestIdentityAction[*] --> Actions_BasicActions_OutputPin[1:1];

//A read self action is an action that retrieves the host object of an action.
node class ReadSelfAction extends Actions_BasicActions_Action;
edge class Actions_IntermediateActions_ReadSelfAction_result extends association
	 connect ReadSelfAction[*] --> Actions_BasicActions_OutputPin[1:1];

//StructuralFeatureAction is an abstract class for all structural feature actions.
abstract node class StructuralFeatureAction extends Actions_BasicActions_Action;
edge class Actions_IntermediateActions_StructuralFeatureAction_structuralFeature extends association
	 connect StructuralFeatureAction[*] --> Classes_Kernel_StructuralFeature[1:1];
edge class Actions_IntermediateActions_StructuralFeatureAction_object extends association
	 connect StructuralFeatureAction[*] --> Actions_BasicActions_InputPin[1:1];

//A read structural feature action is a structural feature action that retrieves the values of a structural feature.
node class ReadStructuralFeatureAction extends Actions_IntermediateActions_StructuralFeatureAction;
edge class Actions_IntermediateActions_ReadStructuralFeatureAction_result extends association
	 connect ReadStructuralFeatureAction[*] --> Actions_BasicActions_OutputPin[1:1];

//WriteStructuralFeatureAction is an abstract class for structural feature actions that change structural feature values.
abstract node class WriteStructuralFeatureAction extends Actions_IntermediateActions_StructuralFeatureAction;
edge class Actions_IntermediateActions_WriteStructuralFeatureAction_value extends association
	 connect WriteStructuralFeatureAction[*] --> Actions_BasicActions_InputPin[1:1];

//A clear structural feature action is a structural feature action that removes all values of a structural feature.
node class ClearStructuralFeatureAction extends Actions_IntermediateActions_StructuralFeatureAction;

//A remove structural feature value action is a write structural feature action that removes values from structural features.
node class RemoveStructuralFeatureValueAction extends Actions_IntermediateActions_WriteStructuralFeatureAction;
edge class Actions_IntermediateActions_RemoveStructuralFeatureValueAction_removeAt extends association
	 connect RemoveStructuralFeatureValueAction[*] --> Actions_BasicActions_InputPin[0:1];

//An add structural feature value action is a write structural feature action for adding values to a structural feature.
node class AddStructuralFeatureValueAction extends Actions_IntermediateActions_WriteStructuralFeatureAction;
edge class Actions_IntermediateActions_AddStructuralFeatureValueAction_insertAt extends association
	 connect AddStructuralFeatureValueAction[*] --> Actions_BasicActions_InputPin[0:1];

//LinkAction is an abstract class for all link actions that identify their links by the objects at the ends of the links and by the qualifiers at ends of the links.
abstract node class LinkAction extends Actions_BasicActions_Action;
edge class Actions_IntermediateActions_LinkAction_endData extends association
	 connect LinkAction[*] --> Actions_IntermediateActions_LinkEndData[2:*];
edge class Actions_IntermediateActions_LinkAction_inputValue extends association
	 connect LinkAction[*] --> Actions_BasicActions_InputPin[1:*];

//A link end data is not an action. It is an element that identifies links. It identifies one end of a link to be read or written by the children of a link action. A link cannot be passed as a runtime value to or from an action. Instead, a link is identified by its end objects and qualifier values, if any. This requires more than one piece of data, namely, the statically-specified end in the user model, the object on the end, and the qualifier values for that end, if any. These pieces are brought together around a link end data. Each association end is identified separately with an instance of the LinkEndData class.
node class LinkEndData extends Classes_Kernel_Element;
edge class Actions_IntermediateActions_LinkEndData_value extends association
	 connect LinkEndData[*] --> Actions_BasicActions_InputPin[0:1];
edge class Actions_IntermediateActions_LinkEndData_end extends association
	 connect LinkEndData[*] --> Classes_Kernel_Property[1:1];

//A read link action is a link action that navigates across associations to retrieve objects on one end.
node class ReadLinkAction extends Actions_IntermediateActions_LinkAction;
edge class Actions_IntermediateActions_ReadLinkAction_result extends association
	 connect ReadLinkAction[*] --> Actions_BasicActions_OutputPin[1:1];

//A link end creation data is not an action. It is an element that identifies links. It identifies one end of a link to be created by a create link action.
node class LinkEndCreationData extends Actions_IntermediateActions_LinkEndData;
edge class Actions_IntermediateActions_LinkEndCreationData_insertAt extends association
	 connect LinkEndCreationData[*] --> Actions_BasicActions_InputPin[0:1];

//A create link action is a write link action for creating links.
node class CreateLinkAction extends Actions_IntermediateActions_WriteLinkAction;
edge class Actions_IntermediateActions_CreateLinkAction_endData extends association
	 connect CreateLinkAction[*] --> Actions_IntermediateActions_LinkEndCreationData[2:*];

//A destroy link action is a write link action that destroys links and link objects.
node class DestroyLinkAction extends Actions_IntermediateActions_WriteLinkAction;
edge class Actions_IntermediateActions_DestroyLinkAction_endData extends association
	 connect DestroyLinkAction[*] --> Actions_IntermediateActions_LinkEndDestructionData[2:*];

//WriteLinkAction is an abstract class for link actions that create and destroy links.
abstract node class WriteLinkAction extends Actions_IntermediateActions_LinkAction;

//A clear association action is an action that destroys all links of an association in which a particular object participates.
node class ClearAssociationAction extends Actions_BasicActions_Action;
edge class Actions_IntermediateActions_ClearAssociationAction_object extends association
	 connect ClearAssociationAction[*] --> Actions_BasicActions_InputPin[1:1];
edge class Actions_IntermediateActions_ClearAssociationAction_association extends association
	 connect ClearAssociationAction[*] --> Classes_Kernel_Association[1:1];

//A broadcast signal action is an action that transmits a signal instance to all the potential target objects in the system, which may cause the firing of a state machine transitions or the execution of associated activities of a target object. The argument values are available to the execution of associated behaviors. The requestor continues execution immediately after the signals are sent out. It does not wait for receipt. Any reply messages are ignored and are not transmitted to the requestor.
node class BroadcastSignalAction extends Actions_BasicActions_InvocationAction;
edge class Actions_IntermediateActions_BroadcastSignalAction_signal extends association
	 connect BroadcastSignalAction[*] --> CommonBehaviors_Communications_Signal[1:1];

//A send object action is an action that transmits an object to the target object, where it may invoke behavior such as the firing of state machine transitions or the execution of an activity. The value of the object is available to the execution of invoked behaviors. The requestor continues execution immediately. Any reply message is ignored and is not transmitted to the requestor.
node class SendObjectAction extends Actions_BasicActions_InvocationAction;
edge class Actions_IntermediateActions_SendObjectAction_target extends association
	 connect SendObjectAction[*] --> Actions_BasicActions_InputPin[1:1];
edge class Actions_IntermediateActions_SendObjectAction_request extends association
	 connect SendObjectAction[*] --> Actions_BasicActions_InputPin[1:1];

//A link end destruction data is not an action. It is an element that identifies links. It identifies one end of a link to be destroyed by destroy link action.
node class LinkEndDestructionData extends Actions_IntermediateActions_LinkEndData;
edge class Actions_IntermediateActions_LinkEndDestructionData_destroyAt extends association
	 connect LinkEndDestructionData[*] --> Actions_BasicActions_InputPin[0:1];

//A value specification action is an action that evaluates a value specification.
node class ValueSpecificationAction extends Actions_BasicActions_Action;
edge class Actions_IntermediateActions_ValueSpecificationAction_value extends association
	 connect ValueSpecificationAction[*] --> Classes_Kernel_ValueSpecification[1:1];
edge class Actions_IntermediateActions_ValueSpecificationAction_result extends association
	 connect ValueSpecificationAction[*] --> Actions_BasicActions_OutputPin[1:1];

//An action with implementation-specific semantics.
node class OpaqueAction extends Actions_BasicActions_Action;
edge class Actions_BasicActions_OpaqueAction_body extends attribute
	 connect OpaqueAction[*] --> [0:*];
edge class Actions_BasicActions_OpaqueAction_language extends attribute
	 connect OpaqueAction[*] --> [0:*];
edge class Actions_BasicActions_OpaqueAction_inputValue extends association
	 connect OpaqueAction[*] --> Actions_BasicActions_InputPin[0:*];
edge class Actions_BasicActions_OpaqueAction_outputValue extends association
	 connect OpaqueAction[*] --> Actions_BasicActions_OutputPin[0:*];

//A pin is a typed element and multiplicity element that provides values to actions and accept result values from them.
abstract node class Pin extends Classes_Kernel_TypedElement, Classes_Kernel_MultiplicityElement;

//A value pin is an input pin that provides a value by evaluating a value specification.
node class ValuePin extends Actions_BasicActions_InputPin;
edge class Actions_BasicActions_ValuePin_value extends association
	 connect ValuePin[*] --> Classes_Kernel_ValueSpecification[1:1];

//An output pin is a pin that holds output values produced by an action.
node class OutputPin extends Actions_BasicActions_Pin;

//An input pin is a pin that holds input values to be consumed by an action.
node class InputPin extends Actions_BasicActions_Pin;

//InvocationAction is an abstract class for the various actions that invoke behavior.
abstract node class InvocationAction extends Actions_BasicActions_Action;
edge class Actions_BasicActions_InvocationAction_argument extends association
	 connect InvocationAction[*] --> Actions_BasicActions_InputPin[0:*];

//CallAction is an abstract class for actions that invoke behavior and receive return values.
abstract node class CallAction extends Actions_BasicActions_InvocationAction;
edge class Actions_BasicActions_CallAction_result extends association
	 connect CallAction[*] --> Actions_BasicActions_OutputPin[0:*];

//A send signal action is an action that creates a signal instance from its inputs, and transmits it to the target object, where it may cause the firing of a state machine transition or the execution of an activity. The argument values are available to the execution of associated behaviors. The requestor continues execution immediately. Any reply message is ignored and is not transmitted to the requestor. If the input is already a signal instance, use a send object action.
node class SendSignalAction extends Actions_BasicActions_InvocationAction;
edge class Actions_BasicActions_SendSignalAction_target extends association
	 connect SendSignalAction[*] --> Actions_BasicActions_InputPin[1:1];
edge class Actions_BasicActions_SendSignalAction_signal extends association
	 connect SendSignalAction[*] --> CommonBehaviors_Communications_Signal[1:1];

//A call operation action is an action that transmits an operation call request to the target object, where it may cause the invocation of associated behavior. The argument values of the action are available to the execution of the invoked behavior. If the action is marked synchronous, the execution of the call operation action waits until the execution of the invoked behavior completes and a reply transmission is returned to the caller; otherwise execution of the action is complete when the invocation of the operation is established and the execution of the invoked operation proceeds concurrently with the execution of the calling behavior. Any values returned as part of the reply transmission are put on the result output pins of the call operation action. Upon receipt of the reply transmission, execution of the call operation action is complete.
node class CallOperationAction extends Actions_BasicActions_CallAction;
edge class Actions_BasicActions_CallOperationAction_operation extends association
	 connect CallOperationAction[*] --> Classes_Kernel_Operation[1:1];
edge class Actions_BasicActions_CallOperationAction_target extends association
	 connect CallOperationAction[*] --> Actions_BasicActions_InputPin[1:1];

//A call behavior action is a call action that invokes a behavior directly rather than invoking a behavioral feature that, in turn, results in the invocation of that behavior. The argument values of the action are available to the execution of the invoked behavior. For synchronous calls the execution of the call behavior action waits until the execution of the invoked behavior completes and a result is returned on its output pin. The action completes immediately without a result, if the call is asynchronous. In particular, the invoked behavior may be an activity.
node class CallBehaviorAction extends Actions_BasicActions_CallAction;
edge class Actions_BasicActions_CallBehaviorAction_behavior extends association
	 connect CallBehaviorAction[*] --> CommonBehaviors_BasicBehaviors_Behavior[1:1];

//An action is a named element that is the fundamental unit of executable functionality. The execution of an action represents some transformation or processing in the modeled system, be it a computer system or otherwise.
abstract node class Action extends Classes_Kernel_NamedElement;
edge class Actions_BasicActions_Action_output extends association
	 connect Action[*] --> Actions_BasicActions_OutputPin[0:*];
edge class Actions_BasicActions_Action_input extends association
	 connect Action[*] --> Actions_BasicActions_InputPin[0:*];
edge class Actions_BasicActions_Action_context extends association
	 connect Action[*] --> Classes_Kernel_Classifier[0:1];

//
abstract node class MultiplicityElement;

//VariableAction is an abstract class for actions that operate on a statically specified variable.
abstract node class VariableAction extends Actions_BasicActions_Action;
edge class Actions_StructuredActions_VariableAction_variable extends association
	 connect VariableAction[*] --> Activities_StructuredActivities_Variable[1:1];

//A read variable action is a variable action that retrieves the values of a variable.
node class ReadVariableAction extends Actions_StructuredActions_VariableAction;
edge class Actions_StructuredActions_ReadVariableAction_result extends association
	 connect ReadVariableAction[*] --> Actions_BasicActions_OutputPin[1:1];

//WriteVariableAction is an abstract class for variable actions that change variable values.
abstract node class WriteVariableAction extends Actions_StructuredActions_VariableAction;
edge class Actions_StructuredActions_WriteVariableAction_value extends association
	 connect WriteVariableAction[*] --> Actions_BasicActions_InputPin[1:1];

//A clear variable action is a variable action that removes all values of a variable.
node class ClearVariableAction extends Actions_StructuredActions_VariableAction;

//An add variable value action is a write variable action for adding values to a variable.
node class AddVariableValueAction extends Actions_StructuredActions_WriteVariableAction;
edge class Actions_StructuredActions_AddVariableValueAction_insertAt extends association
	 connect AddVariableValueAction[*] --> Actions_BasicActions_InputPin[0:1];

//A remove variable value action is a write variable action that removes values from variables.
node class RemoveVariableValueAction extends Actions_StructuredActions_WriteVariableAction;
edge class Actions_StructuredActions_RemoveVariableValueAction_removeAt extends association
	 connect RemoveVariableValueAction[*] --> Actions_BasicActions_InputPin[0:1];

//A raise exception action is an action that causes an exception to occur. The input value becomes the exception object.
node class RaiseExceptionAction extends Actions_BasicActions_Action;
edge class Actions_StructuredActions_RaiseExceptionAction_exception extends association
	 connect RaiseExceptionAction[*] --> Actions_BasicActions_InputPin[1:1];

//An action input pin is a kind of pin that executes an action to determine the values to input to another.
node class ActionInputPin extends Actions_BasicActions_InputPin;
edge class Actions_StructuredActions_ActionInputPin_fromAction extends association
	 connect ActionInputPin[*] --> Actions_BasicActions_Action[1:1];

//An object node is an abstract activity node that is part of defining object flow in an activity.
abstract node class ObjectNode extends Activities_BasicActivities_ActivityNode, Classes_Kernel_TypedElement;

//A control node is an abstract activity node that coordinates flows in an activity.
abstract node class ControlNode extends Activities_BasicActivities_ActivityNode;

//An activity edge is an abstract class for directed connections between two activity nodes.
abstract node class ActivityEdge extends Classes_Kernel_RedefinableElement;
edge class Activities_BasicActivities_ActivityEdge_activity extends association
	 connect ActivityEdge[*] --> Activities_BasicActivities_Activity[0:1];
edge class Activities_BasicActivities_ActivityEdge_source extends association
	 connect ActivityEdge[*] --> Activities_BasicActivities_ActivityNode[1:1];
edge class Activities_BasicActivities_ActivityEdge_target extends association
	 connect ActivityEdge[*] --> Activities_BasicActivities_ActivityNode[1:1];
edge class Activities_BasicActivities_ActivityEdge_inGroup extends association
	 connect ActivityEdge[*] --> Activities_BasicActivities_ActivityGroup[0:*];
edge class Activities_BasicActivities_ActivityEdge_redefinedEdge extends association
	 connect ActivityEdge[*] --> Activities_BasicActivities_ActivityEdge[0:*];

//A control flow is an edge that starts an activity node after the previous one is finished.
node class ControlFlow extends Activities_BasicActivities_ActivityEdge;

//An object flow is an activity edge that can have objects or data passing along it.
node class ObjectFlow extends Activities_BasicActivities_ActivityEdge;

//An initial node is a control node at which flow starts when the activity is invoked.
node class InitialNode extends Activities_BasicActivities_ControlNode;

//An activity final node is a final node that stops all flows in an activity.
node class ActivityFinalNode extends Activities_BasicActivities_ControlNode;

//
abstract node class ActivityGroup;
edge class Activities_BasicActivities_ActivityGroup_containedEdge extends association
	 connect ActivityGroup[*] --> Activities_BasicActivities_ActivityEdge[0:*];

//An activity parameter node is an object node for inputs and outputs to activities.
node class ActivityParameterNode extends Activities_BasicActivities_ObjectNode;
edge class Activities_BasicActivities_ActivityParameterNode_parameter extends association
	 connect ActivityParameterNode[*] --> Classes_Kernel_Parameter[1:1];

//
abstract node class ActivityNode extends Classes_Kernel_RedefinableElement;
edge class Activities_BasicActivities_ActivityNode_outgoing extends association
	 connect ActivityNode[*] --> Activities_BasicActivities_ActivityEdge[0:*];
edge class Activities_BasicActivities_ActivityNode_incoming extends association
	 connect ActivityNode[*] --> Activities_BasicActivities_ActivityEdge[0:*];
edge class Activities_BasicActivities_ActivityNode_redefinedNode extends association
	 connect ActivityNode[*] --> Activities_BasicActivities_ActivityNode[0:*];

//A pin is an object node for inputs and outputs to actions.
node class Pin extends Activities_BasicActivities_ObjectNode;

//
node class Activity extends CommonBehaviors_BasicBehaviors_Behavior;
edge class Activities_BasicActivities_Activity_edge extends association
	 connect Activity[*] --> Activities_BasicActivities_ActivityEdge[0:*];

//
node class ValuePin;

//A fork node is a control node that splits a flow into multiple concurrent flows.
node class ForkNode extends Activities_BasicActivities_ControlNode;

//A flow final node is a final node that terminates a flow.
node class FlowFinalNode extends Activities_IntermediateActivities_FinalNode;

//A central buffer node is an object node for managing flows from multiple sources and destinations.
node class CentralBufferNode extends Activities_BasicActivities_ObjectNode;

//An activity partition is a kind of activity group for identifying actions that have some characteristic in common.
node class ActivityPartition extends Classes_Kernel_NamedElement, Activities_IntermediateActivities_ActivityGroup;
edge class Activities_IntermediateActivities_ActivityPartition_edge extends association
	 connect ActivityPartition[*] --> Activities_IntermediateActivities_ActivityEdge[0:*];
edge class Activities_IntermediateActivities_ActivityPartition_node extends association
	 connect ActivityPartition[*] --> Activities_IntermediateActivities_ActivityNode[0:*];
edge class Activities_IntermediateActivities_ActivityPartition_subpartition extends association
	 connect ActivityPartition[*] --> Activities_IntermediateActivities_ActivityPartition[0:*];
edge class Activities_IntermediateActivities_ActivityPartition_superPartition extends association
	 connect ActivityPartition[*] --> Activities_IntermediateActivities_ActivityPartition[0:1];
edge class Activities_IntermediateActivities_ActivityPartition_represents extends association
	 connect ActivityPartition[*] --> Classes_Kernel_Element[0:1];

//
abstract node class ActivityEdge extends Classes_Kernel_RedefinableElement;
edge class Activities_IntermediateActivities_ActivityEdge_inPartition extends association
	 connect ActivityEdge[*] --> Activities_IntermediateActivities_ActivityPartition[0:*];
edge class Activities_IntermediateActivities_ActivityEdge_guard extends association
	 connect ActivityEdge[*] --> Classes_Kernel_ValueSpecification[1:1];
edge class Activities_IntermediateActivities_ActivityEdge_inGroup extends association
	 connect ActivityEdge[*] --> Activities_IntermediateActivities_ActivityGroup[0:*];

//
abstract node class ActivityNode extends Classes_Kernel_RedefinableElement;
edge class Activities_IntermediateActivities_ActivityNode_inPartition extends association
	 connect ActivityNode[*] --> Activities_IntermediateActivities_ActivityPartition[0:*];
edge class Activities_IntermediateActivities_ActivityNode_inGroup extends association
	 connect ActivityNode[*] --> Activities_IntermediateActivities_ActivityGroup[0:*];

//A merge node is a control node that brings together multiple alternate flows. It is not used to synchronize concurrent flows but to accept one among several alternate flows.
node class MergeNode extends Activities_BasicActivities_ControlNode;

//A decision node is a control node that chooses between outgoing flows.
node class DecisionNode extends Activities_BasicActivities_ControlNode;
edge class Activities_IntermediateActivities_DecisionNode_decisionInput extends association
	 connect DecisionNode[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:1];

//A final node is an abstract control node at which a flow in an activity stops.
abstract node class FinalNode extends Activities_BasicActivities_ControlNode;

//
node class ActivityFinalNode extends Activities_IntermediateActivities_FinalNode;

//A join node is a control node that synchronizes multiple flows.
node class JoinNode extends Activities_BasicActivities_ControlNode;

//
abstract node class ActivityGroup;
edge class Activities_IntermediateActivities_ActivityGroup_containedNode extends association
	 connect ActivityGroup[*] --> Activities_IntermediateActivities_ActivityNode[0:*];
edge class Activities_IntermediateActivities_ActivityGroup_containedEdge extends association
	 connect ActivityGroup[*] --> Activities_IntermediateActivities_ActivityEdge[0:*];
edge class Activities_IntermediateActivities_ActivityGroup_inActivity extends association
	 connect ActivityGroup[*] --> Activities_IntermediateActivities_Activity[0:1];

//
node class Activity;
edge class Activities_IntermediateActivities_Activity_partition extends association
	 connect Activity[*] --> Activities_IntermediateActivities_ActivityPartition[0:*];
edge class Activities_IntermediateActivities_Activity_group extends association
	 connect Activity[*] --> Activities_IntermediateActivities_ActivityGroup[0:*];

//Join nodes have a Boolean value specification using the names of the incoming edges to specify the conditions under which the join will emit a token.
node class JoinNode extends Activities_BasicActivities_ControlNode;
edge class Activities_CompleteActivities_JoinNode_joinSpec extends association
	 connect JoinNode[*] --> Classes_Kernel_ValueSpecification[1:1];

//A data store node is a central buffer node for non-transient information.
node class DataStoreNode extends Activities_IntermediateActivities_CentralBufferNode;

//Object flows have support for multicast/receive, token selection from object nodes, and transformation of tokens.
node class ObjectFlow;
edge class Activities_CompleteActivities_ObjectFlow_transformation extends association
	 connect ObjectFlow[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:1];
edge class Activities_CompleteActivities_ObjectFlow_selection extends association
	 connect ObjectFlow[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:1];

//Activity edges can be contained in interruptible regions.
abstract node class ActivityEdge extends Classes_Kernel_RedefinableElement;
edge class Activities_CompleteActivities_ActivityEdge_weight extends association
	 connect ActivityEdge[*] --> Classes_Kernel_ValueSpecification[1:1];
edge class Activities_CompleteActivities_ActivityEdge_interrupts extends association
	 connect ActivityEdge[*] --> Activities_CompleteActivities_InterruptibleActivityRegion[0:1];

//Object nodes have support for token selection, limitation on the number of tokens, specifying the state required for tokens, and carrying control values.
abstract node class ObjectNode extends Classes_Kernel_TypedElement;
edge class Activities_CompleteActivities_ObjectNode_upperBound extends association
	 connect ObjectNode[*] --> Classes_Kernel_ValueSpecification[1:1];
edge class Activities_CompleteActivities_ObjectNode_inState extends association
	 connect ObjectNode[*] --> StateMachines_BehaviorStateMachines_State[0:*];
edge class Activities_CompleteActivities_ObjectNode_selection extends association
	 connect ObjectNode[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:1];

//A parameter set is an element that provides alternative sets of inputs or outputs that a behavior may use.
node class ParameterSet extends Classes_Kernel_NamedElement;
edge class Activities_CompleteActivities_ParameterSet_parameter extends association
	 connect ParameterSet[*] --> Activities_CompleteActivities_Parameter[1:*];
edge class Activities_CompleteActivities_ParameterSet_condition extends association
	 connect ParameterSet[*] --> Classes_Kernel_Constraint[0:*];

//
node class Activity;

//Parameters have support for streaming, exceptions, and parameter sets.
node class Parameter;
edge class Activities_CompleteActivities_Parameter_effect extends attribute
	 connect Parameter[*] --> Activities_CompleteActivities_ParameterEffectKind[0:1];
edge class Activities_CompleteActivities_Parameter_parameterSet extends association
	 connect Parameter[*] --> Activities_CompleteActivities_ParameterSet[0:*];

//An action has pre- and post-conditions.
abstract node class Action extends Classes_Kernel_NamedElement;
edge class Activities_CompleteActivities_Action_localPrecondition extends association
	 connect Action[*] --> Classes_Kernel_Constraint[0:*];
edge class Activities_CompleteActivities_Action_localPostcondition extends association
	 connect Action[*] --> Classes_Kernel_Constraint[0:*];

//An interruptible activity region is an activity group that supports termination of tokens flowing in the portions of an activity.
node class InterruptibleActivityRegion extends Activities_BasicActivities_ActivityGroup;
edge class Activities_CompleteActivities_InterruptibleActivityRegion_interruptingEdge extends association
	 connect InterruptibleActivityRegion[*] --> Activities_CompleteActivities_ActivityEdge[0:*];
edge class Activities_CompleteActivities_InterruptibleActivityRegion_node extends association
	 connect InterruptibleActivityRegion[*] --> Activities_CompleteActivities_ActivityNode[0:*];

//
abstract node class ActivityNode;
edge class Activities_CompleteActivities_ActivityNode_inInterruptibleRegion extends association
	 connect ActivityNode[*] --> Activities_CompleteActivities_InterruptibleActivityRegion[0:*];
edge class Activities_CompleteActivities_ActivityNode_inGroup extends association
	 connect ActivityNode[*] --> Activities_CompleteActivities_ActivityGroup[0:*];

//A behavioral feature owns zero or more parameter sets.
abstract node class BehavioralFeature extends Classes_Kernel_Feature, Classes_Kernel_Namespace;
edge class Activities_CompleteActivities_BehavioralFeature_ownedParameterSet extends association
	 connect BehavioralFeature[*] --> Activities_CompleteActivities_ParameterSet[0:*];

//A behavior owns zero or more parameter sets.
abstract node class Behavior extends Classes_Kernel_Class;
edge class Activities_CompleteActivities_Behavior_ownedParameterSet extends association
	 connect Behavior[*] --> Activities_CompleteActivities_ParameterSet[0:*];

//
node class Pin;

//
abstract node class ActivityGroup;
edge class Activities_CompleteActivities_ActivityGroup_containedNode extends association
	 connect ActivityGroup[*] --> Activities_CompleteActivities_ActivityNode[0:*];

//Variables are elements for passing data between actions indirectly. A local variable stores values shared by the actions within a structured activity group but not accessible outside it. The output of an action may be written to a variable and read for the input to a subsequent action, which is effectively an indirect data flow path. Because there is no predefined relationship between actions that read and write variables, these actions must be sequenced by control flows to prevent race conditions that may occur between actions that read or write the same variable.
node class Variable extends Classes_Kernel_TypedElement, Classes_Kernel_MultiplicityElement;
edge class Activities_StructuredActivities_Variable_scope extends association
	 connect Variable[*] --> Activities_StructuredActivities_StructuredActivityNode[0:1];
edge class Activities_StructuredActivities_Variable_activityScope extends association
	 connect Variable[*] --> Activities_StructuredActivities_Activity[0:1];

//A structured activity node is an executable activity node that may have an expansion into subordinate nodes as an activity group. The subordinate nodes must belong to only one structured activity node, although they may be nested.
node class StructuredActivityNode extends Activities_StructuredActivities_ActivityGroup, Activities_StructuredActivities_ExecutableNode, Classes_Kernel_Namespace;
edge class Activities_StructuredActivities_StructuredActivityNode_variable extends association
	 connect StructuredActivityNode[*] --> Activities_StructuredActivities_Variable[0:*];
edge class Activities_StructuredActivities_StructuredActivityNode_node extends association
	 connect StructuredActivityNode[*] --> Activities_StructuredActivities_ActivityNode[0:*];
edge class Activities_StructuredActivities_StructuredActivityNode_activity extends association
	 connect StructuredActivityNode[*] --> Activities_StructuredActivities_Activity[0:1];

//A conditional node is a structured activity node that represents an exclusive choice among some number of alternatives.
node class ConditionalNode extends Activities_StructuredActivities_StructuredActivityNode;
edge class Activities_StructuredActivities_ConditionalNode_clause extends association
	 connect ConditionalNode[*] --> Activities_StructuredActivities_Clause[1:*];

//A loop node is a structured activity node that represents a loop with setup, test, and body sections.
node class LoopNode extends Activities_StructuredActivities_StructuredActivityNode;
edge class Activities_StructuredActivities_LoopNode_bodyPart extends association
	 connect LoopNode[*] --> Activities_StructuredActivities_ExecutableNode[0:*];
edge class Activities_StructuredActivities_LoopNode_setupPart extends association
	 connect LoopNode[*] --> Activities_StructuredActivities_ExecutableNode[0:*];
edge class Activities_StructuredActivities_LoopNode_decider extends association
	 connect LoopNode[*] --> Actions_BasicActions_OutputPin[1:1];
edge class Activities_StructuredActivities_LoopNode_test extends association
	 connect LoopNode[*] --> Activities_StructuredActivities_ExecutableNode[0:*];

//A clause is an element that represents a single branch of a conditional construct, including a test and a body section. The body section is executed only if (but not necessarily if) the test section evaluates true.
node class Clause extends Classes_Kernel_Element;
edge class Activities_StructuredActivities_Clause_test extends association
	 connect Clause[*] --> Activities_StructuredActivities_ExecutableNode[0:*];
edge class Activities_StructuredActivities_Clause_body extends association
	 connect Clause[*] --> Activities_StructuredActivities_ExecutableNode[0:*];
edge class Activities_StructuredActivities_Clause_predecessorClause extends association
	 connect Clause[*] --> Activities_StructuredActivities_Clause[0:*];
edge class Activities_StructuredActivities_Clause_successorClause extends association
	 connect Clause[*] --> Activities_StructuredActivities_Clause[0:*];
edge class Activities_StructuredActivities_Clause_decider extends association
	 connect Clause[*] --> Actions_BasicActions_OutputPin[1:1];

//
node class Activity extends CommonBehaviors_BasicBehaviors_Behavior;
edge class Activities_StructuredActivities_Activity_structuredNode extends association
	 connect Activity[*] --> Activities_StructuredActivities_StructuredActivityNode[0:*];
edge class Activities_StructuredActivities_Activity_variable extends association
	 connect Activity[*] --> Activities_StructuredActivities_Variable[0:*];
edge class Activities_StructuredActivities_Activity_group extends association
	 connect Activity[*] --> Activities_StructuredActivities_ActivityGroup[0:*];
edge class Activities_StructuredActivities_Activity_node extends association
	 connect Activity[*] --> Activities_StructuredActivities_ActivityNode[0:*];

//
abstract node class ActivityNode extends Classes_Kernel_RedefinableElement;
edge class Activities_StructuredActivities_ActivityNode_inStructuredNode extends association
	 connect ActivityNode[*] --> Activities_StructuredActivities_StructuredActivityNode[0:1];
edge class Activities_StructuredActivities_ActivityNode_inGroup extends association
	 connect ActivityNode[*] --> Activities_StructuredActivities_ActivityGroup[0:*];
edge class Activities_StructuredActivities_ActivityNode_activity extends association
	 connect ActivityNode[*] --> Activities_StructuredActivities_Activity[0:1];

//An executable node is an abstract class for activity nodes that may be executed. It is used as an attachment point for exception handlers.
abstract node class ExecutableNode extends Activities_StructuredActivities_ActivityNode;

//A sequence node is a structured activity node that executes its actions in order.
node class SequenceNode extends Activities_StructuredActivities_StructuredActivityNode;
edge class Activities_StructuredActivities_SequenceNode_executableNode extends association
	 connect SequenceNode[*] --> Activities_StructuredActivities_ExecutableNode[0:*];

//
abstract node class Action extends Activities_StructuredActivities_ExecutableNode;

//
abstract node class ActivityGroup extends Classes_Kernel_Element;
edge class Activities_StructuredActivities_ActivityGroup_containedNode extends association
	 connect ActivityGroup[*] --> Activities_StructuredActivities_ActivityNode[0:*];
edge class Activities_StructuredActivities_ActivityGroup_inActivity extends association
	 connect ActivityGroup[*] --> Activities_StructuredActivities_Activity[0:1];

//
node class InputPin;

//
node class OutputPin;

//An expansion node is an object node used to indicate a flow across the boundary of an expansion region. A flow into a region contains a collection that is broken into its individual elements inside the region, which is executed once per element. A flow out of a region combines individual elements into a collection for use outside the region.
node class ExpansionNode extends Activities_BasicActivities_ObjectNode;
edge class Activities_ExtraStructuredActivities_ExpansionNode_regionAsOutput extends association
	 connect ExpansionNode[*] --> Activities_ExtraStructuredActivities_ExpansionRegion[0:1];
edge class Activities_ExtraStructuredActivities_ExpansionNode_regionAsInput extends association
	 connect ExpansionNode[*] --> Activities_ExtraStructuredActivities_ExpansionRegion[0:1];

//An expansion region is a structured activity region that executes multiple times corresponding to elements of an input collection.
node class ExpansionRegion extends Activities_StructuredActivities_StructuredActivityNode;
edge class Activities_ExtraStructuredActivities_ExpansionRegion_outputElement extends association
	 connect ExpansionRegion[*] --> Activities_ExtraStructuredActivities_ExpansionNode[0:*];
edge class Activities_ExtraStructuredActivities_ExpansionRegion_inputElement extends association
	 connect ExpansionRegion[*] --> Activities_ExtraStructuredActivities_ExpansionNode[1:*];

//An executable node is an abstract class for activity nodes that may be executed. It is used as an attachment point for exception handlers.
abstract node class ExecutableNode extends Activities_StructuredActivities_ActivityNode;
edge class Activities_ExtraStructuredActivities_ExecutableNode_handler extends association
	 connect ExecutableNode[*] --> Activities_ExtraStructuredActivities_ExceptionHandler[0:*];

//An exception handler is an element that specifies a body to execute in case the specified exception occurs during the execution of the protected node.
node class ExceptionHandler extends Classes_Kernel_Element;
edge class Activities_ExtraStructuredActivities_ExceptionHandler_protectedNode extends association
	 connect ExceptionHandler[*] --> Activities_ExtraStructuredActivities_ExecutableNode[1:1];
edge class Activities_ExtraStructuredActivities_ExceptionHandler_handlerBody extends association
	 connect ExceptionHandler[*] --> Activities_ExtraStructuredActivities_ExecutableNode[1:1];
edge class Activities_ExtraStructuredActivities_ExceptionHandler_exceptionInput extends association
	 connect ExceptionHandler[*] --> Activities_BasicActivities_ObjectNode[1:1];
edge class Activities_ExtraStructuredActivities_ExceptionHandler_exceptionType extends association
	 connect ExceptionHandler[*] --> Classes_Kernel_Classifier[1:*];

//
node class ConditionalNode extends Activities_CompleteStructuredActivities_StructuredActivityNode;
edge class Activities_CompleteStructuredActivities_ConditionalNode_result extends association
	 connect ConditionalNode[*] --> Actions_BasicActions_OutputPin[0:*];

//Because of the concurrent nature of the execution of actions within and across activities, it can be difficult to guarantee the consistent access and modification of object memory. In order to avoid race conditions or other concurrency-related problems, it is sometimes necessary to isolate the effects of a group of actions from the effects of actions outside the group. This may be indicated by setting the mustIsolate attribute to true on a structured activity node. If a structured activity node is "isolated," then any object used by an action within the node cannot be accessed by any action outside the node until the structured activity node as a whole completes. Any concurrent actions that would result in accessing such objects are required to have their execution deferred until the completion of the node.
node class StructuredActivityNode extends Actions_BasicActions_Action, Activities_CompleteStructuredActivities_ActivityGroup;
edge class Activities_CompleteStructuredActivities_StructuredActivityNode_edge extends association
	 connect StructuredActivityNode[*] --> Activities_CompleteStructuredActivities_ActivityEdge[0:*];

//
node class LoopNode extends Activities_CompleteStructuredActivities_StructuredActivityNode;
edge class Activities_CompleteStructuredActivities_LoopNode_result extends association
	 connect LoopNode[*] --> Actions_BasicActions_OutputPin[0:*];
edge class Activities_CompleteStructuredActivities_LoopNode_loopVariable extends association
	 connect LoopNode[*] --> Actions_BasicActions_OutputPin[0:*];
edge class Activities_CompleteStructuredActivities_LoopNode_bodyOutput extends association
	 connect LoopNode[*] --> Actions_BasicActions_OutputPin[0:*];
edge class Activities_CompleteStructuredActivities_LoopNode_loopVariableInput extends association
	 connect LoopNode[*] --> Actions_BasicActions_InputPin[0:*];

//
node class Clause;
edge class Activities_CompleteStructuredActivities_Clause_bodyOutput extends association
	 connect Clause[*] --> Actions_BasicActions_OutputPin[0:*];

//
abstract node class ActivityEdge;
edge class Activities_CompleteStructuredActivities_ActivityEdge_inStructuredNode extends association
	 connect ActivityEdge[*] --> Activities_CompleteStructuredActivities_StructuredActivityNode[0:1];
edge class Activities_CompleteStructuredActivities_ActivityEdge_inGroup extends association
	 connect ActivityEdge[*] --> Activities_CompleteStructuredActivities_ActivityGroup[0:*];

//
abstract node class ActivityGroup;
edge class Activities_CompleteStructuredActivities_ActivityGroup_containedEdge extends association
	 connect ActivityGroup[*] --> Activities_CompleteStructuredActivities_ActivityEdge[0:*];

//An activity is the specification of parameterized behavior as the coordinated sequencing of subordinate units whose individual elements are actions.
node class Activity extends CommonBehaviors_BasicBehaviors_Behavior;
edge class Activities_FundamentalActivities_Activity_node extends association
	 connect Activity[*] --> Activities_FundamentalActivities_ActivityNode[0:*];
edge class Activities_FundamentalActivities_Activity_group extends association
	 connect Activity[*] --> Activities_FundamentalActivities_ActivityGroup[0:*];

//ActivityGroup is an abstract class for defining sets of nodes and edges in an activity.
abstract node class ActivityGroup extends Classes_Kernel_Element;
edge class Activities_FundamentalActivities_ActivityGroup_containedNode extends association
	 connect ActivityGroup[*] --> Activities_FundamentalActivities_ActivityNode[0:*];
edge class Activities_FundamentalActivities_ActivityGroup_inActivity extends association
	 connect ActivityGroup[*] --> Activities_FundamentalActivities_Activity[0:1];
edge class Activities_FundamentalActivities_ActivityGroup_subgroup extends association
	 connect ActivityGroup[*] --> Activities_FundamentalActivities_ActivityGroup[0:*];
edge class Activities_FundamentalActivities_ActivityGroup_superGroup extends association
	 connect ActivityGroup[*] --> Activities_FundamentalActivities_ActivityGroup[0:1];

//An action represents a single step within an activity, that is, one that is not further decomposed within the activity.
abstract node class Action extends Activities_FundamentalActivities_ActivityNode;

//ActivityNode is an abstract class for points in the flow of an activity connected by edges.
abstract node class ActivityNode extends Classes_Kernel_NamedElement;
edge class Activities_FundamentalActivities_ActivityNode_activity extends association
	 connect ActivityNode[*] --> Activities_FundamentalActivities_Activity[0:1];
edge class Activities_FundamentalActivities_ActivityNode_inGroup extends association
	 connect ActivityNode[*] --> Activities_FundamentalActivities_ActivityGroup[0:*];

//The default multiplicity of an extension end is 0..1.
node class ExtensionEnd;
edge class AuxiliaryConstructs_Profiles_ExtensionEnd_lower extends attribute
	 connect ExtensionEnd[*] --> [0:1];

//An information item is an abstraction of all kinds of information that can be exchanged between objects. It is a kind of classifier intended for representing information in a very abstract way, one which cannot be instantiated.
node class InformationItem extends Classes_Kernel_Classifier;
edge class AuxiliaryConstructs_InformationFlows_InformationItem_represented extends association
	 connect InformationItem[*] --> Classes_Kernel_Classifier[0:*];

//An information flow specifies that one or more information items circulates from its sources to its targets. Information flows require some kind of information channel for transmitting information items from the source to the destination. An information channel is represented in various ways depending on the nature of its sources and targets. It may be represented by connectors, links, associations, or even dependencies. For example, if the source and destination are parts in some composite structure such as a collaboration, then the information channel is likely to be represented by a connector between them. Or, if the source and target are objects (which are a kind of instance specification), they may be represented by a link that joins the two, and so on.
node class InformationFlow extends Classes_Kernel_DirectedRelationship, Classes_Kernel_PackageableElement;
edge class AuxiliaryConstructs_InformationFlows_InformationFlow_realization extends association
	 connect InformationFlow[*] --> Classes_Kernel_Relationship[0:*];
edge class AuxiliaryConstructs_InformationFlows_InformationFlow_conveyed extends association
	 connect InformationFlow[*] --> Classes_Kernel_Classifier[1:*];
edge class AuxiliaryConstructs_InformationFlows_InformationFlow_informationSource extends association
	 connect InformationFlow[*] --> Classes_Kernel_NamedElement[1:*];
edge class AuxiliaryConstructs_InformationFlows_InformationFlow_informationTarget extends association
	 connect InformationFlow[*] --> Classes_Kernel_NamedElement[1:*];
edge class AuxiliaryConstructs_InformationFlows_InformationFlow_realizingActivityEdge extends association
	 connect InformationFlow[*] --> Activities_BasicActivities_ActivityEdge[0:*];
edge class AuxiliaryConstructs_InformationFlows_InformationFlow_realizingConnector extends association
	 connect InformationFlow[*] --> CompositeStructures_InternalStructures_Connector[0:*];
edge class AuxiliaryConstructs_InformationFlows_InformationFlow_realizingMessage extends association
	 connect InformationFlow[*] --> Interactions_BasicInteractions_Message[0:*];

//A model captures a view of a physical system. It is an abstraction of the physical system, with a certain purpose. This purpose determines what is to be included in the model and what is irrelevant. Thus the model completely describes those aspects of the physical system that are relevant to the purpose of the model, at the appropriate level of detail.
node class Model extends Classes_Kernel_Package;
edge class AuxiliaryConstructs_Models_Model_viewpoint extends attribute
	 connect Model[*] --> [0:1];

//A template signature bundles the set of formal template parameters for a templated element.
node class TemplateSignature extends Classes_Kernel_Element;
edge class AuxiliaryConstructs_Templates_TemplateSignature_parameter extends association
	 connect TemplateSignature[*] --> AuxiliaryConstructs_Templates_TemplateParameter[1:*];
edge class AuxiliaryConstructs_Templates_TemplateSignature_ownedParameter extends association
	 connect TemplateSignature[*] --> AuxiliaryConstructs_Templates_TemplateParameter[0:*];
edge class AuxiliaryConstructs_Templates_TemplateSignature_template extends association
	 connect TemplateSignature[*] --> AuxiliaryConstructs_Templates_TemplateableElement[1:1];

//A named element supports using a string expression to specify its name. This allows names of model elements to involve template parameters. The actual name is evaluated from the string expression only when it is sensible to do so (e.g., when a template is bound).
abstract node class NamedElement extends Classes_Kernel_Element;
edge class AuxiliaryConstructs_Templates_NamedElement_nameExpression extends association
	 connect NamedElement[*] --> AuxiliaryConstructs_Templates_StringExpression[0:1];

//A template parameter exposes a parameterable element as a formal template parameter of a template.
node class TemplateParameter extends Classes_Kernel_Element;
edge class AuxiliaryConstructs_Templates_TemplateParameter_signature extends association
	 connect TemplateParameter[*] --> AuxiliaryConstructs_Templates_TemplateSignature[1:1];
edge class AuxiliaryConstructs_Templates_TemplateParameter_parameteredElement extends association
	 connect TemplateParameter[*] --> AuxiliaryConstructs_Templates_ParameterableElement[1:1];
edge class AuxiliaryConstructs_Templates_TemplateParameter_ownedParameteredElement extends association
	 connect TemplateParameter[*] --> AuxiliaryConstructs_Templates_ParameterableElement[0:1];
edge class AuxiliaryConstructs_Templates_TemplateParameter_default extends association
	 connect TemplateParameter[*] --> AuxiliaryConstructs_Templates_ParameterableElement[0:1];
edge class AuxiliaryConstructs_Templates_TemplateParameter_ownedDefault extends association
	 connect TemplateParameter[*] --> AuxiliaryConstructs_Templates_ParameterableElement[0:1];

//An expression that specifies a string value that is derived by concatenating a set of sub string expressions, some of which might be template parameters.
node class StringExpression extends AuxiliaryConstructs_Templates_TemplateableElement, Classes_Kernel_Expression;
edge class AuxiliaryConstructs_Templates_StringExpression_subExpression extends association
	 connect StringExpression[*] --> AuxiliaryConstructs_Templates_StringExpression[0:*];
edge class AuxiliaryConstructs_Templates_StringExpression_owningExpression extends association
	 connect StringExpression[*] --> AuxiliaryConstructs_Templates_StringExpression[0:1];

//A template binding represents a relationship between a templateable element and a template. A template binding specifies the substitutions of actual parameters for the formal parameters of the template.
node class TemplateBinding extends Classes_Kernel_DirectedRelationship;
edge class AuxiliaryConstructs_Templates_TemplateBinding_boundElement extends association
	 connect TemplateBinding[*] --> AuxiliaryConstructs_Templates_TemplateableElement[1:1];
edge class AuxiliaryConstructs_Templates_TemplateBinding_signature extends association
	 connect TemplateBinding[*] --> AuxiliaryConstructs_Templates_TemplateSignature[1:1];
edge class AuxiliaryConstructs_Templates_TemplateBinding_parameterSubstitution extends association
	 connect TemplateBinding[*] --> AuxiliaryConstructs_Templates_TemplateParameterSubstitution[0:*];

//A template parameter substitution relates the actual parameter(s) to a formal template parameter as part of a template binding.
node class TemplateParameterSubstitution extends Classes_Kernel_Element;
edge class AuxiliaryConstructs_Templates_TemplateParameterSubstitution_formal extends association
	 connect TemplateParameterSubstitution[*] --> AuxiliaryConstructs_Templates_TemplateParameter[1:1];
edge class AuxiliaryConstructs_Templates_TemplateParameterSubstitution_templateBinding extends association
	 connect TemplateParameterSubstitution[*] --> AuxiliaryConstructs_Templates_TemplateBinding[1:1];
edge class AuxiliaryConstructs_Templates_TemplateParameterSubstitution_actual extends association
	 connect TemplateParameterSubstitution[*] --> AuxiliaryConstructs_Templates_ParameterableElement[1:*];
edge class AuxiliaryConstructs_Templates_TemplateParameterSubstitution_ownedActual extends association
	 connect TemplateParameterSubstitution[*] --> AuxiliaryConstructs_Templates_ParameterableElement[0:*];

//A templateable element is an element that can optionally be defined as a template and bound to other templates.
abstract node class TemplateableElement extends Classes_Kernel_Element;
edge class AuxiliaryConstructs_Templates_TemplateableElement_templateBinding extends association
	 connect TemplateableElement[*] --> AuxiliaryConstructs_Templates_TemplateBinding[0:*];
edge class AuxiliaryConstructs_Templates_TemplateableElement_ownedTemplateSignature extends association
	 connect TemplateableElement[*] --> AuxiliaryConstructs_Templates_TemplateSignature[0:1];

//A parameterable element is an element that can be exposed as a formal template parameter for a template, or specified as an actual parameter in a binding of a template.
abstract node class ParameterableElement extends Classes_Kernel_Element;
edge class AuxiliaryConstructs_Templates_ParameterableElement_templateParameter extends association
	 connect ParameterableElement[*] --> AuxiliaryConstructs_Templates_TemplateParameter[0:1];
edge class AuxiliaryConstructs_Templates_ParameterableElement_owningTemplateParameter extends association
	 connect ParameterableElement[*] --> AuxiliaryConstructs_Templates_TemplateParameter[0:1];

//Property specializes ParameterableElement to specify that a property can be exposed as a formal template parameter, and provided as an actual parameter in a binding of a template.
node class Property extends AuxiliaryConstructs_Templates_ParameterableElement, AuxiliaryConstructs_Templates_TemplateableElement;

//ValueSpecification specializes ParameterableElement to specify that a value specification can be exposed as a formal template parameter, and provided as an actual parameter in a binding of a template.
abstract node class ValueSpecification extends AuxiliaryConstructs_Templates_ParameterableElement;

//Operation specializes TemplateableElement in order to support specification of template operations and bound operations. Operation specializes ParameterableElement to specify that an operation can be exposed as a formal template parameter, and provided as an actual parameter in a binding of a template.
node class Operation extends AuxiliaryConstructs_Templates_ParameterableElement, AuxiliaryConstructs_Templates_TemplateableElement;
edge class AuxiliaryConstructs_Templates_Operation_templateParameter extends association
	 connect Operation[*] --> AuxiliaryConstructs_Templates_OperationTemplateParameter[0:1];

//An operation template parameter exposes an operation as a formal parameter for a template.
node class OperationTemplateParameter extends AuxiliaryConstructs_Templates_TemplateParameter;
edge class AuxiliaryConstructs_Templates_OperationTemplateParameter_parameteredElement extends association
	 connect OperationTemplateParameter[*] --> AuxiliaryConstructs_Templates_Operation[1:1];

//Packageable elements are able to serve as a template parameter.
abstract node class PackageableElement extends AuxiliaryConstructs_Templates_ParameterableElement;

//Classifier is defined to be a kind of templateable element so that a classifier can be parameterized. It is also defined to be a kind of parameterable element so that a classifier can be a formal template parameter.
abstract node class Classifier extends AuxiliaryConstructs_Templates_TemplateableElement, AuxiliaryConstructs_Templates_ParameterableElement, Classes_Kernel_Namespace;
edge class AuxiliaryConstructs_Templates_Classifier_ownedTemplateSignature extends association
	 connect Classifier[*] --> AuxiliaryConstructs_Templates_RedefinableTemplateSignature[0:1];
edge class AuxiliaryConstructs_Templates_Classifier_templateParameter extends association
	 connect Classifier[*] --> AuxiliaryConstructs_Templates_ClassifierTemplateParameter[0:1];

//A classifier template parameter exposes a classifier as a formal template parameter.
node class ClassifierTemplateParameter extends AuxiliaryConstructs_Templates_TemplateParameter;
edge class AuxiliaryConstructs_Templates_ClassifierTemplateParameter_parameteredElement extends association
	 connect ClassifierTemplateParameter[*] --> AuxiliaryConstructs_Templates_Classifier[1:1];
edge class AuxiliaryConstructs_Templates_ClassifierTemplateParameter_defaultClassifier extends association
	 connect ClassifierTemplateParameter[*] --> AuxiliaryConstructs_Templates_Classifier[0:1];
edge class AuxiliaryConstructs_Templates_ClassifierTemplateParameter_constrainingClassifier extends association
	 connect ClassifierTemplateParameter[*] --> AuxiliaryConstructs_Templates_Classifier[0:1];

//A redefinable template signature supports the addition of formal template parameters in a specialization of a template classifier.
node class RedefinableTemplateSignature extends Classes_Kernel_RedefinableElement, AuxiliaryConstructs_Templates_TemplateSignature;
edge class AuxiliaryConstructs_Templates_RedefinableTemplateSignature_classifier extends association
	 connect RedefinableTemplateSignature[*] --> AuxiliaryConstructs_Templates_Classifier[1:1];
edge class AuxiliaryConstructs_Templates_RedefinableTemplateSignature_extendedSignature extends association
	 connect RedefinableTemplateSignature[*] --> AuxiliaryConstructs_Templates_RedefinableTemplateSignature[0:*];
edge class AuxiliaryConstructs_Templates_RedefinableTemplateSignature_inheritedParameter extends association
	 connect RedefinableTemplateSignature[*] --> AuxiliaryConstructs_Templates_TemplateParameter[0:*];

//A connectable element may be exposed as a connectable element template parameter.
abstract node class ConnectableElement extends AuxiliaryConstructs_Templates_ParameterableElement;
edge class AuxiliaryConstructs_Templates_ConnectableElement_templateParameter extends association
	 connect ConnectableElement[*] --> AuxiliaryConstructs_Templates_ConnectableElementTemplateParameter[0:1];

//A connectable element template parameter exposes a connectable element as a formal parameter for a template.
node class ConnectableElementTemplateParameter extends AuxiliaryConstructs_Templates_TemplateParameter;
edge class AuxiliaryConstructs_Templates_ConnectableElementTemplateParameter_parameteredElement extends association
	 connect ConnectableElementTemplateParameter[*] --> AuxiliaryConstructs_Templates_ConnectableElement[1:1];

//Package specializes TemplateableElement and PackageableElement specializes ParameterableElement to specify that a package can be used as a template and a PackageableElement as a template parameter.
node class Package extends AuxiliaryConstructs_Templates_TemplateableElement;

//An element is a constituent of a model. As such, it has the capability of owning other elements.
abstract node class Element;
edge class Classes_Kernel_Element_ownedElement extends association
	 connect Element[*] --> Classes_Kernel_Element[0:*];
edge class Classes_Kernel_Element_owner extends association
	 connect Element[*] --> Classes_Kernel_Element[0:1];
edge class Classes_Kernel_Element_ownedComment extends association
	 connect Element[*] --> Classes_Kernel_Comment[0:*];

//A comment is a textual annotation that can be attached to a set of elements.
node class Comment extends Classes_Kernel_Element;
edge class Classes_Kernel_Comment_body extends attribute
	 connect Comment[*] --> [0:1];
edge class Classes_Kernel_Comment_annotatedElement extends association
	 connect Comment[*] --> Classes_Kernel_Element[0:*];

//A directed relationship represents a relationship between a collection of source model elements and a collection of target model elements.
abstract node class DirectedRelationship extends Classes_Kernel_Relationship;
edge class Classes_Kernel_DirectedRelationship_source extends association
	 connect DirectedRelationship[*] --> Classes_Kernel_Element[1:*];
edge class Classes_Kernel_DirectedRelationship_target extends association
	 connect DirectedRelationship[*] --> Classes_Kernel_Element[1:*];

//A named element is an element in a model that may have a name.
abstract node class NamedElement extends Classes_Kernel_Element;
edge class Classes_Kernel_NamedElement_name extends attribute
	 connect NamedElement[*] --> [0:1];
edge class Classes_Kernel_NamedElement_visibility extends attribute
	 connect NamedElement[*] --> Classes_Kernel_VisibilityKind[0:1];
edge class Classes_Kernel_NamedElement_qualifiedName extends attribute
	 connect NamedElement[*] --> [0:1];
edge class Classes_Kernel_NamedElement_namespace extends association
	 connect NamedElement[*] --> Classes_Kernel_Namespace[0:1];

//A packageable element indicates a named element that may be owned directly by a package.
abstract node class PackageableElement extends Classes_Kernel_NamedElement;

//An opaque expression is an uninterpreted textual statement that denotes a (possibly empty) set of values when evaluated in a context.
node class OpaqueExpression extends Classes_Kernel_ValueSpecification;
edge class Classes_Kernel_OpaqueExpression_body extends attribute
	 connect OpaqueExpression[*] --> [0:*];
edge class Classes_Kernel_OpaqueExpression_language extends attribute
	 connect OpaqueExpression[*] --> [0:*];

//A literal specification identifies a literal constant being modeled.
abstract node class LiteralSpecification extends Classes_Kernel_ValueSpecification;

//A literal integer is a specification of an integer value.
node class LiteralInteger extends Classes_Kernel_LiteralSpecification;

//A literal string is a specification of a string value.
node class LiteralString extends Classes_Kernel_LiteralSpecification;
edge class Classes_Kernel_LiteralString_value extends attribute
	 connect LiteralString[*] --> [0:1];

//A literal Boolean is a specification of a Boolean value.
node class LiteralBoolean extends Classes_Kernel_LiteralSpecification;

//A literal null specifies the lack of a value.
node class LiteralNull extends Classes_Kernel_LiteralSpecification;

//A constraint is a condition or restriction expressed in natural language text or in a machine readable language for the purpose of declaring some of the semantics of an element.
node class Constraint extends Classes_Kernel_PackageableElement;
edge class Classes_Kernel_Constraint_constrainedElement extends association
	 connect Constraint[*] --> Classes_Kernel_Element[0:*];
edge class Classes_Kernel_Constraint_specification extends association
	 connect Constraint[*] --> Classes_Kernel_ValueSpecification[1:1];
edge class Classes_Kernel_Constraint_context extends association
	 connect Constraint[*] --> Classes_Kernel_Namespace[0:1];

//An element import identifies an element in another package, and allows the element to be referenced using its name without a qualifier.
node class ElementImport extends Classes_Kernel_DirectedRelationship;
edge class Classes_Kernel_ElementImport_alias extends attribute
	 connect ElementImport[*] --> [0:1];
edge class Classes_Kernel_ElementImport_importedElement extends association
	 connect ElementImport[*] --> Classes_Kernel_PackageableElement[1:1];
edge class Classes_Kernel_ElementImport_importingNamespace extends association
	 connect ElementImport[*] --> Classes_Kernel_Namespace[1:1];

//A multiplicity is a definition of an inclusive interval of non-negative integers beginning with a lower bound and ending with a (possibly infinite) upper bound. A multiplicity element embeds this information to specify the allowable cardinalities for an instantiation of this element.
abstract node class MultiplicityElement extends Classes_Kernel_Element;
edge class Classes_Kernel_MultiplicityElement_upper extends attribute
	 connect MultiplicityElement[*] --> [0:1];
edge class Classes_Kernel_MultiplicityElement_lower extends attribute
	 connect MultiplicityElement[*] --> [0:1];
edge class Classes_Kernel_MultiplicityElement_upperValue extends association
	 connect MultiplicityElement[*] --> Classes_Kernel_ValueSpecification[0:1];
edge class Classes_Kernel_MultiplicityElement_lowerValue extends association
	 connect MultiplicityElement[*] --> Classes_Kernel_ValueSpecification[0:1];

//A typed element has a type.
abstract node class TypedElement extends Classes_Kernel_NamedElement;
edge class Classes_Kernel_TypedElement_type extends association
	 connect TypedElement[*] --> Classes_Kernel_Type[0:1];

//A classifier is a classification of instances - it describes a set of instances that have features in common. A classifier can specify a generalization hierarchy by referencing its general classifiers.
abstract node class Classifier extends Classes_Kernel_RedefinableElement, Classes_Kernel_Namespace, Classes_Kernel_Type;
edge class Classes_Kernel_Classifier_generalization extends association
	 connect Classifier[*] --> Classes_Kernel_Generalization[0:*];
edge class Classes_Kernel_Classifier_feature extends association
	 connect Classifier[*] --> Classes_Kernel_Feature[0:*];
edge class Classes_Kernel_Classifier_inheritedMember extends association
	 connect Classifier[*] --> Classes_Kernel_NamedElement[0:*];
edge class Classes_Kernel_Classifier_attribute extends association
	 connect Classifier[*] --> Classes_Kernel_Property[0:*];
edge class Classes_Kernel_Classifier_redefinedClassifier extends association
	 connect Classifier[*] --> Classes_Kernel_Classifier[0:*];
edge class Classes_Kernel_Classifier_general extends association
	 connect Classifier[*] --> Classes_Kernel_Classifier[0:*];

//A feature declares a behavioral or structural characteristic of instances of classifiers.
abstract node class Feature extends Classes_Kernel_RedefinableElement;
edge class Classes_Kernel_Feature_featuringClassifier extends association
	 connect Feature[*] --> Classes_Kernel_Classifier[0:*];

//A redefinable element is an element that, when defined in the context of a classifier, can be redefined more specifically or differently in the context of another classifier that specializes (directly or indirectly) the context classifier.
abstract node class RedefinableElement extends Classes_Kernel_NamedElement;
edge class Classes_Kernel_RedefinableElement_redefinedElement extends association
	 connect RedefinableElement[*] --> Classes_Kernel_RedefinableElement[0:*];
edge class Classes_Kernel_RedefinableElement_redefinitionContext extends association
	 connect RedefinableElement[*] --> Classes_Kernel_Classifier[0:*];

//A generalization is a taxonomic relationship between a more general classifier and a more specific classifier. Each instance of the specific classifier is also an indirect instance of the general classifier. Thus, the specific classifier inherits the features of the more general classifier.
node class Generalization extends Classes_Kernel_DirectedRelationship;
edge class Classes_Kernel_Generalization_isSubstitutable extends attribute
	 connect Generalization[*] --> [0:1];
edge class Classes_Kernel_Generalization_specific extends association
	 connect Generalization[*] --> Classes_Kernel_Classifier[1:1];
edge class Classes_Kernel_Generalization_general extends association
	 connect Generalization[*] --> Classes_Kernel_Classifier[1:1];

//A behavioral feature is a feature of a classifier that specifies an aspect of the behavior of its instances.
abstract node class BehavioralFeature extends Classes_Kernel_Feature, Classes_Kernel_Namespace;
edge class Classes_Kernel_BehavioralFeature_ownedParameter extends association
	 connect BehavioralFeature[*] --> Classes_Kernel_Parameter[0:*];
edge class Classes_Kernel_BehavioralFeature_raisedException extends association
	 connect BehavioralFeature[*] --> Classes_Kernel_Type[0:*];

//A parameter is a specification of an argument used to pass information into or out of an invocation of a behavioral feature.
node class Parameter extends Classes_Kernel_TypedElement, Classes_Kernel_MultiplicityElement;
edge class Classes_Kernel_Parameter_default extends attribute
	 connect Parameter[*] --> [0:1];
edge class Classes_Kernel_Parameter_defaultValue extends association
	 connect Parameter[*] --> Classes_Kernel_ValueSpecification[0:1];
edge class Classes_Kernel_Parameter_operation extends association
	 connect Parameter[*] --> Classes_Kernel_Operation[0:1];

//By specializing multiplicity element, it supports a multiplicity that specifies valid cardinalities for the collection of values associated with an instantiation of the structural feature.
abstract node class StructuralFeature extends Classes_Kernel_Feature, Classes_Kernel_TypedElement, Classes_Kernel_MultiplicityElement;

//An instance specification is a model element that represents an instance in a modeled system.
node class InstanceSpecification extends Classes_Kernel_PackageableElement;
edge class Classes_Kernel_InstanceSpecification_classifier extends association
	 connect InstanceSpecification[*] --> Classes_Kernel_Classifier[0:*];
edge class Classes_Kernel_InstanceSpecification_slot extends association
	 connect InstanceSpecification[*] --> Classes_Kernel_Slot[0:*];
edge class Classes_Kernel_InstanceSpecification_specification extends association
	 connect InstanceSpecification[*] --> Classes_Kernel_ValueSpecification[0:1];

//A slot specifies that an entity modeled by an instance specification has a value or values for a specific structural feature.
node class Slot extends Classes_Kernel_Element;
edge class Classes_Kernel_Slot_owningInstance extends association
	 connect Slot[*] --> Classes_Kernel_InstanceSpecification[1:1];
edge class Classes_Kernel_Slot_definingFeature extends association
	 connect Slot[*] --> Classes_Kernel_StructuralFeature[1:1];
edge class Classes_Kernel_Slot_value extends association
	 connect Slot[*] --> Classes_Kernel_ValueSpecification[0:*];

//A package is used to group elements, and provides a namespace for the grouped elements.
node class Package extends Classes_Kernel_PackageableElement, Classes_Kernel_Namespace;
edge class Classes_Kernel_Package_packageMerge extends association
	 connect Package[*] --> Classes_Kernel_PackageMerge[0:*];
edge class Classes_Kernel_Package_packagedElement extends association
	 connect Package[*] --> Classes_Kernel_PackageableElement[0:*];
edge class Classes_Kernel_Package_ownedType extends association
	 connect Package[*] --> Classes_Kernel_Type[0:*];
edge class Classes_Kernel_Package_nestedPackage extends association
	 connect Package[*] --> Classes_Kernel_Package[0:*];
edge class Classes_Kernel_Package_nestingPackage extends association
	 connect Package[*] --> Classes_Kernel_Package[0:1];

//A package import is a relationship that allows the use of unqualified names to refer to package members from other namespaces.
node class PackageImport extends Classes_Kernel_DirectedRelationship;
edge class Classes_Kernel_PackageImport_importingNamespace extends association
	 connect PackageImport[*] --> Classes_Kernel_Namespace[1:1];
edge class Classes_Kernel_PackageImport_importedPackage extends association
	 connect PackageImport[*] --> Classes_Kernel_Package[1:1];

//A class describes a set of objects that share the same specifications of features, constraints, and semantics.
node class Class extends Classes_Kernel_Classifier;
edge class Classes_Kernel_Class_nestedClassifier extends association
	 connect Class[*] --> Classes_Kernel_Classifier[0:*];
edge class Classes_Kernel_Class_ownedAttribute extends association
	 connect Class[*] --> Classes_Kernel_Property[0:*];
edge class Classes_Kernel_Class_ownedOperation extends association
	 connect Class[*] --> Classes_Kernel_Operation[0:*];
edge class Classes_Kernel_Class_superClass extends association
	 connect Class[*] --> Classes_Kernel_Class[0:*];

//A property is a structural feature of a classifier that characterizes instances of the classifier. A property related by ownedAttribute to a classifier (other than an association) represents an attribute and might also represent an association end. It relates an instance of the class to a value or set of values of the type of the attribute. A property related by memberEnd or its specializations to an association represents an end of the association. The type of the property is the type of the end of the association.
node class Property extends Classes_Kernel_StructuralFeature;
edge class Classes_Kernel_Property_default extends attribute
	 connect Property[*] --> [0:1];
edge class Classes_Kernel_Property_class extends association
	 connect Property[*] --> Classes_Kernel_Class[0:1];
edge class Classes_Kernel_Property_redefinedProperty extends association
	 connect Property[*] --> Classes_Kernel_Property[0:*];
edge class Classes_Kernel_Property_owningAssociation extends association
	 connect Property[*] --> Classes_Kernel_Association[0:1];
edge class Classes_Kernel_Property_datatype extends association
	 connect Property[*] --> Classes_Kernel_DataType[0:1];
edge class Classes_Kernel_Property_defaultValue extends association
	 connect Property[*] --> Classes_Kernel_ValueSpecification[0:1];
edge class Classes_Kernel_Property_opposite extends association
	 connect Property[*] --> Classes_Kernel_Property[0:1];
edge class Classes_Kernel_Property_subsettedProperty extends association
	 connect Property[*] --> Classes_Kernel_Property[0:*];
edge class Classes_Kernel_Property_association extends association
	 connect Property[*] --> Classes_Kernel_Association[0:1];

//An operation is a behavioral feature of a classifier that specifies the name, type, parameters, and constraints for invoking an associated behavior.
node class Operation extends Classes_Kernel_BehavioralFeature;
edge class Classes_Kernel_Operation_lower extends attribute
	 connect Operation[*] --> [0:1];
edge class Classes_Kernel_Operation_upper extends attribute
	 connect Operation[*] --> [0:1];
edge class Classes_Kernel_Operation_class extends association
	 connect Operation[*] --> Classes_Kernel_Class[0:1];
edge class Classes_Kernel_Operation_precondition extends association
	 connect Operation[*] --> Classes_Kernel_Constraint[0:*];
edge class Classes_Kernel_Operation_postcondition extends association
	 connect Operation[*] --> Classes_Kernel_Constraint[0:*];
edge class Classes_Kernel_Operation_redefinedOperation extends association
	 connect Operation[*] --> Classes_Kernel_Operation[0:*];
edge class Classes_Kernel_Operation_datatype extends association
	 connect Operation[*] --> Classes_Kernel_DataType[0:1];
edge class Classes_Kernel_Operation_bodyCondition extends association
	 connect Operation[*] --> Classes_Kernel_Constraint[0:1];
edge class Classes_Kernel_Operation_type extends association
	 connect Operation[*] --> Classes_Kernel_Type[0:1];
edge class Classes_Kernel_Operation_ownedParameter extends association
	 connect Operation[*] --> Classes_Kernel_Parameter[0:*];
edge class Classes_Kernel_Operation_raisedException extends association
	 connect Operation[*] --> Classes_Kernel_Type[0:*];

//A data type is a type whose instances are identified only by their value. A data type may contain attributes to support the modeling of structured data types.
node class DataType extends Classes_Kernel_Classifier;
edge class Classes_Kernel_DataType_ownedAttribute extends association
	 connect DataType[*] --> Classes_Kernel_Property[0:*];
edge class Classes_Kernel_DataType_ownedOperation extends association
	 connect DataType[*] --> Classes_Kernel_Operation[0:*];

//An enumeration is a data type whose values are enumerated in the model as enumeration literals.
node class Enumeration extends Classes_Kernel_DataType;
edge class Classes_Kernel_Enumeration_ownedLiteral extends association
	 connect Enumeration[*] --> Classes_Kernel_EnumerationLiteral[0:*];

//An enumeration literal is a user-defined data value for an enumeration.
node class EnumerationLiteral extends Classes_Kernel_InstanceSpecification;
edge class Classes_Kernel_EnumerationLiteral_enumeration extends association
	 connect EnumerationLiteral[*] --> Classes_Kernel_Enumeration[0:1];

//A primitive type defines a predefined data type, without any relevant substructure (i.e., it has no parts in the context of UML). A primitive datatype may have an algebra and operations defined outside of UML, for example, mathematically.
node class PrimitiveType extends Classes_Kernel_DataType;

//An association describes a set of tuples whose values refer to typed instances. An instance of an association is called a link.
node class Association extends Classes_Kernel_Relationship, Classes_Kernel_Classifier;
edge class Classes_Kernel_Association_ownedEnd extends association
	 connect Association[*] --> Classes_Kernel_Property[0:*];
edge class Classes_Kernel_Association_endType extends association
	 connect Association[*] --> Classes_Kernel_Type[1:*];
edge class Classes_Kernel_Association_memberEnd extends association
	 connect Association[*] --> Classes_Kernel_Property[2:*];
edge class Classes_Kernel_Association_navigableOwnedEnd extends association
	 connect Association[*] --> Classes_Kernel_Property[0:*];

//A namespace is an element in a model that contains a set of named elements that can be identified by name.
abstract node class Namespace extends Classes_Kernel_NamedElement;
edge class Classes_Kernel_Namespace_elementImport extends association
	 connect Namespace[*] --> Classes_Kernel_ElementImport[0:*];
edge class Classes_Kernel_Namespace_packageImport extends association
	 connect Namespace[*] --> Classes_Kernel_PackageImport[0:*];
edge class Classes_Kernel_Namespace_ownedRule extends association
	 connect Namespace[*] --> Classes_Kernel_Constraint[0:*];
edge class Classes_Kernel_Namespace_ownedMember extends association
	 connect Namespace[*] --> Classes_Kernel_NamedElement[0:*];
edge class Classes_Kernel_Namespace_member extends association
	 connect Namespace[*] --> Classes_Kernel_NamedElement[0:*];
edge class Classes_Kernel_Namespace_importedMember extends association
	 connect Namespace[*] --> Classes_Kernel_PackageableElement[0:*];

//A value specification is the specification of a (possibly empty) set of instances, including both objects and data values.
abstract node class ValueSpecification extends Classes_Kernel_TypedElement, Classes_Kernel_PackageableElement;

//Relationship is an abstract concept that specifies some kind of relationship between elements.
abstract node class Relationship extends Classes_Kernel_Element;
edge class Classes_Kernel_Relationship_relatedElement extends association
	 connect Relationship[*] --> Classes_Kernel_Element[1:*];

//A package merge defines how the contents of one package are extended by the contents of another package.
node class PackageMerge extends Classes_Kernel_DirectedRelationship;
edge class Classes_Kernel_PackageMerge_receivingPackage extends association
	 connect PackageMerge[*] --> Classes_Kernel_Package[1:1];
edge class Classes_Kernel_PackageMerge_mergedPackage extends association
	 connect PackageMerge[*] --> Classes_Kernel_Package[1:1];

//An instance value is a value specification that identifies an instance.
node class InstanceValue extends Classes_Kernel_ValueSpecification;
edge class Classes_Kernel_InstanceValue_instance extends association
	 connect InstanceValue[*] --> Classes_Kernel_InstanceSpecification[1:1];

//A literal unlimited natural is a specification of an unlimited natural number.
node class LiteralUnlimitedNatural extends Classes_Kernel_LiteralSpecification;

//A type constrains the values represented by a typed element.
abstract node class Type extends Classes_Kernel_PackageableElement;
edge class Classes_Kernel_Type_package extends association
	 connect Type[*] --> Classes_Kernel_Package[0:1];

//An expression represents a node in an expression tree, which may be non-terminal or terminal. It defines a symbol, and has a possibly empty sequence of operands which are value specifications.
node class Expression extends Classes_Kernel_ValueSpecification;
edge class Classes_Kernel_Expression_symbol extends attribute
	 connect Expression[*] --> [0:1];
edge class Classes_Kernel_Expression_operand extends association
	 connect Expression[*] --> Classes_Kernel_ValueSpecification[0:*];

//An interface is a kind of classifier that represents a declaration of a set of coherent public features and obligations. An interface specifies a contract; any instance of a classifier that realizes the interface must fulfill that contract. The obligations that may be associated with an interface are in the form of various kinds of constraints (such as pre- and post-conditions) or protocol specifications, which may impose ordering restrictions on interactions through the interface.
node class Interface extends Classes_Kernel_Classifier;
edge class Classes_Interfaces_Interface_ownedAttribute extends association
	 connect Interface[*] --> Classes_Kernel_Property[0:*];
edge class Classes_Interfaces_Interface_ownedOperation extends association
	 connect Interface[*] --> Classes_Interfaces_Operation[0:*];
edge class Classes_Interfaces_Interface_nestedClassifier extends association
	 connect Interface[*] --> Classes_Kernel_Classifier[0:*];
edge class Classes_Interfaces_Interface_redefinedInterface extends association
	 connect Interface[*] --> Classes_Interfaces_Interface[0:*];

//An interface realization is a specialized realization relationship between a classifier and an interface. This relationship signifies that the realizing classifier conforms to the contract specified by the interface.
node class InterfaceRealization extends Classes_Dependencies_Realization;
edge class Classes_Interfaces_InterfaceRealization_contract extends association
	 connect InterfaceRealization[*] --> Classes_Interfaces_Interface[1:1];
edge class Classes_Interfaces_InterfaceRealization_implementingClassifier extends association
	 connect InterfaceRealization[*] --> Classes_Interfaces_BehavioredClassifier[1:1];

//A behaviored classifier may have an interface realization.
abstract node class BehavioredClassifier extends Classes_Dependencies_NamedElement, Classes_Kernel_Classifier;
edge class Classes_Interfaces_BehavioredClassifier_interfaceRealization extends association
	 connect BehavioredClassifier[*] --> Classes_Interfaces_InterfaceRealization[0:*];

//
node class Operation extends Classes_Kernel_BehavioralFeature;
edge class Classes_Interfaces_Operation_interface extends association
	 connect Operation[*] --> Classes_Interfaces_Interface[0:1];

//A usage is a relationship in which one element requires another element (or set of elements) for its full implementation or operation. A usage is a dependency in which the client requires the presence of the supplier.
node class Usage extends Classes_Dependencies_Dependency;

//An abstraction is a relationship that relates two elements or sets of elements that represent the same concept at different levels of abstraction or from different viewpoints.
node class Abstraction extends Classes_Dependencies_Dependency;
edge class Classes_Dependencies_Abstraction_mapping extends association
	 connect Abstraction[*] --> Classes_Kernel_OpaqueExpression[0:1];

//A dependency is a relationship that signifies that a single or a set of model elements requires other model elements for their specification or implementation. This means that the complete semantics of the depending elements is either semantically or structurally dependent on the definition of the supplier element(s).
node class Dependency extends Classes_Kernel_DirectedRelationship, Classes_Dependencies_PackageableElement;
edge class Classes_Dependencies_Dependency_supplier extends association
	 connect Dependency[*] --> Classes_Dependencies_NamedElement[1:*];
edge class Classes_Dependencies_Dependency_client extends association
	 connect Dependency[*] --> Classes_Dependencies_NamedElement[1:*];

//Realization is a specialized abstraction relationship between two sets of model elements, one representing a specification (the supplier) and the other represents an implementation of the latter (the client). Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.
node class Realization extends Classes_Dependencies_Abstraction;

//A substitution is a relationship between two classifiers signifies that the substituting classifier complies with the contract specified by the contract classifier. This implies that instances of the substituting classifier are runtime substitutable where instances of the contract classifier are expected.
node class Substitution extends Classes_Dependencies_Realization;
edge class Classes_Dependencies_Substitution_contract extends association
	 connect Substitution[*] --> Classes_Dependencies_Classifier[1:1];
edge class Classes_Dependencies_Substitution_substitutingClassifier extends association
	 connect Substitution[*] --> Classes_Dependencies_Classifier[1:1];

//
abstract node class Classifier extends Classes_Dependencies_NamedElement, Classes_Dependencies_Namespace;
edge class Classes_Dependencies_Classifier_substitution extends association
	 connect Classifier[*] --> Classes_Dependencies_Substitution[0:*];

//
abstract node class NamedElement extends Classes_Kernel_Element;
edge class Classes_Dependencies_NamedElement_clientDependency extends association
	 connect NamedElement[*] --> Classes_Dependencies_Dependency[0:*];
edge class Classes_Dependencies_NamedElement_namespace extends association
	 connect NamedElement[*] --> Classes_Dependencies_Namespace[0:1];

//
abstract node class PackageableElement extends Classes_Dependencies_NamedElement;

//
abstract node class Namespace extends Classes_Dependencies_NamedElement;
edge class Classes_Dependencies_Namespace_ownedMember extends association
	 connect Namespace[*] --> Classes_Dependencies_NamedElement[0:*];

//A generalization set is a packageable element whose instances define collections of subsets of generalization relationships.
node class GeneralizationSet extends Classes_Kernel_PackageableElement;
edge class Classes_PowerTypes_GeneralizationSet_powertype extends association
	 connect GeneralizationSet[*] --> Classes_PowerTypes_Classifier[0:1];
edge class Classes_PowerTypes_GeneralizationSet_generalization extends association
	 connect GeneralizationSet[*] --> Classes_PowerTypes_Generalization[0:*];

//
abstract node class Classifier;
edge class Classes_PowerTypes_Classifier_powertypeExtent extends association
	 connect Classifier[*] --> Classes_PowerTypes_GeneralizationSet[0:*];

//A generalization relates a specific classifier to a more general classifier, and is owned by the specific classifier.
node class Generalization;
edge class Classes_PowerTypes_Generalization_generalizationSet extends association
	 connect Generalization[*] --> Classes_PowerTypes_GeneralizationSet[0:*];

//A model element that has both association and class properties. An AssociationClass can be seen as an association that also has class properties, or as a class that also has association properties. It not only connects a set of classifiers but also defines a set of features that belong to the relationship itself and not to any of the classifiers.
node class AssociationClass extends Classes_Kernel_Association, Classes_Kernel_Class;

//Property represents a declared state of one or more instances in terms of a named relationship to a value or values. When a property is an attribute of a classifier, the value or values are related to the instance of the classifier by being held in slots of the instance. When a property is an association end, the value or values are related to the instance or instances at the other end(s) of the association. The range of valid values represented by the property can be controlled by setting the property's type.
node class Property extends Classes_Kernel_StructuralFeature;
edge class Classes_AssociationClasses_Property_qualifier extends association
	 connect Property[*] --> Classes_AssociationClasses_Property[0:*];
edge class Classes_AssociationClasses_Property_associationEnd extends association
	 connect Property[*] --> Classes_AssociationClasses_Property[0:1];

//A behavioral feature is implemented (realized) by a behavior. A behavioral feature specifies that a classifier will respond to a designated request by invoking its implementing method.
abstract node class BehavioralFeature;
edge class CommonBehaviors_Communications_BehavioralFeature_raisedException extends association
	 connect BehavioralFeature[*] --> Classes_Kernel_Classifier[0:*];

//A call event models the receipt by an object of a message invoking a call of an operation.
node class CallEvent extends CommonBehaviors_Communications_MessageEvent;
edge class CommonBehaviors_Communications_CallEvent_operation extends association
	 connect CallEvent[*] --> CommonBehaviors_Communications_Operation[1:1];

//A change event models a change in the system configuration that makes a condition true.
node class ChangeEvent extends CommonBehaviors_Communications_Event;
edge class CommonBehaviors_Communications_ChangeEvent_changeExpression extends association
	 connect ChangeEvent[*] --> Classes_Kernel_ValueSpecification[1:1];

//A class may be designated as active (i.e., each of its instances having its own thread of control) or passive (i.e., each of its instances executing within the context of some other object). A class may also specify which signals the instances of this class handle.
node class Class extends CommonBehaviors_BasicBehaviors_BehavioredClassifier;
edge class CommonBehaviors_Communications_Class_ownedReception extends association
	 connect Class[*] --> CommonBehaviors_Communications_Reception[0:*];

//A trigger relates an event to a behavior that may affect an instance of the classifier.
node class Trigger extends Classes_Kernel_NamedElement;
edge class CommonBehaviors_Communications_Trigger_event extends association
	 connect Trigger[*] --> CommonBehaviors_Communications_Event[1:1];

//Interfaces may include receptions (in addition to operations).
node class Interface extends Classes_Kernel_Classifier;
edge class CommonBehaviors_Communications_Interface_ownedReception extends association
	 connect Interface[*] --> CommonBehaviors_Communications_Reception[0:*];

//A reception is a declaration stating that a classifier is prepared to react to the receipt of a signal. A reception designates a signal and specifies the expected behavioral response. The details of handling a signal are specified by the behavior associated with the reception or the classifier itself.
node class Reception extends CommonBehaviors_Communications_BehavioralFeature;
edge class CommonBehaviors_Communications_Reception_signal extends association
	 connect Reception[*] --> CommonBehaviors_Communications_Signal[0:1];

//A signal is a specification of send request instances communicated between objects. The receiving object handles the received request instances as specified by its receptions. The data carried by a send request (which was passed to it by the send invocation occurrence that caused that request) are represented as attributes of the signal. A signal is defined independently of the classifiers handling the signal occurrence.
node class Signal extends Classes_Kernel_Classifier;
edge class CommonBehaviors_Communications_Signal_ownedAttribute extends association
	 connect Signal[*] --> Classes_Kernel_Property[0:*];

//A signal event represents the receipt of an asynchronous signal instance. A signal event may, for example, cause a state machine to trigger a transition.
node class SignalEvent extends CommonBehaviors_Communications_MessageEvent;
edge class CommonBehaviors_Communications_SignalEvent_signal extends association
	 connect SignalEvent[*] --> CommonBehaviors_Communications_Signal[1:1];

//A time event specifies a point in time. At the specified time, the event occurs.
node class TimeEvent extends CommonBehaviors_Communications_Event;
edge class CommonBehaviors_Communications_TimeEvent_when extends association
	 connect TimeEvent[*] --> Classes_Kernel_ValueSpecification[1:1];

//A message event specifies the receipt by an object of either a call or a signal.
abstract node class MessageEvent extends CommonBehaviors_Communications_Event;

//A transition trigger associated with an any receive event specifies that the transition is to be triggered by the receipt of any message that is not explicitly referenced in another transition from the same vertex.
node class AnyReceiveEvent extends CommonBehaviors_Communications_MessageEvent;

//A classifier can have behavior specifications defined in its namespace. One of these may specify the behavior of the classifier itself.
abstract node class BehavioredClassifier extends Classes_Kernel_Classifier;
edge class CommonBehaviors_Communications_BehavioredClassifier_ownedTrigger extends association
	 connect BehavioredClassifier[*] --> CommonBehaviors_Communications_Trigger[0:*];

//An event is the specification of some occurrence that may potentially trigger effects by an object.
abstract node class Event extends Classes_Kernel_PackageableElement;

//An operation may invoke both the execution of method behaviors as well as other behavioral responses.
node class Operation;

//Behavior is a specification of how its context classifier changes state over time. This specification may be either a definition of possible behavior execution or emergent behavior, or a selective illustration of an interesting subset of possible executions. The latter form is typically used for capturing examples, such as a trace of a particular execution.
abstract node class Behavior extends Classes_Kernel_Class;
edge class CommonBehaviors_BasicBehaviors_Behavior_redefinedBehavior extends association
	 connect Behavior[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:*];
edge class CommonBehaviors_BasicBehaviors_Behavior_specification extends association
	 connect Behavior[*] --> CommonBehaviors_BasicBehaviors_BehavioralFeature[0:1];
edge class CommonBehaviors_BasicBehaviors_Behavior_ownedParameter extends association
	 connect Behavior[*] --> Classes_Kernel_Parameter[0:*];
edge class CommonBehaviors_BasicBehaviors_Behavior_context extends association
	 connect Behavior[*] --> CommonBehaviors_BasicBehaviors_BehavioredClassifier[0:1];
edge class CommonBehaviors_BasicBehaviors_Behavior_precondition extends association
	 connect Behavior[*] --> Classes_Kernel_Constraint[0:*];
edge class CommonBehaviors_BasicBehaviors_Behavior_postcondition extends association
	 connect Behavior[*] --> Classes_Kernel_Constraint[0:*];

//A classifier can have behavior specifications defined in its namespace. One of these may specify the behavior of the classifier itself.
abstract node class BehavioredClassifier extends Classes_Kernel_Classifier;
edge class CommonBehaviors_BasicBehaviors_BehavioredClassifier_ownedBehavior extends association
	 connect BehavioredClassifier[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:*];
edge class CommonBehaviors_BasicBehaviors_BehavioredClassifier_classifierBehavior extends association
	 connect BehavioredClassifier[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:1];

//Provides a mechanism for precisely defining the behavior of an opaque expression. An opaque expression is defined by a behavior restricted to return one result.
node class OpaqueExpression;
edge class CommonBehaviors_BasicBehaviors_OpaqueExpression_result extends association
	 connect OpaqueExpression[*] --> Classes_Kernel_Parameter[0:1];
edge class CommonBehaviors_BasicBehaviors_OpaqueExpression_behavior extends association
	 connect OpaqueExpression[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:1];

//A behavioral feature is implemented (realized) by a behavior. A behavioral feature specifies that a classifier will respond to a designated request by invoking its implementing method.
abstract node class BehavioralFeature;
edge class CommonBehaviors_BasicBehaviors_BehavioralFeature_method extends association
	 connect BehavioralFeature[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:*];

//An behavior with implementation-specific semantics.
node class OpaqueBehavior extends CommonBehaviors_BasicBehaviors_Behavior;
edge class CommonBehaviors_BasicBehaviors_OpaqueBehavior_body extends attribute
	 connect OpaqueBehavior[*] --> [0:*];
edge class CommonBehaviors_BasicBehaviors_OpaqueBehavior_language extends attribute
	 connect OpaqueBehavior[*] --> [0:*];

//A function behavior is an opaque behavior that does not access or modify any objects or other external data.
node class FunctionBehavior extends CommonBehaviors_BasicBehaviors_OpaqueBehavior;

//A time expression defines a value specification that represents a time value.
node class TimeExpression extends Classes_Kernel_ValueSpecification;
edge class CommonBehaviors_SimpleTime_TimeExpression_expr extends association
	 connect TimeExpression[*] --> Classes_Kernel_ValueSpecification[0:1];
edge class CommonBehaviors_SimpleTime_TimeExpression_observation extends association
	 connect TimeExpression[*] --> CommonBehaviors_SimpleTime_Observation[0:*];

//Duration defines a value specification that specifies the temporal distance between two time instants.
node class Duration extends Classes_Kernel_ValueSpecification;
edge class CommonBehaviors_SimpleTime_Duration_expr extends association
	 connect Duration[*] --> Classes_Kernel_ValueSpecification[0:1];
edge class CommonBehaviors_SimpleTime_Duration_observation extends association
	 connect Duration[*] --> CommonBehaviors_SimpleTime_Observation[0:*];

//A duration interval defines the range between two durations.
node class DurationInterval extends CommonBehaviors_SimpleTime_Interval;
edge class CommonBehaviors_SimpleTime_DurationInterval_min extends association
	 connect DurationInterval[*] --> CommonBehaviors_SimpleTime_Duration[1:1];
edge class CommonBehaviors_SimpleTime_DurationInterval_max extends association
	 connect DurationInterval[*] --> CommonBehaviors_SimpleTime_Duration[1:1];

//A time constraint is a constraint that refers to a time interval.
node class TimeConstraint extends CommonBehaviors_SimpleTime_IntervalConstraint;
edge class CommonBehaviors_SimpleTime_TimeConstraint_specification extends association
	 connect TimeConstraint[*] --> CommonBehaviors_SimpleTime_TimeInterval[1:1];
edge class CommonBehaviors_SimpleTime_TimeConstraint_firstEvent extends attribute
	 connect TimeConstraint[*] --> [0:1];

//A time interval defines the range between two time expressions.
node class TimeInterval extends CommonBehaviors_SimpleTime_Interval;
edge class CommonBehaviors_SimpleTime_TimeInterval_max extends association
	 connect TimeInterval[*] --> CommonBehaviors_SimpleTime_TimeExpression[1:1];
edge class CommonBehaviors_SimpleTime_TimeInterval_min extends association
	 connect TimeInterval[*] --> CommonBehaviors_SimpleTime_TimeExpression[1:1];

//A duration constraint is a constraint that refers to a duration interval.
node class DurationConstraint extends CommonBehaviors_SimpleTime_IntervalConstraint;
edge class CommonBehaviors_SimpleTime_DurationConstraint_specification extends association
	 connect DurationConstraint[*] --> CommonBehaviors_SimpleTime_DurationInterval[1:1];
edge class CommonBehaviors_SimpleTime_DurationConstraint_firstEvent extends attribute
	 connect DurationConstraint[*] --> [0:2];

//An interval constraint is a constraint that refers to an interval.
node class IntervalConstraint extends Classes_Kernel_Constraint;
edge class CommonBehaviors_SimpleTime_IntervalConstraint_specification extends association
	 connect IntervalConstraint[*] --> CommonBehaviors_SimpleTime_Interval[1:1];

//An interval defines the range between two value specifications.
node class Interval extends Classes_Kernel_ValueSpecification;
edge class CommonBehaviors_SimpleTime_Interval_min extends association
	 connect Interval[*] --> Classes_Kernel_ValueSpecification[1:1];
edge class CommonBehaviors_SimpleTime_Interval_max extends association
	 connect Interval[*] --> Classes_Kernel_ValueSpecification[1:1];

//A time event specifies a point in time. At the specified time, the event occurs.
node class TimeEvent extends CommonBehaviors_Communications_Event;
edge class CommonBehaviors_SimpleTime_TimeEvent_when extends association
	 connect TimeEvent[*] --> Classes_Kernel_ValueSpecification[1:1];

//Observation is a superclass of TimeObservation and DurationObservation in order for TimeExpression and Duration to refer to either in a simple way.
abstract node class Observation extends Classes_Kernel_PackageableElement;

//A time observation is a reference to a time instant during an execution. It points out the element in the model to observe and whether the observation is when this model element is entered or when it is exited.
node class TimeObservation extends CommonBehaviors_SimpleTime_Observation;
edge class CommonBehaviors_SimpleTime_TimeObservation_event extends association
	 connect TimeObservation[*] --> Classes_Kernel_NamedElement[1:1];

//A duration observation is a reference to a duration during an execution. It points out the element(s) in the model to observe and whether the observations are when this model element is entered or when it is exited.
node class DurationObservation extends CommonBehaviors_SimpleTime_Observation;
edge class CommonBehaviors_SimpleTime_DurationObservation_event extends association
	 connect DurationObservation[*] --> Classes_Kernel_NamedElement[1:2];
edge class CommonBehaviors_SimpleTime_DurationObservation_firstEvent extends attribute
	 connect DurationObservation[*] --> [0:2];

//In the namespace of a component, all model elements that are involved in or related to its definition are either owned or imported explicitly. This may include, for example, use cases and dependencies (e.g. mappings), packages, components, and artifacts.
node class Component extends Classes_Kernel_Namespace;
edge class Components_PackagingComponents_Component_packagedElement extends association
	 connect Component[*] --> Classes_Kernel_PackageableElement[0:*];

//A component represents a modular part of a system that encapsulates its contents and whose manifestation is replaceable within its environment.
node class Component extends CompositeStructures_StructuredClasses_Class, Classes_Dependencies_NamedElement;
edge class Components_BasicComponents_Component_required extends association
	 connect Component[*] --> Classes_Interfaces_Interface[0:*];
edge class Components_BasicComponents_Component_provided extends association
	 connect Component[*] --> Classes_Interfaces_Interface[0:*];
edge class Components_BasicComponents_Component_realization extends association
	 connect Component[*] --> Components_BasicComponents_ComponentRealization[0:*];

//The realization concept is specialized to (optionally) define the classifiers that realize the contract offered by a component in terms of its provided and required interfaces. The component forms an abstraction from these various classifiers.
node class ComponentRealization extends Classes_Dependencies_Realization;
edge class Components_BasicComponents_ComponentRealization_abstraction extends association
	 connect ComponentRealization[*] --> Components_BasicComponents_Component[0:1];
edge class Components_BasicComponents_ComponentRealization_realizingClassifier extends association
	 connect ComponentRealization[*] --> Classes_Kernel_Classifier[1:1];

//A delegation connector is a connector that links the external contract of a component (as specified by its ports) to the internal realization of that behavior by the component's parts. It represents the forwarding of signals (operation requests and events): a signal that arrives at a port that has a delegation connector to a part or to another port will be passed on to that target for handling. An assembly connector is a connector between two components that defines that one component provides the services that another component requires. An assembly connector is a connector that is defined from a required interface or port to a provided interface or port.
node class Connector;
edge class Components_BasicComponents_Connector_kind extends attribute
	 connect Connector[*] --> Components_BasicComponents_ConnectorKind[0:1];
edge class Components_BasicComponents_Connector_contract extends association
	 connect Connector[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:*];

//A class has the capability to have an internal structure and ports.
node class Class extends CompositeStructures_Ports_EncapsulatedClassifier;

//A collaboration use represents one particular use of a collaboration to explain the relationships between the properties of a classifier. A collaboration use shows how the pattern described by a collaboration is applied in a given context, by binding specific entities from that context to the roles of the collaboration. Depending on the context, these entities could be structural features of a classifier, instance specifications, or even roles in some containing collaboration. There may be multiple occurrences of a given collaboration within a classifier, each involving a different set of roles and connectors. A given role or connector may be involved in multiple occurrences of the same or different collaborations. Associated dependencies map features of the collaboration type to features in the classifier. These dependencies indicate which role in the classifier plays which role in the collaboration.
node class CollaborationUse extends Classes_Kernel_NamedElement;
edge class CompositeStructures_Collaborations_CollaborationUse_type extends association
	 connect CollaborationUse[*] --> CompositeStructures_Collaborations_Collaboration[1:1];
edge class CompositeStructures_Collaborations_CollaborationUse_roleBinding extends association
	 connect CollaborationUse[*] --> Classes_Dependencies_Dependency[0:*];

//A collaboration use represents the application of the pattern described by a collaboration to a specific situation involving specific classes or instances playing the roles of the collaboration.
node class Collaboration extends CompositeStructures_Collaborations_Classifier, CompositeStructures_InternalStructures_StructuredClassifier, CommonBehaviors_BasicBehaviors_BehavioredClassifier;
edge class CompositeStructures_Collaborations_Collaboration_collaborationRole extends association
	 connect Collaboration[*] --> CompositeStructures_InternalStructures_ConnectableElement[0:*];

//A classifier has the capability to own collaboration uses. These collaboration uses link a collaboration with the classifier to give a description of the workings of the classifier.
abstract node class Classifier extends Classes_Kernel_RedefinableElement, Classes_Kernel_Namespace, Classes_Kernel_Type;
edge class CompositeStructures_Collaborations_Classifier_representation extends association
	 connect Classifier[*] --> CompositeStructures_Collaborations_CollaborationUse[0:1];
edge class CompositeStructures_Collaborations_Classifier_collaborationUse extends association
	 connect Classifier[*] --> CompositeStructures_Collaborations_CollaborationUse[0:*];

//Parameters are allowed to be treated as connectable elements.
node class Parameter extends CompositeStructures_InternalStructures_ConnectableElement;

//A port is a property of a classifier that specifies a distinct interaction point between that classifier and its environment or between the (behavior of the) classifier and its internal parts. Ports are connected to properties of the classifier by connectors through which requests can be made to invoke the behavioral features of a classifier. A Port may specify the services a classifier provides (offers) to its environment as well as the services that a classifier expects (requires) of its environment.
node class Port extends CompositeStructures_InternalStructures_Property;
edge class CompositeStructures_Ports_Port_required extends association
	 connect Port[*] --> Classes_Interfaces_Interface[0:*];
edge class CompositeStructures_Ports_Port_redefinedPort extends association
	 connect Port[*] --> CompositeStructures_Ports_Port[0:*];
edge class CompositeStructures_Ports_Port_provided extends association
	 connect Port[*] --> Classes_Interfaces_Interface[0:*];

//A classifier has the ability to own ports as specific and type checked interaction points.
abstract node class EncapsulatedClassifier extends CompositeStructures_InternalStructures_StructuredClassifier;
edge class CompositeStructures_Ports_EncapsulatedClassifier_ownedPort extends association
	 connect EncapsulatedClassifier[*] --> CompositeStructures_Ports_Port[0:*];

//A connector end is an endpoint of a connector, which attaches the connector to a connectable element. Each connector end is part of one connector.
node class ConnectorEnd;
edge class CompositeStructures_Ports_ConnectorEnd_partWithPort extends association
	 connect ConnectorEnd[*] --> CompositeStructures_InternalStructures_Property[0:1];

//In addition to targeting an object, invocation actions can also invoke behavioral features on ports from where the invocation requests are routed onwards on links deriving from attached connectors. Invocation actions may also be sent to a target via a given port, either on the sending object or on another object.
abstract node class InvocationAction;
edge class CompositeStructures_InvocationActions_InvocationAction_onPort extends association
	 connect InvocationAction[*] --> CompositeStructures_Ports_Port[0:1];

//A trigger specification may be qualified by the port on which the event occurred.
abstract node class Trigger;
edge class CompositeStructures_InvocationActions_Trigger_port extends association
	 connect Trigger[*] --> CompositeStructures_Ports_Port[0:*];

//A connector end is an endpoint of a connector, which attaches the connector to a connectable element. Each connector end is part of one connector.
node class ConnectorEnd extends Classes_Kernel_MultiplicityElement;
edge class CompositeStructures_InternalStructures_ConnectorEnd_definingEnd extends association
	 connect ConnectorEnd[*] --> CompositeStructures_InternalStructures_Property[0:1];
edge class CompositeStructures_InternalStructures_ConnectorEnd_role extends association
	 connect ConnectorEnd[*] --> CompositeStructures_InternalStructures_ConnectableElement[1:1];

//Specifies a link that enables communication between two or more instances. This link may be an instance of an association, or it may represent the possibility of the instances being able to communicate because their identities are known by virtue of being passed in as parameters, held in variables or slots, or because the communicating instances are the same instance. The link may be realized by something as simple as a pointer or by something as complex as a network connection. In contrast to associations, which specify links between any instance of the associated classifiers, connectors specify links between instances playing the connected parts only.
node class Connector extends Classes_Kernel_Feature;
edge class CompositeStructures_InternalStructures_Connector_type extends association
	 connect Connector[*] --> Classes_Kernel_Association[0:1];
edge class CompositeStructures_InternalStructures_Connector_redefinedConnector extends association
	 connect Connector[*] --> CompositeStructures_InternalStructures_Connector[0:*];
edge class CompositeStructures_InternalStructures_Connector_end extends association
	 connect Connector[*] --> CompositeStructures_InternalStructures_ConnectorEnd[2:*];

//A property represents a set of instances that are owned by a containing classifier instance.
node class Property extends CompositeStructures_InternalStructures_ConnectableElement, Classes_Kernel_StructuralFeature;

//A structured classifier is an abstract metaclass that represents any classifier whose behavior can be fully or partly described by the collaboration of owned or referenced instances.
abstract node class StructuredClassifier extends Classes_Kernel_Classifier;
edge class CompositeStructures_InternalStructures_StructuredClassifier_ownedAttribute extends association
	 connect StructuredClassifier[*] --> CompositeStructures_InternalStructures_Property[0:*];
edge class CompositeStructures_InternalStructures_StructuredClassifier_part extends association
	 connect StructuredClassifier[*] --> CompositeStructures_InternalStructures_Property[0:*];
edge class CompositeStructures_InternalStructures_StructuredClassifier_role extends association
	 connect StructuredClassifier[*] --> CompositeStructures_InternalStructures_ConnectableElement[0:*];
edge class CompositeStructures_InternalStructures_StructuredClassifier_ownedConnector extends association
	 connect StructuredClassifier[*] --> CompositeStructures_InternalStructures_Connector[0:*];

//ConnectableElement is an abstract metaclass representing a set of instances that play roles of a classifier. Connectable elements may be joined by attached connectors and specify configurations of linked instances to be created within an instance of the containing classifier.
abstract node class ConnectableElement extends Classes_Kernel_TypedElement;
edge class CompositeStructures_InternalStructures_ConnectableElement_end extends association
	 connect ConnectableElement[*] --> CompositeStructures_InternalStructures_ConnectorEnd[0:*];

//A classifier has the capability to own collaboration uses. These collaboration uses link a collaboration with the classifier to give a description of the workings of the classifier.
abstract node class Classifier;
edge class CompositeStructures_InternalStructures_Classifier_attribute extends association
	 connect Classifier[*] --> CompositeStructures_InternalStructures_Property[0:*];

//A variable is considered a connectable element.
node class Variable extends CompositeStructures_InternalStructures_ConnectableElement;

//A component deployment is the deployment of one or more artifacts or artifact instances to a deployment target, optionally parameterized by a deployment specification. Examples are executables and configuration files.
node class Deployment extends Classes_Dependencies_Dependency;
edge class Deployments_ComponentDeployments_Deployment_configuration extends association
	 connect Deployment[*] --> Deployments_ComponentDeployments_DeploymentSpecification[0:*];

//A deployment specification specifies a set of properties that determine execution parameters of a component artifact that is deployed on a node. A deployment specification can be aimed at a specific type of container. An artifact that reifies or implements deployment specification properties is a deployment descriptor.
node class DeploymentSpecification extends Deployments_Nodes_Artifact;
edge class Deployments_ComponentDeployments_DeploymentSpecification_deploymentLocation extends attribute
	 connect DeploymentSpecification[*] --> [0:1];
edge class Deployments_ComponentDeployments_DeploymentSpecification_executionLocation extends attribute
	 connect DeploymentSpecification[*] --> [0:1];
edge class Deployments_ComponentDeployments_DeploymentSpecification_deployment extends association
	 connect DeploymentSpecification[*] --> Deployments_ComponentDeployments_Deployment[0:1];

//A deployment is the allocation of an artifact or artifact instance to a deployment target.
node class Deployment extends Classes_Dependencies_Dependency;
edge class Deployments_Nodes_Deployment_deployedArtifact extends association
	 connect Deployment[*] --> Deployments_Nodes_DeployedArtifact[0:*];
edge class Deployments_Nodes_Deployment_location extends association
	 connect Deployment[*] --> Deployments_Nodes_DeploymentTarget[1:1];

//A node is computational resource upon which artifacts may be deployed for execution. Nodes can be interconnected through communication paths to define network structures.
node class Node_ extends CompositeStructures_StructuredClasses_Class, Deployments_Nodes_DeploymentTarget;
edge class Deployments_Nodes_Node_nestedNode extends association
	 connect Node_[*] --> Deployments_Nodes_Node[0:*];

//A device is a physical computational resource with processing capability upon which artifacts may be deployed for execution. Devices may be complex (i.e., they may consist of other devices).
node class Device extends Deployments_Nodes_Node;

//An execution environment is a node that offers an execution environment for specific types of components that are deployed on it in the form of executable artifacts.
node class ExecutionEnvironment extends Deployments_Nodes_Node;

//A deployment target is the location for a deployed artifact.
abstract node class DeploymentTarget extends Classes_Dependencies_NamedElement;
edge class Deployments_Nodes_DeploymentTarget_deployment extends association
	 connect DeploymentTarget[*] --> Deployments_Nodes_Deployment[0:*];
edge class Deployments_Nodes_DeploymentTarget_deployedElement extends association
	 connect DeploymentTarget[*] --> Classes_Kernel_PackageableElement[0:*];

//A deployed artifact is an artifact or artifact instance that has been deployed to a deployment target.
abstract node class DeployedArtifact extends Classes_Dependencies_NamedElement;

//A communication path is an association between two deployment targets, through which they are able to exchange signals and messages.
node class CommunicationPath extends Classes_Kernel_Association;

//A property has the capability of being a deployment target in a deployment relationship. This enables modeling the deployment to hierarchical nodes that have properties functioning as internal parts.
node class Property extends Deployments_Nodes_DeploymentTarget;

//An instance specification has the capability of being a deployment target in a deployment relationship, in the case that it is an instance of a node. It is also has the capability of being a deployed artifact, if it is an instance of an artifact.
node class InstanceSpecification extends Deployments_Nodes_DeploymentTarget, Deployments_Nodes_DeployedArtifact;

//An artifact is the source of a deployment to a node.
node class Artifact extends Deployments_Nodes_DeployedArtifact;

//An artifact is the specification of a physical piece of information that is used or produced by a software development process, or by deployment and operation of a system. Examples of artifacts include model files, source files, scripts, and binary executable files, a table in a database system, a development deliverable, or a word-processing document, a mail message.
node class Artifact extends Classes_Kernel_Classifier, Classes_Dependencies_NamedElement;
edge class Deployments_Artifacts_Artifact_fileName extends attribute
	 connect Artifact[*] --> [0:1];
edge class Deployments_Artifacts_Artifact_nestedArtifact extends association
	 connect Artifact[*] --> Deployments_Artifacts_Artifact[0:*];
edge class Deployments_Artifacts_Artifact_manifestation extends association
	 connect Artifact[*] --> Deployments_Artifacts_Manifestation[0:*];
edge class Deployments_Artifacts_Artifact_ownedOperation extends association
	 connect Artifact[*] --> Classes_Kernel_Operation[0:*];
edge class Deployments_Artifacts_Artifact_ownedAttribute extends association
	 connect Artifact[*] --> Classes_Kernel_Property[0:*];

//A manifestation is the concrete physical rendering of one or more model elements by an artifact.
node class Manifestation extends Classes_Dependencies_Abstraction;
edge class Deployments_Artifacts_Manifestation_utilizedElement extends association
	 connect Manifestation[*] --> Classes_Kernel_PackageableElement[1:1];

//An interaction is a unit of behavior that focuses on the observable exchange of information between connectable elements.
node class Interaction extends Interactions_BasicInteractions_InteractionFragment, CommonBehaviors_BasicBehaviors_Behavior;
edge class Interactions_BasicInteractions_Interaction_lifeline extends association
	 connect Interaction[*] --> Interactions_BasicInteractions_Lifeline[0:*];
edge class Interactions_BasicInteractions_Interaction_message extends association
	 connect Interaction[*] --> Interactions_BasicInteractions_Message[0:*];
edge class Interactions_BasicInteractions_Interaction_fragment extends association
	 connect Interaction[*] --> Interactions_BasicInteractions_InteractionFragment[0:*];
edge class Interactions_BasicInteractions_Interaction_action extends association
	 connect Interaction[*] --> Actions_BasicActions_Action[0:*];

//A lifeline represents an individual participant in the interaction. While parts and structural features may have multiplicity greater than 1, lifelines represent only one interacting entity.
node class Lifeline extends Classes_Kernel_NamedElement;
edge class Interactions_BasicInteractions_Lifeline_coveredBy extends association
	 connect Lifeline[*] --> Interactions_BasicInteractions_InteractionFragment[0:*];
edge class Interactions_BasicInteractions_Lifeline_represents extends association
	 connect Lifeline[*] --> CompositeStructures_InternalStructures_ConnectableElement[0:1];
edge class Interactions_BasicInteractions_Lifeline_interaction extends association
	 connect Lifeline[*] --> Interactions_BasicInteractions_Interaction[1:1];
edge class Interactions_BasicInteractions_Lifeline_selector extends association
	 connect Lifeline[*] --> Classes_Kernel_ValueSpecification[0:1];

//InteractionFragment is an abstract notion of the most general interaction unit. An interaction fragment is a piece of an interaction. Each interaction fragment is conceptually like an interaction by itself.
abstract node class InteractionFragment extends Classes_Kernel_NamedElement;
edge class Interactions_BasicInteractions_InteractionFragment_covered extends association
	 connect InteractionFragment[*] --> Interactions_BasicInteractions_Lifeline[0:*];
edge class Interactions_BasicInteractions_InteractionFragment_generalOrdering extends association
	 connect InteractionFragment[*] --> Interactions_BasicInteractions_GeneralOrdering[0:*];
edge class Interactions_BasicInteractions_InteractionFragment_enclosingInteraction extends association
	 connect InteractionFragment[*] --> Interactions_BasicInteractions_Interaction[0:1];

//A message defines a particular communication between lifelines of an interaction.
node class Message extends Classes_Kernel_NamedElement;
edge class Interactions_BasicInteractions_Message_receiveEvent extends association
	 connect Message[*] --> Interactions_BasicInteractions_MessageEnd[0:1];
edge class Interactions_BasicInteractions_Message_sendEvent extends association
	 connect Message[*] --> Interactions_BasicInteractions_MessageEnd[0:1];
edge class Interactions_BasicInteractions_Message_connector extends association
	 connect Message[*] --> CompositeStructures_InternalStructures_Connector[0:1];
edge class Interactions_BasicInteractions_Message_interaction extends association
	 connect Message[*] --> Interactions_BasicInteractions_Interaction[1:1];
edge class Interactions_BasicInteractions_Message_argument extends association
	 connect Message[*] --> Classes_Kernel_ValueSpecification[0:*];
edge class Interactions_BasicInteractions_Message_signature extends association
	 connect Message[*] --> Classes_Dependencies_NamedElement[0:1];

//A general ordering represents a binary relation between two occurrence specifications, to describe that one occurrence specification must occur before the other in a valid trace. This mechanism provides the ability to define partial orders of occurrence cpecifications that may otherwise not have a specified order.
node class GeneralOrdering extends Classes_Kernel_NamedElement;
edge class Interactions_BasicInteractions_GeneralOrdering_before extends association
	 connect GeneralOrdering[*] --> Interactions_BasicInteractions_OccurrenceSpecification[1:1];
edge class Interactions_BasicInteractions_GeneralOrdering_after extends association
	 connect GeneralOrdering[*] --> Interactions_BasicInteractions_OccurrenceSpecification[1:1];

//An execution specification is a specification of the execution of a unit of behavior or action within the lifeline. The duration of an execution specification is represented by two cccurrence specifications, the start occurrence specification and the finish occurrence specification.
abstract node class ExecutionSpecification extends Interactions_BasicInteractions_InteractionFragment;
edge class Interactions_BasicInteractions_ExecutionSpecification_start extends association
	 connect ExecutionSpecification[*] --> Interactions_BasicInteractions_OccurrenceSpecification[1:1];
edge class Interactions_BasicInteractions_ExecutionSpecification_finish extends association
	 connect ExecutionSpecification[*] --> Interactions_BasicInteractions_OccurrenceSpecification[1:1];

//An occurrence specification is the basic semantic unit of interactions. The sequences of occurrences specified by them are the meanings of interactions.
node class OccurrenceSpecification extends Interactions_BasicInteractions_InteractionFragment;
edge class Interactions_BasicInteractions_OccurrenceSpecification_covered extends association
	 connect OccurrenceSpecification[*] --> Interactions_BasicInteractions_Lifeline[1:1];
edge class Interactions_BasicInteractions_OccurrenceSpecification_toAfter extends association
	 connect OccurrenceSpecification[*] --> Interactions_BasicInteractions_GeneralOrdering[0:*];
edge class Interactions_BasicInteractions_OccurrenceSpecification_toBefore extends association
	 connect OccurrenceSpecification[*] --> Interactions_BasicInteractions_GeneralOrdering[0:*];
edge class Interactions_BasicInteractions_OccurrenceSpecification_event extends association
	 connect OccurrenceSpecification[*] --> CommonBehaviors_Communications_Event[1:1];

//MessageEnd is an abstract specialization of NamedElement that represents what can occur at the end of a message.
abstract node class MessageEnd extends Classes_Kernel_NamedElement;
edge class Interactions_BasicInteractions_MessageEnd_message extends association
	 connect MessageEnd[*] --> Interactions_BasicInteractions_Message[0:1];

//A state invariant is a runtime constraint on the participants of the interaction. It may be used to specify a variety of different kinds of constraints, such as values of attributes or variables, internal or external states, and so on. A state invariant is an interaction fragment and it is placed on a lifeline.
node class StateInvariant extends Interactions_BasicInteractions_InteractionFragment;
edge class Interactions_BasicInteractions_StateInvariant_invariant extends association
	 connect StateInvariant[*] --> Classes_Kernel_Constraint[1:1];
edge class Interactions_BasicInteractions_StateInvariant_covered extends association
	 connect StateInvariant[*] --> Interactions_BasicInteractions_Lifeline[1:1];

//An action execution specification is a kind of execution specification representing the execution of an action.
node class ActionExecutionSpecification extends Interactions_BasicInteractions_ExecutionSpecification;
edge class Interactions_BasicInteractions_ActionExecutionSpecification_action extends association
	 connect ActionExecutionSpecification[*] --> Actions_BasicActions_Action[1:1];

//A behavior execution specification is a kind of execution specification representing the execution of a behavior.
node class BehaviorExecutionSpecification extends Interactions_BasicInteractions_ExecutionSpecification;
edge class Interactions_BasicInteractions_BehaviorExecutionSpecification_behavior extends association
	 connect BehaviorExecutionSpecification[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:1];

//An execution event models the start or finish of an execution occurrence.
node class ExecutionEvent extends CommonBehaviors_Communications_Event;

//A creation event models the creation of an object.
node class CreationEvent extends CommonBehaviors_Communications_Event;

//A destruction event models the destruction of an object.
node class DestructionEvent extends CommonBehaviors_Communications_Event;

//A send operation event models the invocation of an operation call.
node class SendOperationEvent extends CommonBehaviors_Communications_MessageEvent;
edge class Interactions_BasicInteractions_SendOperationEvent_operation extends association
	 connect SendOperationEvent[*] --> Classes_Kernel_Operation[1:1];

//A send signal event models the sending of a signal.
node class SendSignalEvent extends CommonBehaviors_Communications_MessageEvent;
edge class Interactions_BasicInteractions_SendSignalEvent_signal extends association
	 connect SendSignalEvent[*] --> CommonBehaviors_Communications_Signal[1:1];

//A message occurrence specification pecifies the occurrence of message events, such as sending and receiving of signals or invoking or receiving of operation calls. A message occurrence specification is a kind of message end. Messages are generated either by synchronous operation calls or asynchronous signal sends. They are received by the execution of corresponding accept event actions.
node class MessageOccurrenceSpecification extends Interactions_BasicInteractions_MessageEnd, Interactions_BasicInteractions_OccurrenceSpecification;

//An execution occurrence specification represents moments in time at which actions or behaviors start or finish.
node class ExecutionOccurrenceSpecification extends Interactions_BasicInteractions_OccurrenceSpecification;
edge class Interactions_BasicInteractions_ExecutionOccurrenceSpecification_execution extends association
	 connect ExecutionOccurrenceSpecification[*] --> Interactions_BasicInteractions_ExecutionSpecification[1:1];
edge class Interactions_BasicInteractions_ExecutionOccurrenceSpecification_event extends association
	 connect ExecutionOccurrenceSpecification[*] --> Interactions_BasicInteractions_ExecutionEvent[1:1];

//A receive operation event specifies the event of receiving an operation invocation for a particular operation by the target entity.
node class ReceiveOperationEvent extends CommonBehaviors_Communications_MessageEvent;
edge class Interactions_BasicInteractions_ReceiveOperationEvent_operation extends association
	 connect ReceiveOperationEvent[*] --> Classes_Kernel_Operation[1:1];

//A receive signal event specifies the event of receiving a signal by the target entity.
node class ReceiveSignalEvent extends CommonBehaviors_Communications_MessageEvent;
edge class Interactions_BasicInteractions_ReceiveSignalEvent_signal extends association
	 connect ReceiveSignalEvent[*] --> CommonBehaviors_Communications_Signal[1:1];

//An interaction use refers to an interaction. The interaction use is a shorthand for copying the contents of the referenced interaction where the interaction use is. To be accurate the copying must take into account substituting parameters with arguments and connect the formal gates with the actual ones.
node class InteractionUse extends Interactions_Fragments_InteractionFragment;
edge class Interactions_Fragments_InteractionUse_refersTo extends association
	 connect InteractionUse[*] --> Interactions_Fragments_Interaction[1:1];
edge class Interactions_Fragments_InteractionUse_actualGate extends association
	 connect InteractionUse[*] --> Interactions_Fragments_Gate[0:*];
edge class Interactions_Fragments_InteractionUse_argument extends association
	 connect InteractionUse[*] --> Actions_BasicActions_Action[0:*];

//A part decomposition is a description of the internal interactions of one lifeline relative to an interaction.
node class PartDecomposition extends Interactions_Fragments_InteractionUse;

//An interaction operand is contained in a combined fragment. An interaction operand represents one operand of the expression given by the enclosing combined fragment.
node class InteractionOperand extends Interactions_Fragments_InteractionFragment, Classes_Kernel_Namespace;
edge class Interactions_Fragments_InteractionOperand_guard extends association
	 connect InteractionOperand[*] --> Interactions_Fragments_InteractionConstraint[0:1];
edge class Interactions_Fragments_InteractionOperand_fragment extends association
	 connect InteractionOperand[*] --> Interactions_Fragments_InteractionFragment[0:*];

//An interaction constraint is a Boolean expression that guards an operand in a combined fragment.
node class InteractionConstraint extends Classes_Kernel_Constraint;
edge class Interactions_Fragments_InteractionConstraint_minint extends association
	 connect InteractionConstraint[*] --> Classes_Kernel_ValueSpecification[0:1];
edge class Interactions_Fragments_InteractionConstraint_maxint extends association
	 connect InteractionConstraint[*] --> Classes_Kernel_ValueSpecification[0:1];

//A gate is a connection point for relating a message outside an interaction fragment with a message inside the interaction fragment.
node class Gate extends Interactions_BasicInteractions_MessageEnd;

//A combined fragment defines an expression of interaction fragments. A combined fragment is defined by an interaction operator and corresponding interaction operands. Through the use of combined fragments the user will be able to describe a number of traces in a compact and concise manner.
node class CombinedFragment extends Interactions_Fragments_InteractionFragment;
edge class Interactions_Fragments_CombinedFragment_operand extends association
	 connect CombinedFragment[*] --> Interactions_Fragments_InteractionOperand[1:*];
edge class Interactions_Fragments_CombinedFragment_cfragmentGate extends association
	 connect CombinedFragment[*] --> Interactions_Fragments_Gate[0:*];

//
node class Interaction extends CommonBehaviors_BasicBehaviors_Behavior;
edge class Interactions_Fragments_Interaction_formalGate extends association
	 connect Interaction[*] --> Interactions_Fragments_Gate[0:*];

//
node class Lifeline;
edge class Interactions_Fragments_Lifeline_decomposedAs extends association
	 connect Lifeline[*] --> Interactions_Fragments_PartDecomposition[0:1];

//A continuation is a syntactic way to define continuations of different branches of an alternative combined fragment. Continuations is intuitively similar to labels representing intermediate points in a flow of control.
node class Continuation extends Interactions_Fragments_InteractionFragment;

//
abstract node class InteractionFragment extends Classes_Kernel_NamedElement;
edge class Interactions_Fragments_InteractionFragment_enclosingOperand extends association
	 connect InteractionFragment[*] --> Interactions_Fragments_InteractionOperand[0:1];

//A consider ignore fragment is a kind of combined fragment that is used for the consider and ignore cases, which require lists of pertinent messages to be specified.
node class ConsiderIgnoreFragment extends Interactions_Fragments_CombinedFragment;
edge class Interactions_Fragments_ConsiderIgnoreFragment_message extends association
	 connect ConsiderIgnoreFragment[*] --> Classes_Kernel_NamedElement[0:*];

//State machines can be used to express the behavior of part of a system. Behavior is modeled as a traversal of a graph of state nodes interconnected by one or more joined transition arcs that are triggered by the dispatching of series of (event) occurrences. During this traversal, the state machine executes a series of activities associated with various elements of the state machine.
node class StateMachine extends CommonBehaviors_BasicBehaviors_Behavior;
edge class StateMachines_BehaviorStateMachines_StateMachine_region extends association
	 connect StateMachine[*] --> StateMachines_BehaviorStateMachines_Region[1:*];
edge class StateMachines_BehaviorStateMachines_StateMachine_connectionPoint extends association
	 connect StateMachine[*] --> StateMachines_BehaviorStateMachines_Pseudostate[0:*];
edge class StateMachines_BehaviorStateMachines_StateMachine_extendedStateMachine extends association
	 connect StateMachine[*] --> StateMachines_BehaviorStateMachines_StateMachine[0:*];
edge class StateMachines_BehaviorStateMachines_StateMachine_submachineState extends association
	 connect StateMachine[*] --> StateMachines_BehaviorStateMachines_State[0:*];

//A state models a situation during which some (usually implicit) invariant condition holds.
node class State extends StateMachines_BehaviorStateMachines_Vertex, Classes_Kernel_RedefinableElement, Classes_Kernel_Namespace;
edge class StateMachines_BehaviorStateMachines_State_submachine extends association
	 connect State[*] --> StateMachines_BehaviorStateMachines_StateMachine[0:1];
edge class StateMachines_BehaviorStateMachines_State_connection extends association
	 connect State[*] --> StateMachines_BehaviorStateMachines_ConnectionPointReference[0:*];
edge class StateMachines_BehaviorStateMachines_State_redefinedState extends association
	 connect State[*] --> StateMachines_BehaviorStateMachines_State[0:1];
edge class StateMachines_BehaviorStateMachines_State_region extends association
	 connect State[*] --> StateMachines_BehaviorStateMachines_Region[0:*];
edge class StateMachines_BehaviorStateMachines_State_redefinitionContext extends association
	 connect State[*] --> Classes_Kernel_Classifier[1:1];
edge class StateMachines_BehaviorStateMachines_State_stateInvariant extends association
	 connect State[*] --> Classes_Kernel_Constraint[0:1];
edge class StateMachines_BehaviorStateMachines_State_entry extends association
	 connect State[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:1];
edge class StateMachines_BehaviorStateMachines_State_exit extends association
	 connect State[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:1];
edge class StateMachines_BehaviorStateMachines_State_doActivity extends association
	 connect State[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:1];
edge class StateMachines_BehaviorStateMachines_State_connectionPoint extends association
	 connect State[*] --> StateMachines_BehaviorStateMachines_Pseudostate[0:*];
edge class StateMachines_BehaviorStateMachines_State_deferrableTrigger extends association
	 connect State[*] --> CommonBehaviors_Communications_Trigger[0:*];

//A transition is a directed relationship between a source vertex and a target vertex. It may be part of a compound transition, which takes the state machine from one state configuration to another, representing the complete response of the state machine to an occurrence of an event of a particular type.
node class Transition extends Classes_Kernel_RedefinableElement, Classes_Kernel_Namespace;
edge class StateMachines_BehaviorStateMachines_Transition_container extends association
	 connect Transition[*] --> StateMachines_BehaviorStateMachines_Region[1:1];
edge class StateMachines_BehaviorStateMachines_Transition_source extends association
	 connect Transition[*] --> StateMachines_BehaviorStateMachines_Vertex[1:1];
edge class StateMachines_BehaviorStateMachines_Transition_target extends association
	 connect Transition[*] --> StateMachines_BehaviorStateMachines_Vertex[1:1];
edge class StateMachines_BehaviorStateMachines_Transition_redefinedTransition extends association
	 connect Transition[*] --> StateMachines_BehaviorStateMachines_Transition[0:1];
edge class StateMachines_BehaviorStateMachines_Transition_guard extends association
	 connect Transition[*] --> Classes_Kernel_Constraint[0:1];
edge class StateMachines_BehaviorStateMachines_Transition_redefinitionContext extends association
	 connect Transition[*] --> Classes_Kernel_Classifier[1:1];
edge class StateMachines_BehaviorStateMachines_Transition_effect extends association
	 connect Transition[*] --> CommonBehaviors_BasicBehaviors_Behavior[0:1];
edge class StateMachines_BehaviorStateMachines_Transition_trigger extends association
	 connect Transition[*] --> CommonBehaviors_Communications_Trigger[0:*];

//A vertex is an abstraction of a node in a state machine graph. In general, it can be the source or destination of any number of transitions.
abstract node class Vertex extends Classes_Kernel_NamedElement;
edge class StateMachines_BehaviorStateMachines_Vertex_container extends association
	 connect Vertex[*] --> StateMachines_BehaviorStateMachines_Region[0:1];
edge class StateMachines_BehaviorStateMachines_Vertex_outgoing extends association
	 connect Vertex[*] --> StateMachines_BehaviorStateMachines_Transition[0:*];
edge class StateMachines_BehaviorStateMachines_Vertex_incoming extends association
	 connect Vertex[*] --> StateMachines_BehaviorStateMachines_Transition[0:*];

//A pseudostate is an abstraction that encompasses different types of transient vertices in the state machine graph.
node class Pseudostate extends StateMachines_BehaviorStateMachines_Vertex;
edge class StateMachines_BehaviorStateMachines_Pseudostate_stateMachine extends association
	 connect Pseudostate[*] --> StateMachines_BehaviorStateMachines_StateMachine[0:1];
edge class StateMachines_BehaviorStateMachines_Pseudostate_state extends association
	 connect Pseudostate[*] --> StateMachines_BehaviorStateMachines_State[0:1];

//A special kind of state signifying that the enclosing region is completed. If the enclosing region is directly contained in a state machine and all other regions in the state machine also are completed, then it means that the entire state machine is completed.
node class FinalState extends StateMachines_BehaviorStateMachines_State;

//A connection point reference represents a usage (as part of a submachine state) of an entry/exit point defined in the statemachine reference by the submachine state.
node class ConnectionPointReference extends StateMachines_BehaviorStateMachines_Vertex;
edge class StateMachines_BehaviorStateMachines_ConnectionPointReference_entry extends association
	 connect ConnectionPointReference[*] --> StateMachines_BehaviorStateMachines_Pseudostate[0:*];
edge class StateMachines_BehaviorStateMachines_ConnectionPointReference_state extends association
	 connect ConnectionPointReference[*] --> StateMachines_BehaviorStateMachines_State[0:1];
edge class StateMachines_BehaviorStateMachines_ConnectionPointReference_exit extends association
	 connect ConnectionPointReference[*] --> StateMachines_BehaviorStateMachines_Pseudostate[0:*];

//A region is an orthogonal part of either a composite state or a state machine. It contains states and transitions.
node class Region extends Classes_Kernel_RedefinableElement, Classes_Kernel_Namespace;
edge class StateMachines_BehaviorStateMachines_Region_subvertex extends association
	 connect Region[*] --> StateMachines_BehaviorStateMachines_Vertex[0:*];
edge class StateMachines_BehaviorStateMachines_Region_transition extends association
	 connect Region[*] --> StateMachines_BehaviorStateMachines_Transition[0:*];
edge class StateMachines_BehaviorStateMachines_Region_stateMachine extends association
	 connect Region[*] --> StateMachines_BehaviorStateMachines_StateMachine[0:1];
edge class StateMachines_BehaviorStateMachines_Region_state extends association
	 connect Region[*] --> StateMachines_BehaviorStateMachines_State[0:1];
edge class StateMachines_BehaviorStateMachines_Region_extendedRegion extends association
	 connect Region[*] --> StateMachines_BehaviorStateMachines_Region[0:1];
edge class StateMachines_BehaviorStateMachines_Region_redefinitionContext extends association
	 connect Region[*] --> Classes_Kernel_Classifier[1:1];

//A time event can be defined relative to entering the current state of the executing state machine.
node class TimeEvent;

//Protocol state machines can be redefined into more specific protocol state machines, or into behavioral state machines. Protocol conformance declares that the specific protocol state machine specifies a protocol that conforms to the general state machine one, or that the specific behavioral state machine abide by the protocol of the general protocol state machine.
node class ProtocolConformance extends Classes_Kernel_DirectedRelationship;
edge class StateMachines_ProtocolStateMachines_ProtocolConformance_specificMachine extends association
	 connect ProtocolConformance[*] --> StateMachines_ProtocolStateMachines_ProtocolStateMachine[1:1];
edge class StateMachines_ProtocolStateMachines_ProtocolConformance_generalMachine extends association
	 connect ProtocolConformance[*] --> StateMachines_ProtocolStateMachines_ProtocolStateMachine[1:1];

//Since an interface specifies conformance characteristics, it does not own detailed behavior specifications. Instead, interfaces may own a protocol state machine that specifies event sequences and pre/post conditions for the operations and receptions described by the interface.
node class Interface extends Classes_Kernel_Classifier;
edge class StateMachines_ProtocolStateMachines_Interface_protocol extends association
	 connect Interface[*] --> StateMachines_ProtocolStateMachines_ProtocolStateMachine[0:1];

//A port has an associated protocol state machine.
node class Port;
edge class StateMachines_ProtocolStateMachines_Port_protocol extends association
	 connect Port[*] --> StateMachines_ProtocolStateMachines_ProtocolStateMachine[0:1];

//A protocol transition specifies a legal transition for an operation. Transitions of protocol state machines have the following information: a pre condition (guard), on trigger, and a post condition. Every protocol transition is associated to zero or one operation (referred BehavioralFeature) that belongs to the context classifier of the protocol state machine.
node class ProtocolTransition extends StateMachines_BehaviorStateMachines_Transition;
edge class StateMachines_ProtocolStateMachines_ProtocolTransition_postCondition extends association
	 connect ProtocolTransition[*] --> Classes_Kernel_Constraint[0:1];
edge class StateMachines_ProtocolStateMachines_ProtocolTransition_referred extends association
	 connect ProtocolTransition[*] --> Classes_Kernel_Operation[0:*];
edge class StateMachines_ProtocolStateMachines_ProtocolTransition_preCondition extends association
	 connect ProtocolTransition[*] --> Classes_Kernel_Constraint[0:1];

//A protocol state machine is always defined in the context of a classifier. It specifies which operations of the classifier can be called in which state and under which condition, thus specifying the allowed call sequences on the classifier's operations. A protocol state machine presents the possible and permitted transitions on the instances of its context classifier, together with the operations which carry the transitions. In this manner, an instance lifecycle can be created for a classifier, by specifying the order in which the operations can be activated and the states through which an instance progresses during its existence.
node class ProtocolStateMachine extends StateMachines_BehaviorStateMachines_StateMachine;
edge class StateMachines_ProtocolStateMachines_ProtocolStateMachine_conformance extends association
	 connect ProtocolStateMachine[*] --> StateMachines_ProtocolStateMachines_ProtocolConformance[0:*];

//The states of protocol state machines are exposed to the users of their context classifiers. A protocol state represents an exposed stable situation of its context classifier: when an instance of the classifier is not processing any operation, users of this instance can always know its state configuration.
node class State extends Classes_Kernel_Namespace;

//
node class Region;

//An actor specifies a role played by a user or any other system that interacts with the subject.
node class Actor extends CommonBehaviors_BasicBehaviors_BehavioredClassifier;

//A relationship from an extending use case to an extended use case that specifies how and when the behavior defined in the extending use case can be inserted into the behavior defined in the extended use case.
node class Extend extends Classes_Kernel_DirectedRelationship, Classes_Kernel_NamedElement;
edge class UseCases_Extend_extendedCase extends association
	 connect Extend[*] --> UseCases_UseCase[1:1];
edge class UseCases_Extend_extension extends association
	 connect Extend[*] --> UseCases_UseCase[1:1];
edge class UseCases_Extend_condition extends association
	 connect Extend[*] --> Classes_Kernel_Constraint[0:1];
edge class UseCases_Extend_extensionLocation extends association
	 connect Extend[*] --> UseCases_ExtensionPoint[1:*];

//An include relationship defines that a use case contains the behavior defined in another use case.
node class Include extends Classes_Kernel_DirectedRelationship, Classes_Kernel_NamedElement;
edge class UseCases_Include_includingCase extends association
	 connect Include[*] --> UseCases_UseCase[1:1];
edge class UseCases_Include_addition extends association
	 connect Include[*] --> UseCases_UseCase[1:1];

//A use case is the specification of a set of actions performed by a system, which yields an observable result that is, typically, of value for one or more actors or other stakeholders of the system.
node class UseCase extends CommonBehaviors_BasicBehaviors_BehavioredClassifier;
edge class UseCases_UseCase_include extends association
	 connect UseCase[*] --> UseCases_Include[0:*];
edge class UseCases_UseCase_extend extends association
	 connect UseCase[*] --> UseCases_Extend[0:*];
edge class UseCases_UseCase_extensionPoint extends association
	 connect UseCase[*] --> UseCases_ExtensionPoint[0:*];
edge class UseCases_UseCase_subject extends association
	 connect UseCase[*] --> UseCases_Classifier[0:*];

//An extension point identifies a point in the behavior of a use case where that behavior can be extended by the behavior of some other (extending) use case, as specified by an extend relationship.
node class ExtensionPoint extends Classes_Kernel_RedefinableElement;
edge class UseCases_ExtensionPoint_useCase extends association
	 connect ExtensionPoint[*] --> UseCases_UseCase[1:1];

//A classifier has the capability to own use cases. Although the owning classifier typically represents the subject to which the owned use cases apply, this is not necessarily the case. In principle, the same use case can be applied to multiple subjects, as identified by the subject association role of a use case.
abstract node class Classifier extends Classes_Kernel_Namespace;
edge class UseCases_Classifier_ownedUseCase extends association
	 connect Classifier[*] --> UseCases_UseCase[0:*];
edge class UseCases_Classifier_useCase extends association
	 connect Classifier[*] --> UseCases_UseCase[0:*];
