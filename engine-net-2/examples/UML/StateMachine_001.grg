using L3;

rule init {
  pattern { }
  replace {
    // the machine and its region
    sm:StateMachine -:region-> reg:Region -:stateMachine-> sm;

    qs:Pseudostate; // muss ohne irgenwas angebunden sein: kein trigger etc erlaubt
    qf:FinalState;
    q1:State;
    q2:State;

    // embed states to region
    reg -:subvertex-> qs -:container-> reg;
    reg -:subvertex-> qf -:container-> reg;
    reg -:subvertex-> q1 -:container-> reg;
    reg -:subvertex-> q2 -:container-> reg;

    // make initial state
    qs -:kind-> qs_kind:PseudostateKind_Value;
    eval { 
      qs_kind.value = PseudostateKind::entryPoint;
    }

    // create the transitions in region
    t1:Transition -:container-> reg -:transition-> t1;
    t2:Transition -:container-> reg -:transition-> t2;
    t3:Transition -:container-> reg -:transition-> t3;
    t4:Transition -:container-> reg -:transition-> t4;
    t5:Transition -:container-> reg -:transition-> t5;
    t6:Transition -:container-> reg -:transition-> t6;

    // the triggers (transitions without a trigger are epsilon transitions)
    t1 -:trigger-> :Trigger -:event-> :CallEvent;
    t2 -:trigger-> :Trigger -:event-> :CallEvent;
    t3 -:trigger-> :Trigger -:event-> :CallEvent;

    // the connections
    qs -:source-> t1 -:target-> q1 
       -:source-> t2 -:target-> q2
       -:source-> t3 -:target-> qf;

    qs -:source-> t4 -:target-> q2;
    q1 -:source-> t5 -:target-> qf;
    qs -:source-> t6 -:target-> qf;
  }
}

rule ForwardTransition {
    pattern {
        x:State -:source-> xy:Transition -:target-> y:State -:source-> yz:Transition -:target-> z:State;
        yz -:trigger-> trig:Trigger;
        hom(x,y,z);
        negative {
            negative { xy -:trigger-> ; }                // xy is an epsilon transition
            x -:source-> xz:Transition -:target-> z;     // no transition xz with
            xz -:trigger-> trig;                         // the same trigger as yz

        }
    }
    modify {
        x -:source-> xz:Transition -:target-> z;
        xz -:trigger-> trig;
    }    
}

rule AddStartFinalState {
    pattern {
        x:State  -:source-> t:Transition -:target-> :FinalState;
        x -:kind-> kv:PseudostateKind_Value;
        if { kv.value == PseudostateKind::entryPoint; }
        negative { t -:trigger-> ; }
    }
    modify {
        //y:StartFinalState<x>;        
    }
}

rule AddFinalState {
    pattern {
        //x:State -:EpsilonTransition-> :FinalState;
        //if { typeof(x) < SpecialState; }
    }
    modify {
        //y:FinalState<x>;
    }
}

rule RemoveEpsilonTransition {
    pattern {
        //-:EpsilonTransition->;
    }
    replace {}   
}
