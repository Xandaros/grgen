// we declare two external classes we want to use in our external attribute computations
// signature only, external implmentation!
class Own;
class OwnPown extends Own;
class OwnPownHome extends OwnPown;

enum Enu
{
	reh, lamm, hurz
}

node class N
{
	i:int;
	s:string;
	o:object;
	b:boolean = true;
	f:float;
	d:double;
	enu:Enu;
	si:set<int>;
	mso:map<string,object>;
	a:array<double>;
	de:deque<double>;
	ow:Own; // attributes of type externally defined
	op:OwnPown; // attributes of type externally defined
	oh:OwnPownHome; // attributes of type externally defined
}

edge class E;

// we declare the external attribute functions
// signature only, external implementation!
foo(int, double, Enu, string) : boolean;
bar(object, object) : object;
isnull(object) : boolean;
bla(N, E) : boolean;
blo(Node, Edge) : N;
har(Own, OwnPown) : OwnPown;
hur(OwnPown) : boolean;
hurdur(OwnPownHome) : boolean;

// we declare the external attribute procedures
// signature only, external implementation!
fooProc(int, double, Enu, string);
barProc(object, object) : (object);
isnullProc(object) : (boolean);
blaProc(N, E) : (boolean, boolean);
bloProc(Node, Edge) : (N);
harProc(Own, OwnPown) : (OwnPown, Own, N);
hurProc(OwnPown);
hurdurProc(OwnPownHome);

