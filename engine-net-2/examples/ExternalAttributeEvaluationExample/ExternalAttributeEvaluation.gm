// we declare three external classes we want to use in our external attribute computations
// signature only, external implmentation!
class Own;
class OwnPown extends Own;
class OwnPownHome extends OwnPown;

// we declare that we want to implement parsing, serializing, and debug output generation 
// of objects of external types or of object type
emit class;

// we declare that we want to implement copying 
// of objects of external types or of object type
copy class;

// we declare that we want to implement comparison 
// of objects of external types or of object type
== class;
< class;

enum Enu
{
	reh, lamm, hurz
}

node class N
{
	i:int;
	s:string;
	o:object;
	b:boolean = true;
	f:float;
	d:double;
	enu:Enu;
	si:set<int>;
	mso:map<string,object>;
	a:array<double>;
	de:deque<double>;
	ow:Own; // attributes of type externally defined
	op:OwnPown; // attributes of type externally defined
	oh:OwnPownHome; // attributes of type externally defined
}

edge class E;

// we declare the external attribute functions
// signature only, external implementation!
function foo(int, double, Enu, string) : boolean;
function bar(object, object) : object;
function isnull(object) : boolean;
function bla(N, E) : boolean;
function blo(Node, Edge) : N;
function har(Own, OwnPown) : OwnPown;
function hur(OwnPown) : boolean;
function hurdur(OwnPownHome) : boolean;

// "constructors" implemented as attribute functions, for filling attributes
function own() : Own;
function ownPown() : OwnPown;
function ownPownHome() : OwnPownHome;

// we declare the external attribute procedures
// signature only, external implementation!
procedure fooProc(int, double, Enu, string);
procedure barProc(object, object) : (object);
procedure isnullProc(object) : (boolean);
procedure blaProc(N, E) : (boolean, boolean);
procedure bloProc(Node, Edge) : (N);
procedure harProc(Own, OwnPown) : (OwnPown, Own, N);
procedure hurProc(OwnPown);
procedure hurdurProc(OwnPownHome);

