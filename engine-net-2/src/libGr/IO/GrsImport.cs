/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 4.0
 * Copyright (C) 2003-2013 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.net
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Text;

namespace de.unika.ipd.grGen.libGr
{
    enum TokenKind
    {
        UNKNOWN, //internal state, lexing underway
        COLON, //:
        DOUBLECOLON, //::
        DOLLAR, //$
        EQUAL, //=
        DOT, //.
        COMMA, //,
        ARROW, //->
        MINUS, //-
        LPARENTHESIS, //(
        RPARENTHESIS, //)
        AT, //@
        LANGLE, //<
        RANGLE, //>
        LBRACE, //{
        RBRACE, //}
        LBOXBRACKET, //[
        RBOXBRACKET, //]
        NUMBER, //("-")? (["0"-"9"])+
        NUMBER_BYTE, //NUMBER ("y"|"Y")
        NUMBER_SHORT, //NUMBER ("s"|"S")
        NUMBER_LONG, //NUMBER ("l"|"L")
        HEXNUMBER, //0x (["0"-"9", "a"-"f", "A"-"F"])+
        HEXNUMBER_BYTE, //HEXNUMBER ("y"|"Y")
        HEXNUMBER_SHORT, //HEXNUMBER ("s"|"S")
        HEXNUMBER_LONG, //HEXNUMBER ("l"|"L")
        NUMFLOAT, //floating point number, with "f"|"F" suffix
        NUMDOUBLE, //floating point number (combination of sign, number, dot, fractional part, exponent)
        DOUBLEQUOTEDTEXT, // "\"" (~["\""])* "\""
        SINGLEQUOTEDTEXT, // "\'" (~["\'"])* "\'"
        IDENT, // LETTER (LETTER | DIGIT)*
        FALSE, //false
        GRAPH, //graph
        NEW, //new
        NULL, //null
        TRUE, //true
        SET, //set
        MAP, //map
        ARRAY, //array
        DEQUE, //deque
        EOF // end of file
    }

    /// <summary>
    /// Imports graphs from files in GRS format.
    /// Implementation note: this is a boring hand written lexer and parser,
    /// needed because the lexer/parser generated by CSharpCC that was replaced by it
    /// fired a multitude of "LookaheadSuccess"-exceptions, wreaking havoc on performance.
    /// </summary>
    public class GRSImport
    {
        INamedGraph graph;
        IBackend backend;
        IGraphModel model;
        String modelOverride;
        BaseActions actions;
        TextReader reader; // the text reader containing the grs contents to import
        long fileSize; // the size of the grs file, used to initialize the capacity of the name maps of the named graph
        int line; // the current line reached during parsing/lexing, for error messages
        int column; // the current column reached during parsing/lexing, for error messages
        bool tokenFound; // tells whether a token was matched lately, cleared by the parser when asking for the next one to be delivered
        TokenKind tokenKind; // gives the kind of token matched lately
        StringBuilder tokenContent; // the buffer with the token matched lately

        /// <summary>
        /// Imports the given graph from a file with the given filename.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="importFilename">The filename of the file to be imported.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="modelOverride">The graph model to be used, 
        ///     it must be conformant to the model used in the file to be imported.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>
        public static INamedGraph Import(String importFilename, String modelOverride, IBackend backend, out BaseActions actions)
        {
            FileInfo fi = new FileInfo(importFilename);
            long fileSize = fi.Length;
            return Import(new StreamReader(importFilename), fileSize, modelOverride, backend, out actions);
        }

        /// <summary>
        /// Imports the given graph from the given text reader input stream.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="reader">The text reader input stream import source.</param>
        /// <param name="fileSize">The size of the input file.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="modelOverride">The graph model to be used, 
        ///     it must be conformant to the model used in the file to be imported.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(TextReader reader, long fileSize, String modelOverride, IBackend backend, out BaseActions actions)
        {
            GRSImport importer = new GRSImport(reader, fileSize);
            importer.backend = backend;
            importer.modelOverride = modelOverride;
            importer.model = null;
            importer.ParseGraphBuildingScript();
            actions = importer.actions;
            return importer.graph;
        }

        /// <summary>
        /// Imports the given graph from a file with the given filename.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="importFilename">The filename of the file to be imported.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(String importFilename, IBackend backend, out BaseActions actions)
        {
            return Import(importFilename, null, backend, out actions);
        }

        /// <summary>
        /// Imports the given graph from a file with the given filename.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="importFilename">The filename of the file to be imported.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="graphModel">The graph model to be used.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(String importFilename, IBackend backend, IGraphModel graphModel, out BaseActions actions)
        {
            FileInfo fi = new FileInfo(importFilename);
            long fileSize = fi.Length;
            return Import(new StreamReader(importFilename), fileSize, backend, graphModel, out actions);
        }
        
        /// <summary>
        /// Imports the given graph from the given text reader input stream.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="reader">The text reader input stream import source.</param>
        /// <param name="fileSize">The size of the input file.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="graphModel">The graph model to be used.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(TextReader reader, long fileSize, IBackend backend, IGraphModel graphModel, out BaseActions actions)
        {
            GRSImport importer = new GRSImport(reader, fileSize);
            importer.backend = backend;
            importer.modelOverride = null;
            importer.model = graphModel;
            importer.ParseGraphBuildingScript();
            actions = importer.actions;
            return importer.graph;
        }

        private GRSImport(TextReader reader, long fileSize) {
            this.reader = reader;
            this.fileSize = fileSize;
            this.line = 1;
            this.column = 1;
            this.tokenFound = false;
            this.tokenKind = TokenKind.UNKNOWN;
            this.tokenContent = new StringBuilder();
        }
        
        private void ParseGraphBuildingScript()
        {
            ParseNewGraphCommand();
            while(LookaheadToken() != TokenKind.EOF)
            {
                if(LookaheadToken() == TokenKind.NEW)
                    ParseNewGraphElementCommand();
                else if(LookaheadToken() == TokenKind.IDENT)
                    ParseDeferredAttributeAssignment();
                else
                    throw GetSyntaxException("syntax error", "new command or deferred attribute assingment");
            }
        }

        private void ParseNewGraphCommand()
        {
            // new graph filename (graphname)?
            Match(TokenKind.NEW);
            Match(TokenKind.GRAPH);
            String modelFilename = MatchFilePath();
            String graphName = "";
            if(LookaheadText())
                graphName = ParseText();

            if(modelOverride!=null)
                modelFilename = modelOverride;
            else
                modelFilename += ".gm";

            // estimate a line creating one node or edge to 50 bytes
            int capacity = (int)(fileSize / 50);
            String capacityStr = "capacity=" + capacity.ToString();

            if(model!=null)
                graph = backend.CreateNamedGraph(model, graphName, capacityStr);
            else 
            {
                if(modelFilename.EndsWith(".grg"))
                    backend.CreateNamedFromSpec(modelFilename, graphName, ProcessSpecFlags.UseNoExistingFiles, new List<String>(), capacity,
                        out graph, out actions);
                else
                    graph = backend.CreateNamedGraph(modelFilename, graphName, capacityStr);
            }
        }

        private void ParseNewGraphElementCommand()
        {
            Match(TokenKind.NEW);
            if(LookaheadToken()==TokenKind.AT)
            {
                // new Node minus ElementDefinition arrow Node, for edge definition
                INode srcNode = ParseNode();
                Match(TokenKind.MINUS);
                string edgeName;
                EdgeType edgeType;
                IEdge edge = ParseEdgeDefinition(out edgeName, out edgeType);
                Match(TokenKind.ARROW);
                INode tgtNode = ParseNode();
                edgeType.SetSourceAndTarget(edge, srcNode, tgtNode);
                graph.AddEdge(edge, edgeName);
            }
            else if(LookaheadToken()==TokenKind.COLON)
            {
                // new ElementDefinition, for node definition
                string nodeName;
                INode node = ParseNodeDefinition(out nodeName);
                graph.AddNode(node, nodeName);
            }
            else
                throw GetSyntaxException("Syntax error", "@ for nodee start in edge definition or : for node definition");
        }

        private void ParseDeferredAttributeAssignment()
        {
            IGraphElement elem = ParseGraphElement();
            Match(TokenKind.DOT);
            string attrName = ParseText();
            AttributeType attrType = elem.Type.GetAttributeType(attrName);

            if(LookaheadToken()==TokenKind.EQUAL)
            {
                // GraphElement . Text = Value
                Match(TokenKind.EQUAL);
                ParseAttributeValue(elem, attrType);
            }
            /*else if(LookaheadToken()==TokenKind.LBOXBRACKET)
            {
                AttributeType indexAttrType;
                if(attrType.Kind == AttributeKind.ArrayAttr)
                    indexAttrType = new AttributeType(null, null, AttributeKind.IntegerAttr, null, null, null, null);
                else if(attrType.Kind == AttributeKind.DequeAttr)
                    indexAttrType = new AttributeType(null, null, AttributeKind.IntegerAttr, null, null, null, null);
                else if(attrType.Kind == AttributeKind.MapAttr)
                    indexAttrType = attrType.KeyType;
                else
                    throw GetSyntaxException("indexed assignment to type not offering indexed assignment", "map|array|deque type attribute");

                // GraphElement . Text [ Value ] = Value
                Match(TokenKind.LBOXBRACKET);
                object index = ParseAttributeSimpleValue(indexAttrType);
                Match(TokenKind.RBOXBRACKET);
                Match(TokenKind.EQUAL);
                ParseAttributeValue(elem, attrType);
                DeferredAttributeInitialization(elem, attrName, index, value);
            }*/
            else
                throw GetSyntaxException("Syntax error", "= for assignment to attribute or [ for indexed assignment to attribute");
        }

        private bool LookaheadText()
        {
            if(LookaheadToken() == TokenKind.IDENT)
                return true;
            else if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
                return true;
            else if(LookaheadToken() == TokenKind.SINGLEQUOTEDTEXT)
                return true;
            else
                return false;
        }

        private string ParseText()
        {
            if(LookaheadToken() == TokenKind.IDENT)
                return MatchAndReturnToken(TokenKind.IDENT);
            else if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
                return MatchAndReturnToken(TokenKind.DOUBLEQUOTEDTEXT);
            else if(LookaheadToken() == TokenKind.SINGLEQUOTEDTEXT)
                return MatchAndReturnToken(TokenKind.SINGLEQUOTEDTEXT);
            else
                throw GetSyntaxException("Syntax error", "ident or double quoted text or single quoted text");
        }

        private INode ParseNode()
        {
            // at lparen Text rparen
            Match(TokenKind.AT);
            Match(TokenKind.LPARENTHESIS);
            string nodeName = ParseText();
            Match(TokenKind.RPARENTHESIS);
            return GetNodeByName(nodeName);
        }

        private IGraphElement ParseGraphElement()
        {
            // at lparen Text rparen
            Match(TokenKind.AT);
            Match(TokenKind.LPARENTHESIS);
            string elemName = ParseText();
            Match(TokenKind.RPARENTHESIS);
            return GetElemByName(elemName);
        }

        private INode ParseNodeDefinition(out string nodeName)
        {
            // colon Text lparen dollar equal Text Attributes rparen
            Match(TokenKind.COLON);
            string typeName = ParseText();
            
            NodeType nodeType = graph.Model.NodeModel.GetType(typeName);
            if(nodeType == null) throw new Exception("Unknown node type: \"" + typeName + "\"");
            if(nodeType.IsAbstract) throw new Exception("Abstract node type \"" + typeName + "\" may not be instantiated!");
            
            Match(TokenKind.LPARENTHESIS);
            Match(TokenKind.DOLLAR);
            Match(TokenKind.EQUAL);
            nodeName = ParseText();

            INode node = nodeType.CreateNode();

            while(LookaheadToken() == TokenKind.COMMA)
            {
                Match(TokenKind.COMMA);
                string attribName = ParseText();
                Match(TokenKind.EQUAL);
                
                AttributeType attrType = node.Type.GetAttributeType(attribName);
                
                ParseAttributeValue(node, attrType);
            }
            Match(TokenKind.RPARENTHESIS);

            return node;
        }

        private IEdge ParseEdgeDefinition(out string edgeName, out EdgeType edgeType)
        {
            // colon Text lparen dollar equal Text Attributes rparen
            Match(TokenKind.COLON);
            string typeName = ParseText();

            edgeType = graph.Model.EdgeModel.GetType(typeName);
            if(edgeType == null) throw new Exception("Unknown edge type: \"" + typeName + "\"");
            if(edgeType.IsAbstract) throw new Exception("Abstract edge type \"" + typeName + "\" may not be instantiated!");
            
            Match(TokenKind.LPARENTHESIS);
            Match(TokenKind.DOLLAR);
            Match(TokenKind.EQUAL);
            edgeName = ParseText();
            
            IEdge edge = edgeType.CreateEdge();

            while(LookaheadToken() == TokenKind.COMMA)
            {
                Match(TokenKind.COMMA);
                string attribName = ParseText();
                Match(TokenKind.EQUAL);
                
                AttributeType attrType = edge.Type.GetAttributeType(attribName);
                
                ParseAttributeValue(edge, attrType);
            }
            Match(TokenKind.RPARENTHESIS);

            return edge;
        }

        private void ParseAttributeValue(IGraphElement elem, AttributeType attrType)
        {
            object attributeValue;
            if(LookaheadToken()==TokenKind.SET)
            {
                if(attrType.Kind != AttributeKind.SetAttr)
                    throw new Exception("Attribute initialization of set found, but expecting " + attrType.ToString());

                // set<type> { value * , } 
                Match(TokenKind.SET);
                Match(TokenKind.LANGLE);
                string type = ParseText();
                Match(TokenKind.RANGLE);

                IDictionary set = ContainerHelper.NewDictionary(
                    ContainerHelper.GetTypeFromNameForContainer(type, graph),
                    typeof(de.unika.ipd.grGen.libGr.SetValueType));

                Match(TokenKind.LBRACE);
                if(LookaheadToken() != TokenKind.RBRACE)
                {
                    object key = ParseAttributeSimpleValue(attrType.ValueType);
                    set[key] = null;
                    while(LookaheadToken() == TokenKind.COMMA)
                    {
                        Match(TokenKind.COMMA);
                        key = ParseAttributeSimpleValue(attrType.ValueType);
                        set[key] = null;
                    }
                }
                Match(TokenKind.RBRACE);

                attributeValue = set;
            }
            else if(LookaheadToken()==TokenKind.MAP)
            {
                if(attrType.Kind != AttributeKind.MapAttr)
                    throw new Exception("Attribute initialization of map found, but expecting " + attrType.ToString());

                // map<type,tgtType> { value -> tgtValue * , } 
                Match(TokenKind.MAP);
                Match(TokenKind.LANGLE);
                string type = ParseText();
                Match(TokenKind.COMMA);
                string tgtType = ParseText();
                Match(TokenKind.RANGLE);

                IDictionary map = ContainerHelper.NewDictionary(
                    ContainerHelper.GetTypeFromNameForContainer(type, graph),
                    ContainerHelper.GetTypeFromNameForContainer(tgtType, graph));

                Match(TokenKind.LBRACE);
                if(LookaheadToken() != TokenKind.RBRACE)
                {
                    object key = ParseAttributeSimpleValue(attrType.KeyType);
                    Match(TokenKind.ARROW);
                    object value = ParseAttributeSimpleValue(attrType.ValueType);
                    map[key] = value;
                    while(LookaheadToken() == TokenKind.COMMA)
                    {
                        Match(TokenKind.COMMA);
                        key = ParseAttributeSimpleValue(attrType.KeyType);
                        Match(TokenKind.ARROW);
                        value = ParseAttributeSimpleValue(attrType.ValueType);
                        map[key] = value;
                    }
                }
                Match(TokenKind.RBRACE);

                attributeValue = map;
            }
            else if(LookaheadToken()==TokenKind.ARRAY)
            {
                if(attrType.Kind != AttributeKind.ArrayAttr)
                    throw new Exception("Attribute initialization of array found, but expecting " + attrType.ToString());

                // array<type> [ value * , ]
                Match(TokenKind.ARRAY);
                Match(TokenKind.LANGLE);
                string type = ParseText();
                Match(TokenKind.RANGLE);

                IList array = ContainerHelper.NewList(
                    ContainerHelper.GetTypeFromNameForContainer(type, graph));

                Match(TokenKind.LBOXBRACKET);
                if(LookaheadToken() != TokenKind.RBOXBRACKET)
                {
                    object value = ParseAttributeSimpleValue(attrType.ValueType);
                    array.Add(value);
                    while(LookaheadToken() == TokenKind.COMMA)
                    {
                        Match(TokenKind.COMMA);
                        value = ParseAttributeSimpleValue(attrType.ValueType);
                        array.Add(value);
                    }
                }
                Match(TokenKind.RBOXBRACKET);

                attributeValue = array;
            }
            else if(LookaheadToken()==TokenKind.DEQUE)
            {
                if(attrType.Kind != AttributeKind.DequeAttr)
                    throw new Exception("Attribute initialization of deque found, but expecting " + attrType.ToString());

                // deque<type> ] value * , [
                Match(TokenKind.DEQUE);
                Match(TokenKind.LANGLE);
                string type = ParseText();
                Match(TokenKind.RANGLE);

                IDeque deque = ContainerHelper.NewDeque(
                    ContainerHelper.GetTypeFromNameForContainer(type, graph));

                Match(TokenKind.RBOXBRACKET);
                if(LookaheadToken() != TokenKind.LBOXBRACKET)
                {
                    object value = ParseAttributeSimpleValue(attrType.ValueType);
                    deque.Enqueue(value);
                    while(LookaheadToken() == TokenKind.COMMA)
                    {
                        Match(TokenKind.COMMA);
                        value = ParseAttributeSimpleValue(attrType.ValueType);
                        deque.Enqueue(value);
                    }
                }
                Match(TokenKind.LBOXBRACKET);

                attributeValue = deque;
            }
            else
            {
                // value
                attributeValue = ParseAttributeSimpleValue(attrType);
            }

            /*AttributeChangeType changeType = AttributeChangeType.Assign;
            if(elem is INode)
                graph.ChangingNodeAttribute((INode)elem, attrType, changeType, value, null);
            else
                graph.ChangingEdgeAttribute((IEdge)elem, attrType, changeType, value, null);
            */
            elem.SetAttribute(attrType.Name, attributeValue);
        }

        private object ParseAttributeSimpleValue(AttributeType attrType)
        {
            switch(attrType.Kind)
            {
                case AttributeKind.ByteAttr:
                    return ParseByteValue();
                case AttributeKind.ShortAttr:
                    return ParseShortValue();
                case AttributeKind.IntegerAttr:
                    return ParseIntValue();
                case AttributeKind.LongAttr:
                    return ParseLongValue();
                case AttributeKind.BooleanAttr:
                    return ParseBooleanValue();
                case AttributeKind.StringAttr:
                    return ParseStringValue();
                case AttributeKind.EnumAttr:
                    return ParseEnumValue(attrType.EnumType);
                case AttributeKind.FloatAttr:
                    return ParseFloatValue();
                case AttributeKind.DoubleAttr:
                    return ParseDoubleValue();
                case AttributeKind.ObjectAttr:
                    return ParseObjectValue();
                case AttributeKind.GraphAttr:
                    return ParseGraphValue();
                case AttributeKind.NodeAttr:
                    return ParseNodeValue(attrType.TypeName);
                case AttributeKind.EdgeAttr:
                    return ParseEdgeValue(attrType.TypeName);
                case AttributeKind.MapAttr:
                case AttributeKind.SetAttr:
                case AttributeKind.ArrayAttr:
                case AttributeKind.DequeAttr:
                    throw new Exception("Internal error, non-simple value in simple value parsing");
                default:
                    throw new Exception("Unsupported attribute type " + attrType.ToString());
            }
        }

        private sbyte ParseByteValue()
        {
            if(LookaheadToken() == TokenKind.HEXNUMBER_BYTE)
                return SByte.Parse(EatAndReturnToken(), System.Globalization.NumberStyles.HexNumber);
            else if(LookaheadToken() == TokenKind.NUMBER_BYTE)
                return SByte.Parse(EatAndReturnToken());
            else
                throw GetSyntaxException("Literal type error", "byte number or hex byte number");
        }

        private short ParseShortValue()
        {
            if(LookaheadToken() == TokenKind.HEXNUMBER_SHORT)
                return Int16.Parse(EatAndReturnToken(), System.Globalization.NumberStyles.HexNumber);
            else if(LookaheadToken() == TokenKind.NUMBER_SHORT)
                return Int16.Parse(EatAndReturnToken());
            else
                throw GetSyntaxException("Literal type error", "short number or hex short number");
        }

        private int ParseIntValue()
        {
            if(LookaheadToken() == TokenKind.HEXNUMBER)
                return Int32.Parse(EatAndReturnToken(), System.Globalization.NumberStyles.HexNumber);
            else if(LookaheadToken() == TokenKind.NUMBER)
                return Int32.Parse(EatAndReturnToken());
            else
                throw GetSyntaxException("Literal type error", "int number or hex int number");
        }

        private long ParseLongValue()
        {
            if(LookaheadToken() == TokenKind.HEXNUMBER_LONG)
                return Int64.Parse(EatAndReturnToken(), System.Globalization.NumberStyles.HexNumber);
            else if(LookaheadToken() == TokenKind.NUMBER_LONG)
                return Int64.Parse(EatAndReturnToken());
            else
                throw GetSyntaxException("Literal type error", "long number or hex long number");
        }

        private bool ParseBooleanValue()
        {
            if(LookaheadToken() == TokenKind.TRUE)
            {
                EatToken();
                return true;
            }
            else if(LookaheadToken() == TokenKind.FALSE)
            {
                EatToken();
                return false;
            }
            else
                throw GetSyntaxException("Literal type error", "boolean literal (true|false)");
        }

        private string ParseStringValue()
        {
            if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
                return EatAndReturnToken();
            else if(LookaheadToken() == TokenKind.SINGLEQUOTEDTEXT)
                return EatAndReturnToken();
            else
                throw GetSyntaxException("Literal type error", "double quoted or single quoted string");
        }

        private object ParseEnumValue(EnumAttributeType enumAttrType)
        {
            string enumName = ParseText();
            string enumValue;
            if(LookaheadToken() == TokenKind.DOUBLECOLON)
            {
                Match(TokenKind.DOUBLECOLON);
                enumValue = ParseText();
            }
            else
            {
                enumValue = enumName;
                enumName = enumAttrType.Name;
            }

            if(enumAttrType.Name != enumName)
                throw GetSyntaxException("", "enum type " + enumAttrType.Name);

            object value;
            int val;
            if(Int32.TryParse(enumValue, out val))
                value = Enum.ToObject(enumAttrType.EnumType, val);
            else
                value = Enum.Parse(enumAttrType.EnumType, enumValue);
            if(value == null)
                throw GetSyntaxException("Unknown enum member", "member of " + enumAttrType.Name);

            return value;
        }

        private float ParseFloatValue()
        {
            if(LookaheadToken() == TokenKind.NUMFLOAT)
                return Single.Parse(EatAndReturnToken(), System.Globalization.CultureInfo.InvariantCulture);
            else if(LookaheadToken() == TokenKind.NUMBER)
                return Single.Parse(EatAndReturnToken(), System.Globalization.CultureInfo.InvariantCulture);
            else
                throw GetSyntaxException("Literal type error", "float number");
        }

        private double ParseDoubleValue()
        {
            if(LookaheadToken() == TokenKind.NUMDOUBLE)
                return Double.Parse(EatAndReturnToken(), System.Globalization.CultureInfo.InvariantCulture);
            else if(LookaheadToken() == TokenKind.NUMBER)
                return Double.Parse(EatAndReturnToken(), System.Globalization.CultureInfo.InvariantCulture);
            else
                throw GetSyntaxException("Literal type error", "double number");
        }

        private object ParseObjectValue()
        {
            if(LookaheadToken() == TokenKind.NULL)
                throw GetSyntaxException("(Non-null) Object attributes unsupported", "null");
            EatToken();
            return null;
        }

        private IGraph ParseGraphValue()
        {
            if(LookaheadToken() == TokenKind.NULL)
                throw GetSyntaxException("(Non-null) (Sub-)Graph attributes unsupported", "null");
            EatToken();
            return null;
        }

        private INode ParseNodeValue(string typeName)
        {
            return GetNodeByName(ParseText());
        }

        private IEdge ParseEdgeValue(string typeName)
        {
            return GetEdgeByName(ParseText());
        }

        private void ThrowSyntaxError(TokenKind kind)
        {
            switch(kind)
            {
                case TokenKind.DOUBLECOLON:
                    throw GetSyntaxException("Syntax error", "::");
                case TokenKind.DOLLAR:
                    throw GetSyntaxException("Syntax error", "$");
                case TokenKind.EQUAL:
                    throw GetSyntaxException("Syntax error", "=");
                case TokenKind.COMMA:
                    throw GetSyntaxException("Syntax error", ",");
                case TokenKind.ARROW:
                    throw GetSyntaxException("Syntax error", "->");
                case TokenKind.MINUS:
                    throw GetSyntaxException("Syntax error", "-");
                case TokenKind.LPARENTHESIS:
                    throw GetSyntaxException("Syntax error", "(");
                case TokenKind.RPARENTHESIS:
                    throw GetSyntaxException("Syntax error", ")");
                case TokenKind.AT:
                    throw GetSyntaxException("Syntax error", "@");
                case TokenKind.LANGLE:
                    throw GetSyntaxException("Syntax error", "<");
                case TokenKind.RANGLE:
                    throw GetSyntaxException("Syntax error", ">");
                case TokenKind.LBRACE:
                    throw GetSyntaxException("Syntax error", "{");
                case TokenKind.RBRACE:
                    throw GetSyntaxException("Syntax error", "}");
                case TokenKind.LBOXBRACKET:
                    throw GetSyntaxException("Syntax error", "[");
                case TokenKind.RBOXBRACKET:
                    throw GetSyntaxException("Syntax error", "]");
                case TokenKind.NUMBER:
                case TokenKind.NUMBER_BYTE:
                case TokenKind.NUMBER_SHORT:
                case TokenKind.NUMBER_LONG:
                    throw GetSyntaxException("Syntax error", "number");
                case TokenKind.HEXNUMBER:
                case TokenKind.HEXNUMBER_BYTE:
                case TokenKind.HEXNUMBER_SHORT:
                case TokenKind.HEXNUMBER_LONG:
                    throw GetSyntaxException("Syntax error", "number in hex notation");
                case TokenKind.NUMFLOAT:
                case TokenKind.NUMDOUBLE:
                    throw GetSyntaxException("Syntax error", "floating point number");
                case TokenKind.DOUBLEQUOTEDTEXT:
                    throw GetSyntaxException("Syntax error", "double quoted text");
                case TokenKind.SINGLEQUOTEDTEXT:
                    throw GetSyntaxException("Syntax error", "single quoted text");
                case TokenKind.IDENT:
                    throw GetSyntaxException("Syntax error", "identifier");
                case TokenKind.FALSE:
                    throw GetSyntaxException("Syntax error", "false");
                case TokenKind.GRAPH:
                    throw GetSyntaxException("Syntax error", "graph");
                case TokenKind.NEW:
                    throw GetSyntaxException("Syntax error", "new");
                case TokenKind.NULL:
                    throw GetSyntaxException("Syntax error", "null");
                case TokenKind.TRUE:
                    throw GetSyntaxException("Syntax error", "true");
                case TokenKind.SET:
                    throw GetSyntaxException("Syntax error", "set");
                case TokenKind.MAP:
                    throw GetSyntaxException("Syntax error", "map");
                case TokenKind.ARRAY:
                    throw GetSyntaxException("Syntax error", "array");
                case TokenKind.DEQUE:
                    throw GetSyntaxException("Syntax error", "deque");
            }
        }

        private void Match(TokenKind kind)
        {
            if(LookaheadToken() != kind)
                ThrowSyntaxError(kind);

            EatToken();
        }

        private string MatchAndReturnToken(TokenKind kind)
        {
            if(LookaheadToken() != kind)
                ThrowSyntaxError(kind);

            return EatAndReturnToken();
        }

        private Exception GetSyntaxException(string what, string expected)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("at line ");
            sb.Append(line);
            sb.Append(", column ");
            sb.Append(column);
            sb.Append(": \"");
            sb.Append(what);
            sb.Append("\" -- expected ");
            sb.Append(expected);
            sb.Append(" but found ");
            sb.Append(tokenContent.ToString());
            return new Exception(sb.ToString());
        }

        private void EatToken()
        {
            tokenFound = false;
            tokenKind = TokenKind.UNKNOWN;
            tokenContent.Length = 0;
        }

        private string EatAndReturnToken()
        {
            string result = tokenContent.ToString();
            tokenFound = false;
            tokenKind = TokenKind.UNKNOWN;
            tokenContent.Length = 0;
            return result;
        }

        private string MatchFilePath()
        {
            while(Lookahead() == ' ' || Lookahead() == '\t')
            {
                EatCharWithoutIngesting();
            }
                        
            if(Lookahead() == '\"')
            {
                EatCharWithoutIngesting();
                while(Lookahead() != '\"' && Lookahead() != '\0')
                {
                    EatChar();
                }
                if(Lookahead() == '\0')
                    throw GetTokenException("Missing termination of double quoted string", "\"");
                EatCharWithoutIngesting();
                string path = tokenContent.ToString();
                EatToken();
                return path;
            }
            
            if(Lookahead() == '\'')
            {
                EatCharWithoutIngesting();
                while(Lookahead() != '\'' && Lookahead() != '\0')
                {
                    EatChar();
                }
                if(Lookahead() == '\0')
                    throw GetTokenException("Missing termination of double quoted string", "\"");
                EatCharWithoutIngesting();
                string path = tokenContent.ToString();
                EatToken();
                return path;
            }

            while(true)
            {
                if(char.IsLetterOrDigit(Lookahead())) // TODO: is the underscore included?
                {
                    EatChar();
                    continue;
                }

                switch(Lookahead())
                {
                    case '-':
                    case '.':
                    case ',':
                    case ':':
                    case '/':
                    case '\\':
                    case '(':
                    case ')':
                        EatChar();
                        break;
                    default:
                        string path = tokenContent.ToString();
                        EatToken();
                        return path;
                }
            }
        }

        // if no token was matched yet or the last was not eaten yet: determines next token, yields filled tokenKind and tokenContent variables
        // if token was already matched it returns it (idempotent operation); use EatToken so the lastly matched gives way for ingesting the next one
        private TokenKind LookaheadToken()
        {
            if(tokenFound)
                return tokenKind;

            if(reader.Peek() == -1)
                return FoundToken(TokenKind.EOF);

            char lookahead = (char)reader.Peek();

            if(lookahead == '#' || lookahead == ' ' || lookahead == '\n' || lookahead == '\r' || lookahead == '\t')
            {
                SkipWhitespaceAndComment();
                
                if(reader.Peek() == -1)
                    return FoundToken(TokenKind.EOF);

                lookahead = (char)reader.Peek();
            }

            if(char.IsLetter(lookahead))
                return TokenizeIdentOrKeyword();

            if(char.IsDigit(lookahead))
                return TokenizeNumber();

            switch(lookahead)
            {
                case ':':
                    EatChar();
                    if(Lookahead() == ':')
                    {
                        EatChar();
                        return FoundToken(TokenKind.DOUBLECOLON);
                    }
                    return FoundToken(TokenKind.COLON);

                case '+':
                    EatChar();
                    return TokenizeNumber();

                case '-':
                    EatChar();
                    if(Lookahead() == '>')
                    {
                        EatChar();
                        return FoundToken(TokenKind.ARROW);
                    }
                    if(char.IsDigit(Lookahead()) || Lookahead() == '.')
                        return TokenizeNumber();
                    return FoundToken(TokenKind.MINUS);

                case '.':
                    EatChar();
                    if(char.IsDigit(Lookahead()))
                        return TokenizeFloatingPointNumber();
                    return FoundToken(TokenKind.DOT);

                case '$':
                    EatChar();
                    return FoundToken(TokenKind.DOLLAR);

                case '=':
                    EatChar();
                    return FoundToken(TokenKind.EQUAL);

                case ',':
                    EatChar();
                    return FoundToken(TokenKind.COMMA);

                case '(':
                    EatChar();
                    return FoundToken(TokenKind.LPARENTHESIS);

                case ')':
                    EatChar();
                    return FoundToken(TokenKind.RPARENTHESIS);

                case '@':
                    EatChar();
                    return FoundToken(TokenKind.AT);

                case '<':
                    EatChar();
                    return FoundToken(TokenKind.LANGLE);

                case '>':
                    EatChar();
                    return FoundToken(TokenKind.RANGLE);

                case '{':
                    EatChar();
                    return FoundToken(TokenKind.LBRACE);

                case '}':
                    EatChar();
                    return FoundToken(TokenKind.RBRACE);

                case '[':
                    EatChar();
                    return FoundToken(TokenKind.LBOXBRACKET);

                case ']':
                    EatChar();
                    return FoundToken(TokenKind.RBOXBRACKET);

                case '\"':
                    EatCharWithoutIngesting();
                    while(Lookahead() != '\"' && Lookahead() != '\0')
                    {
                        EatChar();
                    }
                    if(Lookahead() == '\0')
                        throw GetTokenException("Missing termination of double quoted string", "\"");
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.DOUBLEQUOTEDTEXT);

                case '\'':
                    EatCharWithoutIngesting();
                    while(Lookahead() != '\'' && Lookahead() != '\0')
                    {
                        EatChar();
                    }
                    if(Lookahead() == '\0')
                        throw GetTokenException("Missing termination of single quoted sring", "\'");
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.SINGLEQUOTEDTEXT);

                default:
                    throw GetTokenException("Unknown/unsupported character", "\"0-9,a-z,A-Z,:,+,-,.,$,=,\",\",(,),@,<,>,{,},[,],\",\',\\n,\\r,\\t, ,#\"");
            }
        }

        private TokenKind TokenizeIdentOrKeyword()
        {
            EatChar(); // lookahead was IsLetter
            while(char.IsLetterOrDigit(Lookahead())) // TODO: is the underscore included?
            {
                EatChar();
            }

            if(tokenContent.Length < 3 || tokenContent.Length > 5)
                return FoundToken(TokenKind.IDENT);

            switch(tokenContent[0])
            {
                case 'a':
                    if(tokenContent.Length == 5
                        && tokenContent[1] == 'r'
                        && tokenContent[2] == 'r'
                        && tokenContent[3] == 'a'
                        && tokenContent[4] == 'y')
                        return FoundToken(TokenKind.ARRAY);
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'd':
                    if(tokenContent.Length == 5
                        && tokenContent[1] == 'e'
                        && tokenContent[2] == 'q'
                        && tokenContent[3] == 'u'
                        && tokenContent[4] == 'e')
                        return FoundToken(TokenKind.DEQUE);
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'f':
                case 'F':
                    if(tokenContent.Length == 5
                        && tokenContent[1] == 'a'
                        && tokenContent[2] == 'l'
                        && tokenContent[3] == 's'
                        && tokenContent[4] == 'e')
                        return FoundToken(TokenKind.FALSE);
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'g':
                    if(tokenContent.Length == 5
                        && tokenContent[1] == 'r'
                        && tokenContent[2] == 'a'
                        && tokenContent[3] == 'p'
                        && tokenContent[4] == 'h')
                        return FoundToken(TokenKind.GRAPH);
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'm':
                    if(tokenContent.Length == 3
                        && tokenContent[1] == 'a'
                        && tokenContent[2] == 'p')
                        return FoundToken(TokenKind.MAP);
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'n':
                    if(tokenContent.Length == 3
                        && tokenContent[1] == 'e'
                        && tokenContent[2] == 'w')
                        return FoundToken(TokenKind.NEW);
                    else if(tokenContent.Length == 4
                        && tokenContent[1] == 'u'
                        && tokenContent[2] == 'l'
                        && tokenContent[3] == 'l')
                        return FoundToken(TokenKind.NULL);
                    else
                        return FoundToken(TokenKind.IDENT);
                case 's':
                    if(tokenContent.Length == 3
                        && tokenContent[1] == 'e'
                        && tokenContent[2] == 't')
                        return FoundToken(TokenKind.SET);
                    else
                        return FoundToken(TokenKind.IDENT);
                case 't':
                case 'T':
                    if(tokenContent.Length == 4
                        && tokenContent[1] == 'r'
                        && tokenContent[2] == 'u'
                        && tokenContent[3] == 'e')
                        return FoundToken(TokenKind.TRUE);
                    else
                        return FoundToken(TokenKind.IDENT);
                default:
                    return FoundToken(TokenKind.IDENT);
            }
        }

        private TokenKind TokenizeNumber()
        {
            if(Lookahead() == '0')
            {
                char eaten = EatCharWithoutIngesting();
                if(Lookahead() == 'x' || Lookahead() == 'X')
                {
                    EatCharWithoutIngesting();
                    return TokenizeHexNumber();
                }
                tokenContent.Append(eaten);
            }

            while(true)
            {
                if(char.IsDigit(Lookahead()))
                {
                    EatChar();
                    continue;
                }

                switch(Lookahead())
                {
                    case '.':
                        return TokenizeFloatingPointNumber();

                    case 'e':
                    case 'E':
                        return TokenizeFloatingPointNumber();

                    case 'y':
                    case 'Y':
                        EatCharWithoutIngesting();
                        return FoundToken(TokenKind.NUMBER_BYTE);

                    case 's':
                    case 'S':
                        EatCharWithoutIngesting();
                        return FoundToken(TokenKind.NUMBER_SHORT);

                    case 'l':
                    case 'L':
                        EatCharWithoutIngesting();
                        return FoundToken(TokenKind.NUMBER_LONG);

                    case 'f':
                    case 'F':
                        return TokenizeFloatingPointNumber();

                    case 'd':
                    case 'D':
                        return TokenizeFloatingPointNumber();

                    default:
                        return FoundToken(TokenKind.NUMBER);
                }
            }
        }

        private TokenKind TokenizeHexNumber()
        {
            // starts after 0x was eaten in TokenizeNumber

            if(!char.IsDigit(Lookahead()) && !char.IsLetter(Lookahead()))
                throw GetTokenException("No hex number following hex prefix 0x", "0-9,a-f,A-F");

            while(true)
            {
                if(char.IsDigit(Lookahead()))
                {
                    EatChar();
                    continue;
                }

                switch(Lookahead())
                {
                    case 'a':
                    case 'b':
                    case 'c':
                    case 'd':
                    case 'e':
                    case 'f':
                    case 'A':
                    case 'B':
                    case 'C':
                    case 'D':
                    case 'E':
                    case 'F':
                        EatChar();
                        break;

                    case 'y':
                    case 'Y':
                        EatCharWithoutIngesting();
                        return FoundToken(TokenKind.HEXNUMBER_BYTE);

                    case 's':
                    case 'S':
                        EatCharWithoutIngesting();
                        return FoundToken(TokenKind.HEXNUMBER_SHORT);

                    case 'l':
                    case 'L':
                        EatCharWithoutIngesting();
                        return FoundToken(TokenKind.HEXNUMBER_LONG);

                    default:
                        return FoundToken(TokenKind.HEXNUMBER);
                }
            }
        }

        private TokenKind TokenizeFloatingPointNumber()
        {
            // starts when . or e|E or f|F or d|D is seen in TokenizeNumber or after . was eaten in LookaheadToken

            while(true)
            {
                if(char.IsDigit(Lookahead()))
                {
                    EatChar();
                    continue;
                }

                switch(Lookahead())
                {
                    case '.':
                        EatChar();
                        break;

                    case 'e':
                    case 'E':
                        EatChar();
                        return TokenizeFloatingPointNumberExponent();

                    case 'f':
                    case 'F':
                        EatCharWithoutIngesting();
                        return FoundToken(TokenKind.NUMFLOAT);

                    case 'd':
                    case 'D':
                        EatCharWithoutIngesting();
                        return FoundToken(TokenKind.NUMDOUBLE);

                    default:
                        return FoundToken(TokenKind.NUMDOUBLE);
                }
            }
        }

        private TokenKind TokenizeFloatingPointNumberExponent()
        {
            // starts after e|E was eaten in TokenizeFloatingPointNumber

            if(Lookahead() == '+' || Lookahead() == '-')
                EatChar();

            if(!char.IsDigit(Lookahead()))
                throw GetTokenException("No exponent number following exponent introduction e|E in floating point number", "+,-,0-9");

            while(true)
            {
                if(char.IsDigit(Lookahead()))
                {
                    EatChar();
                    continue;
                }

                switch(Lookahead())
                {
                    case 'f':
                    case 'F':
                        EatCharWithoutIngesting();
                        return FoundToken(TokenKind.NUMFLOAT);

                    case 'd':
                    case 'D':
                        EatCharWithoutIngesting();
                        return FoundToken(TokenKind.NUMDOUBLE);

                    default:
                        return FoundToken(TokenKind.NUMDOUBLE);
                }
            }
        }

        private void SkipWhitespaceAndComment()
        {
            while(true)
            {
                switch(Lookahead())
                {
                    case ' ':
                    case '\t':
                        EatCharWithoutIngesting();
                        break;

                    case '\r':
                        EatCharWithoutIngesting();
                        if(Lookahead() == '\n')
                            EatCharWithoutIngesting();
                        ++line;
                        column = 0;
                        break;

                    case '\n':
                        EatCharWithoutIngesting();
                        ++line;
                        column = 0;
                        break;

                    case '#':
                        EatCharWithoutIngesting();
                        while(Lookahead() != '\n' && Lookahead() != '\r' && Lookahead() != '\0')
                        {
                            EatCharWithoutIngesting();
                        }
                        break;

                    default:
                        return;
                }
            }
        }

        private char Lookahead()
        {
            if(reader.Peek() == -1)
                return '\0';
            else
                return (char)reader.Peek();
        }

        private void EatChar()
        {
            ++column;
            tokenContent.Append((char)reader.Read());
        }

        private char EatCharWithoutIngesting()
        {
            ++column;
            return (char)reader.Read();
        }

        private TokenKind FoundToken(TokenKind kind)
        {
            tokenFound = true;
            tokenKind = kind;
            return tokenKind;
        }

        private Exception GetTokenException(string what, string expected)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("at line ");
            sb.Append(line);
            sb.Append(", column ");
            sb.Append(column);
            sb.Append(": \"");
            sb.Append(what);
            sb.Append("\" -- expected ");
            sb.Append(expected);
            sb.Append(" but found ");
            sb.Append(Lookahead());
            return new Exception(sb.ToString());
        }

        private INode GetNodeByName(String elemName)
        {
            return (INode)GetElemByName(elemName);
        }

        private IEdge GetEdgeByName(String elemName)
        {
            return (IEdge)GetElemByName(elemName);
        }

        private IGraphElement GetElemByName(String elemName)
        {
            IGraphElement elem = graph.GetGraphElement(elemName);
            if(elem == null) throw new Exception("Unknown graph element " + elemName);
            return elem;
        }
    }
}
