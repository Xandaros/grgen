\chapter{Storages, Visited Flags, and Set Returning Graph Queries}\indexmain{storage}\indexmain{visited flag}
\label{cha:storagesvisited}

In this chapter we'll have in the fist part a look at storages,
which are variables of container type which (may) contain graph elements;
and at the sequence computation and rule constructs concerned with them.
In the second part we'll then have a look at the visited flags, 
used for marking already visited elements or for partitioning a graph;
and at the sequence computation and rule constructs concerned with them.
We close the chapter with an overview of the set returning graph queries,
available in the expressions of the rule language,
and in the expressions of the sequence computations.

%-----------------------------------------------------------------------------------------------
\section{Storage Handling in the Sequences}\label{sec:storages}\indexmain{storage}

Storages are variables of container (set/map/array/deque) type (cf. \ref{sec:builtingenerictypes}) storing nodes or edges.
They are primarily used in the sequences, from where they are handed in to the rules via \texttt{ref} parameters (but additionally container attributes in graph elements may be used as storages,
esp. for doing data flow analyses, cf. \ref{subsub:flow}).
They allow to decouple processing phases: the first run collects all graph elements relevant for the second run which consists of a sequence executed for each graph element in the set.
A difference of storage sets and maps in the sequences to the sets and maps in the rewrite rules is that they only offer imperative addition and removal instead of union, intersection, difference and construction, and only empty constructors without initializing elements.
The splitting of transformations into passes mediated by container valued global variables allows for subgraph copying without model pollution, cf. \ref{subsub:copystructure}; please have a look at \ref{sub:mergesplit}, \ref{subsub:copystructure} and \ref{subsub:flow} regarding a discussion on when to use which transformation combinators and for storage examples.
The syntax diagrams given in the Rule Application Control Language chapter \ref{cha:xgrs} already contained the storage constructs.
Here we only give some refinements and explanations of the semantics.

\begin{rail}
  Type: 'set' '<' Type '>'
    | 'map' '<' KeyType ',' ValueType '>'
    | 'array' '<' Type '>'
    | 'deque' '<' Type '>'
  ;
  Literal:
    'set' '<' Type '>' lbrace rbrace |
    'map' '<' KeyType ',' ValueType '>' lbrace rbrace |
    'array' '<' Type '>' '[' ']' |
    'deque' '<' Type '>' ']' '['
	;
\end{rail}\indexmain{map}\indexmain{array}\indexmain{set}\indexmain{deque}%\makeatother

The Type used in a variable declaration may be set or map or array or deque.
The Literals used in variable initialization may be empty sets or maps or arrays or deques.
A container must be created and assigned to a variable before it can be used.

\begin{example}
\begin{grgen}
::x=set<NodeTypeA>{}
y:map<Node,Edge> = map<Node,Edge>{}
\end{grgen}
The first line declares or references a global variable \texttt{x} (without static type) and assigns the newly created, empty set of type \texttt{set<NodeTypeA>} to it as value.
The second line declares a variable \texttt{y} of type \texttt{map<Node,Edge>} and assigns the newly created, empty map of the same type to it as value.
\end{example}

\begin{rail}
  MethodName: 'add' | 'rem' | 'clear' | 'size' | 'empty' | 'peek';
\end{rail}\ixkeyw{add}\ixkeyw{rem}\ixkeyw{clear}\ixkeyw{size}\ixkeyw{empty}\ixkeyw{peek}

\noindent There are several sequence computation operations on set variables available in method call notation, these are:

\begin{description}
\item[Set addition:] \texttt{s.add(v)} adds the value \texttt{v} to the set \texttt{s}, succeeds always.
\item[Set removal:] \texttt{s.rem(v)} removes the value \texttt{v} from the set \texttt{s}, succeeds always.
\item[Set clearing:] \texttt{s.clear()} removes all values from the set \texttt{s}, succeeds always.
\end{description}

\noindent Very similar operations are available on map variables:

\begin{description}
\item[Map addition:] \texttt{m.add(k,v)} adds the pair (\texttt{k},\texttt{v}) to the map \texttt{m}, succeeds always.
\item[Map removal:] \texttt{m.rem(k)} removes the pair (\texttt{k},unknown) from the map \texttt{m}, succeeds always.
\item[Map clearing:] \texttt{m.clear()} removes all key-value-pairs from the map \texttt{m}, succeeds always.
\end{description}

\noindent Similar operations are available on array variables:

\begin{description}
\item[Array addition:] \texttt{a.add(v)} adds the value \texttt{v} to the end of array \texttt{a}, succeeds always.
\item[Array addition:] \texttt{a.add(v,i)} inserts the value \texttt{v} to the array \texttt{a} at index \texttt{i}, succeeds always.
\item[Array removal:] \texttt{a.rem()} removes the value at the end of array \texttt{a}, succeeds always.
\item[Array removal:] \texttt{a.rem(i)} removes the value at index \texttt{i} from the array \texttt{a}, succeeds always.
\item[Array clearing:] \texttt{a.clear()} removes all values from the array \texttt{a}, succeeds always.
\end{description}

\noindent Very similar operations are available on deque variables:

\begin{description}
\item[Deque addition:] \texttt{d.add(v)} adds the value \texttt{v} to the end of deque \texttt{d}, succeeds always.
\item[Deque addition:] \texttt{d.add(v,i)} inserts the value \texttt{v} to the deque \texttt{d} at index \texttt{i}, succeeds always.
\item[Deque removal:] \texttt{d.rem()} removes the value at the begin of deque \texttt{d}, succeeds always.
\item[Deque removal:] \texttt{d.rem(i)} removes the value at index \texttt{i} from the deque \texttt{d}, succeeds always.
\item[Deque clearing:] \texttt{d.clear()} removes all values from the deque \texttt{d}, succeeds always.
\end{description}

\noindent There are further operations which are only available in the sequence expressions, too, not only in the sequence computations as the constructs before; but they can't be chained as they don't return the storage and are in that sense terminal:

\begin{description}
\item[Size assignment:] \texttt{v=w.size()} writes the number of entries in the container \texttt{w} to the variable \texttt{v},\\succeeds always.
\item[Emptyness assignment:] \texttt{v=w.empty()} writes to the variable \texttt{v} whether the container \texttt{w} is empty, succeeds always.
\item[Peeking:] \texttt{v=w.peek(i)} writes to the variable \texttt{v} the value at the corresponding position \texttt{i} in the sequence of iteration, succeeds always. For arrays and deques that is the value at the corresponding index. A \texttt{w.peek()} on an array \texttt{w} yields the last element of the array, a \texttt{w.peek()} on a deque \texttt{w} yields the first element of the deque.
\item[Lookup assignement:] \texttt{v=m[k]} assigns the result of the map lookup or array or deque indexed access to the variable \texttt{v}, succeeds iff \texttt{k} was contained in \texttt{m} (or was a valid index), fails otherwise, not touching the variable \texttt{v}.
\item[Indexed assignement:] \texttt{a[i]=v} assigns the variable \texttt{v} to the array or deque or map \texttt{a} at the index \texttt{i}, overwriting the old value, succeeds iff \texttt{i} is a valid index into \texttt{a}, fails otherwise.
\end{description}

\noindent Handling of the storages is completed by the sequence expression operator \texttt{in} for membership query and the sequence loop for storage iteration.

\begin{rail}
  RewriteFactor:
    'for' lbrace (Var 'in' SetVar | Var '->' Var 'in' MapVar | Var 'in' ArrayVar | Var '->' Var 'in' ArrayVar) ';' RewriteSequence rbrace
    ;
\end{rail}\ixkeyw{in}\ixkeyw{for}\ixnterm{RewriteFactor}\label{forstorage}

The binary operator \texttt{v in w} checks for container membership; it returns true if \texttt{v} is contained in the set, or the domain of the map, or the array or deque \texttt{w}, otherwise false.
It is an O(1) operation for sets and maps, and a O(n) operation for arrays or deques.
The \texttt{for} command iterates over all elements in the set or array or deque, or all key-value pairs in the map or array or deque, and executes for each element / key-value pair the nested graph rewrite sequence; it completes successfully iff all sequences were executed successfully (an empty container causes immediate successful completion); the key in the key-value pair iteration of an array or deque is the integer typed index. (See \ref{forgraphelem} for another version of the \texttt{for} command.)

\begin{example}
The following XGRS is a typical storage usage.
First an empty set \texttt{x} is created, which gets populated by an rule \texttt{t} executed iteratedly, returning a node which is written to the set.
Then another rule is executed iteratedly for every member of the set doing the main work, and finally the set gets cleared to prevent memory leaks or later mistakes.
If the graph should stay untouched during set filling you may need \texttt{visited} flags to prevent endless looping.
\verb#x=set<Node>{} ;> ( (v)=t() && {x.add(v)} )+ && for{v in x; r(v)} <; {x.clear()}#
Handing in the storage to the rule, and using the set \texttt{add} method as introduced down below in \ref{sct:imperative} within the rule to fill the storage, allows to shorten the sequence to:\\
\verb#x=set<Node>{} ;> ( t(x) )+ && for{v in x; r(v)} <; {x.clear()}#\\
The for loop could be replaced by employing the storage access in the rule construct, cf. \ref{sub:storageaccess}; this would be especially benefitial if the rule \texttt{r} inside the for loop would have to change the storage \texttt{x}, which would corrupt the iteration/enumeration variable.
\end{example}

\begin{warning}
The container over which the for loop iterates must stay untouched during iteration.
\end{warning}


%-----------------------------------------------------------------------------------------------
\section{Storage Access in the Rules} \label{sub:storageaccess}\indexmain{storage access}

Storages can be used in the rule application control language as introduced above \ref{sec:storages}, they can get filled or emptied in the rules as defined here \ref{replstmt}, a discussion about their usage and examples are given here \ref{sub:mergesplit}, here \ref{subsub:copystructure}, and here \ref{subsub:flow}.
In the pattern part you may ask for an element to get bound to an element from a storage or a storage attribute;
this is syntactically specified by giving the storage enclosed in left and right braces.
You may ask for an element to get bound to the value element queried from a storagemap by a key graph element;
this is syntactically specified by giving the storagemap indexed by the key graph element enclosed in left and right braces
(this is not possible for storage map attributes due to internal limitations with the search planning).
If the type of the element retrieved from the storage is not compatible to the type of the pattern element specified,
or if the storage is empty, or if the key element is not contained in the storagemap, matching fails.

The advantage of this storage querying inside the rule over handing in a value from a for loop iterating the storage values outside the rule are: i) a more concise syntax, ii) the ability to access a storage attribute of an element just matched or to access a storage map with an element just matched in the same rule, which would require to break up the rule in two rules in the other case, and iii), a restriction of the iteration to the matching phase, so that at rewriting one can happily manipulate the storage without destroying the iterator/enumerator used in the loop which would be the case when using an outside loop.

The following syntax diagram gives an extensions to the syntax diagrams of the Rule Set Language chapter \ref{chaprulelang}, pattern part:
\begin{rail}
  StorageAccess:
    lbrace StorageVariable rbrace |
    lbrace NodeOrEdge '.' StorageAttribute rbrace |
    lbrace StorageMap '[' Ident ']' rbrace;
\end{rail}\ixnterm{StorageAccess}

\begin{example}
Queries the graph for the neighbouring cities to the cities contained in the storageset.
\begin{grgen}
test neighbour(ref startCities:set<City>) : City
{
    :City{startCities} -:Street-> n:City;
    return(n);
}
\end{grgen}
\end{example}

\begin{example}
Queries for the neighbour of the neighbour of a city matched.
With the first neigbouring relation queried from the storagemap assumed to contain the neighbouring relation of some cities of interest, and the second neighbouring relation queried from the graph.
\begin{grgen}
test neighbourneighbour(ref neighbours:map<City, City>) : City
{
    someCity:City;
    nc:City{neighbours[someCity]} -:Street-> nnc:City;
    return(nnc);
}
\end{grgen}
\end{example}

These were the storage queries available in the pattern part;
additionally you can query the storages in the \texttt{if} attribute evaluation clause,
with the set/map/array/deque expressions as given in the Types and Expressions chapter \ref{cha:typeexpr}.

Furthermore you can add and remove elements from the storages (or other, non-node/edge storing container) in the \texttt{eval} clause of the rewrite part, the following syntax diagrams give extensions to the \texttt{eval} clause:

\begin{rail}
  CompoundAssignment:
    (SetEntity | MapEntity) ('|' '=' | ampersand '=' | backslash '=') Expr ChangeAssignment? |
    (ArrayEntity | DequeEntity) '+' '=' Expr
  ;
  ChangeAssignment:
    ('=' '>' | '|' '>' | ampersand '>') (NodeOrEdge '.' BoolAttribute | BoolVariable | VisitedFlag)
  ;
\end{rail}\ixnterm{CompoundAssignment}

\begin{rail}
  ContainerStateChange:
   	SetEntity '.' ( ( 'add' '(' Expr ')') | ( 'rem' '(' Expr ')' ) ) |
	  MapEntity '.' ( ( 'add' '(' KeyExpr ',' ValueExpr ')' ) | ( 'rem' '(' KeyExpr ')' ) ) |
	  ArrayEntity '.' ( ( 'add' '(' ValueExpr (','  IndexExpr)? ')' ) | ( 'rem' '(' (IndexExpr)? ')' ) ) |
	  DequeEntity '.' ( ( 'add' '(' ValueExpr (','  IndexExpr)? ')' ) | ( 'rem' '(' (IndexExpr)? ')' ) ) |
	  ContainerEntity '.' 'clear' '(' ')' |
	  ArrayOrDequeOrMapEntity '[' IndexExpr ']' '=' Expr
	;
	AnyContainerEntity:
	  (NodeOrEdge '.' SetAttribute | Variable)
	;
\end{rail}\ixnterm{ContainerStateChange}

The by-ref container parameters or container attributes can be operated upon by the container state change methods,
which allow to only partially change the container by adding or removing or overwriting elements resp. pairs of elements (in contrast to normal assignments which replace overwrite the target variable entirely);
they are especially useful for containers containing nodes or edges.

\noindent The state change methods on containers are:

\begin{description}
\item[Set addition:] \texttt{s.add(v)} adds the value \texttt{v} to the set \texttt{s}.
\item[Set removal:] \texttt{s.rem(v)} removes the value \texttt{v} from the set \texttt{s}.
\item[Map addition:] \texttt{m.add(k,v)} adds the pair (\texttt{k},\texttt{v}) to the map \texttt{m}, overwrites the old value if a pair (\texttt{k},unknown) was already existing.
\item[Map removal:] \texttt{m.rem(k)} removes the pair (\texttt{k},unknown) from the map \texttt{m}.
\item[Array addition:] \texttt{a.add(v)} adds the value \texttt{v} to the end of array \texttt{a}.
\item[Array addition:] \texttt{a.add(v,i)} inserts the value \texttt{v} at index \texttt{i} to array \texttt{a}.
\item[Array removal:] \texttt{a.rem()} removes the value at then end of the array \texttt{a}.
\item[Array removal:] \texttt{a.rem(i)} removes the value at index \texttt{i} from the array \texttt{a}.
\item[Deque addition:] \texttt{d.add(v)} adds the value \texttt{v} to the end of deque \texttt{d}.
\item[Deque addition:] \texttt{d.add(v,i)} inserts the value \texttt{v} at index \texttt{i} to deque \texttt{d}.
\item[Deque removal:] \texttt{d.rem()} removes the value at then begin of the deque \texttt{d}.
\item[Deque removal:] \texttt{d.rem(i)} removes the value at index \texttt{i} from the deque \texttt{d}.
\item[Indexed assignment:] \texttt{a[i]=v} overwrites the old value at index \texttt{i} in the array or deque or map \texttt{a} with the new value \texttt{v}.
\end{description}

%currently only implemented for iterated accumulation, for sequences;   todo: extend to rules
%\begin{rail}
%  ForLoop:
%    'for' lbrace Var 'in' SetVar ';' RewriteSequence rbrace |
%    'for' lbrace Var '->' Var 'in' MapVar ';' RewriteSequence rbrace
%\end{rail}\ixkeyw{in}\ixkeyw{for}\ixnterm{ForLoop}

Compound assignments are assignments which use the first source as target, too,
only adapting the target value instead of computing a new value and overwriting the target with it.
For scalars this is not supported, but for container valued enitities it is offered due to performance reasons.
The compound assignment statements are union \verb#|=#, intersection \verb#&=# and difference \verb#\=# assignment on set/map and \verb#+=# concatenation assignment on arrays and deques; they are especially useful for sets and maps containing nodes or edges.

The compound assignments on sets and maps may be enhanced with a change assignment declaration.
The change value is \texttt{true} in case the target collection changes and \texttt{false} in case the target collection is not altered.
The assign-to operator \verb#=># assigns the change value to the specified target, the or-to operator \verb#|># assigns the boolean disjunction of the change value target with the change value to the change value target, the and-to operator \verb#&># assigns the boolean conjunction of the change value target with the change value to the change value target.
This addition allows for efficient data flow computations not needing to check for a change by set comparison, see \ref{subsub:flow}.


\begin{example}
The container state change methods \texttt{add} and \texttt{rem} allow to add graph elements to storages or remove graph elements from storages, i.e. sets or maps or arrays or deques holding nodes and edges used for rewrite in the calling sequence (cf. \ref{sec:storages}).
This way you can write transformations consisting of several passes with one pass operating on nodes/edges determined in a previous pass,
without the need to mark the element in the graph by helper edges or visited flags.
	\begin{grgen}
rule foo(ref storage:set<Node>)
{
  n:Node;
  modify {
    eval {
      storage.add(n);
    }
  }
}
	\end{grgen}
\end{example}



%-----------------------------------------------------------------------------------------------
\section{Visited Flag Handling in the Sequences}\label{sec:visited}

Visited flags are flags available for/in each graph element which can be set, reset, and queried in the rules and in the sequences and must be allocated and deallocated in the sequences;
they allow to mark already visited elements during a run over the graph.
The syntax diagrams given in the Rule Application Control Language chapter \ref{cha:xgrs} already contained the visited flag constructs.
Here we only give some refinements and explanations of the semantics.

The visited flags are stored in some excess bits of the graph elements, if this pool is exceeded they are stored in additional dictionaries, one per visited flag requested.
Due to this flags must get allocated/deallocated, and all flag related operations require an integer number -- the flag id -- specifying the flag to operate on (with exception of the allocation operation returning this flag id).
The operations always return true as sequence results (with exception of the operation reading the flag, it fails iff the visited flag is not set for the graph element);
if you try to access a not previously allocated visited flag, an exception is thrown.

\begin{rail}
  FunctionName: 'valloc' | 'vfree' | 'vreset' | 'vfreenonreset';
\end{rail}\ixkeyw{valloc}\ixkeyw{vfree}\ixkeyw{vreset}\ixkeyw{vfreenonreset}

The operations managing the visited flags are:
\begin{description}
\item[Flag allocation:] By \texttt{valloc}\label{allocvisitflag} -- allocates space for a visited flag in the elements of the graph and returns the id of the visited flag (integer number), starting at 0.
Afterwards, the visited flag of the id can be read and written within the rules by the \texttt{visited}-expression and the \texttt{visited}-assignment,
as well as by the \texttt{visited} flag reading and writing rewrite factors.
The first visited flags are stored in some excess bits of the graph elements and are thus essentially for free,
but if this implementation defined space is used up completely, the information is stored in graph element external dictionaries.
Visited flag allocation is only possible in sequence computations in the form of \texttt{var=valloc()}.
\item[Flag deallocation:] By \texttt{vfree} -- frees the space previously allocated for the visited flag; afterwards you must not access it anymore.
The value passed in \texttt{vfree(var)} must be of integer type, stemming from a previous allocation.
\item[Flag writing:] By \texttt{e.visited[f] = b} -- sets the visited status of the flag given by the flag id variable \texttt{f} of the graph element \texttt{e} to the given boolean value \texttt{b}; visited flags are normally written by \texttt{eval} parts of the rule language.
\item[Flag reading:] By \texttt{e.visited[f]} -- returns the visited status of the flag given by the flag id variable \texttt{f} of the graph element \texttt{e}; visited flags are normally read by \texttt{if} conditions of the rule language.
\item[Flag resetting:] By \texttt{vreset} -- resets the visitor flag given by the flag id variable in all graph elements.
\item[Flag deallocation without reset:] With \texttt{vfreenonreset} the space previously allocated for the visited flag is freed, too, but the implicit internal \texttt{vreset(id)} of \texttt{vfree} is not executed. It is your duty to ensure the flag is \texttt{false} in all graph elements -- otherwise after a following allocation elements may start as being marked. This saves us an O(n) operation, but opens the door to nasty bugs if you can't design your algorithm in a way which renders unmarking trivial.
\end{description}


%-----------------------------------------------------------------------------------------------
\section{Visited Flag Access in the Rules} \label{sub:visitedaccess}\indexmain{visited access}

The visited flag queries available in the \texttt{if} attribute evaluation clause of the pattern part are given in the Types and Expressions chapter \ref{cha:typeexpr}.

Additionally you can set them in the \texttt{eval} clause of the rewrite part, the following syntax diagram gives an extensions to the \texttt{eval} clause:

\begin{rail}
  VisitedAssignment:
    VisitedFlag '=' BoolExpr
	;
	VisitedFlag:
    NodeOrEdge '.' 'visited' ('[' FlagNumber ']')?
  ;
\end{rail}\ixnterm{VisitedAssignment}\ixkeyw{visited}

The \texttt{visited} flag assignment sets the \texttt{boolean} status of the \indexed{visited flag} of the given number for the given graph element.
If no flag number is given, the default number for the first visited flag of 0 is used.
Make sure to allocate \ref{allocvisitflag}/\ref{apiallocvisitflag} visited flags before you try to use them
(and deallocate them afterwards, as they are a sparse resource stored in some excess bits of the graph elements, or in some dictionary if the needed number of flags exceeds the number of available bits per graph element.)


%-----------------------------------------------------------------------------------------------
\section{Set Returning Graph Queries}\indexmain{set returning graph queries}\label{neighbouringelementsfunctions}

In this section we'll have primarily a look at set returning graph queries, which are available as functions in the expressions of the rules, as well as in the expressions of the sequence computations.
They are especially used to query for connected elements.
While they are convenient to use, they require to build a set that is likely thrown away thereafter, so esp. for large sets they are inefficent.

There are functions to ask for all nodes or edges of a type available: 
\begin{description}
\item[\texttt{nodes()}] returns all nodes in the graph, as set.
\item[\texttt{nodes(.)}] returns all nodes in the graph compatible to the given type, as set.
\item[\texttt{edges()}] returns all edges in the graph, as set.
\item[\texttt{edges(.)}] returns all edges in the graph compatible to the given type, as set.
\end{description}

Other functions allow to ask for the source or target node of an edge: 

\begin{description}
\item[\texttt{source(.)}] returns the source node of the given edge.
\item[\texttt{target(.)}] returns the target node of the given edge.
\end{description}

Furthermore, there are functions to query the directly neighbouring elements.
They allow to compute the set of edges incident to a node:

\begin{description}
\item[\texttt{incident(.)}] returns the set of the edges that are incident to the node given as argument value.
\item[\texttt{incident(.,.)}] as above, but only edges of the type given as second argument are contained.
\item[\texttt{indicent(.,.,.)}] as above, but only edges incident to an opposite node of the type given as third argument are contained.
\item[\texttt{incoming}] same as any of the incidents above, but restricted to incoming edges.
\item[\texttt{outgoing}] same as any of the incidents above, but restricted to outgoing edges.
\end{description}

In addition, they allow to compute the set of nodes adjacent to a node:

\begin{description}
\item[\texttt{adjacent(.)}] returns the set of the nodes that are adjacent to the node given as argument value.
\item[\texttt{adjacent(.,.)}] as above, but only nodes incident to an edge of the type given as second argument are contained.
\item[\texttt{adjacent(.,.,.)}] as above, but only nodes of the node type given as third argument are contained.
\item[\texttt{adjacentIncoming}] same as any of the adjacents above, but restricted to nodes reachable via incoming edges.
\item[\texttt{adjacentOutgoing}] same as any of the adjacents above, but restricted to nodes reachable via outgoing edges.
\end{description}

Beyond direct neighbourhood, transitive neighbourhood can be queried with the reachability functions.
They allow to compute the set of edges reachable from a node:

\begin{description}
\item[\texttt{reachableEdges(.)}] returns the set of the edges that are reachable from the node given as argument value.
\item[\texttt{reachableEdges(.,.)}] as above, but only edges of the type given as second argument are contained and followed.
\item[\texttt{reachableEdges(.,.,.)}] as above, but only edges incident to an opposite node of the type given as third argument are contained and followed.
\item[\texttt{reachableEdgesIncoming}] same as any of the reachableEdges above, but restricted to incoming edges.
\item[\texttt{reachableEdgesOutgoing}] same as any of the reachableEdges above, but restricted to outgoing edges.
\end{description}

In addition, they allow to compute the set of nodes reachable from a node:

\begin{description}
\item[\texttt{reachable(.)}] returns the set of the nodes that are reachable from the node given as argument value.
\item[\texttt{reachable(.,.)}] as above, but only nodes incident to an edge of the type given as second argument are contained and followed.
\item[\texttt{reachable(.,.,.)}] as above, but only nodes of the node type given as third argument are contained and followed.
\item[\texttt{reachableIncoming}] same as any of the reachables above, but restricted to nodes reachable via incoming edges.
\item[\texttt{reachableOutgoing}] same as any of the reachables above, but restricted to nodes reachable via outgoing edges.
\end{description}

% todo: beispiele

% todo: a common section for container handling in sequence computations and rule evals, make clearer that container methods in general hold for sequences expressions and rule expressions (in if/eval)
