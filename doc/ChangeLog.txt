v3.0beta3 (2011-07-04)
 LHS retyping:
  - allowed retype operator on lhs, x:T<y> tries to cast y to T, 
    if successful x allows to access y as T (attributes!), otherwise matching fails for this y

 Totally homomorphic matching:
  - with syntax independent(name) pattern elements may be requested to be matched homomorphic to any other element
  - isomorphy exceptions may be specified with syntax independent(name\name)
    or independent(name\(name+name+...+name))
  - this allows to match the already matched target node of a use-def backlink in a program graph,
    but is potentially dangerous as conflicting rewrites may be specified

 Iteration breaking:
  - iterated { X; break negative { Y; } }
    if the negative matches, not only the current iteration instance is prevented from matching, 
    but the entire iterated is failing to match
  - iterated { X; break independent { Y; } }
    if the independent does not match, not only the current iteration instance is prevented from matching,
    but the entire iterated is failing to match
  - this allows to check that "every pattern X must also satisfy Y" holds on single-rule level

 Visualization and Debugging:
  - added debug set node|edge mode matched|created|deleted|retyped command
     it allows to configure the same visualization options as the dump set node|edge command,
     but for the debugging visualization effects instead of for the types
     (so one can configure a debugging display which is better visible with regard to the normal graph display)
  - added ability to configure linestyle continuous|dotted|dashed in dump set edge command
  - added ability to configure thickness 1|2|3|4|5 in dump set edge command
  - added missing .vcg colors lightyellow and yellowgreen to color enum/parsing, fixed turqouise -> turquoise

 Improved External Function Handling:
  - allowed to give assembly references as parameters to the grgen compiler (grgen -r <name>.dll), 
    so one can access external assemblies in the user defined function/class implementation
  - allowed to add/register assembly references in grshell used at the invocations of the compiler:
    new add reference "<path to dll>"
  - and a keepdebug flag for improved debugging:
    new set keepdebug on|off

 Syntactical convenience: in case a top level rewrite part is missing a default empty modify is assumed

 Improved Import: EMF/ecore/XMI adapted to TTC live contest input

 Bugfixes:
  - fixed issue when parsing (pat1 | ... | patn) construct
  - fixed compilation error for iterated in negative/independent
  - bugfix for elements to be deleted but referenced in a typeof

 Syntax highlighting: adapted to latest changes

 
v3.0beta2 (2011-05-19)
 Solutions of Transformation Tool Contest 2011 tasks added to examples:
  - HelloWorld! in examples\HelloWorld-TTC2011
  - ProgramUnderstanding in examples\Reengineering-TTC-2011
  - CompilerOptimization in examples\CompilerOptimization-TTC2011
 Export/Import:
  - Model override can now be a rule file, e.g. import Foo.gxl Rules.grg
    imports Foo.gxl using the model(s) from Rules.grg and selects the actions for usage.
  - EMF/ecore/XMI importer extended, can now handle references by url fragments instead of ids
  - GrgExport is now writing a rule creating the graph and a test matching the graph
 New searchplans are created for all actions when no rule name is given,
   i.e. custom actions gen_searchplan is recompiling all the matchers
 Syntax highlighting improvements
 Fixed several bugs:
  - crash in vcg dumper on a certain combination of exclude and group by
  - wrong emitting of tuple attributes in GXL export
  - problems due to elements referenced not being available in the pattern,
      for typeof and emithere
  - unsigned shift right >>> semantics fixed, and now correctly explained in manual

  
v3.0beta (2011-04-17)
 Local variables, ordered evaluation, and yielding outwards:
  - added def entity declarations, which on RHS do not get created, on LHS do not get matched,
    but are yielded to from evals, evalheres, subpattern rewrites, or execs on RHS,
    or are yielded to from yields, subpattern usages on LHS,
    out of the same pattern, but especially out of nested patterns and called subpatterns.
	They can be uses as local and output variables;
	def vars may receive an initialization assignment.
  - added yield block which is an eval on the LHS constrainded to not assigning to /
     not changing graph element attributes, only parameters or def entities allowed
  - added yielding assignments to evals, evalheres, execs
  - added yielding assignments to yields, esp. including iterated yield accumulation with for
  - added yield arguments to def parameters in subpattern calls and subpattern rewrite calls
  - added evalhere command to evaluate attributes in between the subpattern rewrite calls
  - added alternative/iterated rewrite usage specification to trigger an alternative/iterated
    rewrite usage in between the subpattern rewrite calls
  - was made possible by: every nested pattern can be given a name,
     for the anonymous ones a counted makeshift name is assigned

 Generic datatype array<T> introduced:
  - mapping to C# list (misnamed dynamic array)
  - supporting operations added, in types and expressions, in model and rules, in sequences, in shell:
    - array<T>[ el, el2, el3 ] constructor
    - a.add(x) to add x to the end of array, a.add(x,i) to insert x at index i
    - a.rem() to remove element from end of array, a.rem(i) to remove element at index i
    - a.clear() clears array
    - a.size() gives size of array, a.subarray(i,l) returns subarray from start i on of length l
    - a.indexOf(x), a.lastIndexOf(x) give index of first/last occurence of value x in the array
    - x in a returns whether x is contained in a
    - a[i] returns value at index position i, same does a.peek(i)
    - a[i] = x overwrites element at position i by x
    - a==b, a!=b checking equality of size and of the elements at their respective positions
    - a<b, a<=b, a>b, a>=b checking order of size and equality of elements
	   at their respective positions up to the size of the smaller array
    - a+b returning a concatenation of array a followed by b, compound version a+=b supplied, too
    - storage access in rules n{a} or n{m.a} of array elements

 Expressions extended by incoming/outgoing edge function:
  - incoming(node, EdgeType, NodeType) returns a set of the edges incoming to the node,
     only if of the given EdgeType, only if originating from a node of given node type
	 NodeType is defaultet to Node if omitted; EdgeType is defaulted to Edge if omitted
  - outgoing(node, EdgeType, NodeType) does the same for the edges going out from node

 Changed syntax of storage access in pattern from "<" storage ">" suffix to "{" storage "}" suffix
   because "<" ">" is already used for retyping, input parameter type, copy; was too overloaded

 GrShell extended by pwd, cd, ls commands:
  - pwd: prints working directory
  - cd <path>: changes working directory to <path>
  - ls: lists the content of the working directory with files relevant to GrGen highlighted

 Bugfixes:
  - the mono csharp compiler yields errors for unicode escaping in identifiers,
    changed attribute implementation suffix
  - fixed code generation for calls in compiled sequences which do not assign return values,
    but the rule/sequence called returns some
  - if grgen is called with "path/file" then by now the path is only prepended
    when opening an "#include i-path" to the i-path, if the i-path is not absolute
  - added error messages in case edges created are referenced in evalhere,
    in case edges from nesting pattern are referenced in nested pattern (instead of compiler crash)
  - fixed assertion when using node/edge valued set/map types

 Optimizations by better/global data flow analyses allowing for cheaper runtime implementations:
  - reduced overhead of runtime neg level checking to the very seldom cases it is really needed
  - reduced overhead of patternpath setup to the very seldom cases it is really needed

 Minor:
  - refactorings of iterated patterns in API
  - syntaxhighlighting adapted
  - enough changes to call the child v3.0 instead of v2.7 by now


v2.7.ms4 (2011-02-07)
 Added procedural abstraction for graph rewrite sequences with sequence definitions:
 - added support for compiled named sequence definitions in rules file with syntax:
    sequence name(input variables):(output variables) { sequence }
 - added support for interpreted named sequence definitions in shell with syntax:
    def name(input variables):(output variables) { sequence }
 - for both: input and output variables are local variables,
    they get filled with the input values,
    and define the output values in case of success,
	where success is defined by the sequence.
 - they can be called from other sequences (or even the same) with
   (output parameters)=name(input parameters) syntax,
   as for rule calls the output parameters of sequence calls are only written on success

 Added debugger commands
  - "(v)ariables" which prints out all global variables and all local variables
      of the currently executed sequence (up to the point focussed)
  - "stack (t)race" which prints the call stack of the sequences currently executed
      (including sequence content and execution state)
  - "(f)ull dump" which prints the call stack of sequences including all their variables

 User manual restructuring and extension:
  - split chapter "Understanding and Extending GrGen.NET" out of API chapter,
    added a lot of content there explaining how GrGen.NET works
  - split chapter "Visualization and Debugging" out of GrShell chapter,
    to decrease shell chapter size and emphasize visualization and debugging

 Further minor:
   - added support for sequence result postfix assignment s => v, s |> v, s &> v


v2.7.ms3 (2011-01-17)
 Added support for storage attributes, i.e. attributes typed with set/map of node/edge,
  can now be declared in model, handled by all the other set/map constructs already available,
  furthermore added an extension of the storage access constructs on the LHS by:
   x:T<n.a> with n being a node or edge and a an attribute of it,
   yielding a pattern element picked from the storage attribute

 Added compound assignment statement which allows for efficient set/map operations,
  especially for efficient data flow analysis with the optional change assignment:
   -set/map union |=, intersection &=, difference \= assignments are available
   -change assignment operators assign-to =>, union-to |=, intersect-to &> are available
     examples: v |= w => changed; n.s &= m.s |> e.changed; n.m \= w &> n.visited[2];

 Improved user manual:
  - split off exec/emit and storage handling (+visited)
    into an own chapter "Embedded Sequences and Storages",
    meant as an introduction into combining rules to build transformations.
  - added subsection on data flow analysis explaining how to compute reachability.

 Bugfixes:
  - transaction handling (thus backtracking too) now capable of nested processing,
    i.e. a committed nested transaction gets rolled back if the enclosing transaction fails
  - deferred execs used from rules contained in deferred execs
    don't execute pending execs from their parent any more

 Further minor features:
  - added pow operator to expressions, pow(x,y) computes x to the power of y (only for double)
  - intersection changed to retain first element for maps


v2.7.ms2 (2011-01-03)
 Added copy operator:
 - new-node:copy<old-node> creates a clone of the old node
   (type and attribute values are same, incident edges are not taken care of)
 - -new-edge:copy<old-edge>-> creates a clone of the old edge,
   the source and target nodes of the new edge must be specified (otherwise edge would dangle)

 Added deferred exec:
 - allowed exec from nested alternatives or iterateds, and from subpatterns
 - when used closures for the exec applications are put into a to-be-processed queue,
   which gets executed at the end of the root rule using them

 Added storage access clauses:
 - on LHS one can write x:T<s> with s being a storage;
   the storage elements are iterated, the ones which are of type T are accepted as a match of x
 - on LHS one can write x:T<s[y]> with s being a storage-map and y being an element from the pattern;
   the value of y in s is looked up and if it exists and is of type T it is accepted as a match of x

 Improved user manual with some pragmatics explanations, some fixes
  "Merge and Split, Node Replacement Grammars, and Subgraph Copying"

 Fixes:
  - values of variables are now transmitted into nested iterateds/alternatives
  - anonymous subpatterns are now named "sub"_X,
    so that nodes don't get blown up that much in debugger detail mode


v2.7.ms1b (2010-12-20)
 Bugfixes:
  Compiler:
  - generation error when attribute named A had a sibling attribute named _A (i.e. "_" prefix) fixed
  - rewrite parameters not being available for attribute assignment fixed
  - emit error on attempt to rewrite a rhs declared subpattern usage, i.e. a subpattern which gets instantiated
  Shell/Debugger:
  - fixed debugger/named graph mismatch on retyping (retyped elements stayed in debugger)
  - allowed every place which expects a word (e.g. a type name) to contain a single or double quoted text,
     so user can reference shell keyword named entities by escaping
  - prevent computer from going into sleep mode while a sequence gets executed (windows only)

v2.7.ms1 (2010-12-05)
 Added record and replay feature (plus supporting instructions):
 - record shell command for writing the current graph and then the changes applied to it into a .grs
    for replaying later on, with comments telling about the events causing them as debugging help
 - replay shell command for replaying previously recorded changes
    with capability to define begin and end lines to replay only certain change sets/states
 - record operator in sequences for emitting to the currently ongoing recordings
    e.g. record("\# label1\n") for labeling a state (2 such labels can be used to mark a changeset)
 - retype shell command, e.g. retype (@"$1")<NT> for a node and retype -e<ET>-> for an edge
 - commands to add/remove elements to/from graph element attributes of set/map type, e.g. (@"$4").m1.rem(42)

 Added capability for using external, user defined functions and types in attribute computations (if/eval):
 - added external function declarations, with the GrGen compiler type checking them
 - added external type declarations(with inheritance relationsships but without attributes),
    which can be used from the external attribute computation functions (only)
 - the user must implement the external functions and types in a <X>ModelExternalFunctionsImpl.cs file
    where <X> stands for the model/rule files name, by supplying further parts of partial classes

 Other changes:
 - min(.,.)/max(.,.) functions added to the expressions
 - compiled version of backtracking brackets <<r;s>> now available
 - ability to specify lower bound for random match selection, e.g. $v1,v2[r], $v1,*[r];
     otherwise (when only an upper bound is given as e.g. in $v2[r]) fixed to value 1
 - added askfor shell command just waiting for enter to be pressed
 - further smaller fixes and improvements
 - purged deprecated shell constructs for set handling, map handling, visited flags handling


v2.6.4 (2010-10-30)
 Fixes for bugs introduced in 2.6.3:
 - certain pattern elements were deleted when using patterns with more than 2 nesting levels; fixed
 - subpattern deletion erased the subpattern parameters; fixed

v2.6.3 (2010-10-11)
 Changes:
 - allowed pattern elements to get deleted(/retyped) in nested alternative/iterated blocks or even in subpatterns
    compiler checks that only one delete/retype is ever happening for any pattern element
    this behaviour is only specifiable in modify mode with explicit delete
 - added backtracking brackets: <<r;s>> computes all matches of the rule r (for given inputs), then
    foreach match: apply rewrite (assigning outputs), then execute s
                   if s failed: rollback effects of r and s, continue with next match, fail if exhausted
                   if s succeeded: commit effects, succeed
 - annotations are now available on API level (transmitted from .gm/.grg to code)
 - semantic change: the parameters/attachment points of a subpattern now get deleted
    if not mentioned in the _replace_ part of the subpattern, as was always the case with rules
 - bugfix: allow abstract node types as replacement parameters
 - fixed crash in debugger on printing a rule call with a constant argument (instead of a variable)
 - improved FiniteStateMachine and ProgramGraphs examples,
    split into a succession of examples building on each other, giving a nice overview of the capabilities of GrGen
 - further minor fixes/improvements

v2.6.2 (2010-09-19)
 Changes:
 - bugfixes/improvements for debugger detail mode annotations
 - improved compiler checks, esp. against non-terminating subpattern recursions
    and iterated empty graph matching
 - fixed crash on printing the <var>=null assignment to console in debugger

v2.6.1 (2010-09-12)
 Changes:
 - debugger detail mode now annotates in yComp all the pattern elements matching on a host graph node
 - debugger detail mode annotations now show in addition to the pattern element name the path to the name
   (with symbols from the regular expression syntax, and the subpattern entity names,
    clipped from nesting level 3 on, only showing nesting depth due to display size constraints)
 - removed the rule rewrite part reuse optimization (reuse optimization still there on graph level),
    was source of too many errors over time, esp. when used with transactions
 - some smaller fixes (regarding independents and subpattern rewrite parameters)

v2.6 (2010-09-05)
 Single most important change:
  - user manual updated (including all the changes from 1.4->2.6)

 New sequencing constructs in xgrs:
  - operator then-left l <; r executing l then r, returning the execution result of l
  - operator then-right l ;> r executing l then r, returning the execution result of r
  - decision if{cond; truecase; falsecase} executing cond,
     on success truecase is executed and its result returned,
     on failure falsecase is executed and its result returned
  - if{cond; truecase} which equals if{cond;truecase;true} thus giving a lazy implication
  - n-ary random all of operators (currently only available in the interpreted sequences),
     in function call notation with the operator symbol as function name:
	 - the strict $|(s1,s2,s3) and $&(s1,s2,s3) evaluate all their subsequences in random order
	 returning the disjunction resp. conjunction of their truth values.
     - the lazy versions || and && evaluate the subsequences in random order
	 as long as the outcome is not fixed or every subsequence was evaluated,
	 returning the disjunction resp. conjunction of their truth values.
  - some-of-set braces {r,[s],$[t]} matching all contained rules
     and then executing the ones which matched; true if one of the rules matched
  - one-of-set braces ${r,[s],$[t]} matching all contained rules
     and then executing at random one of the rules which matched; true if one of the rules matched

 Uniform variable handling in xgrs:
  - now the compiled and the interpreted sequences both always support
    i) graph global variables, untyped, i.e. type errors are only detected at runtime,
     live from first assignment/implicit declaration on, written to file on save and restored on load
    ii) sequence local variables, typed thus statically type checked,
     only live until sequence execution ends (thus no persistency available)

 Handling of set<T>/map<S,T> in xgrs:
  - in contrast to the set/map in models and rules, S/T may be of node/edge typ, giving storages/storagemaps
  - set/map addition st.add(el)/mp.add(el,val) always succeding
  - set/map removal st.rem(el)/mp.rem(el) always succeding
  - set/map clearing sm.clear() always succeeding
  - set/map iteration for{el in st; seq} / for{el->val in mp; seq},
     failing iff seq fails for at least one el/el->val in the set/map
  - set/map membership query el in sm succeeding iff el is contained in the set/map
  - map lookup assignment val=mp[el] assigning the result of a map lookup to a variable,
     succeeding iff el is contained in mp, otherwise failing, not touching the variable
  - set/map size assignment sz=sm.size() assigning size to the variable, always succeeding
  - set/map emptyness query result assignment se=sm.empty() assigning to the variable
     whether set/map is empty, always succeeding
  - set/map creation st=set<T>/mp=map<S,T>, and variable declarations of explicit set/map type,
     st:set<S>, mp:map<S,T>,  e.g. st:set<Node>=set<Node>

 Handling of set<T>/map<S,T> in rules, to ease the processing of storages:
  - ref st:set<T>, ref mp:map<S,T> parameters, call-by-reference, including S/T of node/edge type
  - rule rewrite part extension, new statements besides emit/exec:
   - set/map addition st.add(el)/mp.add(el,val);
   - set/map removal st.rem(el)/mp.rem(el);

 Visited flags handling:
  - visited flags processing in rules in function notation deprecated
    visited flags processing in rules now by syntax:
      e.visited[f] = b  or  e.visited = b
      e.visited[f]  or  e.visited
  - visited flags management in shell deprecated
    (allocvisitflag, isvisited, setvisited, freevisitflag, resetvisitflag)
    visited flags management now by xgrs operations instead of shell commands:
      f=valloc() for visited flags allocation
      vfree(f) for visited flags deallocation
      vreset(f) for resetting visited flag in all graph elements
      e.visited[f] for query whether graph element was visited
      e.visited[f] = b for setting whether graph element was visited

 New assignments in xgrs:
  - attribute reading in xgrs: toVar = fromVar.attributeName (value semantics)
  - attribute writing in xgrs: toVar.attributeName = fromVar (value semantics)
  - constant value/literal assignment: toVar = int|float|double|string|boolean|enum|set|map - constants/literals
  - random number assignment: v = $(Number) assigning a value from 0 up to excluding Number to v
  - user input assignment: v = $%(Type) querying the user for a value of given type and assigning it to v
     only in interpreted xgrs, as shell input required; only in debug mode if a node/edge type is requested

 Improved debugging:
  - blue > at sequence start
  - renamed (n)ext to (u)p (going one level up in the sequence tree)
  - added (n)ext command focusing the rule which matches next in green
     (instead of normal/other step commands focusing the rule which will be tried next)
  - the rules which matched during sequence execution are shown on dark green background,
    the rules which failed during sequence execution are shown on dark red background;
	at the end of a loop iteration the old highlighting state is displayed,
    at the begin of a new loop iteration the highlighting state of the contained rules is reset.
  - choice points similar to break points added; denoted by % appended to the random operator $
     transforming the random choice to a user choice, triggered when execution reaches the choice point
	 applicable to the random binary operators, random match selection, random number assignment
	 user input assignments are choice points which can't be toggled off
  - debug support for all the new and changed xgrs constructs

 Rewrite part handling of nested patterns:
  - modify/replace graph elements of nesting pattern
     are now available in modify/replace of nested alternative/iterated/multiple/optional-patterns
  - modify/replace of nested alternative/iterated/multiple/optional-patterns can't take parameters any more,
     better: no need to give them any more, as they can access the rhs elements of the nesting pattern
  - the modify/replace parameter declaration of the subpattern has to be given at the subpattern head / interface,
     not in the subpattern body any more

 Retyping:
  - graph elements matched outside alternative case now can get retyped in alternatives cases
  - graph elements matched outside optional pattern now can get retyped in optional pattern

 Export/Import:
  - GRS(I) import/export (of .grs, .grsi files; and GrShell) now support set/map attribute initialization
    (example: new :N1($="$0", a = set<int>{1,2,3}, b = map<string,boolean>{"foo"->true,"bar"->false})
  - withvariables parameter for grs export causing variables to get exported; default is nodes/edges only
  - GRS(I) import/export now writes and reads persistent names correctly
       (instead of variables; only if a non named graph is given fallback to hash names)
  - GXL import/export now supports enum attributes (set/map not supported)
  - support for importing/exporting .gz compressed .gxl/.grs
  - add parameter for .gxl/.grs import, adding the graph from the file to import to the current host graph
  - ecore/XMI importer extended to support a larger class of inputs (plus nopackagenameprefix parameter)

  Set/Map comparison in rewrite rules:
  - new set/map comparison operators in rewrite rules:
     sm1 == sm2 is true iff sm1 equals sm2 (sm1<=sm2 && sm2<=sm1)
  	 sm1 != sm2 is true iff sm1 unequal sm2 (at least one entry not available/same in the other set/map)
 	 sm1 <= sm2 is true iff sm1 is subset/submap of sm2 (every entry from sm1 is available in sm2)
	 sm1 < sm2  is true iff sm1 is proper subset/submap of smp (sm1<=sm2 && !sm1==sm2)
	 sm1 >= sm2 is true iff sm1 is superset of sm2 (sm2<=sm1)
	 sm1 > sm2  is true iff sm1 is proper superset of sm2 (sm2<sm1)
	maps require key and value to be same for the equality, (proper) sub/supermap relationships to hold

 EBNF/regular expression-like notation for nested patterns added:
  - (P)* = iterated { P }
  - (P)+ = multiple { P }
  - (P)? = optional { P }
  - (P1|P2) = alternative { L1 { P1 } L2 { P2 } }
  - ~(P) = negative { P }
  - &(P) = independent { P }
  The notation supports additionally (P)[k], (P)[k:l], (P)[k:*] for matching a bounded number of times.

  The rewrite part can be given in embedded action style:
  - {+ R } = modify { R }
  - {- R } = replace { R }

 Connection assertions:
  - nodes without incident edges were ignored in validation, now the lower bound 0 vs. 1 is always checked
  - the default if no multiplicity is given is now [*] instead of [1], i.e. no constraint specified
  - support for "validate strict only specified" mode, doing a strict validation,
    but only of edge types for which connection assertions were specified
  - support for "copy extends" to copy the connection assertions of the direct supertypes
  - support for undirected edges with -- syntax
  - support for arbitrary edges with ?--? syntax

 Fixes:
  - escaping of quotation marks in VCG files
  - escaping of quotation marks and newlines in communication with yComp
  - escaping of XML language elements in GXL export
  - escaping of some parameters to the call of grgen.jar containing paths
  - nameof(element) now working correctly, i.e. returning persistent name as announced
      (instead of variable name; only in case of a non-named graph a hash value name is returned)
  - typeof(element of abstract type) now working
  - bad interference of transactions with the reuse optimization removed
  - several cases of use before definition in rule language now working
  - Mono compiler error (MS.NET warning) when using alternatives removed
  - initialization overwrite in model (on inheritance paths of depth >2; for sets/maps)
  - fixes for nesting hierarchies of right hand side declared elements
  - dump into .vcg format now handles nesting as declared by "dump add group" commands correctly
  - name collision between shell and rule generated graph elements causing debug display corruption
  - directed/undirected edges (as given by edge syntax) can extend arbitrary edges
    without being forces to explicitely extend Edge/UEdge, too
  - removed check against homomorphy of retyped elements not needed
  - lazy or operator parsing priority bug
  - ResetVisitedFlag/vreset now reliably working on edge types, too
  - code generation for conditions in nested patterns
  - code generation for alternatives nested in negatives/independents
  - subpattern creation/instantiation with parameters from rewrite part
  - runtime cast exception when calling a subpattern modification with an argument being a subtype of the parameter type
  - wrong matching of iterated consisting of only a terminal pattern not requiring a candidate iteration loop
  - endless loop prevention by checking against unbounded pattern cardinality constructs
      containing no locally defined nodes or edges (not being homomorphic to enclosing elements)
  - several bugs in code generation for iterated fixed
  - usage of rhs elements on lhs
  - further minor fixes

 Further changes:
  - null arguments must be declared beforehand if they should be used,
    causing the element to be searched by its own search plan,
	thus every null-capable argument doubles the number of matchers;
    declaration syntax example: rule r(x:Node<null>, y:T<S+null>)
	  (y is example for inexactly typed input which may be null in addition)
  - the deprecated old grs were removed
  - new shell construct <Var> = askfor <Type> prompting the user to enter a value of given type
     - if the type is a graph element type the user is asked to select a graph element
       by double clicking in yComp (debug mode must be enabled)
     - if the type is a value type the user is asked to enter a value of this type on the keyboard
    the older debug apply with wildcard elements is deprecated now, succeeded by this construct
  - assignment of sequence result to variable is now always true (independent of sequence result)
  - execs may yield elements which can be used in return statements; yield statement in compiled xgrs
  - replaced emitpre by emithere, which is emitted before regular emits,
    at the position syntax-relative to the subpattern modification invocations and the other emitheres
  - the random match selector now expects a variable instead of a number
  - new rule modifiers dangling (only apply rule if all incident edges of a node to be deleted
     are specified in the pattern), and identification (don't apply rule if a node to be deleted
     was matched homomorphically to a node to be kept), allowing to pick from the dpo conditions
	 (dpo = dangling + identification)
  - new method .peek(num:int) on set<S> and map<S,T> types, returning the element/the key of the element
      at the position num in the sequence of enumeration
  - new function random() returning a double random value in between 0.0 and 1.0
      and random(sup:int) returning an integer random value in between 0 and sup, sup exclusive
  - added emit to xgrs: emit(double-quoted-text|variable)
      example: xgrs emit("foo\n") && emit(v)
  - same literal/constant syntax now in assignments and attribute initializations of
      model, rules, sequences, shell, grs (ex/)importer
      (e.g. Foo::bar for enum, 3.141593f for float, 0x11 for hex integer, map<string,double>{"42"->42.0})
  - the graph with model combined class is now named FooGraph instead of Foo for Foo.grg
  - set/map commands in GrShell are deprecated (succeeded by xgrs set/map operators)
  - set/map-valued attributes are now displayed in yComp, too
  - now error reported on attempt to delete and return elments allowed to be matched homomorphically
  - added exitonfailure to GrShell validate command leaving GrShell on failed validation with error code
  - undirected edge creation in GrShell with -name:type- syntax and type UEdge if no type given
  - Added GrGen syntax highlighting for vim (model, rules, shell)
  - Extended GrGen syntax highlighting for Notepad++ to GrShell files
  - added GrGen-solution for ModelMigration case from TTC2010
  - added GrGen-version of "Repotting the Geraniums: On Nested Graph Transformation Rules" to examples
  - user manual now under Creative Commons Attribution-Share Alike 3.0 Germany license
  - further minor improvements


v2.5.1 (2009-09-09)
 Additions:
  - subpatterns now support var parameters, too
  - GrShell now with non-debug/gui-mode and return value
  - additional checks and warnings in GrGen compiler
  - GraBaTs 2009 Live Contest Winning Solution ConveyorBeltSystem added
  - some renaming in examples folder to show case origins
 Fixes:
  - usage of var parameters in alternative, iterated - blocks
  - nested iterated, alternative blocks
  - elements of enclosing lhs pattern only mentioned in eval of rhs
  - gxl export (showing in mono glx import exception)
  - several examples work again (not all, though)
  - some previously failing tests

v2.5 (2009-06-28)
 Advanced subpattern/subrule features:
  - iterated block matching contained subpattern as often as possible implemented
  - multiple block as an iterated block requiring at least one match added
  - optional block matching contained subpattern (eagerly) at most once implemented
  - independent block for specifiying positive application conditions implemented
  - emitpre (before emitting from subpatterns) and emitpost(=emit; after emitting from subpatterns)

 Im/Export:
  - import/export commands added to GrShell, porter module added to LibGr
  - GXL importer and exporter added
  - EMF / ECore importer added
  - GRS importer and exporter added

 New API:
  - Generation of an action interface per action, implemented by the action class,
    plus an action-interface-typed member per action in actions class instance
  - Action interface with exactly typed input parameters, matches object, output parameters
    (for the match / modify / apply methods)
  - Old input parameters semantics - silently failing rule application on wrong type -
    now only available with syntax r(x:ExactType<InexactType>)

 Semantic changes:
  - Semantics of negative regarding subpatterns/subrules changed:
    negative pattern elements get matched independent from the subpatterns utilizing them
	(explicit patternpath/pattern statement in the negative/independent needed for old behaviour)
  - hom declarations are inherited into nested negatives/independents now
  - hom delarations are non-transitive by now (hom(a,b) and hom(b,c) don't cause hom(a,c) unless specified)

 Examples:
  - Solution to the GraBaTs 2009 Program Comprehension case study added
    (including EMF import)
  - Completed JavaProgramGraphs sample (Grabats 2008 refactoring case solution),
	including GRS import/export in source code sample
  - Rewritten ProgramGraphs sample with new iterated construct,
    added corresponding source code sample
  - Updated source code samples to the new 2.5 API

 libGr:
  - Added short infotags (without displaying attribute name)
  - The labels of elements can now be removed or set to a constant string

 GrShell/yComp:
  - Improved interactivity: debug apply <rule with ? as placeholders>
    allows to select wildcard elements ? by double clicking at elements in graph viewer yComp
  - Debugging much more robust to unexpected connection loss
  - show var <variable> implemented
  - Shell / debugger now showing match parts due to all forms of subpatterns in debug mode / with %
  - Finally implemented the help command and improved the error handling
  - Replaced "dump edge labels (on | off)" by "dump edge [only] <type> labels (on | off | <text>)"
  - Added "dump set node [only] <type> labels (on | off | <text>)"
  - Added "dump add (node | edge) [only] <type> shortinfotag <member>"

 Misc:
  - Changed License to LGPL v3
  - Added GrGen syntax highlighting for Notepad++
  - Shorthand visited(el) for visited(el, 0)

 Bugs:
  - Several smashed


v2.1.2 (2009-02-16)
 Fixes:
  - don't create elements declared outside alternative if only appearing in modify/replace part

v2.1.1 (2009-02-06)
 Features/API changes/Fixes/Examples:
  - Added icons for GrGen, GrShell
  - Added conference scheduling/grabats2008 live contest solution to examples
  - Added IsAbstract and IsConst to GrGenType, catch attempts to create abstract elements in GrShell

v2.1 (2008-12-19)
 Features:
  - Added string methods (indexOf, lastIndexOf, length, substring, replace)
    (see frontend/should_pass/strfunc_001.grg in source release)
  - Added set<K> and map<K,V> attribute types (using value semantics)
  - Inline condition evaluation code to improve performance
  - Const attributes are now implemented as static to improve performance

 GrShell:
  - Added support for set/map variables
  - Added "setvisited <elem> <vis_id> <visited>" command
  - Added "isvisited <elem> <vis_id>" command
  - Removed silent modifier from node/edge creation commands
  - Added "silence (on|off)" command

 API changes:
  - Changed interface of changing-node/edge-attribute handlers because of
    set/map feature
  - Provide metainfo about declared enum types

 Fixes:
  - Improved compilation time of specifications for large amount of actions
  - Fixed comment parser in .grg dependency checker
  - Improved several error messages
  - Use an own namespace for alternative names
  - Entity (node/edge/subpattern usage) names now overwrite type names
    in expressions
  - Allow <element>.<attr> with attr being an GrShell keyword

 Examples:
  - Improved layout of Transcription examples
  - Added (parts of) the petri-net-benchmark from the paper "A Benchmark
    Evaluation of Incremental Pattern Matching in Graph Transformation"
	by Varró et al.
  - Added "Object to Relational Mapping" by Varró et al.

 Other changes:
  - Increase stack size of Java frontend and GrShell

v2.0 (2008-07-28)
 Features:
  - Added support for literals as parameters for XGRSs
  - Improved performance of matching a bit
  - Improved performance of rules with return statements
  - Improved performance of compiled XGRSs (exec statement)
  - Added -noevents and -noperfinfo options for GrGen.exe disabling firing
    of events in generated code and counting of matches/rewrites for a small
    speedup
  - Added GXL (Graph eXchange Language) to GRS (GrShell script) converter
    (gxl2grs.exe; an according model must be generated by hand)

 API changes:
  - Improved debugger support by using some DebuggerStepThrough and
    DebuggerDisplay attributes on GraphElements and Types
  - Allow newlines in XGRS strings (enables use of verbatim strings in user
    source code to reduce noise caused by string concatenation)

 Fixes:
  - Elements used by nameof()-operator if not mentioned otherwise in modify
  - Allow boolean literals as attribute initializers in "new node/edge"
    GrShell commands
  - Retyping in subpattern or alternative case
  - Do not reserve several libGr/lgspBackend class names

 Examples:
  - Added JavaProgramGraphs example, a partial solution of Program
    Refactoring case of GraBaTs 2008
    (contains rules for a specialized GXL dumper making use of the nameof
     operator and rules inserting helper edges for a nested layout of the
     program graph assisting the GrShell "group by" dump commands)
  - Added AntWorld version passing integer constants in exec (_NoGammel)

 Other changes:
  - Updated GrShellBenchmarker


v2.0 beta 2 (2008-06-24)
 Features:
  - Allow assignments of the success of a sequence to a variable
    (e.g. "res:boolean=(r1 || r2[5])")
  - Allow boolean variables as sequences (only works in execs, yet)
    (e.g. "res && r1")
  - Added visited flags
  - Added random-match-selector
    (e.g. "$7[r1]" searches for all matches and then randomly selects
     7 of them to be rewritten. "$[r1]" is equivalent to "$1[r1]")
  - Added nameof()-operator
    (e.g. "nameof(blub)" yields the name of the graph entity "blub";
     "nameof()" yields the name of the graph)

 Features for GrShell:
  - Added "silent"" keyword to new node/edge commands to prevent
    "element successfully created"-messages
    => Shell scripts creating a lot of elements run much faster when
       using this keyword
    (e.g. "new state:State silent" or "new a1 -:Edge-> a2 silent")
  - Added post build step to grshell to increase stack size to 16MB
    (so that matching engine can handle much larger recursive structures)
  - Added visited flags support
  - Support assignments of "true" and "false" to variables
  - Added "randomseed" command
    (e.g. "randomseed 13" sets the random seed to 13 for reproducible
     results when using the $-operator-prefix or the random-match-selector;
     "randomseed time" sets the random seed to the current time in ms)
  - Reduced GrShell overhead of XGRS execution significantly

 API changes:
  - Moved PerformanceInfo, MaxMatches, Replace, ApplyRewrite,
    ApplyGraphRewriteSequence(Sequence), ValidateWithSequence(Sequence)
    and the events from BaseActions to IGraph
  - Sequence.Apply now takes an IGraph instead of a BaseActions instance
  - Removed BaseActions.ApplyGraphRewrite
  - Added GetNewestActionVersion and SetNewestActionVersion to IGraph
    (perhaps only temporarily...)
  - Added AddNode and AddEdge variants to IGraph to allow adding
    e.g. cloned elements to the graph
  - Added INode.Adjacent, INode.GetCompatibleAdjacent,
    INode.GetExactAdjacent and IEdge.GetOther
  - PerformanceInfo.MatchesFound is now always changed after firing the
    IGraph.OnMatched event

 Fixes:
  - Allow identifiers to begin with an underscore
  - yComp: Remove related reference nodes, when a node is moved to
    another subgraph
  - Don't generate pattern creation functions, when the pattern contains
    abstract members
  - Fixed inheritance of same attribute over multiple inheritance paths
  - Fixed crash of SequenceParser on lexer error
  - Don't ignore wrong text after correct sequence prefix
  - Allow to write "r1*" instead of "r1[*]" in execs
  - Fixed range specifications of the form "[200]" in .gm and .grg files
  - Fixed the performed rewrites counter for compiled XGRSs (exec)
  - Replaced exponential constant folding algorithm in Java frontend
    by a linear-time one

 Examples:
  - Updated BusyBeaver API example
  - Added TranskriptionAbstrakt example
    (doing transcription on chains instead of chemical structure graphs;
     Viatra2 R2 solution included)
  - Added TranskriptionAbstraktNachAtom example
    (transforming the abstract dna chains of TranskriptionAbstrakt into
     the chemical structure graphs of Transkription)
  - Added ProgramGraphs example and API example
    (implementing program graphs as specified in "Adaptive Star Grammars
     for Graph Models" plus PullUpMethod refactoring on these program
     graphs)
  - Added WeakComponents examples and VisitedExample API example
    (using visited flags)
  - Added AntWorld example for GraBats 2008
    (using the random-match-selector)

 Other changes:
  - Return statements now only allowed after all normal statements;
    exec/emit statements only as last statements


v2.0 beta (2008-04-28)
 Features:
  - Introduced subpatterns, alternative patterns, and recursive patterns
  - Introduced dependent replacement and recursive rules
  - Introduced "var" parameters and return values for basic types
    like int and string
  - Allow expressions as return arguments
  - Added "arbitrary" and optional "directed" keywords for edge classes
  - Added "using" statement for models
  - Implemented dpo/exact/induced also for the new edge kinds
  - Graph variables are objects now, and not only graph elements anymore

 Features for GrShell:
  - Added support for variable assignments with literals
  - Variable to variable assignments
  - "show graph" and "dump graph" now use the layouter configured
    via "debug set layout"

 API changes:
  - The classes for Node/Edge and for elements inheriting from Node/Edge
    now inherit from INode/IEdge directly instead of the IAttributes
  - Removed obsolete IAttributes
  - Renamed IGraphModel.Name to IGraphModel.ModelName
  - Special classes being a graph an a model at the same time
    are now generated for each model. They also contain specialized
    element creation methods for each element type
  - Removed deprecated IDumperFactory
  - The VCGDumper can now specify a layouter to be used
  - Added static type property "TypeInstance" to element classes
    for easier access to the appropriate type instance
  - Generated C# element class names are not prefixed anymore as long
    as the would be no name clash (a warning is generated then, too)
  - Added EdgeType.Directedness property
  - Renamed Condition to PatternCondition
  - Added IGraph.Actions property as a currently associated actions object
    (perhaps only temporarily...)

 Fixes:
  - Dangling edges in nested negative patterns
  - Fixed several frontend tests

 Examples:
  - Updated examples
  - Added "Recursive" example
  - Added "Transkription" example
  - Continued Firm-IFConv example (now also using var parameters and return values)

 Other changes:
  - Changed License to GPL v3
  - The names of the generated model files now depend on the model name


v1.4 (2008-03-20)
 Features:
  - Introduced the imperative statement "emit" in RHS printing text
    to the console or to files (see UML2CSP2 example)
  - Introduced the imperative statement "exec" in RHS executing xgrs'
  - Introduced abstract members in element types
    (these members do not have a declared type,
    hence containing classes are abstract)
  - Introduced "dpo", "induced" and "exact" modifiers for rules
  - Introduced "induced" and "exact" statements in rule patterns
  - "null" is a keyword, now. It represents the default object value
  - Member initializers in model specification
  - Added support for external implementations of element types
  - Updated implicit and explicit casts (see user manual section 5.1)
  - Nested negative patterns
  - Undirected edges
  - Directed "-->" or "<--", undirected "--", arbitrary directed "<-->"
    and arbitrary "?--?" edges in patterns
  - Added "maybeDeleted" element annotation to ignore warnings claiming
    that a returned element could be deleted due to a hom statement

 Features for GrShell:
  - Enhanced grouping support:
    "dump add node [only] <NodeType> group [by [hidden] <GroupMode>
    [[only] <EdgeType> [with [only] <NodeType>]]]",
    where <GroupMode> can be "no", "incoming", "outgoing", or "any".
  - Allow setting layout options without starting the debugger first
  - Remember layout options during a session
  - Save layout options when using "save graph"

 API changes:
  - Redesign of type architecture
  - Direct access to element attributes
  - Changed namespaces of generated code
  - Introduced IGraphElement.Valid, IGraphElement.ReplacedByElement,
    INode.ReplacedByNode, and IEdge.ReplacedByEdge to check, whether
    elements were deleted or retyped during a rewrite
  - Removed unused dump fields from BaseActions

 Fixes:
  - Returns for test actions
  - Enums are now allowed as values in '?:'-operators
  - Fixed dependency calculation for includes in grg-files
  - GrShell "save graph" command
  - GrShell debugging of sequences containing "[SomeRule]"
  - GrShell debugging of element retyping
  - GrShell "dump (node|edge) only <nodeType> exclude" command
  - GrShell debugging with grouped nodes
  - Problems with edge parameters
  - Handling of abstract element classes
  - Several cases involving combinations of hom, retype, delete, and return
  - Output compile warnings also when compilation did not fail

 Examples:
  - Added Sierpinksi3 (with parallel rewrite semantics)
  - Added FiniteStateMachine example
  - Added UML2CSP2 example using the new emit statement
  - Added DebugExec example

 Other changes:
  - "pattern" part is now directly embedded in rules and tests
  - Added XML documentation files for Intellisense help in IDEs
  - Replaced 'include "<grg-file>";' by '#include "<grg-file>"'
  - ycomp.bat does not need to be edited anymore
  - Changed syntax for rule application in xgrs:
    e.g. "%?[(a,b)=R(a,c)]" to "(a,b)=[?%R(a,c)]"


v1.3.1 (2007-12-07)
 Features:
  - Added "-gensp" option to spBench allowing generation of dynamic
    searchplans after execution of the initialization xgrs
  - Stabilized content of generated C# files for better version control
  - Test actions work now

 Fixes:
  - spBench acted on the original graph instead of the cloned version
  - Clone variables and all statistical information when cloning a graph
  - Clear variables when clearing a graph
  - Disabled buggy node reusing as a workaround
  - Reflexive pattern edges were not always matched correctly


v1.3 (2007-11-06)
 Features:
  - The reuse optimization reusing deleted elements can now be disabled
  - Infotags with null values are not displayed anymore
  - Speedup transactions a bit
  - GrGen.exe: Renamed -d option to -keep, added -debug and -usefull option
  - Added options for dumping and commenting generated matcher programs
    (accessible through properties and "Custom")
  - Reimplemented LGSPGraph.Clone via copy constructor to allow derived
    classes to support cloning
  - Added convenience methods BaseGraph.GetNodeType and BaseGraph.GetEdgeType

 Features for GrShell:
  - Added "debug layout" to relayout the graph in yComp
  - Added "debug get layout options" and "debug set layout option" allowing
    access to the parameters of the current layouter in yComp

 Examples:
  - Added HelloMutex api example
  - Added YCompExample api example
  - Added GrIO example
  - Added AGTIVE example UML2CSP
  - Added another Sierpinski triangle implementation

 Tools:
  - Added spBench, an application to benchmark all possible searchplans for
    a rule pattern

 Fixes:
  - Fixed ASTdapter
  - Fixed multiline custom commands for GrShell
  - Fixed xgrs parser not allowing "somerule[1:*]"
  - Fixed node reusing causing a crash
  - Disabled debug output of yComp
  - Fixed NACs only containing an if
  - Fixed attributes output of VCGDumper
  - Fixed infotags
  - Fixed homomorphic matching (testcase hom1 and hom2)
  - Includes in GRG-files are now also considered as dependencies

 Specification processing (grgen.jar):
   Changes:
    - Improved processing time
    - Improved error messages
    - Added new attribute type "object"
      (only operators '=', '==', and '!=' are allowed)
    - Warn if a graph element occurs inside and outside a delete statement
    - Warn if a returned graph element may be matched homomorphically to the
      same element as an element within a delete statement
    - "actions" and "model" keywords are now deprecated
    - Enum declarations may now use already existing enum entries

   Fixes:
    - Fixed '?' operator
    - Fixed errors with C# keywords in models and rules
    - Fixed rule specification files without any rules
    - Fixed crash when using a non-existing model


v1.2 (2007-07-19)
 Features:
  - Introduced xgrs as replacement for grs (GrShell can still handle grs, but
    prints the new xgrs version for a given grs).
    See "Developing Graph Transformations with GrGen.NET" for a description
    of the new graph rewrite sequence syntax.
  - Restructured directories
  - Added test bench
  - GrGen now places the generated libraries into the directory of the spec
    files by default (can be overridden with -o)
  - Updated examples

 Features for GrShell:
  - The LGSPBackend is the default backend now. So the "select backend ..."
    line is not necessary anymore in the normal case.
  - Introduced 'new graph <grgfile>' which builds the libraries if neccessary
    and creates graph and actions, superceeding 'new graph <modellibrary>'
    plus 'select actions <actionslibrary>'. The latter commands stay
    available, though.
  - Added "validate xgrs <sequence>" which is successful, if the given
    sequence can be applied successfully on a clone of the current graph
    (implemented by BaseActions.ValidateWithSequence)
  - Added "dump add edge <type> exclude"
  - Added breakpoint support (% flag for rules, true and false in debug mode)
  - Added breakpoint toggling while debugging (use the 'b' key)
  - Fixed infotags
  - Added element exclusion for debug mode
  - Added support for multiline commands using '\' at the end of a line
  - Guess .grg extension for "new graph <specfile>" when <specfile>
    does not exist
  - Guess .grs extensions for files given via commandline

 API changes:
  - Renamed GetOutgoing/Incoming to GetCompatibleOutgoing/Incoming
  - Added GetExactOutgoing/Incoming
  - Added Apply, ApplyStar, ApplyPlus and ApplyMinMax to IAction

 Fixes:
  - Fixed problems with dangling edges in patterns
  - Fixed retyping with typeof operator
  - Newly created edges could not be returned
  - Fixed wrongly reported invalid reuse of nodes and edges in modify part
  - Annotations on anonymous elements did not work
  - Fixed error detection for return statements
  - Fixed comparisons with constant enum expressions
  - Fixed attributes with names of reserved C# keywords
  - Fixed casts to strings
  - Fixed conditions containing casts
  - Fixed float constants


v1.1 (2007-07-02)
 - Base of change log
