\chapter{Extensions}\indexmain{extensions}\label{chapextensions}

This chapter lists the ways you can customize \GrG~without \GrG-language constructs and
shows how to interact with the external world outside of \GrG.
The primary means available are: external attribute types, external functions, match filters, and external sequences; the secondary helpers available are annotations, command line parameters, and external shell commands.

%-----------------------------------------------------------------------------------------------
\section{External Attribute Types}\label{sub:extcls}
\begin{rail}
  ExternalClassDeclaration: 'class' IdentDecl (() | 'extends' (ExternalClassType+',')) ';';
\end{rail}\ixnterm{ExternalClassDeclaration}\ixkeyw{class}\ixkeyw{extends}
Registers a new attribute type with \GrG. You may declare the base types of the type, but not give attributes. The attribute type must be implemented externally, see \ref{sub:extclsfctimpl}; for \GrG~the type is opaque, only external functions can do computations with it. You may extend \GrG~with external attribute types if the built-in attribute types (cf. \ref{sec:builtintypes}) are insufficient for your needs.

%-----------------------------------------------------------------------------------------------
\section{External Function Types}\label{sub:extfct}
\begin{rail}
  ExternalFunctionDeclaration: IdentDecl '(' ( () | (Type + ',') ) ')' ':' Type ';';
\end{rail}\ixnterm{ExternalFunctionDeclaration}
Registers an \indexed{external function} with \GrG~to be used in attribue computation.
An external function declaration specifies the expected input types and the output type. The function must be implemented externally, see \ref{sub:extclsfctimpl}.
An external function call (cf. \ref{sec:primexpr}) may receive and return values of the built-in (attribute) types as well as of the external attribute types; the real arguments on the call sites are type-checked against the declared signature following the subtyping hierarchy of the built-in as well as of the external attribute types.
You may extend \GrG~with external functions if the built-in attribute computation capabilities (cf. \ref{sub:expr}) are insufficient for your needs.

%-----------------------------------------------------------------------------------------------
\section{External Match Filters}\label{sub:extflt}

\begin{rail}
  MatchFilter: ( backslash (IdentDecl + ',') )?;
\end{rail}\ixnterm{MatchFilter}

Registers one or multiple \indexed{external match filter}s with \GrG~, for the rule the match filters are appended at, to be used from selected applications of that rule (cf. \emph{FilterIdent} in \ref{sec:ruleapplication}).
The \indexed{match filter} function must be implemented externally, see \ref{sub:extfltseqimpl}.
You may extend \GrG~with match filters if you need to inspect the matches found for a rule in order to decide which to apply (see note \ref{note:inspect}) or if you just need a post-match hook which informs you about the found matches.

In addition to the external match filters, you may request from GrGen to generate a match filter for \indexed{symmetric matches}.
In order to do so use the special filter name \texttt{auto}; this filter name may be used on multiple rules in contrast to the other names which must be unique.
The generated code implementing the \texttt{auto} filter is to be applied like your own external filters, after a backslash following the rule call.
The filter is removing matches due to an \indexed{automorphic} pattern, matches which are covering the same spot in the host graph with a permutation of the nodes, the edges, or subpatterns of the same type at the same level.
Other nested pattern constructs which are structurally identical are not recognized to be identical when they appear as commuted subparts; but they are so when they are factored into a subpattern which is instantiated multiple times.
It is highly recommended to use this \indexed{symmetry reduction} technique when building state spaces including isomorphic state collapsing, as puring the matches which lead to isomorphic states early saves expensive graph comparisons -- and often it gives the semantics you are interested in anyway.

\subsubsection*{Match object}

For a rule or subpattern \texttt{r} GrGen generates a match interface \texttt{IMatch\_r} extending the generic \texttt{IMatch} interface from the \texttt{libGr}.
The basic constituents, i.e. nodes, edges and variables are mapped directly to members of their name and type, containing the graph element matched or the value computed.
For alternatives nested inside the pattern a common base interface \texttt{IMatch\_r\_altName} is generated, plus for each alternative case an interface \texttt{IMatch\_r\_altName\_altCaseName}. When you walk the matches tree using the type exact interface (which is recommended), you must type switch on the match object in the alternative variable, to determine the case which was finally matched, and cast to its match type.
For iterateds nested inside the pattern, in the pattern match object an iterated variable of type \texttt{IMatchesExact<IMatch\_r\_iteratedName>} is created; the IMatchesExact allows you to iterate over the patterns finally found. 
A subpattern usage is mapped directly to a variable in the match object typed with the match interface of the subpattern.
The same holds for independent patterns; negative patterns do not appear in the match objects, for they prevent the matching and thus the building of a match object in the first place.

%-----------------------------------------------------------------------------------------------
\section{External Sequences}\label{sub:extseq}
\begin{rail}
  ExternalSequenceDeclaration: 
    'sequence' RewriteSequenceSignature ';';
\end{rail}\ixnterm{ExternalSequenceDeclaration}
Registers an \indexed{external sequence} similar to a defined sequence (cf. \ref{sec:sequencedefinition}) but in contrast to that it must or can be implemented outside in C\# code.
An external sequence declaration specifies the expected input types and the output types. The sequence must be implemented externally, see \ref{sub:extfltseqimpl}.
You may extend \GrG~with external sequences if you want to call into external code to interface with libraries from outside the domain of graph rewriting, or if the \GrG-languages are not well suited for parts of the task at hand.

%-----------------------------------------------------------------------------------------------
\section{Shell Commands}

\begin{rail}
  '!' CommandLine
\end{rail}\indexmain{\texttt{"!}}
\emph{CommandLine} is execute as-is by the shell of the operating system.

%-----------------------------------------------------------------------------------------------
\section{Shell and Compiler Parameters}

\noindent When executing the \GrG\ generator/compiler \texttt{GrGen.exe}, the follwing parameters are admissible:

\noindent \texttt{[mono] GrGen.exe } \texttt{[-keep [<dest-dir>]] [-debug]} \texttt{[-lazynic] [-noinline]} \texttt{[-r <assembly-path>]}

The assembly \emph{assembly-path} is linked as reference to the compilation result with the \texttt{-r} parameter.

These compiler parameters can be configured in the GrShell to be used, too:
\begin{rail}
  'new' 'add' 'reference' Filename
\end{rail}\ixkeyw{new}\ixkeyw{add}\ixkeyw{reference}
Configures a reference to an external assembly \emph{Filename} to be linked into the generated assemblies, maps to the \texttt{-r} option of \texttt{grgen.exe} (cf. \ref{grgenoptions}).

\begin{rail}
  'new' 'set' ('keepdebug'|'lazynic'|'noinline') ('on'|'off')
\end{rail}\ixkeyw{new}\ixkeyw{set}\ixkeyw{keepdebug}\ixkeyw{lazynic}\ixkeyw{on}\ixkeyw{off}
Configures the compilation of the generated assemblies to keep the generated files and to add debug symbols,
or configures the generation of the matchers to execute negatives, independents, and conditions only at the end of matching (normally asap),
or configures the generation of the matchers to never inline subpatterns.
Maps to the \texttt{-keep} and the \texttt{-debug} options or to the \texttt{-lazynic} or to the \texttt{-noinline} option of \texttt{grgen.exe}.


%-----------------------------------------------------------------------------------------------
\section{Annotations}\indexmain{annotation}
\label{annotations}

Identifier \indexed{definition}s can be annotated by \indexedsee{pragma}{annotation}s. Annotations are key-value pairs.
\begin{rail}
  IdentDecl: Ident (() | '[' (Ident '=' Constant + ',') ']');
\end{rail}\ixnterm{IdentDecl}
Although you can use any key-value pairs between the brackets, only the identifier \indexed{prio} has an effect so far.
But you may use the annotations to transmit information from the specification files to API level where they can be enumerated.
\begin{table}[htbp]
\begin{tabularx}{\linewidth}{|lllX|} \hline
  \textbf{Key} & \textbf{Value Type} & \textbf{Applies to} & \textbf{Meaning} \\ \hline
  \texttt{prio} & int & node, edge & Changes the ranking of a graph element for \indexed{search plan}s. The default is \texttt{prio}=1000. Graph elements with high values are likely to appear prior to graph elements with low values in search plans.\\ \hline
\end{tabularx}
\caption{Annotations}
\label{tabannotations}
\end{table}
\begin{example}
We search the pattern \texttt{v:NodeTypeA -e:EdgeType-> w:NodeTypeB}. We have a host graph with about 100 nodes of \texttt{NodeTypeA}, 1,000 nodes of \texttt{NodeTypeB} and 10,000 edges of \texttt{EdgeType}. Furthermore we know that between each pair of \texttt{NodeTypeA} and \texttt{NodeTypeB} there exists at most one edge of \texttt{EdgeType}. \GrG\ can use this information to improve the initial search plan if we adjust the pattern like \texttt{v[prio=10000]:NodeTypeA -e[prio=5000]:EdgeType-> w:NodeTypeB}.
\end{example}

% todo: The maybeDeleted by Sebastian?
