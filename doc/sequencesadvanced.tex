\chapter{Advanced Control and Computations}\indexmain{advanced control}\indexmain{sequence computations}
\label{cha:transaction}

In this chapter we'll have a look at advanced graph rewrite sequence constructs,
with the transaction double angles as the central statement;
and sequence computations, which are not concerned with controling rules,
but with computing values or creating side effects.

Transaction: temporal succession.
With copy statements and modelling the temporal succession can be transformed into one step of spatial splitting, defining a state space.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extended control}\label{sec:extctrl}

The extended control constructs offer further rule application control in the form of \indexed{transaction}s and \indexed{backtracking}, parenthesis, \indexed{sequence constant}s, and \indexed{indeterministic choice} from a sets of rules or sequences.

\begin{rail} 
  ExtendedControl: 
    '<' RewriteSequence '>' | 
    '<<' RuleExecution ';;' RewriteSequence '>>' |
    '/' RewriteSequence '/'
	;
\end{rail}

Graph rewrite sequences can be processed \indexed{transaction}ally by using angle brackets (\texttt{<>}), i.e.
if the return value is \texttt{false}, all the related operations on the host graph will be rolled back.
Nested transactions\indexmainsee{nested transaction}{transaction} are supported, i.e. a transaction which was committed is rolled back again if an enclosing transaction fails.
Transactions are a key ingredient for backtracking, which is syntactically specified by double angle brackets (\texttt{<<r;;s>>}.
The semantics of the construct are:
First compute all matches for rule \texttt{r}, then start a transaction.
For each match: execute the rewrite of the match, then execute \texttt{s}.
If \texttt{s} failed then rollback and continue with the loop.
If \texttt{s} succeeded then commit and break from the loop.
A normal or backtracking transaction can be paused temporarily with the \indexed{pause insertion} \texttt{/ s /}.
The effects of the sequence inside the pause insertion are written to the graph and kept even if the transaction fails and is rolled back.
This behaviour allows to generate a state space (see \ref{sec:statespaceenum} for more on this) by iterating all matches with nested backtracking brackets (either statically nested, or dynamically nested via sequence calls, with the body of the sequence called containing one backtracking step), copying during the backtracking pauses the states which are reached during the backtracking enumeration and which should be kept.

\begin{note}
While a transaction or a backtrack is pending, all changes to the graph are recorded into some kind of undo log, which is used to reverse the effects on the graph in the case of rollback (and is thrown away when the nesting root gets committed).
So these constructs are not horribly inefficient, but they do have their price --- if you need them, use them, but evaluate first if you really do.
\end{note}

\begin{rail} 
  ExtendedControl: 
    '(' RewriteSequence ')' |
    (percent)? BoolLit
	;
\end{rail}

Forcing execution order can be achived by parentheses.
Boolean literals \texttt{true}/\texttt{false} come in handy if a sequence is to be evaluated 
but its result must be a predefined value; furtheron a \indexed{break point} may be attached to them.

\begin{rail} 
  ExtendedControl: 
	dollar (percent)? (ampersand | '|' | doubleampersand | '||') '(' SequencesList ')' |
	(dollar (percent)? )? lbrace '(' ((RuleExecution)+(',')) ')' rbrace
	;
  SequencesList:
	RewriteSequence ((',' RewriteSequence)*())
	;
\end{rail}\ixnterm{SequencesList}

The \indexed{random-all-of operators} given in function call notation with the dollar sign plus operator symbol as name have the following semantics:
The strict operators \verb/|/ and \verb/&/ evaluate all their subsequences in random order returning the disjunction resp. conjunction of their truth values.
The lazy operators \verb/||/ and \verb/&&/ evaluate the subsequences in random order as long as the outcome is not fixed or every subsequence was executed 
(which holds for the disjunction as long as there was no succeeding rule and for the conjunction as long as there was no failing rule).
A \indexed{choice point} may be used to define the subsequence to be executed next.
The \indexed{some-of-set braces} \verb/{(r,[s],$[t]=}/ matches all contained rules and then executes the ones which matched.
The \indexed{one-of-set braces} \verb/${(r,[s],$[t])}/ (some-of-set with random choice applied) matches all contained rules and then executes at random one of the rules which matched
(i.e. the one match of a rule, all matches of an all bracketed rule, or one randomly chosen match of an all bracketed rule with random choice).
The one/some-of-set is true if at least one rule matched and false if no contained rule matched.
A \indexed{choice point} may be used on the one-of-set; it allows you to inspect the matches available graphically before deciding on the one to apply. 

\begin{rail}
  ExtendedControl:
    'for' lbrace Variable ':' Type\\
    (';' |
    'in' Function '(' Parameters ')' ';' |
    'in' '[' '?' r ']' ';')\\
    RewriteSequence rbrace
    ;
\end{rail}\ixkeyw{for}\label{forgraphelem}\label{forincidentadjacent}\label{formatch}

The \texttt{for} loop without containment is iterating over all the elements in the current host graph which are compatible to the type given.
The iteration variable is bound to the currently enumerated graph element, then the sequence in the body is executed.
The type of the iteration variable must be statically known to be of a node or edge type.
If you iterate a node type from a graph, you may be interested in iterating its incident edges or its adjacent nodes.
This can be achieved with a for neighbouring elements loop, which binds the iteration variable to an edge in case the \emph{Function} is one of \texttt{incoming}, \texttt{outgoing}, or \texttt{incident}. 
Or which binds the iteration variable to a node in case the \emph{Function} is one of \texttt{adjacentIncoming}, \texttt{adjacentOutgoing}, or \texttt{adjacent}.
The admissible \emph{Parameters} are the source node, or the source node plus the incident edge type, or the source node plus the incident edge type, plus the adjacent node type ---
that's the same as for the sequence expression functions explained in \ref{neighbouringelementsfunctions}/Connectedness queries.
In contrast to these set returning functions, this loop contained functions enumerate nodes/edges multiple times in case of reflexive or multi edges.
The third \texttt{for} loop introduced here, the for matches loop, allows to iterate through the matches found for an all-bracketed rule reduced to a test; i.e. the rule is not applied, we only iterate its matches.
The loop variable must be of a statically known \texttt{match<r>} type with \texttt{r} being the name of the rule matched.
The elements (esp. the nodes and edges) of the pattern of the matched rule can then be accessed by applying the \texttt{.}-operator on the loop variable, giving the name of the element of interest after the dot.
Note: the elements must be assigned to a variable in order to access their attributes, a direct attribute access after the match access is not possible.
Note: the match object allows only to access the top level nodes, edges, or variables.
If you use subpatterns or nested patterns and want to access elements found by them, you have to \texttt{yield}(\ref{sub:yield}) them out to the top-level pattern.
The most important \texttt{for} loop, the one iterating a container, for enumerating the elements contained in storages, will be introduced later on here: \ref{forstorage}.
All \texttt{for} loops fail if one of the sequence executions failed, and succeed otherwise.

\begin{rail}
  ExtendedControl:
		'highlight' '(' Arguments ')'
    ;
\end{rail}\ixkeyw{highlight}
The \texttt{highlight} sequence highlights the arguments given as a quoted text in the graph;
it does what the \texttt{(h)ighlight} command does in the debugger, see \ref{highlight}, just programmed from the sequences. 
Arguments is a comma-separated list of variable names or visited flag ids, the graph elements contained in the variables are highlighted, as are the graph elements marked by the visited flag.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Procedural abstraction (Sequence definitions)} \label{sec:sequencedefinition}
\begin{rail}
  RewriteSequenceDefinition: 
    ('def' | 'sequence') RewriteSequenceSignature lbrace RewriteSequence rbrace;
  RewriteSequenceSignature: 
    SequenceName ('(' ((InVariable ':' Type)*',') ')')? \\ (':' '(' ((OutVariable ':' Type)*',') ')')?
	;
\end{rail}\ixnterm{RewriteSequenceDefinition}\ixnterm{RewriteSequenceSignature}

If you want to use a sequence or sequence part at several locations, factor it out into a \indexed{sequence definition} and reuse with its name as if it were a rule.
A sequence definition declares input and output variables; 
when the sequence gets called the input variables are bound to the values it was called with.
If and only if the sequences succeeds, the values from the output variables get assigned to the assignment target of the sequence call.
Thus a sequence call behaves as a rule call, cf. \ref{sec:ruleapplication}.

The compiled sequences must start with the \texttt{sequence} keyword in the rule file.
The interpreted sequences in the shell must start with the \texttt{def} keyword; a shell sequences can be overwritten with another shell sequence in case the signature is identical. (Overwriting is needed in the shell to define direct or mutually recursive sequences as a sequence must be defined before it can get used; furthermore it allows for a more rapid-prototyping like style of development in the shell.)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sequence computation} \label{sec:seqcomp}

\begin{rail} 
  RewriteComputationUsage: (percent)? lbrace CompoundComputation rbrace; 
\end{rail}\ixnterm{RewriteFactor}

The non-computation constructs introduced before are used for executing rules, to determine which rule to execute next depending on success and failure of the previous rule applications, and where to apply it next by transmitting simple valued variables in between the rules.
Sequence computations in contrast are used for manipulating complex valued variables, evaluating computational expressions, or for causing side effects like output or element markings.
The computation will return a boolean value by comparing the return value of the compound computation to the default value of the corresponding type, and returning false if equal, or true if unequal; a computation without a return value always returns true.
So just using a boolean variable as computation returns the value of the variable.
A prepended \texttt{\%} attaches a \indexed{break point} to the computation.

\begin{rail} 
  CompoundComputation: Computation ((';' Computation)*); 
\end{rail}

A compound computation consists of a computation followed by an optional list of computations separated by semicolons.
The computations are executed from left to right;
the value of the compound computation is the value of the last computation (so you must give an expression there in order to return a value, whereas it is pointless to specify an expression before).

\begin{rail} 
  Computation:
     VariableDeclaration |
     Assignment |
     MethodCall |
     FunctionCall |
     SequenceExpression
  ;
	Assignment:	AssignmentTarget '=' (SequenceExpression | Assignment); 
	MethodCall: Variable (SingleMethodCall +);
	SingleMethodCall: '.' MethodName '(' Arguments ')';
	FunctionCall: FunctionName '(' Arguments ')';
	Arguments: (SequenceExpression * ',');
\end{rail}\ixnterm{Computation}\label{recstmt}\indexmain{record}\indexmain{emit}

A variable declaration declares a local variable in the same way as in the sequences.
An assignment assigns the value of a sequence expression to an assignment target.
It may be chained; such an assignment chain is executed from right to left, assigning the rightmost value to all the assignment targets given.
The form of expressions and assignment targets will be specifed below.
A method call executes a (predefined) method on a variable, passing further arguments.
If may be chained; such a method call chain is executed from left to right. 
This is possible with storage changing methods which return the variable again, better: which return the then altered variable. 
They will be introduced in \ref{sec:storages} in more details.
A function call executes a (predefined) function, passing further arguments.
In addition to the visited flag functions which will be explained in more detail in \ref{sec:visited},
\texttt{emit}, \texttt{record}, and \texttt{export} function calls can be given here: the emit function writes a double quoted string or the value of a variable to the emit target (stdout as default, or a file specified with the shell command \texttt{redirect emit}).
The record function writes a double quoted string or the value of a variable to the currently ongoing recordings (see \ref{recordnreplay}). This feature allows to mark states reached during the transformation process in order to replay only interesting parts of an recording. It is recommended to write only comment label lines, i.e. \verb/"#"/, some label, and \verb/"\n"/.
The export function exports the current graph to the path specified if called with one argument, or it exports the subgraph specified as first argument to the path specified as second argument.
It behaves like the export command from the GrShell, see \ref{outputcmds}.
Having it available in the sequences allows for programmed exporting, and exporting of parts of the graph, with the subgraph containment just computed.
Finally, an expression (without side effects) can be evaluated, this allows to return a (boolean) value from a computation.

\begin{rail}
  AssignmentTarget: 
    Variable (':' Type)? |
    'yield' Variable |
    GraphElement '.' Attribute |
    ArrayVariable '[' SequenceExpression ']' |
    GraphElement '.' 'visited' '[' SequenceExpression ']'
;
\end{rail}\ixnterm{AssignmentTarget}\ixkeyw{visited}\ixkeyw{yield}

Possible targets of assignments are the variables and def-variables to be yielded to, as in the simple assignments of the sequences. 
A \texttt{yield} assignment writes the rhs variable value to the lhs variable which must be declared as a  def-to-be-yielded-to variable (\texttt{def}-prefix) in the pattern containing the \texttt{exec} statement.
Yielding is only possible from compiled sequences, it always succeeds.
Further on, the attributes of graph elements may be written to, the values at given positions of array variables may be written to, and the visited status of graph elements may be changed.

\begin{rail}
  SequenceExpression:  
    ConditionalSequenceExpression |
    BooleanSequenceExpression |
    RelationalSequenceExpression |
    ArtihemticSequenceExpression |
    PrimarySequenceExpression;
\end{rail}\ixnterm{SequenceExpression}

Sequence expressions are basically a subset of the expressions introduced in \ref{sub:expr}.

\begin{rail}
  ConditionalSequenceExpression: 
    BooleanSequenceExpression '?' SequenceExpression ':' SequenceExpression;
\end{rail}\ixnterm{ConditionalSequenceExpression}

The conditional operator has lowest priority, if the condition evaluates to true the first expression is evaluated and returned, otherwise the second.

\begin{rail}
  BooleanSequenceExpression: 
    SequenceExpression (ampersand | xorhat | '|' | doubleampersand | '||') SequenceExpression |
    '!' SequenceExpression;
\end{rail}\ixnterm{BooleanSequenceExpression}

The boolean operators have the same semantics and same priority as in \ref{sub:expr}.

\begin{rail}
  RelationalSequenceExpression: 
    SequenceExpression ('==' | '!=' | '<' | '<='| '>' | '>=' | 'in' | titilde) SequenceExpression;
\end{rail}\ixnterm{RelationalSequenceExpression}

The equality operators work for every type and return whether the values to compare are equal or unequal.
The relational operators on numerical, graph, and set/map/array types work as specified in \ref{sub:expr}.

\begin{rail}
  ArithmeticSequenceExpression:
    SequenceExpression ('+') SequenceExpression;
\end{rail}\ixnterm{ArithmeticSequenceExpression}

The only arithemtic operator available for now is plus, denoting addition of numerical values or string concatenation.

\begin{rail}
  PrimarySequenceExpression:
    BasicSequenceExpression |
    SpecialSequenceExpression;
\end{rail}\ixnterm{PrimarySequenceExpression}

The atoms of the expressions are the basic and the special sequence expressions.

\begin{rail}
  BasicSequenceExpression:
    'def' '(' (Variable+',') ')' |
	  railat '(' NameString ')' |
 	  GraphElement '.' Attribute |
	  Variable | 
    Literal
  ;
\end{rail}\ixnterm{BasicSequenceExpression}\ixkeyw{def}

The basic sequence expressions are the building blocks of the computation sequences.
A \texttt{def} term is successful iff all the variables are defined (not null).
The at operator allows to access a graph element by its \indexed{persistent name}.
The attribute access clause returns the attribute value of the given graph element.
The variable and literal basic expressions are the same as in the SimpleOrInteractiveExpression.

\begin{rail}
  SpecialSequenceExpression:
    GraphElement '.' 'visited' '[' SequenceExpression ']' |
    ArrayOrMapVariable '[' SequenceExpression ']' |
    MethodCall |
    FunctionCall;
  ;
\end{rail}\ixnterm{SpecialSequenceExpression}\ixkeyw{visited}

The special sequence expressions are used for storage and visited flag handling, plus for graph and subgraph handling.

The storage and visited flag oriented ones are used to check whether a value is marked, to access a storage, or to call a method on a storage (note: here it is not possible to build method call chains). 
They will be explained in more detail in chapter \ref{cha:storagesvisited}.

The graph and subgraph oriented ones can be separated into three groups.

\subsubsection*{Basic graph manipulation}
The first group is built from basic graph manipulation operators used for adding or removing elements:

\begin{description}
\item[\texttt{add(.)}] creates a node of the given type and adds it to the host graph.
\item[\texttt{add(.,.,.)}] creates an edge of the given type and adds it to the host graph, starting at the node given as second argument, ending at the node given as third argument.
\item[\texttt{rem(.)}] removes the given node or edge from the graph.
\item[\texttt{clear()}] clears the host graph.
\end{description}

\subsubsection*{Connectedness queries}\label{neighbouringelementsfunctions}
The second group is built from the operators querying the connectedness of graph elements.
It contains functions to ask for the source or target node of an edge: 

\begin{description}
\item[\texttt{source(.)}] returns the source node of the given edge.
\item[\texttt{target(.)}] returns the target node of the given edge.
\end{description}

Furthermore, it contains functions to query the neighbouring elements.
They allow to compute the set of edges incident to a node:

\begin{description}
\item[\texttt{incident(.)}] returns the set of the edges which are incident to the node given as argument value.
\item[\texttt{incident(.,.)}] as above, but only edges of the type given as second argument are contained.
\item[\texttt{indicent(.,.,.)}] as above, but only edges incident to an opposite node of the type given as third argument are contained.
\item[\texttt{incoming}] same as any of the incidents above, but restricted to incoming edges.
\item[\texttt{outgoing}] same as any of the incidents above, but restricted to outgoing edges.
\end{description}

In addition, they allow to compute the set of nodes adjacent to a node:

\begin{description}
\item[\texttt{adjacent(.)}] returns the set of the nodes which are adjacent to the node given as argument value.
\item[\texttt{adjacent(.,.)}] as above, but only nodes incident to an edge of the type given as second argument are contained.
\item[\texttt{adjacent(.,.,.)}] as above, but only nodes of the node type given as third argument are contained.
\item[\texttt{adjacentIncoming}] same as any of the adjacents above, but restricted to nodes reachable via incoming edges.
\item[\texttt{adjacentOutgoing}] same as any of the adjacents above, but restricted to nodes reachable via outgoing edges.
\end{description}

\subsubsection*{Subgraph operations}
The third group is defined by functions which operate on (sub-)graphs:
It contains functions which allow to compute (node-or-edge) induced subgraphs, and to insert clones of induced subgraphs.
They are especially useful in state space enumeration, cf. \ref{sec:statespaceenum}.

\begin{description}
\item[\texttt{inducedSubgraph(.)}] returns the induced subgraph (type: \texttt{graph}) of the host graph for the set of nodes given as argument value.
\item[\texttt{definedSubgraph(.)}] returns the defined (edge-induced) subgraph (type: \texttt{graph}) of the host graph for the set of edges given as argument value.
\item[\texttt{insertInduced(.,.)}] adds a clone of the subgraph induced by the set of nodes given as first argument to the host graph, returns the clone of the anchor node given as second argument.
\item[\texttt{insertDefined(.,.)}] adds a clone of the subgraph defined (edge-induced) by the set of edges given as first argument to the host, returns the clone of the anchor edge given as second argument.
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Quick reference table}

Table~\ref{seqtab} lists most of the operations of the graph rewrite sequences at a glance,
whereas Table~\ref{comptab} lists most of the operations of the graph rewrite computations at a glance.

%\makeatletter
\begin{table}[htbp]
\begin{minipage}{\linewidth} \renewcommand{\footnoterule}{} 
\begin{tabularx}{\linewidth}{|lX|}
\hline
\texttt{<s>}	& Execute \texttt{s} transactionally (rollback on failure).\\
\texttt{<<r;;s>>}	& Backtracking: try the matches of rule \texttt{r} until \texttt{s} succeeds.\\
\hline
\texttt{highlight(vars)} & Highlights the content of the variables in the graph. \\
\texttt{export(filename)} & Exports the current graph to a file with the specified name. \\
\hline
\texttt{\$\{(r1,[r2],\$[r3])\}}	& Tries to match all contained rules, then rewrites indeterministically one of the rules which matched. True if at least one matched.\\
\hline
\texttt{for\{v in u; t\}}	& Execute \texttt{t} for every \texttt{v} in storage set \texttt{u}. One \texttt{t} failing pins the execution result to failure.\\
\texttt{for\{v->w in u; t\}}	& Execute \texttt{t} for every pair (\texttt{v},\texttt{w} in storage map \texttt{u}. One \texttt{t} failing pins the execution result to failure.\\
\texttt{for\{v:match<r> in [?r]; t\}}	& Execute \texttt{t} for every match \texttt{v} from rule \texttt{r}. One \texttt{t} failing pins the execution result to failure.\\
\hline
\texttt{\{comp\}}	& An unspecified sequence computation (see following table).\\
\hline
\texttt{(w)=s(w)} & Calls a sequence \texttt{s} handing in \texttt{w} as input and writing its output to \texttt{w}; defined e.g. with \texttt{sequence s(u:Node):(v:Node)} \texttt{\{ v=u \}}.\\
\hline
\end{tabularx}\indexmain{\texttt{<>}}\indexmain{\texttt{<<;>>}}
\end{minipage}\\
\\ 
{\small Let \texttt{r}, \texttt{s}, \texttt{t} be sequences, \texttt{u}, \texttt{v}, \texttt{w} variable identifiers, \texttt{<op>} $\in \{\texttt{|}, \texttt{\textasciicircum}, \texttt{\&}, \texttt{||}, \texttt{\&\&}\}$ }%and \texttt{n}, \texttt{m} $\in \N_0$.}
\caption{Sequences at a glance}
\label{seqtab}
\end{table}
%\makeatother
 
%\makeatletter
\begin{table}[htbp]
\begin{minipage}{\linewidth} \renewcommand{\footnoterule}{} 
\begin{tabularx}{\linewidth}{|lX|}
\hline
\texttt{c;d}	& Computes c then d; the value of the computation is d\\
\texttt{t=e}	& Simple assignment of an expression value to an assignment target\\
\texttt{t=e=f}	& Chained assignment \\
\texttt{v.m(e)}	& Simple method call, with m e.g. being storage add \\
\texttt{v.m(e).m(e)}	& Chained method call\\
\hline
\texttt{e ? f : g}	& Returns f if e evaluates to true, otherwise g \\
\texttt{e op f}	& For \texttt{op} being one of the boolean operators \texttt{||,|,\&,\&\&,\^\ } \\
\texttt{e op f}	& For \texttt{op} being one of comparison operators \texttt{==,!=,<,<=,>,>=,in} \\
\texttt{e + f}	& Numerical addition or string concatenation \\
\hline
\texttt{v} & Variable. Assignment target or expression.\\
\texttt{v.name} & Attribute of graph element. Assignment target or expression.\\
\texttt{@(name)} & Return graph element of given name.\\
\texttt{emit(v)} & Emits value of v to stdout.\\
\texttt{record(v)} & Records value of v to the replay log.\\
\texttt{export(graph, path)} & Exports the (sub)graph given to the path given.\\
\texttt{def(\emph{Parameters})} & Check if all the variables are defined.\\
\hline
\texttt{v=valloc()} & Allocates a visited-flag, assigns its id to v.\\
\texttt{vfree(e)} & Frees the visited-flag given.\\
\texttt{vreset(e)} & Resets the visited-flag given in all graph elements.\\
\texttt{u.visited[e]} & Visited flag e of u. Assignment target or expression.\\
\hline
\texttt{u=set<Node>\{\}}	& Create storage set and assign to \texttt{u}.\\
\texttt{u.add(e)}	& Add \texttt{e} to storage set \texttt{u}.\\
\texttt{u.rem(e)}	& Remove \texttt{e} from storage set \texttt{u}.\\
\texttt{u.clear()}	& Clears the storage set \texttt{u}.\\
\texttt{u.size()}	& Returns the size of storage set \texttt{u}.\\
\texttt{u.empty()} & Returns whether storage set \texttt{u} is empty.\\
\texttt{u=map<N,Edge>\{\}}	& Create storage map and assign to \texttt{u}. Operations are the same or similar to the operations of storage sets.\\
\texttt{u[e]}	& Target value of \texttt{e} in \texttt{u}. Fails if \texttt{!(e in u)}. Assignment target or expression.\\
\hline
\texttt{add(T)}	& Adds a node to the graph.\\
\texttt{add(T,src,tgt)}	& Adds an edge to the graph.\\
\texttt{rem(e)}	& Remove the node or edge \texttt{e} from the graph.\\
\texttt{clear()}	& Clears the graph.\\
\texttt{incident(n)}	& Returns the set of edges incident to \texttt{n}.\\
\texttt{adjacent(n)} & Returns the set of nodes adjacent to \texttt{n}.\\
\texttt{subgraph operations} & The subgraph operations allow to compute an induced or defined subgraph, or allow to replicate an induced or defined subgraph.\\
\hline
\end{tabularx}
\end{minipage}\\
\\ 
{\small Let \texttt{c} and \texttt{d} be computations, \texttt{t} be an assignment target, \texttt{e}, \texttt{f}, \texttt{g} be expressions, \texttt{u}, \texttt{v}, \texttt{w} be variable identifiers }
\caption{Sequence computations at a glance}
\label{comptab}
\end{table}
%\makeatother
 
% todo: beispiele im text bringen
