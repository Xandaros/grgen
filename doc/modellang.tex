\chapter{Graph Model Language}\indexmain{graph model language}
\label{chapmodellang}
The key features of \GrG\ \emph{graph models}\indexmain{graph model} as described by Geiß et al.~\cite{GBGHS:06,KG:07} are given below:

\begin{description}
\item[Types] Nodes and edges are typed.
  This is similar to classes in common programming languages. \GrG\ edge types can be directed and undirected.
\item[Attributes] Nodes and edges may possess attributes. The set of attributes assigned to a node or edge is determined by its type. The attributes themselves are typed, too.
\item[Inheritance] Node and edge types (classes) can be composed by multiple \indexed{inheritance}. \texttt{Node} and \texttt{Edge} are built-in root types of node and edge types, respectively. Inheritance eases the specification of attributes because subtypes inherit the attributes of their super types. Note that \GrG\ lacks a concept of overwriting for attributes. On a path in the \indexed{type hierarchy} graph from a type up to the built-in root type there must be exactly one declaration for each attribute identifier. Furthermore, if multiple paths from a type up to the built-in root type exist, the declaring types for an attribute identifier must be the same on all such paths. (Virtual inheritance in C++ parlance.)
\item[Connection Assertions] To specify that certain edge types should only connect specific node types a given number of times, we include connection assertions.
\end{description}

\begin{figure}[htbf]
\begin{example}\label{ex:model:map}
The following toy example of a model of road maps gives a rough picture of the language:
\begin{grgen}
enum Resident {VILLAGE = 500, TOWN = 5000, CITY = 50000}

node class Sight;

node class City {
  Size:Resident;
}

const node class Metropolis extends City {
  River:String;
}

abstract node class AbandonedCity extends City;
node class GhostTown extends AbandonedCity;

edge class Street;
edge class Trail extends Street;
edge class Highway extends Street
    connect Metropolis[+] --> Metropolis[+]
{
    Jam:boolean = false;
}
\end{grgen}
\end{example}
\end{figure}
In this chapter as well as in Chapter~\ref{chapgrshell} (\GrShell) we use excerpts of Example~\ref{ex:model:map} (the \texttt{Map} model) for illustration purposes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Building Blocks}
\label{modelbb}

\begin{note}
The following syntax specifications make heavy use of \newtermsee{syntax diagram}{rail diagram}s (also known as \indexed{rail diagram}s).
Syntax diagrams provide a visualization of EBNF\footnote{Extended Backus–Naur Form.}\indexmainsee{EBNF}{rail diagram} grammars.
Follow a path along the arrows through a diagram to get a valid sentence (or subsentence) of the language.
Ellipses represent terminals whereas rectangles represent non-terminals. For further information on syntax diagrams see~\cite{MMJW:91}.
\end{note}
Basic elements of the \GrG\ graph model language are identifiers to denominate nodes, edges, and attributes.
The model's name itself is given by its file name.
The \GrG\ graph model language is \indexed{case sensitive}.\\
\\
\emph{Ident}, \emph{IdentDecl}\\ \indexmain{identifier}\nopagebreak
A non-empty character sequence of arbitrary length consisting of letters, digits, or underscores.
The first character must not be a digit. \emph{Ident} and \emph{IdentDecl} differ in their role:
While \emph{IdentDecl} is a \emph{defining} occurrence of an identifier, \emph{Ident} is a \emph{using} occurrence.
An \emph{IdentDecl} non-terminal may be annotated\indexmain{annotation}. See Section~\ref{annotations} for annotations of declarations.
\begin{note}
\label{note:modeldecl}
  The \GrG\ model language does not distinguish between \indexed{declaration}s and \indexed{definition}s. More precisely, every declaration is also a definition. For instance, the following C-like pseudo \GrG\ model language code is illegal:
\begin{grgen}
node class t_node;
node class t_node {
  ...
}
\end{grgen}
Using an identifier before defining it is allowed. Every used identifier has to be defined exactly once.
\end{note}
\pagebreak
\emph{NodeType}, \emph{EdgeType}, \emph{EnumType}\\ \nopagebreak
These are (semantic) specializations of \emph{Ident} to restrict an identifier to denote a node type, an edge type, or an enum type, respectively.

%-----------------------------------------------------------------------------------------------
\subsection{Base Types}
\label{sct:basetypes}
The \GrG\ model language has built-in types for nodes and edges.
All nodes have the attribute-less, built-in type \texttt{Node} as their ancestor.
All edges have the abstract (see Section~\ref{typedecl}), attribute-less, built-in type \texttt{\indexed{AEdge}} as their ancestor.
The \texttt{AEdge} has two non-abstract built-in children: \texttt{\indexed{UEdge}} as base type for undirected edges and \texttt{\indexed{Edge}} as base type for directed edges.
The direction for \texttt{AEdge} and its anchestors that do not inherit from \texttt{Edge} or \texttt{UEdge} is undefined or \newterm{arbitrary}.
Because there is the ``magic of direction'' linked to the edge base types, its recommended to use the keywords \texttt{directed}, \texttt{undirected}, and \texttt{arbitrary} in order to specify inheritance (see Section~\ref{typedecl}).
As soon as you decided for directed or undirected edge classes within your type hierarchy, you are not able to let ancestor classes inherited from a contradicting base type, of course.
That is, no edge may be directed \emph{and} undirected.
This is an exception of the concept multi-inheritance.
Figure~\ref{fig:basetypes} shows the edge \indexed{type hierarchy}.
\begin{figure}[htbp]
	\centering
	\input{fig/basetypes}
	\caption{Type Hierarchy of \GrG\ Edges}
	\label{fig:basetypes}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type Declarations}
\label{typedecl}

\begin{rail}
  GraphModel: () + (ClassDeclaration
  									 | EnumDeclaration
  									 | AdvancedModelDeclarations
  									 | ModelUsage);
\end{rail}\ixnterm{GraphModel}
The \indexed{graph model} consists of zero or multiple type declarations.
\emph{ClassDeclaration} defines a node type or an edge type.
\emph{EnumDeclaration} defines an enum type to be used as a type for a attributes of nodes or edges.
Like all identifier definitions, types do not need to be declared\indexmain{declaration} before they are used (but of course must be declared somewhere).
The \emph{AdvancedModelDeclarations} are differentiated in Chapter \ref{cha:modeladvanced} (forwarding to even further ones).
In addition, other models may be used (esp. supplying base classes to extend); this happens in the same way as models are used from the rules, see section \ref{ruledecls} for more on this.

%-----------------------------------------------------------------------------------------------
\subsection{Enumeration Types}
\begin{rail}
  EnumDeclaration: 'enum' IdentDecl lbrace ((IdentDecl (() | '=' IntExpr)) + ',') rbrace ;
\end{rail}\ixkeyw{enum}\ixnterm{EnumDeclaration}
Defines an \indexed{enum type}.
An enum type is a collection of so called \emph{\indexed{enum item}s} that are associated with integral numbers, each.
Accordingly, a \GrG\ enum is internally represented as \texttt{int} (see Section~\ref{sec:builtintypes}).
\begin{note}
	An enum type and an {\tt int} are different things, but in expressions enum values are implicitly casted to {\tt int} values 	(see Section~\ref{sec:builtintypes}).
\end{note}
\begin{warning}
	Normally, assignments of {\tt int} values to something that has an enum type are forbidden (see Section~\ref{sec:builtintypes}).
	Only inside a declaration of an enum type an int value may be assigned to the enum item that is currently declared.
	This also includes the usage of items taken from other enum types (because they are implicitly casted to {\tt int}).
	However, items from other enum types must be written fully qualified in this case (which, e.g., looks like {\tt MyEnum::a}, where {\tt MyEnum} is the name of the other enum type).
\end{warning}

\begin{example}
\begin{grgen}
enum Color {RED, GREEN, BLUE}
enum Resident {VILLAGE = 500, TOWN = 5000, CITY = 50000}
enum AsInC {A = 2, B, C = 1, D, e = (int)Resident::VILLAGE + C}
\end{grgen}
Consider, e.g., the declaration of the enum item {\tt e}:
By implicit casts of   {\tt Resident::VILLAGE } and {\tt C} to {\tt int} we get the {\tt int} value 501, which is assigned to {\tt E}.
Moreover, the semantics is as in C~\cite{Sch:1990:ANSIC}. So, the following holds: $\texttt{RED} = 0$, $\texttt{GREEN} = 1$, $\texttt{BLUE} = 2$, $\texttt{A}=2$, $\texttt{B}=3$, $\texttt{C}=1$, $\texttt{D}=2$, and $\texttt{E}=501$.
\end{example}
\begin{note}
	The C-like semantics of enum item declarations implies, that multiple items of one enum type can be associated with the same same {\tt int} value.
	Moreover, it implies, that an enum item must not be used \emph{before} its definition.
	This also holds for items of other enum types, meaning that the items of another enum type can only be used in the definition of an enum item, when the other enum type is defined \emph{before} the enum type currently defined.
\end{note}

%-----------------------------------------------------------------------------------------------
\subsection{Node and Edge Types}\label{nodeandedgetypes}
\begin{rail}
  ClassDeclaration: (() | 'abstract') (() | 'const') \\
    (NodeClass | (() | ('arbitrary' | 'directed' | 'undirected')) EdgeClass);
\end{rail}\ixkeyw{abstract}\ixkeyw{const}\ixnterm{ClassDeclaration}\ixkeyw{arbitrary}\ixkeyw{directed}\ixkeyw{undirected}
Defines a new node type or edge type.
The keyword \texttt{abstract} indicates that you cannot instantiate graph elements of this type.
Instead you have to derive non-abstract types to create graph elements.
The abstract-property will not be inherited by subclasses, of course.

\begin{example}
We adjust our map model and make \texttt{city} abstract:
\begin{grgen}
abstract node class City {
  Size:int;
}
abstract node class AbandonedCity extends City;
node class GhostTown extends AbandonedCity;
\end{grgen}
You will be able to create nodes of type \texttt{GhostTown}, but not of type \texttt{City} or \texttt{AbandonedCity}. However, nodes of type \texttt{GhostTown} are also of type \texttt{AbandonedCity} as well as of type \texttt{City} and they have the attribute \texttt{Size}, hence.
\end{example}
The keyword \texttt{const} indicates that rules may not write to attributes (see also Section~\ref{sec:replacemodify}, \texttt{eval}). However, such attributes are still writable by \LibGr\indexmain{libGr} and \GrShell\indexmain{GrShell} directly. This property applies to attributes defined in the current class, only. It does not apply to inherited attributes. The \texttt{const} property will not be inherited by subclasses, either. If you want a subclass to have the \texttt{const} property, you have to set the \texttt{const} modifier explicitly.

The keywords \texttt{arbitrary}, \texttt{directed}, and \texttt{undirected} specify the direction ``attribute'' of an edge class and thus its inheritance.
An \texttt{arbitrary} edge inherits from \texttt{AEdge}, it is always abstract and neither directed nor undirected.
A \texttt{directed} edge inherits from \texttt{Edge}.
An \texttt{undirected} edge inherits from \texttt{UEdge}.
If you do not specify any of those keywords, a \texttt{directed} edge is chosen by default.
See also Section~\ref{sct:basetypes}

\begin{rail}
  NodeClass: 'node' 'class' IdentDecl (() | 'extends' (NodeType+',')) \\
    (';' | lbrace AttributeDeclarations rbrace);
\end{rail}\ixkeyw{node}\ixkeyw{class}\ixkeyw{extends}\ixnterm{NodeClass}
Defines a new \indexed{node type}. Node types can inherit\indexmain{inheritance} from other node types defined within the same file. If the \texttt{extends} clause is omitted, \emph{NodeType} will inherit from the built-in type \texttt{\indexed{Node}}. Optionally nodes can possess attributes.

\begin{rail}
  EdgeClass: 'edge' 'class' IdentDecl (() | 'extends' (EdgeType+',')) \\
    (() + ConnectionAssertions) (';' | lbrace AttributeDeclarations rbrace);
\end{rail}\ixkeyw{edge}\ixkeyw{class}\ixkeyw{extends}\ixnterm{EdgeClass}
Defines a new \indexed{edge type}.
Edge types can inherit\indexmain{inheritance} from other edge types defined within the same file.
If the \texttt{extends} clause is omitted, \emph{EdgeType} will inherit from the built-in type \texttt{\indexed{Edge}}.
Optionally edges can possess attributes.
A \newterm{connection assertion} specifies that certain edge types should only connect specific nodes a given number of times.
(see Section~\ref{sct:basetypes})

\begin{warning}
It is not forbidden to create graphs that are invalid according to \indexed{connection assertion}s.
\GrG\ just enables you to check, whether a graph is valid or not.
See also Section~\ref{sec:validate}, \texttt{validate}.
\end{warning}

\begin{rail}
  ConnectionAssertions: 'connect' ((NodeConstraint ('-->' | '<--' | '--' | '?--?') NodeConstraint | 'copy' 'extends') + ',');
  NodeConstraint: NodeType (MultiplicityConstraint)? ;
  MultiplicityConstraint: '[' ('*' | '+' | Number | RangeConstraint) ']' ;
  RangeConstraint: Number ':' ('*' | Number) ;
\end{rail}\ixkeyw{connect}\ixkeyw{copy}\ixkeyw{extends}\ixnterm{ConnectionAssertion}\ixnterm{NodeConstraint}\ixnterm{MultiplicityConstraint}\ixnterm{RangeConstraint}\label{sct:ConnectionAssertions}
A \emph{\indexed{connection assertion}} is denoted as a pair of node types, optionally with their multiplicities\indexmainsee{multiplicity}{connection assertion}.
It allows you to specify the node types an edge may connect and the multiplicities with which such edges appear on the nodes.
It is best understood as a simple pattern of the form(cf. ~\ref{sct:graphlets}) \texttt{:SourceNodeType -:EdgeType-> :TargetNodeType}, of which every occurrence in the graph is searched.
In contrast to a real such pattern and the node types only edges of exactly the given edge type are taken into account.
Per node of \texttt{SourceNodeType} (or a subtype) it is counted how often it was covered by a match of the pattern starting at it,
and per node of \texttt{TargetNodeType} (or a subtype) it is counted how often it was covered by a match of the pattern ending at it.
The numbers must be in the range specified at the \texttt{SourceNodeType} and the \texttt{TargetNodeType} for the connection assertion to be fulfilled.
Giving no multiplicity constraint is equivalent to \verb#[*]#, i.e. $[0,\infty[$, i.e. unconstrained.
Please take care of non-disjoint source/target types/subtypes in the case of undirected and especially arbitrary edges.
In the case of multiple connection assertions all are checked and errors for each one reported; for strict validation to succeed at least one of them must match.
It might happen that none of the connection assertions of an \texttt{EdgeType} are matching an edge of this type in the graph.
This is accepted in the case of normal validation (throwing connection assertions without multiplicities effectively back to nops);
but as you normally want to see \emph{only} the specified connections occurring in the graph,
there is the additional mode of strict validation: if an edge is not covered by a single matching connection, validation fails.
Furtheron there is the strict-only-specified mode, which only does strict validation of the edges for which connection assertions are given.
See Section~\ref{sec:validate}, \texttt{validate}\ixkeyw{validate}, for an example.

The arrow syntax is based on the \GrG\ graphlet specification (see Section~\ref{sct:graphlets}).
The different kinds of arrows distinguish between directed, undirected, and arbitrary edges.
The \texttt{-->} arrow means a directed edge aiming towards a node of the target node type (or one of its subtypes).
The \texttt{A<--B} connection assertion is equivalent to the \texttt{B-->A} connection assertion.
The \texttt{--} arrow is used for undirected edges.
The \texttt{?--?} arrow means an arbitrary edge, i.e. directed as well as undirected possible (fixed by the concrete type inheriting from it); in case of an directed edge the connection pattern gets matched in both directions.
\emph{Number} is an \texttt{int} constant as defined in Chapter~\ref{cha:typeexpr}.
Table~\ref{multiplicities} describes the multiplicity definitions.

\begin{table}[htbp]
\begin{tabularx}{\linewidth}{|l|X|}\hline
	\texttt{[$n$:*]} & The number of edges incident to a node of that type is unbounded. At least $n$ edges must be incident to nodes of that type.\\
	\texttt{[$n$:$m$]} & At least $n$ edges must be incident to nodes of that type, but at most $m$ edges may be incident to nodes of that type ($m \geq n \geq 0$ must hold).\\
	\texttt{[*]} & Abbreviation for \texttt{[0:*]}.\\
	\texttt{[+]} & Abbreviation for \texttt{[1:*]}.\\
	\texttt{[$n$]} & Abbreviation for \texttt{[$n$:$n$]}.\\
	               & Abbreviation for \texttt{[$1$]}. \\ \hline
\end{tabularx}
\caption{\GrG\ node constraint multiplicities}
\label{multiplicities}
\end{table}

In order to apply the connection assertions of the supertypes to an \texttt{EdgeType}, you may use the keywords \texttt{copy extends}.
The \texttt{copy extends} assertion ``imports'' the connection assertions of the \emph{direct} ancestors of the declaring edge.
This is a purely syntactical simplification, i.\,e.\ the effect of using \texttt{copy extends} is the same as copying the connection assertions from the direct ancestors by hand.
%\begin{note}
%	Connection assertions must be consistent according to the type hierarchy.
%	That means---roughly spoken---the assertions for subtypes must get monotonously more restrictive or monotonously less restrictive.
%	For instance, the following connection assertions are illegal for node types \texttt{A}, \texttt{B}, \texttt{C}, \texttt{D} with \texttt{A} inherits from \texttt{B} and \texttt{C} inherits from \texttt{B}:
%	\begin{grgen}
%connect A[*] -> D, B[0:5] -> D, C[*] -> D
%	\end{grgen}
%	The \GrG\ compiler will warn you, if you're using inconsistent connection assertions.
%\end{note}

\begin{note}
\GrG~supports multiple inheritance on nodes and edges -- use it!

$\bullet$ Your nodes have something in common?
Then factor it out into some base class.
This works very well because of the support for multiple inheritance; you don't have to decide what is the primary hierarchy, forcing you to fall back to alternative patterns in the situations you need a different classification.
Fine grain type hierarchies not only allow for concise matching patterns and rules,
but deliver good matching performance, too (the search space is reduced early).

$\bullet$ Your edges have something in common?
Then just do the same, edges are first class citizens.
\end{note}

%-----------------------------------------------------------------------------------------------
\subsection{Attributes and Attribute Types}
\label{sct:attrtypes}

\begin{rail}
  AttributeDeclaration: 'const'? IdentDecl ':' AttributeType (() | '=' Expression) ';' | AttributeOverwrite ;
  AttributeType: PrimitiveType | EnumType | ContainerType;
  AttributeOverwrite: Ident '=' Expression
\end{rail}\ixnterm{AttributeDeclaration}\ixnterm{AttributeType}\ixnterm{AttributeOverwrite}\ixkeyw{const}
Defines a node or edge \indexed{attribute}.
Possible types are enumeration types (\texttt{enum}) and primitive types or container types.
See Section~\ref{sec:builtintypes} for a list of built-in primitive and Section~\ref{sec:builtingenerictypes} for a list of built-in container types.
Furthermore, attributes may be of nodes or edge or graph type (directly linking to a node or an edge, or to a subgraph; containers may contain that types, too).
Optionally attributes may be initialized with a \emph{constant} expression.
The expression has to be of a compatible type of the declared attribute.
See Chapter~\ref{cha:typeexpr} for the \GrG\ types and expressions reference.
The \emph{AttributeOverwrite} clause lets you overwrite initialization values for attributes of super classes.
The initialization values are evaluated in the order as they appear in the rule set file.
\begin{warning}
	The following attribute declarations are \emph{illegal} because of the order of evaluation of initialization values:
	\begin{grgen}
x:int = y;
y:int = 42;
	\end{grgen}
\end{warning}

\begin{note}
If you need to mark nodes in the graph, but only very few of them at the same time, think of reflexive edges of a special type. If the marking is sparse, they are the most efficient solution, before attributes, even before visited flags.
\end{note}



% todo: graphik die ein beispielmodell zeigt und mit pfeilen die konstrukte benennt
