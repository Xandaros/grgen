\chapter{Container and Graph Types}
\label{cha:container}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Built-In Types}
\label{sec:builtingenerictypes}
Besides the types already introduced, \GrG\ supports the built-in \indexed{generic types}\indexmainsee{built-in generic types}{generic types} in Table~\ref{builtingenerictypes}.
The exact type format is \indexed{backend} specific.
The \indexed{LGSPBackend} maps the generic types to generic C\#-Dictionaries (i.e. hashmaps) or generic C\#-Lists (misnamed dynamic arrays) or a \GrG\ supplied generic C\#-Deque of their corresponding primitive types, with \texttt{de.unika.ipd.grGen.libGr.SetValueType} as target type for sets, only used with the value \texttt{null}.

\begin{table}[htbp]
\begin{tabularx}{\linewidth}{|l|X|}
	\hline
	\texttt{\indexed{set}<T>} & A (mathematical) set of type \texttt{T}, where \texttt{T} may be an enumeration type or one of the primitive types from above; it may even be a node or edge type, then we speak of storages. \\
	\texttt{\indexed{map}<S,T>} & A (mathematical) map from type \texttt{S} to type \texttt{T}, where \texttt{S} and \texttt{T} may be enumeration types or one of the primitive types from above; it may even be a node or edge type, then we speak of storages. \\
	\texttt{\indexed{array}<T>} & An array of type \texttt{T}, where \texttt{T} may be an enumeration type or one of the primitive types from above; it may even be a node or edge type, then we speak of storages. Shares some similarities with \texttt{map<int,T>}. \\
	\texttt{\indexed{deque}<T>} & A deque of type \texttt{T}, where \texttt{T} may be an enumeration type or one of the primitive types from above; it may even be a node or edge type, then we speak of storages. Shares some similarities with \texttt{array<T>}. \\
	\hline
	\texttt{\indexed{graph}} & A subgraph of the host graph\\
	\hline
\end{tabularx}
\caption{\GrG\ built-in generic types}
\label{builtingenerictypes}
\end{table}

The type \texttt{graph} is not availble for general multi-graph processing but for storing subgraphs of the current host graph.
The only operations supported on it are equality and inequality, i.e. graph isomorphy checking 
(they are considered equal if they can be mapped onto each other showing the same structure and attribute values).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Expressions}\indexmain{container expression}\label{sub:containerexpr}

\GrG~supports numerous operations on the entities of the types introduced above, which are organized into left associative expressions.
In the following they will be explained with their semantics one type after another in the order of the rail diagram below.

\begin{rail}
  Expression: SetExpr | MapExpr | ArrayExpr | DequeExpr | RelationalExpr | PrimaryExpr;
\end{rail}\ixnterm{Expression}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Set Expression}\label{sec:setexpr}

Set expressions consist of the known mathematical set operations, plus some operations in method call notation.

\begin{rail}
  SetExpr: Expr 'in' SetExpr | SetExpr (backslash | ampersand | '|') SetExpr | PrimaryExpr (MethodSelector)?;
\end{rail}\ixnterm{SetExpr}\ixkeyw{in}

\begin{table}[htbp]
  \centering
  %\begin{tabularx}{0.45\linewidth}{|ll|} \hline
  \begin{tabular}[c]{|ll|} \hline
    \begin{tabular}[c]{l} \verb#|# \end{tabular} & \begin{tabular}[c]{l}Set union (contained in resulting set as soon as contained in one of the sets)\end{tabular}\\ \hline
    \begin{tabular}[c]{l} \verb#&# \end{tabular} & \begin{tabular}[c]{l}Set intersection (contained in resulting set only if contained in both of the sets)\end{tabular} \\ \hline
    \begin{tabular}[c]{l} \verb#\# \end{tabular} & \begin{tabular}[c]{l}Set difference (contained in resulting set iff contained in left but not right set)\end{tabular} \\ \hline
  \end{tabular}
  \caption{Binary set operators, in ascending order of precedence}\indexmain{order of precedence}
  \label{tabsetbinops}
\end{table}

The binary set operators require the left and right operands to be of identical type \verb#set<T>#.
The operator \texttt{x in s} denotes set membership $x \in s$, returning whether the set contains the given element, as \texttt{boolean}.
Furthermore there are two operations on sets available in method call notation (MethodSelector):

\begin{description}
\item[\texttt{.size()}] returns the number of elements in the set, as \texttt{int}
\item[\texttt{.peek(num)}] returns the element which comes at position \texttt{num:int} in the sequence of enumeration, as \texttt{T} for \verb#set<T>#; the higher the number, the longer retrieval takes
\end{description}

\begin{note}
To add a value to a set you may use set union with a single valued set constructor,
to remove a value from a set you may use set difference with a single valued set constructor (for set constructors cf. \ref{sec:primexpr}).
\begin{grgen}
s | { "foo" }
s \ { n.a }
\end{grgen}
Used in this way they get internally optimized to the imperative set addition \texttt{s.add(x)} and removal \texttt{s.rem(x)} methods available in the \texttt{eval} block and the XGRS.
\end{note}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Map Expression} \label{sec:mapexpr}

Map expressions consist of the known mathematical set operations extended to maps, and map value lookup, plus some operations in method call notation.

\begin{rail}
  MapExpr: Expr 'in' MapExpr | MapExpr '[' Expr ']' | MapExpr (backslash | ampersand | '|') MapExpr | PrimaryExpr (MethodSelector)?;
\end{rail}\ixnterm{MapExpr}\ixkeyw{in}

\begin{table}[htbp]
  \centering
  %\begin{tabularx}{0.45\linewidth}{|ll|} \hline
  \begin{tabular}[c]{|ll|} \hline
    \begin{tabular}[c]{l} \verb#|# \end{tabular} & \begin{tabular}[c]{l}Map union: returns new map with elements which are in at least one of the maps,\\ with the value of map2 taking precedence\end{tabular}\\ \hline
    \begin{tabular}[c]{l} \verb#&# \end{tabular} & \begin{tabular}[c]{l}Map intersection: returns new map with elements which are in both maps,\\ with the value of map1 taking precedence\end{tabular} \\ \hline
    \begin{tabular}[c]{l} \verb#\# \end{tabular} & \begin{tabular}[c]{l}Map difference: returns new map with elements from map1\\ without the elements with a key contained in map2\end{tabular}\\ \hline
  \end{tabular}
  \caption{Binary map operators, in ascending order of precedence}\indexmain{order of precedence}
  \label{tabmapbinops}
\end{table}

The binary map operators require the left and right operands to be of identical type \verb#map<S,T>#,
with one exception for map difference, this operator accepts for a left operand of type \verb#map<S,T># a right operand of type \verb#set<S>#, too.
The operator \texttt{x in m} denotes map domain membership $x \in dom(m)$, returning whether the domain of the map contains the given element, as \texttt{boolean}.
The operator \texttt{m[x]} denotes map lookup, i.e. it returns the value \texttt{y} which is stored in the map \texttt{m} for the value \texttt{x} (domain value \texttt{x} is mapped by the mapping \texttt{m} to range value \texttt{y}). The value \texttt{x} \emph{must} be in the map, i.e. \texttt{x in m} must hold.
There are several operations on maps available in method call notation (MethodSelector), these are:

\begin{description}
\item[\texttt{.size()}] returns the number of elements in the map, as \texttt{int}
\item[\texttt{.domain()}] returns the set of elements in the domain of the map, as \verb#set<S># for \verb#map<S,T>#
\item[\texttt{.range()}] returns the set of elements in the range of the map, as \verb#set<T># for \verb#map<S,T>#
\item[\texttt{.peek(num)}] returns the key of the element which comes at position \texttt{num:int} in the sequence of enumeration, as \texttt{S} for \verb#map<S,T>#; the higher the number, the longer retrieval takes
\end{description}

\begin{note}
To add a key,value-pair to a map you may use map union with a single valued map constructor,
to remove a value from a map you may use map difference with a single valued set or map constructor (for map constructors cf. \ref{sec:primexpr}).
\begin{grgen}
m | { "foo" -> 42 }
m \ { n.a -> n.b } or m \ { n.a }
\end{grgen}
Used in this way they get internally optimized to the imperative map addition \texttt{s.add(key,value)} and removal \texttt{s.rem(key)} methods available in the \texttt{eval} block and the XGRS.
\end{note}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Array Expression} \label{sec:arrayexpr}

Array expressions consist of array membership checking, array value lookup, and array concatenation, plus some operations in method call notation.

\begin{rail}
  ArrayExpr: Expr 'in' ArrayExpr | ArrayExpr '[' Expr ']' | ArrayExpr '+' ArrayExpr | PrimaryExpr (MethodSelector)?;
\end{rail}\ixnterm{ArrayExpr}\ixkeyw{in}

The operator \texttt{x in a} denotes array value membership, returning whether the array contains the given element, as \texttt{boolean}.
The operator \texttt{a[x]} denotes array lookup, i.e. it returns the value \texttt{y} which is stored in the array \texttt{a} at the index \texttt{x}.
The index \texttt{x} \emph{must} be a valid array index.
The operator \texttt{x + y} denotes array concatenation, which requires the left and right operands to be of identical type \verb#array<T>#.
There are several operations on arrays available in method call notation (MethodSelector), these are:

\begin{description}
\item[\texttt{.size()}] returns the number of elements in the array, as \texttt{int}
\item[\texttt{.indexOf(valueToSearchFor)}] returns first position \texttt{valueToSearchFor:T} appears at, as \texttt{int}, or -1 if not found
\item[\texttt{.lastIndexOf(valueToSearchFor)}] returns last position \texttt{valueToSearchFor:T} appears at, as \texttt{int}, or -1 if not found
\item[\texttt{.subarray(startIndex, length)}] returns subarray of given \texttt{length:int} from \texttt{startIndex:int} on
\item[\texttt{.peek(num)}] returns the value stored in the array at position \texttt{num:int} in the sequence of enumeration, is equivalent to (and implemented by) \texttt{a[num])}; retrieval occurs in constant time.
\item[\texttt{.peek()}] returns the last value stored in the array; retrieval occurs in constant time.
\end{description}

\begin{note}
In contrast to sets and maps which can be handled well by expressions, arrays are meant to be modified by imperative \texttt{eval} block and XGRS statements like array addition \texttt{a.add(value)}/\texttt{a.add(value, index)} and removal \texttt{s.rem()}/\texttt{s.rem(index)}.
For declarative array construction please have a look at \ref{sec:primexpr}.
\end{note}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Deque Expression} \label{sec:dequeexpr}

Deque expressions consist of deque membership checking, deque value lookup, and deque concatenation, plus some operations in method call notation.

\begin{rail}
  DequeExpr: Expr 'in' DequeExpr | DequeExpr '[' Expr ']' | DequeExpr '+' DequeExpr | PrimaryExpr (MethodSelector)?;
\end{rail}\ixnterm{DequeExpr}\ixkeyw{in}

The operator \texttt{x in d} denotes deque value membership, returning whether the deque contains the given element, as \texttt{boolean}.
The operator \texttt{d[x]} denotes deque lookup, i.e. it returns the value \texttt{y} which is stored in the deque \texttt{d} at the index \texttt{x}.
The index \texttt{x} \emph{must} be a valid deque index.
The operator \texttt{x + y} denotes deque concatenation, which requires the left and right operands to be of identical type \verb#deque<T>#.
There are several operations on deques available in method call notation (MethodSelector), these are:

\begin{description}
\item[\texttt{.size()}] returns the number of elements in the deque, as \texttt{int}
\item[\texttt{.indexOf(valueToSearchFor)}] returns first position \texttt{valueToSearchFor:T} appears at, as \texttt{int}, or -1 if not found
\item[\texttt{.lastIndexOf(valueToSearchFor)}] returns last position \texttt{valueToSearchFor:T} appears at, as \texttt{int}, or -1 if not found
\item[\texttt{.subdeque(startIndex, length)}] returns subdeque of given \texttt{length:int} from \texttt{startIndex:int} on
\item[\texttt{.peek(num)}] returns the value stored in the deque at position \texttt{num:int} in the sequence of enumeration, is equivalent to (and implemented by) \texttt{a[num])}; retrieval occurs in constant time.
\item[\texttt{.peek()}] returns the first value stored in the deque; retrieval occurs in constant time.
\end{description}

\begin{note}
In contrast to sets and maps which can be handled well by expressions, deques are meant to be modified by imperative \texttt{eval} block and XGRS statements like deque addition \texttt{d.add(value)}/\texttt{d.add(value, index)} and removal \texttt{d.rem()}/\texttt{d.rem(index)}.
The double ended queue allows for fast addition and removal both at the frond and at the back, in contrast to arrays that only support this at the end.
It is implemented by a ringbuffer that is grown as needed, a lookup is slightly more expensive than an array lookup.
The primary usage of the deque is as a queue, as needed for breadth first search, accessed FIFO.
This is in contrast to the array that is suited to be employed as a stack, e.g. in a depth first search (unless that is programmed using the call stack), accessed LIFO.
\end{note}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Relational Expressions}\label{sec:relationalcontainer}

The relational expressions compare enitites of different kinds, mapping them to the type boolean.
They were alreay introduced in \ref{sec:relational}, here we extend them with container and graph types.

For container expressions, table~\ref{compandsetmap} describes the semantics of the compare operators.
Some set A is a subset of B iff all elements in A are contained in B, too.
A map A is a submap of B iff all key-value pairs of A are contained in B, too. If they have a key in common but map to a different value, they count as not identical.
An array A is a subarray of B iff it is smaller or equal in size and the values at each common index are identical.
A deque A is a subdeque of B iff it is smaller or equal in size and the values at each common index are identical.
\begin{table}[htbp]
  \centering
  \begin{tabularx}{\linewidth}{|l|X|} \hline
    \texttt{A == B} & True, iff $A$ and $B$ are identical. \\
    \texttt{A != B} & True, iff $A$ and $B$ are not identical. \\
    \texttt{A <\ \ B} & True, iff $A$ is a subset/map/array/deque of $B$, but $A$ and $B$ are not identical. \\
    \texttt{A >\ \ B} & True, iff $A$ is a superset/map/array/deque of $B$, but $A$ and $B$ are not identical. \\
    \texttt{A <= B} & True, iff $A$ is a subset/map/array/deque of $B$ or $A$ and $B$ are identical. \\
    \texttt{A >= B} & True, iff $A$ is a superset/map/array/deque of $B$ or $A$ and $B$ are identical. \\ \hline
  \end{tabularx}
  \caption{Compare operators on container expressions}
  \label{compandsetmap}
\end{table}

\begin{table}[htbp]
  \centering
  \begin{tabularx}{\linewidth}{|l|X|} \hline
    \texttt{A == B} & True, iff $A$ is isomorphic to $B$. \\
    \texttt{A != B} & True, iff $A$ is not isomorphic to $B$. \\
    \texttt{A \textasciitilde\textasciitilde{ } B} & True, iff $A$ is structurally the same as $B$ but maybe different regarding the attributes. \\ \hline
  \end{tabularx}
  \caption{Compare operators on graph expressions}
  \label{compandgraph}
\end{table}

\texttt{Graph} types support only the \texttt{==}, the \texttt{!=}, and the \texttt{\textasciitilde\textasciitilde} operators;
on (sub)graph types they tell whether the (sub)graphs are isomorphic to each other (\indexed{isomorphy checking}/\indexed{graph isomorphy checking}) or not, including the attributes, or whether the (sub)graphs are isomorphic disregarding the attributes.

These operators consist just of two charactes, but don't underestimate their impact on performance:
they do graph isomorphy checking, which is expensive.
They are implemented in an early out style, i.e. the more different the graphs are, the earlier does the check return with the result they are not isomorphic.
But if the graphs you are checking are isomorphic (which will happen easily if you use automorphic patterns), then you have to pay the full price for isomorphy checking; if this occurs often, your solution may become prohibitively costly (including an external graph canonization library may be of interest in that case).

Some notes on the early out implementation: first the number of nodes and edges per type are checked, if they are different the graphs can't be isomorphic. The numbers are directly supplied by the \texttt{lgspBackend}, refuting isomorphy based on them is extremely cheap.
Then the \indexed{V-Structure}s (see \ref{searchplanning}) used in computing better matchers at runtime are first computed and then compared; if they are different the graphs can't be isomorphic. They are a good deal less expensive to compute than trying to match the one graph in the other; on well typed graphs the V-Structure counts are highly discriminating.

If these two pruning methods failed, a matcher is computed from one graph with search planning based on the V-Structure information just computed, and then applied on the other graph.
The matchers are stored in the graphs from which they originated, so if you do repeated comparisons of a subgraph which does not change, take care to extract that subgraph only once, store it, e.g. as an attribute in the graph, and continue to compare against it. 
This will save you from the cost of repeated search planning; in addition, often-used isomorphy matchers get eventually compiled resulting in a further speed up.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Primary Expressions}\label{sec:containerprimexpr}

Besides the \emph{Constant} already introduced as a part of the \emph{Literal}, cf. \ref{literaldef}, the literals \emph{SetConstructor}, \emph{MapConstructor}, \emph{ArrayConstructor} and \emph{DequeConstructor} are supported as well.

\begin{rail}
  SetConstructor: ('set' '<' Type '>')? \\ lbrace ( Expression*',' ) rbrace ;
  MapConstructor: ('map' '<' Type ',' Type '>')? \\ lbrace ( (Expression '->' Expression)*',' ) rbrace ;
  ArrayConstructor: ('array' '<' Type '>')? \\ '[' ( Expression*',' ) ']' ;
  DequeConstructor: ('deque' '<' Type '>')? \\ ']' ( Expression*',' ) '[' ;
\end{rail}\ixnterm{SetConstructor}\ixnterm{MapConstructor}\ixnterm{ArrayConstructor}\ixnterm{DequeConstructor}

The container constructors are constant if only primitive type literals, enum literals, or constant expressions are used; this is required for container initializations in the model.
They are non-constant if they contain nodes/edges/or member accesses, which is the common case if used in rules.
If the type of the container is given before the constructor, the elements given in the type constructor are casted to the specified member types if needed and possible.
Without the type prefix all elements given in the constructor must be of the same type.

\begin{example}
Some examples of container literals:
\begin{grgen}
{ "foo", "bar" } // a constant set<string> constructor
map<string,int>{ (n.strVal+m.strVal)->(m.intVal+n.intVal), intVal->strVal, "fool"->42 } // a non-constant map constructor with type prefix
[ 1,2,3 ] // a constant array<int> constructor
] 1,2,3 [ // a constant deque<int> constructor
\end{grgen}
\end{example}

A function call as already inroduced in \ref{sec:primexpr} may consist of one of the built-in functions for querying the elements of a type, the direct neighbourhood of a node, or the transitive neighbourhood of a node introduced in section \ref{neighbouringelementsfunctions}, returning a set of the graph elements of interest.

