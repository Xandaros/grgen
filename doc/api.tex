\chapter{Application Programming Interface}\indexmainsee{application programming interface}{API} \indexmain{API}
\label{cha:api}

This chapter describes the Application Programming Interface of \GrG, i.e. of the system runtime - the LibGr - and of the assemblies generated from the model and rule specifications.
We'll have a look at
\begin{itemize}
\item the interface to the graph and model
\item the interface to the rules and matches
\item the interface of the graph processing environment
\item the porter module for importing and exporting of graphs and miscellaneous stuff
\item implementing external class and function declarations
\item implementing external match filter and external sequence declarations
\end{itemize}

\noindent From the input file \texttt{Foo.grg} \texttt{grgen.exe} generates the output files \texttt{FooModel.cs} for the model and \texttt{FooActions.cs} for the actions,
\begin{itemize}
\item defining the exact interface, 
\item implementing the exact interface with generated code and code from the lgsp backend, i.e. entities from \texttt{de.unika.ipd.grGen.lgsp} available from lgspBackend.dll, 
\item and implementing the generic interface from \texttt{de.unika.ipd.grGen.libGr} using the entities mentioned in both points above.
\end{itemize}

\begin{note}
If you work on the API level it is helpful to keep the generated source code which normally is thrown away 
after it was compiled into the assemblies lgsp-FooModel.dll and lgsp-FooActions.dll.
Use the \texttt{-keep} option when you call \texttt{grgen.exe} to do so.
\end{note}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interface to the host graph}

The generated file \texttt{FooModel.cs} opens the namespace \texttt{de.unika.ipd.grGen.Model\_Foo} containing all the generated entities.
It contains for every node or edge class \texttt{Bar} an interface \texttt{IBar}, which offers C\# properties giving access to the attributes, and is inheriting in the same way as specified in the model file.
This builds the exact interface of the model, it is implemented by a sealed class \texttt{Bar} with generated code and with code from the lgsp backend.
Furtheron the namespace contains a model class \texttt{FooGraphModel} implementing the interface \texttt{de.unika.ipd.grGen.libGr.IGraphModel},
which supports iteration over the entities defined in the model using further, generic(i.e. inexact) interfaces from libGr.
Finally, the namespace contains a class \texttt{FooGraph} which defines an \texttt{LGSPGraph} of a model equivalent to \texttt{FooGraphModel}; 
it contains convenience functions to easily create nodes and edges of exact type in the graph.
In addition, a class \texttt{FooNamedGraph} is available, which defines an \texttt{LGSPNamedGraph} of a model equivalent to \texttt{FooGraphModel}; 
the named graph offers persistent names \ref{persistentex} for all its graph elements, otherwise it is identical to an \texttt{LGSPGraph}.
The naming requires about the same memory as an unnamed graph, but under normal circumstances the named graph is the recommended one to use (and is the one which will be used if employed by the shell).

\begin{note}
If you want to use the type-safe interface, use the interface \texttt{IBar}, and the \texttt{CreateNodeBar}-methods of \texttt{FooGraph} or the \texttt{CreateNode}-method of \texttt{Bar}.
If you want to use the generic interface, your entry point is the \texttt{IGraphModel}, with \texttt{INodeModel.GetType("Bar")} returning a \texttt{NodeType}, used in \texttt{IGraph.AddNode(NodeType)} returning an \texttt{INode}.
\end{note}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interface to rules}

The generated file \texttt{FooActions.cs} opens the \texttt{namespace de.unika.ipd.grGen.Action\_Foo} containing all the generated entities.
It contains for every rule or test \texttt{bar}
\begin{itemize}
\item a class \texttt{Rule\_bar} inheriting from \texttt{de.unika.ipd.grGen.lgsp.LGSPRulePattern}, which contains
the exact match interface \texttt{IMatch\_bar} which defines how a match of the rule looks like,
extending the generic rule-unspecific \texttt{IMatch} interface.
Furtheron there are (but meant only for internal use): a match class \texttt{Match\_bar} implementing the exact and inexact interface,
a description of the pattern to match, and the modify methods doing the rewriting.
\item an exact action interface \texttt{IAction\_bar} which contains the methods:
  \begin{itemize}
  \item \texttt{Match}, to match the pattern in the host graph,
     with in-parameters corresponding to the in-parameters of the rule (name and type),
	 returning matches of the exact type \texttt{Rule\_bar.IMatch\_bar}.
  \item \texttt{Modify}, to modify a given match according to the rewrite specification,
     with out-parameters corresponding to the out-parameters of the rule.
  \item \texttt{Apply}, to match and modify the found match,
     with in-parameters corresponding to the in-parameters of the rule,
     and with ref-parameters corresponding to the out-parameters of the rule.
  \end{itemize}
  Furtheron there is (but meant only for internal use) the class \texttt{Action\_bar} implementing the exact action interface as well as the generic \texttt{IAction} interface from libGr;
  it contains the generated matcher code searching for the patterns.
\end{itemize}

Moreover the namespace contains an action class \texttt{FooActions}
implementing the abstract class \texttt{de.unika.ipd.grGen.libGr.BaseActions} (in fact \texttt{de.unika.ipd.grGen.lgsp.LGSPActions}),
which supports iteration over the entities defined in the actions using further, generic(i.e. inexact) interfaces from libGr.
Additionally, at runtime it contains the instances of the actions singletons,
as member \texttt{bar} of the exact type \texttt{IAction\_bar}.
\begin{note}
If you want to use the type-safe interface, your entry point is the member \texttt{bar} of type \texttt{IAction\_bar} from \texttt{FooActions} (or \texttt{Action\_bar.Instance}).
Actions are used with named parameters of exact types.
If you want to use the generic interface, your entry point is the method \texttt{GetAction("bar")} of the interface \texttt{BaseActions} implemented by \texttt{FooActions} returning an \texttt{IAction}.
Actions are used with \texttt{object}-arrays for parameter passing.
\end{note}

\begin{note}
The old generic interface of string names and entities of node-,edge-, and object-type is implemented with the new interface of exactly typed, named entities.
Thus you will receive runtime exceptions when doing operations which are not type-safe with the generic interface, in contrast to \GrG\ $<$ v2.5.
If you need the flexibility of the old input parameters semantics of silently failing rule application on a wrong type,
you must declare it explicitly with the syntax \verb#r(x:ExactType<InexactType>)#;
then the rule parameter in the exact interface will be of type \texttt{InexactType}.
\end{note}

\begin{example}\label{ex:api1}
Normally you want to use the type-safe interface of the generated code as it is much more convenient.
Only if your application must get along with models and actions unknown before it is compiled you have to fall back to the generic interface.
An extensive example showing how to cope with the latter is shipped with \GrG\ in form of the GrShell.
Here we'll show a short example on how to use \GrG\ with the type-safe API; 
further examples are given in the examples-api folder of the \GrG-distribution.

We'll start with including the namespaces of the libGr and the lgsp backend shipped with \GrG\,
plus the namespaces of our actions and models, generated from \texttt{Foo.grg}.
\begin{verbatim}
using de.unika.ipd.grGen.libGr;
using de.unika.ipd.grGen.lgsp;
using de.unika.ipd.grGen.Action_Foo;
using de.unika.ipd.grGen.Model_Foo;
\end{verbatim}

Then we create a graph with model bound at generation time and create actions to operate on this graph.
Afterwards we create a single node of type \texttt{Bar} in the graph and save it to the variable \texttt{b}.
Finally we apply the action \texttt{bar(Bar x) : (Bar)} to the graph with \texttt{b} as input receiving the output as well.
The rule is taken from the actions via the member named as the action.
\begin{verbatim}
FooGraph graph = new FooGraph();
FooActions actions = new FooActions(graph);
Bar b = graph.CreateNodeBar();
actions.bar.Apply(graph, b, ref b); // input of type Bar, output of type Bar
\end{verbatim}

We could create a named graph instead offering persistent names for its graph elements:
\begin{verbatim}
FooNamedGraph graph = new FooNamedGraph();
\end{verbatim}
\end{example}

\begin{example}
This is an example doing mostly the same as the previous example \ref{ex:api1}, in a slightly more complicated way allowing for more control.
Here we create the model separate from the graph, then the graph with a model not bound at generation time.
We create the actions to apply on the graph, and a single node of type \texttt{Bar} in the graph, which we assign again to a variable \texttt{b}.
Then we get the action from the actions and save it to an action variable \texttt{bar};
afterwards we use the action for finding all available matches of \texttt{bar} with input \texttt{b} -- which is different from the first version -- and remember the found matches in the matches variable with its exact type.
Finally we take the first match from the matches and execute the rewrite with it.
We could have inspected the nodes and edges of the match or their attributes before (using element names prefixed with \texttt{node\_/edge\_} or attribute names to get exactly typed entities). 
\begin{verbatim}
IGraphModel model = new FooGraphModel();
LGSPGraph graph = new LGSPGraph(model);
FooActions actions = new FooActions(graph);
Bar b = Bar.CreateNode(graph);
IAction_bar bar = Action_bar.Instance;
IMatchesExact<Rule_bar.IMatch_bar> matches = bar.Match(graph, 0, b);
bar.Modify(graph, matches.First);
\end{verbatim}

We could create a named graph instead offering persistent names for its graph elements:
\begin{verbatim}
LGSPGraph graph = new LGSPNamedGraph(model);
\end{verbatim}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interface of the graph processing environment}

The interface \texttt{IGraphProcessingEnvironment} implemented by the \texttt{LGSPGraphProcessing\-Environment} class offers all the additional functionality of \GrG~exceeding what is offered by the graph and the actions.
It is constructed as \texttt{LGSPGraphProcessingEnvironment} given the graph and the actions.
It offers execution of the sequences and variable handling, combining actions into transformations
(the former regarding control flow, the latter regarding data flow).
Further on, the environment offers driver or helper objects for transaction management, deferred sequence execution, graph change recording, and emitting.

\begin{example}
For all but the simplest transformations you'll end up constructing a graph processing environment from the graph and the actions constructed until now, executing a graph rewrite sequence on the graph processing environment:
\begin{verbatim}
LGSPGraphProcessingEnvironment procEnv = 
    new LGSPGraphProcessingEnvironment(graph, actions);
procEnv.ApplyGraphRewriteSequence("<(::x)=foo && (::y)=bar(::x) | bla(::y)>");
\end{verbatim}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Import/Export and miscellaneous stuff}\label{sub:imexport}\indexmain{import}\indexmain{export}

GrGen natively supports the following formats:
\begin{description}
  \item[GRS/GRSI] Reduced GrShell script files (graph only, model from \texttt{.gm}; a very limited version of the normal \texttt{.grs}. The recommended standard format.)
  \item[GXL] Graph eXchange Language (\texttt{.gxl}-files, see \url{http://www.gupro.de/GXL/})
  \item[ECORE/XMI] Ecore(\texttt{.ecore}) model files and XMI(\texttt{.xmi}) graph file. Import only, export must be programmed with \texttt{emit}-statements. In an intermediate step, a \texttt{.gm} file is generated for the model.
    \item[GRG] Writes a GrGen rule file containing one rule with an empty pattern and a large rewrite part. Export only \footnote{Original German Pisswasser, for export only :)}, not for normal use.
\end{description}

While both GRS and GXL importers expect one file
(the GXL importer allows to specify a model override, see GrShell import, Note \ref{shellgxlimport}),
the EMF/ECORE importer expects first one or more \texttt{.ecore} files
and following optionally a \texttt{.xmi} files and/or a \texttt{.grg} file (cf. Note \ref{shellecoreexport}). 
To use additional custom graph models you should supply an own \texttt{.grg}
file which may be based on the automatically generated \texttt{.grg} file, if none was
supplied (see the Program-Comprehension example in \texttt{examples/ProgramComprehension-GraBaTs09}).

To import a graph model and/or a graph instance you can use \texttt{Porter.Import()} from the libGr API (the GrShell command \texttt{import} is mapped to it)
The file format is determined by the file extensions.
To export a graph instance you can use \texttt{Porter.Export()} from the libGr API (the GrShell command \texttt{export} is mapped to it).
For an example of how to use the importer/exporter on API level see \texttt{examples-api/JavaProgramGraphsExample/JavaProgramGraphs\-Example.cs}

The GRS(I) importer returns an \texttt{INamedGraph};
if you don't need the persistent names, get rid of them by casting to the \texttt{LGSPNamedGraph} implementing the interface, (copy-)constructing a \texttt{LGSPGraph} from it, and forgetting any references to the named graph.
Please be aware that naming is rather expensive:
A \texttt{LGSPNamedGraph} supplying the name to element and element to name mappings normally uses up about twice the amount of memory of the \texttt{LGSPGraph} defining the graph alone (but is worth is most often).

There are further examples available in the \texttt{examples-api} folder of the \GrG-distribution:
\begin{itemize} 
\item How to use the graph rewrite sequences offered by the libGr on API level is shown in\\
\texttt{examples-api/BusyBeaverExample/BusyBeaverExample.cs}.\\
But normally you want to use your favourite .NET programming language for control together with the type-safe interface when working on API level.
\item How to use the old and new interface for accessing a match on API level is shown in\\
\texttt{examples-api/ProgramGraphsExample/ProgramGraphsExample.cs}.
\item How to use the visited\label{apiallocvisitflag} flags on API level is shown in\\
\texttt{examples-api/VisitedExample/VisitedExample.cs}.
\item How to analyze the graph and generate (hopefully) better performing matchers based on this information is shown in\\
\texttt{examples-api/BusyBeaverExample/BusyBeaverExample.cs}.
\item How to compile a \texttt{.grg}-specification at runtime and dump a graph for visualization in \texttt{.vcg} format on the API level is shown in\\
\texttt{examples-api/HelloMutex/HelloMutex.cs}.
\item How to access the annotations at API level is shown in\\
\texttt{examples-api/MutexDirectExample/MutexDirectExample.cs}.
\item How to communicate with yComp on the API level (from your own code) is shown in\\
\texttt{examples-api/YCompExample/YCompExample.cs}.
\end{itemize}

\begin{warning}
While C\# allows input arguments values to be of a subtype of the declared interface parameter type (OO), 
it requires that the argument variables for the \texttt{out} parameters are of exactly the type declared (non-OO).
Although a variable of a supertype would be fully sufficient -- the variable is only assigned.
So for \texttt{node class Bla extends Bar;} and action \texttt{bar(Bar x) : (Bla)} from the rules file rules \texttt{Foo.grg}
we can't use a desired target variable of type \texttt{Bar} as \texttt{out}-argument,
but are forced to introduce a temporary variable of type \texttt{Bla}
and assign this variable to the desired target variable after the call.
\begin{csharplet}
using de.unika.ipd.grGen.libGr;
using de.unika.ipd.grGen.lgsp;
using de.unika.ipd.grGen.Action_Foo;
using de.unika.ipd.grGen.Model_Foo;
FooGraph graph = new FooGraph();
FooActions actions = new FooActions(graph);
Bar b = graph.CreateNodeBar();
IMatchesExact<Rule_bar.IMatch_bar> matches = actions.bar.Match(graph, 1, b);
//actions.bar.Modify(graph, matches.First, out b); // wont work, needed:
Bla bla = null; 
actions.bar.Modify(graph, matches.First, out bla);
b = bla;
\end{csharplet}
\end{warning}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{External Class and Function Implementation}\label{sub:extclsfctimpl}\indexmain{external class implementation}\indexmain{external function implementation}

For a model file \texttt{Foo} which contains external functions (cf. \ref{sub:extfct}) and/or classes (cf. \ref{sub:extcls}), \GrG~generates a file \texttt{FooModelExternalFunctions.cs} located besides the model and rule files, which contains
\begin{itemize}
	\item within the model namespace public partial classes named as given in the external class declaration,
inherting from each other as stated in the external class declarations.
	\item within the \texttt{de.unika.ipd.grGen.expression} namespace a public partial class named \texttt{ExternalFunctions} with a body of comments giving the expected function prototypes.
\end{itemize}

\noindent The partial classes are empty, you must implement them in a file named \texttt{FooModelExternal\-FunctionsImpl.cs} located in the folder of the \texttt{FooModelExternalFunctions.cs} file by
\begin{itemize}
	\item fleshing out the partial classes skeletons with attributes containing data of interest and maybe helper methods
	\item fleshing out the \texttt{ExternalFunctions} partial class skeleton with the functions you declared in the external function declarations, obeying the function signatures as specified; here you can access the now know attributes or methods of the external classes, or do complicated custom computations with the values you receive from a function call.
\end{itemize}

\noindent Don't forget that the source code file \texttt{FooModelExternalFunctionsImpl.cs} is an integral part of your \GrG~graph transformation project, in contrast to the other C\# files generated (and overwritten) for you.
In \texttt{examples/ExternalAttributeEvaluationExample} and \texttt{examples-api/ExternalAttributeEvaluationExample}
you find a fabricated example showing how to use the external classes and functions.

When you use third-party assemblies in your source code you must inform GrGen.NET about them so references to them are included into the assembly generated; this can be done with the \texttt{-r} parameter when calling \texttt{grgen.exe} directly (cf. \ref{grgenoptions}) or with the \texttt{new} command configurations available in GrShell (cf. \ref{graphcommands}). Using the \texttt{keepdebug} configuration of the \texttt{new} command is recommended as it allows for easier debugging.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{External Filter and Sequence Implementation}\label{sub:extfltseqimpl}\indexmain{external match filter implementation}\indexmain{external sequence implementation}

For an actions file \texttt{Bar} which contains match filter declarations (cf. \ref{sub:extflt}) and/or external sequence declarations (\ref{sub:extseq}), \GrG~generates a file \texttt{BarActionsExternalFunctions.cs} located besides the model and rule files, which contains within the action namespace 
\begin{itemize}
	\item a public partial class named \texttt{MatchFilters} with a body of comments giving the expected function prototypes.
	\item public partial classes, named \texttt{Sequence\_foo} for a sequence \texttt{foo}, with a body containing a comment specifying the expected function prototype of the sequence application function.
\end{itemize}

\noindent The partial classes are empty, you must implement them in a file named \texttt{BarActionsExternal\-FunctionsImpl.cs} located in the folder of the \texttt{BarActionsExternalFunctions.cs} file by
\begin{itemize}
	\item fleshing out the \texttt{MatchFilters} partial class skeleton with the match filter functions you declared, obeying the function signatures as specified; you might want to convert the received matches object to an \texttt{IList} in case you want to reorder the list and reinject it into the matches object afterwards.
	\item fleshing out the partial classes skeletons of the external sequence with the \texttt{ApplyXGRS\_foo} methods needed.
\end{itemize}

\noindent Don't forget that the source code file \texttt{BarActionsExternalFunctionsImpl.cs} is an integral part of your \GrG~graph transformation project, in contrast to the other C\# files generated (and overwritten) for you.
In \texttt{examples/ExternalFiltersAndSequencesExample} and \texttt{examples-api/ExternalFiltersAndSequencesExample}
you find a fabricated example showing how to use the external classes and functions.

When you use third-party assemblies in your source code you must inform GrGen.NET about them so references to them are included into the assembly generated; this can be done with the \texttt{-r} parameter when calling \texttt{grgen.exe} directly (cf. \ref{grgenoptions}) or with the \texttt{new} command configurations available in GrShell (cf. \ref{graphcommands}). Using the \texttt{keepdebug} configuration of the \texttt{new} command is recommended as it allows for easier debugging.


\begin{note}\label{note:inspect}
\LibGr\ allows for splitting a rule application into two steps:
Find all the subgraphs of the host graph that match the pattern first, then rewrite one of these matches. 
By returning a collection of all matches, the \LibGr\ retains the complete graph rewrite process under control.
As a \LibGr\ user have a look at the following methods of the \texttt{IAction} interface:
\begin{csharplet}
IMatches Match(IGraph graph, int maxMatches, object[] parameters);
object[] Modify(IGraph graph, IMatch match);
\end{csharplet}

In C\#, this might look like:
\begin{csharplet}
IMatches myMatches = myAction.Match(myGraph, -1, null); /* -1: get all the matches */
for(int i=0; i<myMatches.NumMatches; ++i)
{
	if(inspectCarefully(myMatches.GetMatch(i))
	{
		myAction.Modify(myGraph, myMatches.GetMatch(i));
		break;
  	}
}
\end{csharplet}

The external match filters are hooking in between the \texttt{Match} and \texttt{Modify} functions, they allow you to do this kind of inspection without being forced to resort to fully external control.
\end{note}
